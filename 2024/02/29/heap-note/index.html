<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>heap note | S1nec-1o's B1og</title><meta name="author" content="s1nec-1o"><meta name="copyright" content="s1nec-1o"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="堆本篇文章摘自华庭大佬的Glibc 内存管理一书，只是插入了一些记录 什么是堆在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。 堆管理器处于用户程序与内核中间，主要做以下工作  响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持">
<meta property="og:type" content="article">
<meta property="og:title" content="heap note">
<meta property="og:url" content="http://s1nec-1o.github.io/2024/02/29/heap-note/index.html">
<meta property="og:site_name" content="S1nec-1o&#39;s B1og">
<meta property="og:description" content="堆本篇文章摘自华庭大佬的Glibc 内存管理一书，只是插入了一些记录 什么是堆在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。 堆管理器处于用户程序与内核中间，主要做以下工作  响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png">
<meta property="article:published_time" content="2024-02-29T10:20:14.000Z">
<meta property="article:modified_time" content="2024-04-28T09:07:33.005Z">
<meta property="article:author" content="s1nec-1o">
<meta property="article:tag" content="traditional pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281712481.jpg"><link rel="canonical" href="http://s1nec-1o.github.io/2024/02/29/heap-note/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离文章发布已经过去","messageNext":"天了，信息可能已经过时"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'heap note',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-28 17:07:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 20
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="S1nec-1o's B1og" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><nav id="nav"><span id="blog-info"><a href="/" title="S1nec-1o's B1og"><span class="site-name">S1nec-1o's B1og</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">heap note</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-29T10:20:14.000Z" title="发表于 2024-02-29 18:20:14">2024-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-28T09:07:33.005Z" title="更新于 2024-04-28 17:07:33">2024-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Pwn%E7%9F%A5%E8%AF%86/">Pwn知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="heap note"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>本篇文章摘自华庭大佬的<code>Glibc 内存管理</code>一书，只是插入了一些记录</p>
<h4 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h4><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p>
<p>堆管理器处于用户程序与内核中间，主要做以下工作</p>
<ol>
<li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ol>
<p>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc&#x2F;free 函数来分配和释放内存块。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h3 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h3><p>这里我们主要介绍</p>
<ul>
<li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用</li>
<li>介绍堆目前的多线程支持。</li>
</ul>
<h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>在 glibc 的 <a target="_blank" rel="noopener" href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.c</a> 中，malloc 的说明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">malloc函数用于分配至少n个字节大小的内存块，并返回指向该内存块的指针。如果没有足够的空间可用，则返回空指针。在失败的情况下，对于 ANSI C 系统，errno 会被设置为 ENOMEM。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果 n 为零，则malloc返回一个最小尺寸的内存块。在大多数 32 位系统上，最小尺寸为 16 个字节，在 64 位系统上为 24 或 32 个字节。在大多数系统中，size_t 是无符号类型，因此带有负参数的调用会被解释为对大量空间的请求，通常会失败。n 的最大支持值因系统而异，但在所有情况下都小于 size_t 可表示的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理</p>
<ul>
<li>当 n&#x3D;0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>在 glibc 的 <a target="_blank" rel="noopener" href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.c</a> 中，free 的说明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      free(void* p)</span></span><br><span class="line"><span class="comment">      Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">      allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">      effects if p has already been freed.</span></span><br><span class="line"><span class="comment">      Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">      when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">      back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">释放指向p的内存块，该内存块之前使用malloc或类似的realloc例程分配。如果p为null，则没有影响。如果p已经被释放，可能会产生任意（即不好的）影响。除非禁用（使用mallopt），释放非常大的空间将在可能的情况下自动触发操作，将未使用的内存返回给系统，从而减少程序占用空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理</p>
<ul>
<li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li>
<li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li>
<li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li>
</ul>
<h4 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h4><p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。</p>
<p>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202403132101103.png" alt="img"></p>
<h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sbrk">brk</a> 的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data&#x2F;bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的随机偏移处。</li>
</ul>
<p>具体效果如下图（这个图片与网上流传的基本一致，这里是因为要画一张大图，所以自己单独画了下）所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202403132101104.png" alt="img"></p>
<p><strong>例子</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid()); <span class="comment">//输出当前进程的PID（进程标识符）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);  <span class="comment">//使用 sbrk(0) 获取当前程序堆区的边界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);        <span class="comment">// 调用 brk(curr_brk+4096) 来将程序的堆区边界地址向上移动 4096 字节（4KB）。brk 函数设置新的 break 的位置。</span></span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);  <span class="comment">//调用 brk(tmp_brk) 将程序的堆区边界重置回最初的位置</span></span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p>
<p><strong>在第一次调用 brk 之前</strong></p>
<p>从下面的输出可以看出，并没有出现堆。因此</p>
<ul>
<li>start_brk &#x3D; brk &#x3D; end_data &#x3D; 0x804b000</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:<span class="number">6141</span></span><br><span class="line">Program Break Location1:<span class="number">0x804b000</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6141</span>/maps</span><br><span class="line">...</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539624</span>     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line">b7e21000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<p><strong>第一次增加 brk 后</strong></p>
<p>从下面的输出可以看出，已经出现了堆段</p>
<ul>
<li>start_brk &#x3D; end_data &#x3D; 0x804b000</li>
<li>brk &#x3D; 0x804c000</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:<span class="number">6141</span></span><br><span class="line">Program Break Location1:<span class="number">0x804b000</span></span><br><span class="line">Program Break Location2:<span class="number">0x804c000</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6141</span>/maps</span><br><span class="line">...</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539624</span>     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0804</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7e21000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<p>其中，关于堆的那一行</p>
<ul>
<li>0x0804b000 是相应堆的起始地址</li>
<li>rw-p 表明堆具有可读可写权限，并且属于隐私数据。</li>
<li>00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
<li>00:00 是主从 (Major&#x2F;mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。</li>
<li>0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
</ul>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285">mmap</a> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<p><strong>例子</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private anonymous mapping example using mmap syscall */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="type">char</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">        addr = mmap(<span class="literal">NULL</span>, (<span class="type">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">                errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unmap mapped region. */</span></span><br><span class="line">        ret = munmap(addr, (<span class="type">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After munmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在执行 mmap 之前</strong></p>
<p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6067</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<p><strong>mmap 后</strong></p>
<p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6067</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e00000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<p><strong>munmap</strong></p>
<p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6067</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h4><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p>
<p>这里给出一个例子。</p>
<p><code>pthread_create</code> 是一个函数，用于在 POSIX 线程库中创建一个新的线程。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>thread</code>：指向 <code>pthread_t</code> 类型的指针，用于存储新创建线程的标识符。</li>
<li><code>attr</code>：指向 <code>pthread_attr_t</code> 类型的指针，用于指定线程的属性。可以传递 <code>NULL</code>，表示使用默认属性。</li>
<li><code>start_routine</code>：指向线程函数的指针，该函数是线程的入口点，线程将从该函数开始执行。</li>
<li><code>arg</code>：传递给线程函数 <code>start_routine</code> 的参数。</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果成功创建线程，则返回 0，表示成功。</li>
<li>如果创建线程失败，则返回一个非零的错误码，表示失败的原因。</li>
</ul>
<p><code>pthread_create</code> 函数用于创建一个新的线程，并在指定的线程函数 <code>start_routine</code> 中执行。新线程的执行将从 <code>start_routine</code> 函数开始，该函数接受一个 <code>void*</code> 类型的参数 <code>arg</code>。线程函数可以执行任意操作，包括计算、I&#x2F;O 操作、同步等。</p>
<p>使用 <code>pthread_create</code> 创建的线程在执行完毕后，可以通过调用 <code>pthread_join</code> 函数来等待线程的结束，并获取线程的返回值。此外，还可以使用其他线程相关的函数来管理和操作线程，例如 <code>pthread_detach</code>、<code>pthread_cancel</code> 等。</p>
<p>需要注意的是，<code>pthread_create</code> 函数是 POSIX 标准中定义的线程创建函数，在不同的操作系统和编译器中可能有所差异。在使用时，应仔细阅读相关文档并遵循相应的使用规范。</p>
<p><code>pthread_join</code> 是一个函数，用于等待指定的线程结束，并获取线程的返回值。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>thread</code>：要等待的线程标识符，通常由 <code>pthread_create</code> 返回。</li>
<li><code>retval</code>：指向 <code>void*</code> 类型指针的指针，用于存储线程的返回值。</li>
</ul>
<p>返回值：</p>
<ul>
<li>如果成功等待线程结束，则返回 0，表示成功。</li>
<li>如果等待线程失败，则返回一个非零的错误码，表示失败的原因。</li>
</ul>
<p><code>pthread_join</code> 函数用于等待指定的线程结束。当调用该函数时，当前线程将被阻塞，直到被等待的线程执行完毕。在线程结束后，可以通过 <code>retval</code> 参数获取线程的返回值，该返回值是线程函数 <code>start_routine</code> 的返回值。</p>
<p>需要注意的是，如果线程被成功等待并成功获取返回值，那么线程的资源将被释放，不再占用系统资源。但是，如果不关心线程的返回值，可以将 <code>retval</code> 参数设置为 <code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);  <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000&#x3D;0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">After <span class="built_in">free</span> in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">After <span class="built_in">free</span> in main thread</span><br><span class="line">Before <span class="built_in">malloc</span> in thread <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7604000-b7605000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7605000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [<span class="built_in">stack</span>:<span class="number">6594</span>]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p>
<p>注意：</p>
<blockquote>
<p>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">After <span class="built_in">free</span> in main thread</span><br><span class="line">Before <span class="built_in">malloc</span> in thread <span class="number">1</span></span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in thread <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7500000-b7521000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7521000-b7600000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7604000-b7605000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7605000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [<span class="built_in">stack</span>:<span class="number">6594</span>]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">After <span class="built_in">free</span> in main thread</span><br><span class="line">Before <span class="built_in">malloc</span> in thread <span class="number">1</span></span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in thread <span class="number">1</span></span><br><span class="line">After <span class="built_in">free</span> in thread <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7500000-b7521000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7521000-b7600000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7604000-b7605000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7605000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [<span class="built_in">stack</span>:<span class="number">6594</span>]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<h4 id="glibc内存管理篇"><a href="#glibc内存管理篇" class="headerlink" title="glibc内存管理篇"></a>glibc内存管理篇</h4><h4 id="5-源代码分析"><a href="#5-源代码分析" class="headerlink" title="5.  源代码分析"></a>5.  源代码分析</h4><h5 id="5-1-边界标记法"><a href="#5-1-边界标记法" class="headerlink" title="5.1  边界标记法"></a>5.1  边界标记法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  这个字段存储前一个内存块的大小（以字节为单位），但仅当这个内存块是“空闲”的（也就是当前没有被分配）时才有意义。*/</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead.这个字段存储当前内存块的大小（字节为单位），包括管理这片内存所需的额外开销。这意味着这个数字可能比用户请求的大小要大一些，因为它还包括结构体自身的大小以及可能的填充字节，以保持内存对齐。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. 这是一个指向下一个内存块的指针，只有当当前内存块是空闲的时候，这个指针才有用。它用于双向链表结构中，指向链表中的下一块空闲内存块。*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>         <span class="comment">/*这是一个指向上一个内存块的指针，同样地，只有当前内存块是空闲的时候，这个指针才有用，它是双向链表中的向前链接。*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free.这个字段是为了管理较大的内存块而设置的，它是指向上一个geng&#x27;xiao内存块的指针。这个指针也只在当前内存块空闲时使用。 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span>  <span class="comment">/* 这个字段类似于`fd_nextsize`，但它指向的是下一个更大的内存块。*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>prev_size</strong>:如果前一个 chunk 是<strong>空闲</strong>的，该域表示<strong>前一个 chunk 的大小</strong>，如果前一个 chunk <strong>不空闲</strong>，该域<strong>无意义</strong>。 </p>
<p><strong>size</strong>：<strong>当前 chunk 的大小</strong>，并且<strong>记录了当前 chunk 和前一个 chunk 的一些属性</strong>，包括前一个 chunk 是否在使用中，当前 chunk 是否是通过 mmap 获得的内存，当前 chunk 是否属于 非主分配区。</p>
<p> <strong>fd 和 bk</strong>：指针 fd 和 bk <strong>只有当该 chunk 块空闲时才存在</strong>，其作用是用于将对应的空闲 chunk 块加入到空闲 chunk 块链表中统一管理，如果该 chunk 块被分配给应用程序使用，那 么这两个指针也就没有用（该 chunk 块已经从空闲链中拆出）了，所以也<strong>当作应用程序的使用空间</strong>，而不至于浪费。 <strong>fd指向低地址，bk指向高地址</strong></p>
<p><strong>fd_nextsize 和 bk_nextsize</strong>:当当前的 chunk 存在于 large bins 中时，large bins 中的空闲 chunk 是按照大小排序的，但同一个大小的 chunk 可能有多个，增加了这两个字段可以<strong>加快遍历空闲 chunk</strong>，并查找满足需要的空闲 chunk，<strong>fd_nextsize 指向下一个比当前 chunk 大小 大的第一个空闲 chunk</strong>，<strong>bk_nextszie 指向前一个比当前 chunk 大小小的第一个空闲 chunk</strong>。 <strong>如果该 chunk 块被分配给应用程序使用，那么这两个指针也就没有用</strong>（该 chunk 块已经从 size 链中拆出）了，所以也<strong>当作应用程序的使用空间</strong>，而不至于浪费。</p>
<p>一个已分配的块的结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt;  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">         | 前一个块的大小（如果已分配） | |</span><br><span class="line">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">         | 块的大小（以字节为单位） |M|P|</span><br><span class="line"> mem-&gt;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">         | 用户数据从这里开始... .</span><br><span class="line">         . </span><br><span class="line">         . （malloc_usable_size() 字节） </span><br><span class="line">         .</span><br><span class="line">         |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">             | 块的大小 |</span><br><span class="line">             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>在这里，”chunk”在大多数malloc代码中表示块的前部，而”mem”是返回给调用者的指针。块的前部包含了前一个块的大小（如果该块已分配），以及当前块的大小（以字节为单位）。”M”和”P”是用于表示块的状态（分配或空闲）的位标志。”mem”指针指向的位置是用户数据的起始位置。下一个块的位置由”nextchunk”指针表示，并且包含了下一个块的大小信息。</p>
<p>空闲块以循环双向链表的形式存储，结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt;  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">         | 前一个块的大小 |</span><br><span class="line">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:<span class="string">&#x27;  | 块的大小（以字节为单位） |P|</span></span><br><span class="line"><span class="string"> mem-&gt;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">         | 指向链表中下一个块的前向指针 |fd</span></span><br><span class="line"><span class="string">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">         | 指向链表中前一个块的后向指针 |bk</span></span><br><span class="line"><span class="string">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">         | 未使用的空间（可能为0字节） .</span></span><br><span class="line"><span class="string">         .</span></span><br><span class="line"><span class="string">         . |</span></span><br><span class="line"><span class="string">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">`foot:&#x27;</span>  | 块的大小 |</span><br><span class="line">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>​	在这里，空闲块的结构与已分配块的结构类似，但有一些差别。空闲块的前部包含了前一个块的大小。<code>head:</code>标记表示这是一个空闲块的头部。在<code>mem</code>指针指向的位置，<strong>存储了块的大小信息和状态标志</strong>（P表示空闲）。空闲块还包含了指向链表中下一个块和前一个块的指针，<strong>形成了循环双向链表的结构</strong>。链表的头部指针指向第一个空闲块。<strong>空闲块的尾部有一个<code>foot:</code>标记，标识块的大小</strong>。</p>
<p>​	<strong>P（PREV_INUSE）位存储在chunk大小的未使用的低位上（chunk大小总是二字倍数）</strong>，它是用于标记<strong>前一个chunk</strong>是否在使用的一个位。如果该位被<em>清除</em>，则当前chunk大小之前的字包含了前一个chunk的大小，并且可以用来找到上一个chunk的开头。第一次分配的chunk总是设置了这个位，这样可以防止访问不存在的（或不属于自己的）内存。如果任何给定的chunk的prev_inuse被设置，则你无法确定前一个chunk的大小，甚至在尝试这样做时可能会遇到内存寻址错误。</p>
<p>​	值得注意的是，当前chunk的<code>foot</code><strong>实际上表示为下一个chunk的prev_size</strong>。这样做可以更容易地处理对齐等问题，但在尝试扩展或适应这段代码时可能会非常困惑。</p>
<p>​	所有这些都有两个异常情况：</p>
<ol>
<li>特殊的chunk <code>顶端</code>（top）并不使用它的后续大小字段，因为没有紧接着的下一个chunk需要依赖它的索引。在初始化后，<code>顶端</code>chunk强制被设置为一直存在。如果它变得小于MINSIZE字节，则会被重新填充。</li>
<li>通过mmap分配的chunks，在其大小字段中设置了第二低位的M（IS_MMAPPED）位。因为它们是单独一个一个分配的，每一个都必须包含自己的后续大小字段。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((Void_t*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE </span></span><br><span class="line"> (<span class="type">unsigned</span> <span class="type">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p)</span></span><br><span class="line"> 	((<span class="type">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem (p))</span><br><span class="line"> 	&amp; MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

<p>​	对于<strong>已经分配的 chunk</strong>，<strong>通过 chunk2mem 宏根据 chunk 地址获得返回给用户的内存地址</strong>，反过来<strong>通过 mem2chunk 宏根据 mem 地址得到 chunk 地址</strong>，chunk 的地址是按 <strong>2 * SIZE_SZ 对齐</strong>的，而 chunk 结构体的<strong>前两个域刚好也是 2*SIZE_SZ 大小</strong>，所以，<strong>mem 地址也是 2 * SIZE_SZ 对齐的</strong>。宏 aligned_OK 和misaligned_chunk(p)用于校验地址是否是按 2 * SIZE_SZ 对齐的。 <strong>MIN_CHUNK_SIZE 定义了最小的 chunk 的大小，32 位平台上位 16 字节，64 位平台为 24 字节或是 32 字节</strong>。<strong>MINSIZE 定义了最小的分配的内存大小</strong>，是对 MIN_CHUNK_SIZE 进行了 2*SIZE_SZ 对齐，地址对齐后与 MIN_CHUNK_SIZE 的大小仍然是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">检查一个请求是否过大，以至于在填充和对齐时会绕回零。为了简化其他代码，边界被设置得足够低，以至于添加MINSIZE也不会绕回零。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req) </span></span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">long</span>)(req) &gt;= </span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(INTERNAL_SIZE_T)(<span class="number">-2</span> * MINSIZE))</span><br><span class="line"><span class="comment">/* 将请求的字节数填充为可用的大小 - 内部版本 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req) </span></span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) </span><br><span class="line">     ? MINSIZE </span><br><span class="line">     : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"><span class="comment">/* 相同功能，同时执行参数检查 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) </span></span><br><span class="line">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123; </span><br><span class="line">    MALLOC_FAILURE_ACTION; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    (sz) = request2size(req);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>这几个宏用于将用户请求的分配大小转换成内部需要分配的 chunk 大小，这里需要注意 的在转换时不但考虑的地址对齐，还额外加上了 SIZE_SZ，这意味着 ptmalloc 分配内存需要 一个额外的overhead，为SIZE_SZ字节，通过chunk的空间复用，我们很容易得出这个overhead 为 SIZE_SZ。</p>
<p><strong>wiki:   当一个 chunk 处于已分配状态时，它的物理相邻的下一个 chunk 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 chunk 使用。这就是 ptmalloc 中 chunk 间的复用。具体流程如下</strong></p>
<ol>
<li>首先，利用 <strong>REQUEST_OUT_OF_RANGE 判断</strong>是否可以分配用户请求的字节大小的 chunk。</li>
<li>其次，需要注意的是用户请求的字节是用来存储数据的，即 chunk header 后面的部分。与此同时，由于 chunk 间复用，所以可以使用下一个 chunk 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</li>
<li>由于系统中所允许的申请的 chunk 最小是 MINSIZE，所以与其进行比较。如果<strong>不满足最低要求，那么就需要直接分配 MINSIZE 字节。</strong></li>
<li><strong>如果大于的话</strong>，因为系统中申请的 chunk 需要 2 * SIZE_SZ 对齐，所以这里需要<strong>加上 MALLOC_ALIGN_MASK 以便于对齐。</strong></li>
</ol>
<p>以 Linux X86_64 平台为例，假设 SIZE_SZ 为 8 字节，空闲时，<strong>一个 chunk 中至少要 4 个 size_t（8B）大小的空间，用来存储 prev_size，size，fd 和 bk，也就是 MINSIZE（32B），chunk 的大小要对齐到 2 * SIZE_SZ（16B）。</strong>当一个 chunk <strong>处于使用状态时</strong>，它的下一个 chunk 的 <strong>prev_size 域肯定是无效</strong>的。所以实际上，这个空间也<strong>可以被当前 chunk 使用</strong>。这听起来有点 不可思议，但确实是<strong>合理空间复用</strong>的例子。故而实际上，一个使用中的 chunk 的大小的计算公式应该是：<strong>in_use_size &#x3D; (用户请求大小+ 16 - 8 ) align to 8B</strong>，这里加 16 是因为需要存储 prev_size 和 size，但又因为向下一个 chunk“借”了 8B，所以要减去 8，<strong>每分配一个 chunk 的 overhead 为 8B</strong>，即 <strong>SIZE_SZ 的大小</strong>。最后，因为空闲的 chunk 和使用中的 chunk 使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即**最终的分配空间 chunk_size &#x3D; max(in_use_size, 32)**。这就是当用户请求内存分配时，ptmalloc 实际需要分配的内存大小。 </p>
<p><strong>注意：如果 chunk 是由 mmap ()直接分配的，则该 chunk 不会有前一个 chunk 和后一个 chunk，所有本 chunk 没有下一个 chunk 的 prev_size 的空间可以“借”，所以对于直接 mmap() 分配内存的 overhead 为 2 * SIZE_SZ,因为每个<code>mmap()</code>分配的内存块都有一个额外的头部和尾部，用于管理和维护内存的相关信息。</strong></p>
<p>对于使用<code>mmap()</code>直接分配的内存块，其内存布局通常是独立的，与其他内存块没有前后关系。因此，这些内存块不会有前一个块或后一个块，也就无法利用前一个块的<code>prev_size</code>字段来存储额外的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前一个相邻的内存块正在使用时，将 size 字段与 PREV_INUSE 进行按位或操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1 </span></span><br><span class="line"><span class="comment">/* 提取前一个内存块的使用位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* 当内存块是通过 mmap() 函数获取时，将 size 字段与 IS_MMAPPED 进行按位或操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2 </span></span><br><span class="line"><span class="comment">/* 检查内存块是否是通过 mmap() 函数获取的 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED) </span></span><br><span class="line"><span class="comment">/* 当内存块来自非主要堆区时，将 size 字段与 NON_MAIN_ARENA 进行按位或操作。</span></span><br><span class="line"><span class="comment">   这仅在必要时在将内存块交给用户之前设置。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"><span class="comment">/*检查内存块是否来自非主要堆区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ol>
<li><code>PREV_INUSE</code>（0x1）：用于表示前一个相邻内存块是否正在使用的标志位。当前一个内存块处于使用状态时，<strong>将该标志位设置为1。</strong></li>
<li><code>prev_inuse(p)</code>：用于提取给定内存块（<code>p</code>）的前一个内存块的使用状态。通过与<code>PREV_INUSE</code>进行按位与操作，可以获取前一个内存块的使用状态。</li>
<li><code>IS_MMAPPED</code>（0x2）：用于表示内存块是否是通过<code>mmap()</code>函数获得的标志位。当内存块是通过<code>mmap()</code>函数分配的时，<strong>将该标志位设置为1。</strong></li>
<li><code>chunk_is_mmapped(p)</code>：用于检查给定内存块（<code>p</code>）是否是通过<code>mmap()</code>函数分配的内存块。<strong>通过与<code>IS_MMAPPED</code>进行按位与操作，可以判断内存块是否是通过<code>mmap()</code>函数分配的。</strong></li>
<li><code>NON_MAIN_ARENA</code>（0x4）：用于表示内存块是否来自非主要堆区（non-main arena）的标志位。非主要堆区是glibc中用于管理多个堆的机制，<strong>当内存块来自非主要堆区时，将该标志位设置为1。</strong></li>
<li><code>chunk_non_main_arena(p)</code>：用于检查给定内存块（<code>p</code>）是否来自非主要堆区。<strong>通过与<code>NON_MAIN_ARENA</code>进行按位与操作，可以判断内存块是否来自非主要堆区。</strong></li>
</ol>
<p>chunk 在分割时总是以地址对齐（默认是 8 字节，可以自由设置，但是 8 字节是最小值 并且设置的值必须是 2 为底的幂函数值，即是 alignment &#x3D; 2^n，n 为整数且 n&gt;&#x3D;3）的方式来 进行的，所以用 chunk-&gt;size 来存储本 chunk 块大小字节数的话，其<strong>末 3bit 位</strong>总是 0，因此 <strong>这三位可以用来存储其它信息</strong>，比如： </p>
<p><strong>以第 0 位作为 P 状态位</strong>，标记<strong>前一</strong>chunk 块是否在使用中，<strong>为 1 表示使用，为 0 表示空闲</strong>。 </p>
<p><strong>以第 1 位作为 M 状态位</strong>，标记本 chunk 块<strong>是否是使用 mmap()直接从进程的 mmap 映射区域分配的</strong>，<strong>为 1 表示是，为 0 表示否。</strong> </p>
<p><strong>以第 2 位作为 A 状态位</strong>，标记本 chunk <strong>是否属于非主分配区</strong>，<strong>为 1 表示是，为 0 表示 否</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"> Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment"> macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment"> cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment"> people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提取大小时要屏蔽的位</span></span><br><span class="line"><span class="comment">注意：在那些不应该看到 mmapped 块的宏中，意图上并没有从大小字段中屏蔽 IS_MMAPPED。</span></span><br><span class="line"><span class="comment">如果由于意外而尝试这样做，这应该导致有用的核心转储发生，以帮助扩展或调整此 malloc 实现的人员。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* 获取大小，忽略使用位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* 指向下一个物理 malloc_chunk 的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"><span class="comment">/* 指向前一个物理 malloc_chunk 的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"><span class="comment">/* 将 ptr + offset 处的空间视为一个块 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char)(p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<p>这些宏的作用如下：</p>
<ol>
<li><code>SIZE_BITS</code>：<strong>用于屏蔽提取大小时不需要的位</strong>。其中包括 <code>PREV_INUSE</code>、<code>IS_MMAPPED</code> 和 <code>NON_MAIN_ARENA</code>。这些位用于标记内存块的状态和属性。</li>
<li><code>chunksize(p)</code>：<strong>用于获取给定内存块（<code>p</code>）的大小</strong>。通过将内存块的 size 字段与 <code>SIZE_BITS</code> 进行按位与操作，可以得到实际的内存块大小，忽略了使用位。</li>
<li><code>next_chunk(p)</code>：<strong>用于获取给定内存块（<code>p</code>）的下一个物理 <code>malloc_chunk</code> 的指针</strong>。通过将内存块的地址加上内存块的大小（忽略了使用位），可以得到下一个物理内存块的地址。</li>
<li><code>prev_chunk(p)</code>：<strong>用于获取给定内存块（<code>p</code>）的前一个物理 <code>malloc_chunk</code> 的指针</strong>。通过将内存块的地址减去前一个内存块的 <code>prev_size</code> 字段的值，可以得到前一个物理内存块的地址。</li>
<li><code>chunk_at_offset(p, s)</code>：<strong>将给定内存块（<code>p</code>）的地址加上偏移量 <code>s</code>，将结果视为一个块的指针</strong>。这个宏用于在指定偏移量处处理内存块。</li>
</ol>
<p>prev_size 字段虽然在当前 chunk 块结构体内，<strong>记录的却是前一个邻接 chunk 块的信息</strong>， 这样做的好处就是我们通过本块 chunk 结构体就可以直接获取到前一 chunk 块的信息，从而 方便做进一步的处理操作。相对的，当前 chunk 块的 foot 信息就存在于下一个邻接 chunk 块的结构体内。字段 prev_size 记录的什么信息呢？有两种情况： </p>
<p>1）如果前一个邻接 chunk 块空闲，那么当前 chunk 块结构体内的 prev_size 字段记录的 是前一个邻接 chunk 块的大小。这就是由当前 chunk 指针获得前一个空闲 chunk 地址的依据。 宏 prev_chunk(p)就是依赖这个假设实现的。 </p>
<p>2）如果前一个邻接 chunk 在使用中，则当前 chunk 的 prev_size 的空间被前一个 chunk 借用中，其中的值是前一个 chunk 的内存内容，对当前 chunk 没有任何意义。 </p>
<p>字段 size 记录了本 chunk 的大小，无论下一个 chunk 是空闲状态或是被使用状态，都可以通过本 chunk 的地址加上本 chunk 的大小，得到下一个 chunk 的地址，由于 size 的低 3 个 bit 记录了控制信息，需要屏蔽掉这些控制信息，取出实际的 size 在进行计算下一个 chunk 地址，这是 next_chunk(p)的实现原理。</p>
<p><strong>浅浅理解：标志位是不占用内存大小的，实际size包含例如pre_size之类的管理信息</strong></p>
<p>宏 chunksize(p)用于获得 chunk 的实际大小，需要屏蔽掉 size 中的控制信息。</p>
<p> 宏 chunk_at_offset(p, s)将 p+s 的地址强制看作一个 chunk。 </p>
<p><strong>注意：按照边界标记法，可以有多个连续的并且正在被使用中的 chunk 块，但是不会有 多个连续的空闲 chunk 块，因为连续的多个空闲 chunk 块一定会合并成一个大的空闲 chunk 块。</strong></p>
<p><strong>补充：合并空闲块的目标通常是为了提高内存利用率和减少内存碎片化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 提取 p 的 inuse 位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)</span></span><br><span class="line">	((((mchunkptr)(((<span class="type">char</span>)(p))+((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span><br><span class="line"><span class="comment">/* 设置/清除块的 inuse 位，同时不影响其他属性 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)</span></span><br><span class="line">	((mchunkptr)(((<span class="type">char</span>)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)</span></span><br><span class="line">	((mchunkptr)(((<span class="type">char</span>*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>inuse(p)</code> 宏用于提取给定内存块 <code>p</code> 的 inuse 位。通过对 <code>p</code> 进行位运算和指针偏移，获取下一个内存块的起始位置，并从其 <code>size</code> 字段中提取出 PREV_INUSE 位的值，<strong>以确定 <code>p</code> 是否被标记为已使用。</strong></li>
<li><code>set_inuse(p)</code> 宏<strong>用于将给定内存块 <code>p</code> 标记为已使用，而不影响其他属性</strong>。通过对 <code>p</code> 进行位运算和指针偏移，获取下一个内存块的起始位置，并将其 <code>size</code> 字段中的 PREV_INUSE 位置为 1，表示该内存块已被使用。</li>
<li><code>clear_inuse(p)</code> 宏<strong>用于将给定内存块 <code>p</code> 标记为未使用，而不影响其他属性</strong>。通过对 <code>p</code> 进行位运算和指针偏移，获取下一个内存块的起始位置，并将其 <code>size</code> 字段中的 PREV_INUSE 位清零，表示该内存块未被使用。</li>
</ul>
<p>上面的这一组宏<strong>用于 check&#x2F;set&#x2F;clear 当前 chunk 使用标志位，</strong>当前 chunk 的使用标志位存储在下一个 chunk 的 size 的第 0 bit（P 状态位），所以首先要获得下一个 chunk 的地址， 然后 check&#x2F;set&#x2F;clear 下一个 chunk 的 size 域的第 0 bit。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)</span></span><br><span class="line">	(((mchunkptr)(((<span class="type">char</span>*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)</span></span><br><span class="line">	(((mchunkptr)(((<span class="type">char</span>*)(p)) + (s)))-&gt;size |= PREV_INUSE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)</span></span><br><span class="line">	(((mchunkptr)(((<span class="type">char</span>*)(p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure>

<p>上面的三个宏用于 check&#x2F;set&#x2F;clear <strong>指定 chunk 的 size 域中的使用标志位</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s) ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;size = (s))</span></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s) (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure>

<p> 宏 set_head_size(p, s)用<strong>于设置当前 chunk p 的 size 域并保留 size 域的控制信息</strong>。宏 set_head(p, s) 用于设置当前 chunk p 的 size 域并忽略已有的 size 域控制信息。宏 set_foot(p,  s)用于设置当前 chunk p 的下一个 chunk 的 prev_size 为 s，s 为当前 chunk 的 size，<strong>只有当 chunk  p 为空闲时才能使用这个宏</strong>，<strong>当前 chunk 的 foot 的内存空间存在于下一个 chunk，即下一个 chunk 的 prev_size。</strong></p>
<h5 id="5-2-分箱式内存管理"><a href="#5-2-分箱式内存管理" class="headerlink" title="5.2 分箱式内存管理"></a>5.2 分箱式内存管理</h5><p>​	对于空闲的 chunk，ptmalloc 采用分箱式内存管理方式，<strong>根据空闲 chunk 的大小和处于的状态将其放在四个不同的 bin 中</strong>，这四个空闲 chunk 的容器包括 <strong>fast bins，unsorted bin， small bins 和 large bins</strong>。<strong>Fast bins</strong> 是<strong>小内存块的高速缓存</strong>，当一些大小<strong>小于 64 字节的 chunk 被回收时</strong>，<strong>首先会放入 fast bins 中</strong>，在<strong>分配小内存时</strong>，<strong>首先会查看 fast bins 中是否有合适的 内存块</strong>，如果存在，则直接返回 fast bins 中的内存块，以加快分配速度。<strong>Usorted bin 只有一个</strong>，<strong>回收的 chunk 块必须先放到 unsorted bin 中</strong>，<strong>分配内存时会查看 unsorted bin 中是否有合适的 chunk</strong>，如果找到满足条件的 chunk，则直接返回给用户，<strong>否则将 unsorted bin 的所有 chunk 放入 small bins 或是 large bins 中</strong>。Small bins 用于<strong>存放固定大小的 chunk</strong>，共 <strong>64</strong> 个 bin，<strong>最小的 chunk 大小为 16 字节或 32 字节</strong>，每个 bin 的<strong>大小相差 8 字节或是 16 字节</strong>，当 分配小内存块时，采用<strong>精确匹配</strong>的方式从 small bins 中查找合适的 chunk。<strong>Large bins 用于存 储大于等于 512B 或 1024B 的空闲 chunk</strong>，这些 chunk 使用双向链表的形式按大小顺序排序， <strong>分配内存时按最近匹配方式从 large bins 中分配 chunk</strong>。</p>
<h5 id="问题小结"><a href="#问题小结" class="headerlink" title="问题小结"></a>问题小结</h5><p><strong>问题：为什么bin数组在遍历的时候会往前跨两个地址，并且将bin元素强转成chunk指针类型？</strong></p>
<p><strong>解答：因为chunk指针指向chunk，如果直接使用bin数组的fd和bk来寻址，那么链表会断掉，因为类型不符合</strong></p>
<p>太强了！！ 强转很重要！！！！</p>
<p>bin 通用的宏如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i)                                                           </span></span><br><span class="line">    (mbinptr)(((<span class="type">char</span> *) &amp;((m)-&gt;bins[ ((i) <span class="number">-1</span>) * <span class="number">2</span> ])) -       <span class="comment">//这里往前跨两个且强转         </span></span><br><span class="line">              offsetof(<span class="keyword">struct</span> malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">//获取下一个bin的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 这两个宏可以用来遍历bin</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表头的 chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表尾的 chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>

<h5 id="5-2-1-Small-bins"><a href="#5-2-1-Small-bins" class="headerlink" title="5.2.1 Small bins"></a>5.2.1 Small bins</h5><p>​	ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index 有如下关系： 	<strong>Chunk_size&#x3D;2 * SIZE_SZ * index</strong> </p>
<p>​	在 <strong>SIZE_SZ 为 4B</strong> 的平台上，small bins 中的 chunk <strong>大小是以 8B 为公差的等差数列</strong>，最大 的 chunk 大小为 <strong>504B</strong>，最小的 chunk 大小为 <strong>16B</strong>，所以<strong>实际共 62 个 bin</strong>。分别为 <strong>16B、24B、 32B，„„，504B</strong>。在 <strong>SIZE_SZ 为 8B</strong> 的平台上，small bins 中的 chunk <strong>大小是以 16B 为公差的等差数列</strong>，最大的 chunk 大小为 <strong>1008B</strong>，最小的 chunk 大小为 <strong>32B</strong>，所以<strong>实际共 62 个 bin</strong>。 分别为 <strong>32B、48B、64B，…… ，1008B</strong>。 </p>
<p>​	<strong>ptmalloc 维护了 62 个双向环形链表</strong>（每个链表<strong>都具有链表头节点</strong>，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程），<strong>每一个链表内的各空闲 chunk 的大小一致</strong>，因此<strong>当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了</strong>， 这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可 以用如下图来表示在 SIZE_SZ 为 4B 的平台上 ptmalloc 对 512B 字节以下的空闲 chunk 组织方 式（所谓的分箱机制）</p>
<p><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202403132101105.png" alt="image-20231219202911816"></p>
<h5 id="5-2-2-Large-bins"><a href="#5-2-2-Large-bins" class="headerlink" title="5.2.2 Large bins"></a>5.2.2 Large bins</h5><p>​	在 SIZE_SZ 为 4B 的平台上，大于等于 512B 的空闲 chunk，或者，在 SIZE_SZ 为 8B 的平 台上，大小大于等于 1024B 的空闲 chunk，由 sorted bins 管理。<strong>Large bins 一共包括 63 个 bin</strong>， <strong>每个 bin 中的 chunk 大小不是一个固定公差的等差数列</strong>，而是<strong>分成 6 组 bin</strong>，<strong>每组 bin 是一个 固定公差的等差数列</strong>，每组的 bin <strong>数量依次为 32、16、8、4、2、1</strong>，<strong>公差依次为 64B、512B、 4096B、32768B、262144B 等</strong>。</p>
<p>​	以 SIZE_SZ 为 4B 的平台为例，第一个 large bin 的起始 chunk 大小为 512B，共 32 个 bin， 公差为 64B，等差数列满足如下关系：</p>
<p>​	<strong>Chunk_size&#x3D;512 + 64 * index</strong></p>
<p>​	第二个 large bin 的起始 chunk 大小为第一组 bin 的结束 chunk 大小，满足如下关系： </p>
<p>​	<strong>Chunk_size&#x3D;512 + 64 * 32 + 512 * index</strong> </p>
<p>​	同理，我们可计算出每个 bin 的起始 chunk 大小和结束 chunk 大小。这些 bin 都是很有规律的，其实 small bins 也是满足类似规律，small bins 可以看着是公差为 8 的等差数列，一 共有 64 个 bin<strong>（第 0 和 1bin 不存在）</strong>，所以我们可以将 small bins 和 large bins 存放在同一个包含 128 个 chunk 的数组上，数组的前一部分位 small bins，后一部分为 large bins，每个 bin 的 index 为 chunk 数组的下标，于是，我们可以根据数组下标计算出该 bin 的 chunk 大小（small bins）或是 chunk 大小范围（large bins），也可以根据需要分配内存块大小计算出所需 chunk 所属 bin 的 index，ptmalloc 使用了一组宏巧妙的实现了这种计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE (NSMALLBINS * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) </span></span><br><span class="line">	((<span class="type">unsigned</span> <span class="type">long</span>)(sz) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)MIN_LARGE_SIZE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) </span></span><br><span class="line">	(SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="type">unsigned</span>)(sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="type">unsigned</span>)(sz)) &gt;&gt; <span class="number">3</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz) </span></span><br><span class="line">	(((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>)? <span class="number">56</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">6</span>): </span><br><span class="line">	((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)? <span class="number">91</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>): </span><br><span class="line">	((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)? <span class="number">110</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>): </span><br><span class="line">	((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)? <span class="number">119</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>): </span><br><span class="line">	((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)? <span class="number">124</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>): </span><br><span class="line">     									  <span class="number">126</span>)</span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz) </span></span><br><span class="line">	(((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>)? <span class="number">48</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">6</span>): </span><br><span class="line">	((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)? <span class="number">91</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>): </span><br><span class="line">	((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)? <span class="number">110</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>): </span><br><span class="line">	((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)? <span class="number">119</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>): </span><br><span class="line">	((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)? <span class="number">124</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>): </span><br><span class="line">										  <span class="number">126</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) </span></span><br><span class="line">	(SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz) : largebin_index_32 (sz))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) </span></span><br><span class="line">	((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span><br></pre></td></tr></table></figure>

<p>​	注意：如果对于用户要分配的内存大小 size， 必须先使用 checked_request2size(req, sz)计算出 chunk 的大小，再使用 bin_index(sz)计算出 chunk 所属的 bin index。 </p>
<p>​	对于 SIZE_SZ 为 4B 的平台，<strong>bin[0]和 bin[1]是不存在的</strong>，因为最小的 chunk 为 16B，small  bins 一共 62 个，large bins 一共 63 个，加起来一共 125 个 bin。而 NBINS 定义为 128，<strong>其实 bin[0]和 bin[127]都不存在</strong>，<strong>bin[1]为 unsorted bin 的 chunk 链表头</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) </span></span><br><span class="line">(mbinptr) (((<span class="type">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>])) - offsetof (<span class="keyword">struct</span> malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) </span></span><br><span class="line">((mbinptr)((<span class="type">char</span>*)(b) + (<span class="keyword">sizeof</span>(mchunkptr)&lt;&lt;<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) </span></span><br><span class="line">((b)-&gt;fd)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) </span></span><br><span class="line">((b)-&gt;bk)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; </span></span><br><span class="line">FD = P-&gt;fd; </span><br><span class="line">BK = P-&gt;bk; </span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) </span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    FD-&gt;bk = BK; </span><br><span class="line">    BK-&gt;fd = FD; </span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123; </span><br><span class="line">        assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); </span><br><span class="line">        assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); </span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (P-&gt;fd_nextsize == P) </span><br><span class="line">                FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                FD-&gt;fd_nextsize = P-&gt;fd_nextsize; </span><br><span class="line">                FD-&gt;bk_nextsize = P-&gt;bk_nextsize; </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = FD; </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = FD; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; </span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>宏 bin_at(m, i)<strong>通过 bin index 获得 bin 的链表头</strong>，<strong>chunk 中的 fb 和 bk 用于将空闲 chunk 链入链表中</strong>，而对于每个 bin 的链表头，只需要这两个域就可以了，<strong>prev_size 和 size 对链表都来说都没有意义</strong>，浪费空间，<strong>ptmalloc</strong> 为了节约这点内存空间，增大 cpu 高速缓存的命中率，<strong>在 bins 数组中只为每个 bin 预留了两个指针的内存空间用于存放 bin 的链表头的 fb 和 bk 指针</strong>。 </p>
<p>从 bin_at(m, i)的定义可以看出，bin[0]不存在，以 SIZE_SZ 为 4B 的平台为例，<strong>bin[1]的前 4B 存储的是指针 fb，后 4B 存储的是指针 bk</strong>，而 <strong>bin_at 返回的是 malloc_chunk 的指针</strong>，由 于 fb 在 malloc_chunk 的偏移地址为 offsetof (struct malloc_chunk, fd))&#x3D;8，所以用 fb 的地址减去 8 就得到 malloc_chunk 的地址。但切记，<strong>对 bin 的链表头的 chunk，一定不能修改 prev_size 和 size 域</strong>，<strong>这两个域是与其他 bin 的链表头的 fb 和 bk 内存复用的</strong>。 </p>
<p><strong>宏 next_bin(b)用于获得下一个 bin 的地址</strong>，根据前面的分析，我们知道<strong>只需要将当前 bin 的地址向后移动两个指针的长度</strong>就得到下一个 bin 的链表头地址。 </p>
<p>每个 bin 使用双向循环链表管理空闲 chunk，<strong>bin 的链表头的指针 fb 指向第一个可用的 chunk</strong>，<strong>指针 bk 指向最后一个可用的 chunk</strong>。<strong>宏 first(b)用于获得 bin 的第一个可用 chunk， 宏 last(b)用于获得 bin 的最后一个可用的 chunk，这两个宏便于遍历 bin，而跳过 bin 的链表头。</strong> </p>
<p><strong>宏 unlink(P, BK, FD)用于将 chunk 从所在的空闲链表中取出来</strong>，注意 <strong>large bins 中的空闲 chunk 可能处于两个双向循环链表中</strong>，unlink 时需要从两个链表中都删除。(还有一个由fdnextsize,bknextsize组成的链表，因为large bin十分特殊，<strong>大小可能不相同</strong>)</p>
<p><strong>注意：bins是声明在malloc_state的指针数组，长度为254，2个元素构成一个bin，bin数组元素指向的是所对应管理的chunk</strong></p>
<h5 id="5-2-3-Unsorted-bin"><a href="#5-2-3-Unsorted-bin" class="headerlink" title="5.2.3  Unsorted bin"></a>5.2.3  Unsorted bin</h5><p>Unsorted bin 可以看作是 small bins 和 large bins 的 cache(缓存)，<strong>只有一个 unsorted bin</strong>，以双向链表管理空闲 chunk，<strong>空闲 chunk 不排序</strong>，所有的 chunk 在<strong>回收时都要先放到 unsorted bin 中</strong>，<strong>分配时</strong>，如果在 <strong>unsorted bin 中没有合适的 chunk</strong>，就<strong>会把 unsorted bin 中的所有 chunk 分别加入到所属的 bin 中</strong>，然后<strong>再在 bin 中分配合适的 chunk</strong>。Bins 数组中的<strong>元素 bin[1]用于 存储 unsorted bin 的 chunk 链表头</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Unsorted chunks</span></span><br><span class="line"><span class="comment"> All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment"> are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment"> in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment"> binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment"> with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment"> and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"> The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment"> does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Top</span></span><br><span class="line"><span class="comment"> The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment"> available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment"> any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment"> released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment"> M_TRIM_THRESHOLD). Because top initially</span></span><br><span class="line"><span class="comment"> points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment"> extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment"> code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment"> need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment"> initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment"> interval between initialization and the first call to</span></span><br><span class="line"><span class="comment"> sYSMALLOc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment"> the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">未排序的块</span></span><br><span class="line"><span class="comment">所有从块分割中剩余的部分，以及所有返回的块，</span></span><br><span class="line"><span class="comment">首先放置在&quot;未排序&quot;的 bin 中。然后，在 malloc 给它们一次使用的机会之前，</span></span><br><span class="line"><span class="comment">将它们放置在常规的 bin 中。因此，基本上，未排序的块列表充当队列，</span></span><br><span class="line"><span class="comment">在释放时将块放置在其中（以及 malloc_consolidate 中），</span></span><br><span class="line"><span class="comment">并在 malloc 中取出（用于使用或放置在 bins 中）。</span></span><br><span class="line"><span class="comment">未排序的块从不设置 NON_MAIN_ARENA 标志，因此在大小比较中不需要考虑它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*无法索引的 1-bin 用于保存未排序的块。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">顶部</span></span><br><span class="line"><span class="comment">最顶部的可用块（即，与可用内存结束边界相邻的块）被特殊对待。</span></span><br><span class="line"><span class="comment">它从不包含在任何 bin 中，仅在没有其他块可用时使用，并且如果非常大（参见 M_TRIM_THRESHOLD）则释放回系统。</span></span><br><span class="line"><span class="comment">因为 top 最初指向自己的 bin，初始大小为零，因此在第一个 malloc 请求时强制扩展，</span></span><br><span class="line"><span class="comment">我们避免在 malloc 中添加任何特殊代码来检查它是否已经存在。</span></span><br><span class="line"><span class="comment">但是，在从系统获取内存时，我们仍然需要这样做，因此我们使 initial_top 在初始化和第一次调用 sYSMALLOc 之间的时间间隔内将 bin 视为合法但不可用的块。（这有些微妙，因为它还依赖于在此时间间隔内前两个字为零。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 方便的是，未排序的 bin 可以在第一次调用时用作虚拟顶部 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure>

<p>上面的宏的定义比较明显，<strong>把 bin[1]设置为 unsorted bin 的 chunk 链表头</strong>，对 top chunk 的初始化，也暂时把 top chunk 初始化为 unsort chunk，<strong>仅仅是初始化一个值而已</strong>，这个 chunk 的内容肯定不能用于 top chunk 来分配内存，主要原因是 <strong>top chunk 不属于任何 bin</strong>，<strong>但 ptmalloc 中的一些 check 代码，可能需要 top chunk 属于一个合法的 bin。</strong></p>
<h5 id="5-2-4-Fast-bins"><a href="#5-2-4-Fast-bins" class="headerlink" title="5.2.4  Fast bins"></a>5.2.4  Fast bins</h5><p>Fast bins 主要是用于提高小内存的分配效率，<strong>默认情况下，对于 SIZE_SZ 为 4B 的平台， 小于 64B 的 chunk 分配请求，对于 SIZE_SZ 为 8B 的平台，小于 128B 的 chunk 分配请求， 首先会查找 fast bins 中是否有所需大小的 chunk 存在（精确匹配），</strong>如果存在，就直接返回。 </p>
<p>Fast bins 可以看着是 small bins 的一小部分 cache，<strong>默认情况下，fast bins 只 cache 了 small  bins 的前 7 个大小的空闲 chunk</strong>，也就是说，对于 SIZE_SZ 为 4B 的平台，fast bins 有 7 个 chunk 空闲链表（bin），每个 bin 的 chunk 大小依次为 16B，24B，32B，40B，48B，56B，64B；对于 SIZE_SZ 为 8B 的平台，fast bins 有 7 个 chunk 空闲链表（bin），每个 bin 的 chunk 大小依 次为 <strong>32B</strong>，48B，64B，80B，96B，112B，<strong>128B</strong>。以 32 为系统为例，分配的内存大小与 chunk 大小和 fast bins 的对应关系如下表所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202403132101106.png" alt="image-20231219224233213"></p>
<p>Fast bins 可以看着是 LIFO 的栈，使用单向链表实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Fastbins</span></span><br><span class="line"><span class="comment"> An array of lists holding recently freed small chunks. Fastbins</span></span><br><span class="line"><span class="comment"> are not doubly linked. It is faster to single-link them, and</span></span><br><span class="line"><span class="comment"> since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment"> double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment"> are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment"> ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment"> fastbins are normally used.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment"> be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment"> releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment"> other free chunks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fast bins</span></span><br><span class="line"><span class="comment">一个包含最近释放的小块的链表数组。fast bins 不是双向链表。</span></span><br><span class="line"><span class="comment">使用单向链接可以更快地操作它们，并且由于这些链表中的块从不被移除，</span></span><br><span class="line"><span class="comment">所以不需要双向链接。此外，与常规 bins 不同，它们甚至不按照 FIFO 的顺序进行处理</span></span><br><span class="line"><span class="comment">（它们使用更快的 LIFO），因为在通常使用fast bins 的瞬时上下文中，顺序并不重要。</span></span><br><span class="line"><span class="comment">fast bins 中的块保持其 inuse 位设置，因此它们不能与其他空闲块合并。</span></span><br><span class="line"><span class="comment">malloc_consolidate 释放fast bins 中的所有块，并将它们与其他空闲块合并。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> <span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>

<p>根据 fast bin 的 index，获得 fast bin 的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">将大小转换为快速 bins 的索引。</span></span><br><span class="line"><span class="comment">这个宏定义用于将块的大小转换为在快速 bins 中的索引。</span></span><br><span class="line"><span class="comment">它使用了一个偏移量 2，以便使用起始的两个 bins，这样就可以处理无法索引的前两个 bins。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) </span></span><br><span class="line"> ((((<span class="type">unsigned</span> <span class="type">int</span>)(sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>​	宏 fastbin_index(sz)<strong>用于获得 fast bin 在 fast bins 数组中的 index</strong>，<strong>由于 bin[0]和 bin[1]中 的chunk不存在，所以需要减2</strong>，对于SIZE_SZ为4B的平台，将sz除以8减2得到fast bin index， 对于 SIZE_SZ 为 8B 的平台，将 sz 除以 16 减去 2 得到 fast bin index。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="comment">/* 我们支持的最大快速 bins 请求大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE))+1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free() </span></span><br><span class="line"><span class="comment"> that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment"> fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment"> matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment"> compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment"> to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment"> consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment"> if trimming is not used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FASTBIN_CONSOLIDATION_THRESHOLD 是在 free() 函数中触发自动合并可能周围的快速 bins 块的块大小阈值。</span></span><br><span class="line"><span class="comment">这是一个启发式值，所以具体的数值并不太重要。它被定义为默认修剪阈值的一半，作为一个折衷的启发式值，</span></span><br><span class="line"><span class="comment">只有当合并可能导致修剪时才尝试合并。然而，它不能动态调整，因为即使不使用修剪，合并也可以减少大块周围的碎片化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure>

<p>​	根据 SIZE_SZ 的不同大小，<strong>定义 MAX_FAST_SIZE 为 80B 或是 160B</strong>，fast bins 数组的大小 NFASTBINS 为 10，FASTBIN_CONSOLIDATION_THRESHOLD 为 64k，<strong>当每次释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 64k 时</strong>，就认为<strong>内存碎片可能比较多</strong>了，就需要 <strong>把 fast bins 中的所有 chunk 都进行合并</strong>，以减少内存碎片对系统的影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Set value of max_fast.</span></span><br><span class="line"><span class="comment"> Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment"> Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment"> Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置 max_fast 的值。</span></span><br><span class="line"><span class="comment">如果为 0，则使用不可能的小值。</span></span><br><span class="line"><span class="comment">前提条件：不存在现有的 fastbin 块。</span></span><br><span class="line"><span class="comment">设置该值会清除 fastchunk 位，但保留非连续 bit。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) </span></span><br><span class="line"> global_max_fast = (((s) == <span class="number">0</span>) ? SMALLBIN_WIDTH: ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure>

<p>​	上面的<strong>宏 DEFAULT_MXFAST 定义了默认的 fast bins 中最大的 chunk 大小</strong>，<strong>对于 SIZE_SZ 为 4B</strong> 的平台，<strong>最大 chunk 为 64B</strong>，对于 <strong>SIZE_SZ 为 8B</strong> 的平台，<strong>最大 chunk 为 128B</strong>。ptmalloc 默认情况下<strong>调用 set_max_fast(s)将全局变量 global_max_fast 设置为 DEFAULT_MXFAST</strong>，也就 是设置 fast bins 中 chunk 的最大值，<strong>get_max_fast()用于获得这个全局变量 global_max_fast 的值</strong>。</p>
<h5 id="5-3-核心结构体分析"><a href="#5-3-核心结构体分析" class="headerlink" title="5.3 核心结构体分析"></a>5.3 核心结构体分析</h5><p>每个分配区是 struct malloc_state 的一个实例，ptmalloc 使用 <strong>malloc_state 来管理分配区</strong>， 而<strong>参数管理使用 struct malloc_par，全局拥有一个唯一的 malloc_par 实例。</strong></p>
<h5 id="5-3-1-malloc-state"><a href="#5-3-1-malloc-state" class="headerlink" title="5.3.1 malloc_state"></a>5.3.1 malloc_state</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="comment">/* 序列化访问 */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="comment">/* 标志位（以前在 max_fast 中） */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="comment">/* 如果 fastbin 块包含最近插入的空闲块，则设置为 1 */</span></span><br><span class="line">  <span class="comment">/* 注意，这是一个布尔值，但并非所有目标平台都支持对布尔值的原子操作 */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  <span class="comment">/* 最顶层块的基址 -- 不在任何 bin 中 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  <span class="comment">/* 最近一次拆分小型请求产生的剩余块 */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">/* 正常 bins，按照上述描述进行打包 */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="comment">/* bins 的位图 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="comment">/* 链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="comment">/* 用于空闲 arenas 的链表。访问该字段由 arena.c 中的 free_list_lock 进行序列化 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">   <span class="comment">/* 附加到该 arena 的线程数。如果该 arena 在空闲列表中，则为 0。访问该字段由 arena.c 中的              free_list_lock 进行序列化 */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  <span class="comment">/* 在该 arena 中从系统分配的内存 */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	<strong>Mutex 用于串行化访问分配区</strong>，当有多个线程访问同一个分配区时，<strong>第一个获得这个 mutex 的线程将使用该分配区分配内存</strong>，<strong>分配完成后，释放该分配区的 mutex</strong>，以便其它线程使用该分配区。</p>
<p>​	<strong>Flags 记录了分配区的一些标志</strong>，<strong>bit0</strong> 用于标识分配区<strong>是否包含至少一个 fast bin chunk</strong>， <strong>bit1</strong> 用于标识分配区<strong>是否能返回连续的虚拟地址空间</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment"> some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment"> fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"> The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment"> upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment"> initialization checks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 max_fast 中持有的 FASTCHUNKS_BIT 表示可能存在一些 fastbin 块。</span></span><br><span class="line"><span class="comment">当将块插入任何 fastbin 中时，将其设置为 true，并且仅在 malloc_consolidate 中清除。</span></span><br><span class="line"><span class="comment">为了使 have_fastchunks 在启动时为 true（因为静态变量会被零填充），真值被取反，简化了初始化检查。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>该注释解释了在 <code>max_fast</code> 中持有的 <strong><code>FASTCHUNKS_BIT</code></strong> 表示可能存在一些 <code>fastbin</code> 块的含义。<strong>当将块插入任何 <code>fastbin</code>中时，会将该标志位设置为 <code>true</code><strong>，并且</strong>只有在 <code>malloc_consolidate</code> 函数中才会清除该标志位</strong>。为了确保在启动时 <code>have_fastchunks</code> 为 <code>true</code>（<strong>因为静态变量会被零填充</strong>），<strong>真值被取反，简化了初始化检查</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) ((M)-&gt;flags |= FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) ((M)-&gt;flags &amp;= ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​	上面的宏<strong>用于设置或是置位 flags 中 fast chunk 的标志位 bit0</strong>，如果 <strong>bit0 为 0</strong>，表示<strong>分配区中有 fast chunk</strong>，<strong>如果为 1 表示没有 fast chunk</strong>，<strong>初始化完成后的 malloc_state 实例中，flags 值为 0</strong>，表示该分配区中有 fast chunk，但<strong>实际上没有</strong>，试图<strong>从 fast bins 中分配 chunk 都会返回 NULL</strong>，在<strong>第一次调用函数 malloc_consolidate()对 fast bins 进行 chunk 合并时</strong>，如果 <strong>max_fast 大于 0</strong>，会<strong>调用 clear_fastchunks 宏</strong>，<strong>标志该分配区中已经没有 fast chunk</strong>，因为函数 malloc_consolidate()会合并所有的 fast bins 中的 chunk。<strong>clear_fastchunks 宏只会在函数 malloc_consolidate()中调用</strong>。<strong>当有 fast chunk 加入 fast bins 时，就是调用 set_fastchunks 宏标 46 识分配区的 fast bins 中存在 fast chunk。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment"> regions. Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment"> when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"> The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment"> changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NONCONTIGUOUS_BIT 表示 MORECORE 不返回连续的内存区域。</span></span><br><span class="line"><span class="comment">否则，在可能的情况下，连续的 MORECORE 调用结果会被合并在一起。</span></span><br><span class="line"><span class="comment">初始值来自 MORECORE_CONTIGUOUS，但如果 mmap 被用作 sbrk 的替代，则会动态更改。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>该注释解释了 <code>NONCONTIGUOUS_BIT</code> 的含义。**<code>NONCONTIGUOUS_BIT</code> 表示 <code>MORECORE</code> 函数不返回连续的内存区域。<strong>在正常情况下，</strong>如果连续的 <code>MORECORE</code> 调用返回的内存区域是相邻的<strong>，那么在</strong>合并内存块时可以利用这种连续性。**</p>
<p>初始情况下，**<code>NONCONTIGUOUS_BIT</code> 的值来自 <code>MORECORE_CONTIGUOUS</code><strong>，但</strong>如果在后续的内存分配中使用了 <code>mmap</code> 作为 <code>sbrk</code> 的替代方式，那么 <code>NONCONTIGUOUS_BIT</code> 的值会动态地进行更改。**</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br></pre></td></tr></table></figure>

<p>​	Flags 的 <strong>bit1 如果为 0</strong>，表示 <strong>MORCORE 返回连续虚拟地址空间</strong>，<strong>bit1 为 1</strong>，表示 <strong>MORCORE 返回非连续虚拟地址空间</strong>，对于<strong>主分配区，MORECORE 其实为 sbr()，默认返回连续虚拟地 址空间</strong>，对于<strong>非主分配区，使用 mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</strong>，而默认情况下 mmap 映射区域是不保证虚拟地址空间连续的，所以<strong>非主分配区默认分配非连续虚拟地址空间。</strong></p>
<p>​	Malloc_state 中声明了几个对锁的统计变量，<strong>默认没有定义 THREAD_STATS</strong>，所以<strong>不会对锁的争用情况做统计</strong>。 </p>
<p>​	<strong>fastbinsY 拥有 10（NFASTBINS）个元素的数组</strong>，<strong>用于存放每个 fast chunk 链表头指针</strong>， <strong>所以 fast bins 最多包含 10 个 fast chunk 的单向链表。</strong> </p>
<p>​	<strong>top 是一个 chunk 指针</strong>，<strong>指向分配区的 top chunk</strong>。 </p>
<p>​	<strong>last_remainder 是一个 chunk 指针</strong>，分配区上次分配 small chunk 时，从一个 chunk 中分裂出一个 small chunk 返回给用户，<strong>分裂后的剩余部分形成一个 chunk，last_remainder 就是指向的这个 chunk。</strong></p>
<p>​	<strong>bins 用于存储 unstored bin，small bins 和 large bins 的 chunk 链表头</strong>，small bins 一共 62 个，large bins 一共 63 个，加起来一共 125 个 bin。而 NBINS 定义为 128，其实 bin[0]和 bin[127] 都不存在，bin[1]为 unsorted bin 的 chunk 链表头，所以实际只有 126bins。<strong>Bins 数组能存放 了 254（NBINS * 2 – 2）个 mchunkptr 指针</strong>，而我们实现需要存储 chunk 的实例，一般情况下， <strong>chunk 实例的大小为 6 个 mchunkptr 大小</strong>，这 254 个指针的大小怎么能存下 126 个 chunk 呢？ 这里使用了一个技巧，如果按照我们的常规想法，也许会申请 126 个 malloc_chunk 结构体指针元素的数组，然后再给链表申请一个头节点（即 126 个），再让每个指针元素正确指向而形成 126 个具有头节点的链表。事实上，对于 malloc_chunk 类型的链表“头节点”，其内的 <strong>prev_size 和 size 字段是没有任何实际作用的，fd_nextsize 和 bk_nextsize 字段只有 large bins 中的空闲 chunk 才会用到，而对于 large bins 的空闲 chunk 链表头不需要这两个字段，因此 这四个字段所占空间如果不合理使用的话那就是白白的浪费。</strong>我们再来看一看 128 个 malloc_chunk 结构体指针元素的数组占了多少内存空间呢？<strong>假设 SIZE_SZ 的大小为 8B，则指针的大小也为 8B</strong>，结果为 126 * 2 * 8&#x3D;2016 字节。而 126 个 malloc_chunk 类型的链表“头节点” 需要多少内存呢？126 * 6 * 8&#x3D;6048，真的是 6048B 么？不是，刚才不是说了，prev_size，size， fd_nextsize 和 bk_nextsize 这四个字段是没有任何实际作用的，因此完全可以被重用（覆盖）， 47 因此实际需要内存为 126<em>2</em>8&#x3D;2016。<em><em>Bins 指针数组的大小为，（128 * 2 - 2）</em> 8&#x3D;2032</em>* , 2032 大 于 2016（<strong>事实上最后 16 个字节都被浪费掉了</strong>），那么这 <strong>254 个 malloc_chunk结构体指针元素数组所占内存空间就可以存储这 126 个头节点了。</strong></p>
<p>​	<strong>binmap 字段是一个 int 数组，ptmalloc 用一个 bit 来标识该 bit 对应的 bin 中是否包含空 闲 chunk。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Binmap</span></span><br><span class="line"><span class="comment"> To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment"> structure is used for bin-by-bin searching. `binmap&#x27; is a</span></span><br><span class="line"><span class="comment"> bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment"> be skipped over during during traversals. The bits are NOT always</span></span><br><span class="line"><span class="comment"> cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment"> when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">位图（Binmap）</span></span><br><span class="line"><span class="comment">为了弥补大量的 bin（内存块链表），使用了一级索引结构来进行逐个 bin 的搜索。</span></span><br><span class="line"><span class="comment">binmap 是一个位向量，记录了哪些 bin 明确为空，以便在遍历过程中可以跳过这些空的 bin。</span></span><br><span class="line"><span class="comment">这些位在 bin 变为空时并不总是立即清除，而是在 malloc 的遍历过程中注意到它们为空时才进行清除。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT)-1))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m,i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>binmap 一共 128bit，16 字节，4 个 int 大小</strong>，binmap 按 int 分成 4 个 block，每个 block 有 32 个 bit，根据 bin indx 可以使用宏 idx2block 计算出该 bin 在 binmap 对应的 bit 属于哪个 block。idx2bit 宏取第 i 位为 1，其它位都为 0 的掩码，举个例子：idx2bit(3) 为 “0000 1000” （只显示 8 位）。<strong>mark_bin 设置第 i 个 bin 在 binmap 中对应的 bit 位为 1；unmark_bin 设置 第 i 个 bin 在 binmap 中对应的 bit 位为 0；get_binmap 获取第 i 个 bin 在 binmap 中对应的 bit。</strong> </p>
<p>​	<strong>next 字段用于将分配区以单向链表链接起来。</strong> </p>
<p>​	<strong>next_free 字段空闲的分配区链接在单向链表中，只有在定义了 PER_THREAD 的情况下才 定义该字段。</strong> </p>
<p>​	<strong>system_mem 字段记录了当前分配区已经分配的内存大小。</strong> </p>
<p>​	<strong>max_system_mem 记录了当前分配区最大能分配的内存大小。</strong></p>
<h4 id="堆相关数据结构-大部分与上述重复"><a href="#堆相关数据结构-大部分与上述重复" class="headerlink" title="堆相关数据结构(大部分与上述重复)"></a>堆相关数据结构(大部分与上述重复)</h4><p><strong>！！！一些关于堆的约束，后面详细考虑！！！</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The three exceptions to all this are:</span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">    trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">    that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">    is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">    MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">    bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">    allocated one-by-one, each must contain its own trailing size</span></span><br><span class="line"><span class="comment">    field.  If the M bit is set, the other bits are ignored</span></span><br><span class="line"><span class="comment">    (because mmapped chunks are neither in an arena, nor adjacent</span></span><br><span class="line"><span class="comment">    to a freed chunk).  The M bit is also used for chunks which</span></span><br><span class="line"><span class="comment">    originally came from a dumped heap via malloc_set_state in</span></span><br><span class="line"><span class="comment">    hooks.c.</span></span><br><span class="line"><span class="comment">     3. Chunks in fastbins are treated as allocated chunks from the</span></span><br><span class="line"><span class="comment">    point of view of the chunk allocator.  They are consolidated</span></span><br><span class="line"><span class="comment">    with their neighbors only in bulk, in malloc_consolidate.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在所有这些规则之外，有三个例外情况：</span></span><br><span class="line"><span class="comment">     1. 特殊块 top 不使用尾部的大小字段，因为没有下一个连续的块需要引用它。在初始化之后，top 始终存在。如果它的长度变得小于 MINSIZE 字节，它会被重新填充。</span></span><br><span class="line"><span class="comment">     2. 通过 mmap 分配的块，在其大小字段中设置了第二低位 M（IS_MMAPPED）。因为它们是逐个分配的，每个块必须包含自己的尾部大小字段。如果设置了 M 位，其他位将被忽略（因为 mmapped 块既不在一个 arena 中，也不与已释放的块相邻）。M 位还用于最初通过 hooks.c 中的 malloc_set_state 从已转储堆中获取的块。</span></span><br><span class="line"><span class="comment">     3. 快速分配链表（fastbins）中的块在块分配器的视角中被视为已分配的块。它们仅在 malloc_consolidate 中批量与相邻块合并。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h5><p>glibc 中对于 top chunk 的描述如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure>

<p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用<strong>在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk</strong>。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p>
<p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p>
<h5 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h5><p>在用户使用 malloc 请求分配内存时，<strong>ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致</strong>，这时候<strong>就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块</strong>。<strong>top chunk 分割剩下的部分不会作为 last remainder.</strong></p>
<h4 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h4><h5 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h5><p>在我们之前介绍的例子中，无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的 arena。那么会不会每个线程都有独立的 arena 呢？下面我们就具体介绍。</p>
<h5 id="arena-数量"><a href="#arena-数量" class="headerlink" title="arena 数量"></a>arena 数量</h5><p>对于不同系统，arena 数量的<a target="_blank" rel="noopener" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847">约束</a>如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores.</span><br></pre></td></tr></table></figure>

<p>显然，不是每一个线程都会有对应的 arena。至于为什么 64 位系统，要那么设置，我也没有想明白。此外，因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 arena。</p>
<h5 id="arena-分配规则-来自于不知名博客，不确定其完全正确性"><a href="#arena-分配规则-来自于不知名博客，不确定其完全正确性" class="headerlink" title="arena 分配规则(来自于不知名博客，不确定其完全正确性)"></a>arena 分配规则(来自于不知名博客，不确定其完全正确性)</h5><p>Ptmalloc2通过几种数据结构来进行管理，主要有arena,heap,chunk三种层级。<strong>arena和heap都是对chunk的一种组织方式，方便之后的分配，arena又是对heap的组织，arene是堆管理器。</strong></p>
<ul>
<li><p><code>arena</code>: 有一个main_arena，是由主线程创建的，thread_arena则为各线程创建的，当arena满了之后就不再创建而是与其他arena共享一个arena，方法为依次给各个arena上锁（查看是否有其他线程正在使用该arena），如果上锁成功（没有其他线程正在使用），则使用该arena，之后一直使用这个arena，如果无法使用则阻塞等待。</p>
</li>
<li><p><code>heap</code>的等级就比arena要低一些了，一个arena可以有多个heap，也是存储了堆相关的信息。</p>
</li>
<li><p><code>chunk</code>为分配给用户的内存的一个单位，每当我们分配一段内存的时候其实就是分配得到了一个chunk，我们就可以在chunk当中进行一定的操作了。不过为了进行动态分配，chunk本身也有一些数据（元数据），是用来指示其分配等等的数据。</p>
</li>
<li><p>glibc的malloc源码中涉及三种最重要数据结构：<strong>Arena、Heap、Chunk</strong> ，分别对应结构体<strong>malloc_state、heap_info、malloc_chunk 。</strong>每个数据结构都有对应的结构体实现,如图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202403132101107.png" alt="image-20231220232830154"></p>
<ul>
<li><strong>Thread - Arena</strong> ： <strong>一个Arena对应多个线程Thread</strong>。即<strong>每个线程都有一个Arena</strong>，但是**有可能多个线程共用一个Arena(同一时间只能一对一)**。每个Arena都包含一个malloc_state结构体，保存bins, top chunk, Last reminder chunk等信息。</li>
<li><strong>Arena - Heap</strong>：一个Arena可能拥有多个heap。Arena开始的时候只有一个heap，<strong>但是当这个heap的空间用尽时，就需要获取新的heap</strong>。(也可以理解为subheap子堆)</li>
<li><strong>Heap - Chunk</strong>：一个Heap根据用户的请求会划分为多个chunk，<strong>每个chunk拥有自己的header - malloc_chunk。</strong></li>
</ul>
</li>
</ul>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>与 thread 不同的是，main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p>
<h5 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h5><p>程序刚开始执行时，每个线程是没有 heap 区域的。当其申请内存时，就需要一个结构来记录对应的信息，而 heap_info 的作用就是这个。而且当该 heap 的资源被使用完后，就必须得再次申请内存了。此外，一般申请的 heap 是不连续的，因此需要记录不同 heap 之间的链接结构。</p>
<p><strong>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程准备的。</strong></p>
<p>主线程可以通过 sbrk() 函数扩展 program break location 获得（直到触及 Memory Mapping Segment），只有一个 heap，没有 heap_info 数据结构。</p>
<p><strong>heap_info 的主要结构如下</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps</span></span><br><span class="line"><span class="comment">   that are dynamically created for multi-threaded programs.  The</span></span><br><span class="line"><span class="comment">   maximum size must be a power of two, for fast determination of</span></span><br><span class="line"><span class="comment">   which heap belongs to a chunk.  It should be much larger than the</span></span><br><span class="line"><span class="comment">   mmap threshold, so that requests with a size just below that</span></span><br><span class="line"><span class="comment">   threshold can be fulfilled without creating too many heaps.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* 必须是2的幂次方 */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE和HEAP_MAX_SIZE限制了为多线程程序动态创建的mmap()堆的大小。</span></span><br><span class="line"><span class="comment">   最大大小必须是2的幂次方，以便快速确定一个内存块属于哪个堆。</span></span><br><span class="line"><span class="comment">   它应该比mmap阈值大得多，这样可以满足大小接近阈值的请求而不会创建太多堆。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆（heap）是一个连续的内存区域，包含（可合并的）malloc_chunk。</span></span><br><span class="line"><span class="comment">   它是通过mmap()分配的，并且始终从HEAP_MAX_SIZE对齐的地址开始。 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* 该堆所属的Arena。 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* 前一个堆。 */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* 当前大小（以字节为单位）。 */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* 已通过mprotect设置为PROT_READ|PROT_WRITE的内存大小（以字节为单位）。 */</span></span><br><span class="line">  <span class="comment">/* 确保以下数据正确对齐，特别是sizeof(heap_info) + 2 * SIZE_SZ是MALLOC_ALIGNMENT的倍数。 */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该结构主要是描述堆的基本信息，包括</p>
<ul>
<li><strong>堆对应的 arena 的地址</strong></li>
<li>由于一个线程申请一个堆之后，可能会使用完，之后就必须得再次申请。因此，一个线程可能会有多个堆。prev 即记录了上一个 heap_info 的地址。这里可以看到每个堆的 heap_info 是<strong>通过单向链表进行链接的。</strong></li>
<li><strong>size 表示当前堆的大小</strong></li>
<li>最后一部分<strong>确保对齐</strong></li>
</ul>
<p><strong>pad 里负数的缘由是什么呢？</strong></p>
<p><code>pad</code> 是为了确保分配的空间是按照 <code>MALLOC_ALIGN_MASK+1</code> (记为 <code>MALLOC_ALIGN_MASK_1</code>) 对齐的。在 <code>pad</code> 之前该结构体一共有 6 个 <code>SIZE_SZ</code> 大小的成员, 为了确保 <code>MALLOC_ALIGN_MASK_1</code> 字节对齐, 可能需要进行 <code>pad</code>，不妨假设该结构体的最终大小为 <code>MALLOC_ALIGN_MASK_1*x</code>，其中 <code>x</code> 为自然数，那么需要 <code>pad</code> 的空间为 <code>MALLOC_ALIGN_MASK_1 * x - 6 * SIZE_SZ = (MALLOC_ALIGN_MASK_1 * x - 6 * SIZE_SZ) % MALLOC_ALIGN_MASK_1 = 0 - 6 * SIZE_SZ % MALLOC_ALIGN_MASK_1=-6 * SIZE_SZ % MALLOC_ALIGN_MASK_1 = -6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK</code>。</p>
<p>看起来该结构应该是相当重要的，但是如果如果我们仔细看完整个 malloc 的实现的话，就会发现它出<strong>现的频率并不高。</strong></p>
<h5 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h5><p><strong>该结构用于管理堆</strong>，<strong>记录每个 arena 当前申请的内存的具体状态</strong>，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。<strong>无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构</strong>。由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。</p>
<p><strong>注意，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p>
<p>其结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="comment">/* 序列化访问 */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="comment">/* 标志位（以前在 max_fast 中） */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="comment">/* 如果 fastbin 块包含最近插入的空闲块，则设置为 1 */</span></span><br><span class="line">  <span class="comment">/* 注意，这是一个布尔值，但并非所有目标平台都支持对布尔值的原子操作 */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  <span class="comment">/* 最顶层块的基址 -- 不在任何 bin 中 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  <span class="comment">/* 最近一次拆分小型请求产生的剩余块 */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">/* 正常 bins，按照上述描述进行打包 */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="comment">/* bins 的位图 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="comment">/* 链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="comment">/* 用于空闲 arenas 的链表。访问该字段由 arena.c 中的 free_list_lock 进行序列化 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">     Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="comment">/* 附加到该 arena 的线程数。如果该 arena 在空闲列表中，则为 0。访问该字段由 arena.c 中的              free_list_lock 进行序列化 */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  <span class="comment">/* 在该 arena 中从系统分配的内存 */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>_libc_lock_define(, mutex);</strong><ul>
<li>该变量<strong>用于控制程序串行访问同一个分配区</strong>，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。</li>
</ul>
</li>
<li><strong>flags</strong><ul>
<li>flags 记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。具体如下</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT在max_fast中表示可能存在一些fastbin块。</span></span><br><span class="line"><span class="comment">   它在将块放入任何fastbin时设置为true，并且仅在malloc_consolidate中清除。</span></span><br><span class="line"><span class="comment">   真值取反，以便在启动时have_fastchunks为true（因为静态变量被零填充），</span></span><br><span class="line"><span class="comment">   简化了初始化检查。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT指示MORECORE不返回连续的内存区域。</span></span><br><span class="line"><span class="comment">   否则，在可能的情况下，利用连续性合并连续MORECORE调用的结果。</span></span><br><span class="line"><span class="comment">   初始值来自MORECORE_CONTIGUOUS，但如果mmap被用作sbrk替代品，则会动态更改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT如果在arena上检测到内存损坏，则设置。</span></span><br><span class="line"><span class="comment">   这样的arena不再用于分配块。在检测到损坏之前在该arena中分配的块不会被释放。 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>fastbinsY[NFASTBINS]</strong><ul>
<li><strong>存放每个 fast chunk 链表头部的指针</strong></li>
</ul>
</li>
<li><strong>top</strong><ul>
<li><strong>指向分配区的 top chunk</strong></li>
</ul>
</li>
<li><strong>last_reminder</strong><ul>
<li><strong>最新的 chunk 分割之后剩下的那部分</strong></li>
</ul>
</li>
<li><strong>bins</strong><ul>
<li><strong>用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</strong></li>
</ul>
</li>
<li><strong>binmap</strong><ul>
<li><strong>ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。</strong></li>
</ul>
</li>
</ul>
<h5 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h5><p><strong>！！待补充！！</strong></p>
<h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><h5 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h5><p>unlink 用来<strong>将一个双向链表（只存储空闲的 chunk）中的一个元素取出来</strong>，可能在以下地方使用</p>
<ul>
<li><strong>malloc</strong><ul>
<li>从恰好大小合适的 large bin 中获取 chunk。<ul>
<li><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</strong></li>
<li><strong>依次遍历处理 unsorted bin 时也没有使用 unlink 。</strong></li>
</ul>
</li>
<li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</li>
</ul>
</li>
<li><strong>free</strong><ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li><strong>malloc_consolidate</strong><ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li><strong>realloc</strong><ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
</ul>
<p>由于 unlink 使用非常频繁，所以 unlink 被实现为了一个宏，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="comment">// unlink p</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    <span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class="line">    FD = P-&gt;fd;                                                                      </span><br><span class="line">    BK = P-&gt;bk;                                                                      </span><br><span class="line">    <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                      </span><br><span class="line">        FD-&gt;bk = BK;                                                              </span><br><span class="line">        BK-&gt;fd = FD;                                                              </span><br><span class="line">        <span class="comment">// 下面主要考虑 P 对应的 nextsize 双向链表的修改</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                              </span><br><span class="line">            <span class="comment">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span></span><br><span class="line">            <span class="comment">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span></span><br><span class="line">            <span class="comment">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span></span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      </span><br><span class="line">            <span class="comment">// 类似于小的 chunk 的检查思路</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">              malloc_printerr (check_action,                                      </span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">                               P, AV);                                              </span><br><span class="line">            <span class="comment">// 这里说明 P 已经在 nextsize 链表中了。</span></span><br><span class="line">            <span class="comment">// 如果 FD 没有在 nextsize 链表中</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      </span><br><span class="line">                <span class="comment">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span></span><br><span class="line">                <span class="comment">// 令 FD 为 nextsize 串起来的</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                    </span><br><span class="line">                <span class="keyword">else</span> &#123;                                                              </span><br><span class="line">                <span class="comment">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span></span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              </span><br><span class="line">                  &#125;                                                              </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                                              </span><br><span class="line">                <span class="comment">// 如果在的话，直接拿走即可</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      </span><br><span class="line">              &#125;                                                                      </span><br><span class="line">          &#125;                                                                      </span><br><span class="line">      &#125;                                                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们以 small bin 的 unlink 为例子介绍一下。对于 large bin 的 unlink，与其类似，只是多了一个 nextsize 的处理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202403132101108.png" alt="img"></p>
<p>可以看出， <strong>P 最后的 fd 和 bk 指针并没有发生变化</strong>，但是当我们去遍历整个双向链表时，已经遍历不到对应的链表了。这一点没有变化还是很有用处的，因为我们有时候可以使用这个方法来泄漏地址</p>
<ul>
<li><strong>libc 地址</strong><ul>
<li>P 位于双向链表头部，bk 泄漏</li>
<li>P 位于双向链表尾部，fd 泄漏</li>
<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li>
</ul>
</li>
<li><strong>泄漏堆地址</strong>，双向链表包含多个空闲 chunk<ul>
<li>P 位于双向链表头部，fd 泄漏</li>
<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>
<li>P 位于双向链表尾部，bk 泄漏</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>这里的<strong>头部</strong>指的是 bin 的 fd 指向的 chunk，即双向链表中<strong>最新加入的 chunk</strong>。</li>
<li>这里的<strong>尾部</strong>指的是 bin 的 bk 指向的 chunk，即双向链表中<strong>最先加入的 chunk</strong>。</li>
</ul>
<p>同时，无论是对于 fd，bk 还是 fd_nextsize ，bk_nextsize，程序都会检测 fd 和 bk 是否满足对应的要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// next_size related</span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">              malloc_printerr (check_action,<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure>

<p>看起来似乎很正常。我们以 fd 和 bk 为例，P 的 forward chunk 的 bk 很自然是 P ，同样 P 的 backward chunk 的 fd 也很自然是 P 。如果没有做相应的检查的话，我们可以修改 P 的 fd 与 bk，从而可以很容易地达到任意地址写的效果。关于更加详细的例子，可以参见利用部分的 unlink 。</p>
<p><strong>注意：堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></p>
<h5 id="malloc-printerr"><a href="#malloc-printerr" class="headerlink" title="malloc_printerr"></a>malloc_printerr</h5><p>在 glibc malloc 时检测到错误的时候，会调用 <code>malloc_printerr</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_printerr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  __libc_message(do_abort, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要会<strong>调用 <code>__libc_message</code> 来执行<code>abort</code> 函数</strong>，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((action &amp; do_abort)) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((action &amp; do_backtrace))</span><br><span class="line">    BEFORE_ABORT(do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Kill the application.  */</span></span><br><span class="line">  <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在<code>abort</code> 函数里，在 glibc 还是 2.23 版本时，会 fflush stream</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class="line"><span class="comment">   might have registered a handler for SIGABRT.  */</span></span><br><span class="line"><span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ++stage;</span><br><span class="line">    fflush (<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h5><p>堆初始化是在<strong>用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的</strong>。这里不做过多讲解。可以参见 <code>malloc_state</code> 相关函数。</p>
<h4 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h4><h5 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h5><p>一般我们会使用 malloc 函数来申请内存块，可是当仔细看 glibc 的源码实现时，其实并没有 malloc 函数。其实该函数真正调用的是 __libc_malloc 函数。为什么不直接写个 malloc 函数呢，因为有时候我们可能需要不同的名称。此外，__libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。下面我们来仔细分析一下具体的实现。</p>
<p>该函数会<strong>首先检查是否有内存分配函数的钩子函数（__malloc_hook）</strong>，这个主要用于用户自定义的堆分配函数，方便用户快速修改堆分配函数并进行测试。这里需要注意的是，<strong>用户申请的字节一旦进入申请内存函数中就变成了无符号整数</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="type">void</span> *__libc_malloc(<span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    mstate ar_ptr;     <span class="comment">//表示堆管理器的状态</span></span><br><span class="line">    <span class="type">void</span> * victim;    <span class="comment">//表示分配的内存块的指针</span></span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="type">void</span> *(*hook)(<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));   </span><br><span class="line">    <span class="comment">//钩子函数接受两个参数：分配的字节数和返回地址。这里使用RETURN_ADDRESS(0)获取当前函数的返回地址作为参数传递给钩子函数</span></span><br><span class="line">    <span class="comment">//如果不存在内存分配钩子，则继续执行后续的内存分配操作</span></span><br></pre></td></tr></table></figure>

<p>接着会寻找一个 arena 来试图分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br></pre></td></tr></table></figure>

<p>然后调用 _int_malloc 函数去申请对应的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br></pre></td></tr></table></figure>

<p>如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena before.  */</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);  <span class="comment">//用于在给定的堆管理器中查找另一个可用的堆管理器的函数</span></span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果申请到了 arena，那么在退出之前还得<strong>解锁</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>) __libc_lock_unlock(ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure>

<p>判断目前的状态是否满足以下条件</p>
<ul>
<li>要么没有申请到内存</li>
<li>要么是 mmap 的内存</li>
<li><strong>要么申请到的内存必须在其所分配的 arena 中</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||ar_ptr == arena_for_chunk(mem2chunk(victim)));  <span class="comment">//断言语句，假则中断程序，确保在特定情况下，victim指针的状态与堆管理器的状态相符合</span></span><br></pre></td></tr></table></figure>

<p>最后返回内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h5><p>_int_malloc 是内存分配的核心函数，其核心思路有如下</p>
<ol>
<li>它根据用户申请的<strong>内存块大小</strong>以及<strong>相应大小 chunk 通常使用的频度</strong>（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li>
<li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li>
<li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li>
<li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">在进入该函数后，函数立马定义了一系列自己需要的变量，并将用户申请的内存大小转换为内部的 chunk 大小。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *_int_malloc(mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  <span class="comment">/* normalized request size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    idx; <span class="comment">/* associated bin index */</span></span><br><span class="line">    mbinptr         bin; <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr       victim;       <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T size;         <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">int</span>             victim_index; <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr     remainder;      <span class="comment">/* remainder from a split */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> block; <span class="comment">/* bit map traverser */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bit;   <span class="comment">/* bit map traverser */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;   <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr fwd; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr bck; <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">       overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">       to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">       size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">       that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">       aligned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    checked_request2size(bytes, nb);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *_int_malloc(mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  <span class="comment">/* 规范化后的请求大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx;   <span class="comment">/* 相关联的bin索引 */</span></span><br><span class="line">    mbinptr bin;        <span class="comment">/* 相关联的bin */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr victim;       <span class="comment">/* 被检查/选择的chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T size;   <span class="comment">/* chunk的大小 */</span></span><br><span class="line">    <span class="type">int</span> victim_index;       <span class="comment">/* chunk的bin索引 */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr remainder;      <span class="comment">/* 分割后的剩余部分 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* 剩余部分的大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> block; <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bit;   <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;   <span class="comment">/* 当前binmap的字 */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr fwd; <span class="comment">/* 用于链接的临时变量 */</span></span><br><span class="line">    mchunkptr bck; <span class="comment">/* 用于链接的临时变量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       通过添加SIZE_SZ字节的开销，将请求大小转换为内部形式，</span></span><br><span class="line"><span class="comment">       可能还需要更多的字节以获得必要的对齐和/或至少为MINSIZE的大小，</span></span><br><span class="line"><span class="comment">       MINSIZE是最小可分配大小。此外，checked_request2size函数</span></span><br><span class="line"><span class="comment">       会检查并阻止（返回0）请求大小太大，以至于在填充和对齐时</span></span><br><span class="line"><span class="comment">       四舍五入为零。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    checked_request2size(bytes, nb);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="arena-1"><a href="#arena-1" class="headerlink" title="arena"></a>arena</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(av == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h5><p>如果申请的 chunk 的大小位于 fastbin 范围内，<strong>需要注意的是这里比较的是无符号整数</strong>。<strong>此外，是从 fastbin 的头结点开始取 chunk</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">       This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">       can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果大小符合快速分配块的条件，首先检查相应的bin。</span></span><br><span class="line"><span class="comment">   即使av(内存管理状态结构体)尚未初始化，这段代码也可以安全执行，因此我们可以在不检查的情况下尝试执行它，</span></span><br><span class="line"><span class="comment">   这在这个快速路径上节省了一些时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast())) &#123;</span><br><span class="line">        <span class="comment">// 得到对应的fastbin的下标</span></span><br><span class="line">        idx             = fastbin_index(nb);</span><br><span class="line">        <span class="comment">// 得到对应的fastbin的头指针</span></span><br><span class="line">        mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">        mchunkptr    pp = *fb;</span><br><span class="line">        <span class="comment">// 利用fd遍历对应的bin内是否有空闲的chunk块，</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            victim = pp;</span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,victim)) != victim);</span><br><span class="line">        <span class="comment">// 存在可以利用的chunk</span></span><br><span class="line">        <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。</span></span><br><span class="line">            <span class="comment">// 根据取得的 victim ，利用 chunksize 计算其大小。</span></span><br><span class="line">            <span class="comment">// 利用fastbin_index 计算 chunk 的索引。</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">                malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 细致的检查。。只有在 DEBUG 的时候有用</span></span><br><span class="line">            check_remalloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将获取的到chunk转换为mem模式</span></span><br><span class="line">            <span class="type">void</span> *p = chunk2mem(victim); <span class="comment">//将内存块的起始地址转换为指向实际可用内存的指针</span></span><br><span class="line">            <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes); <span class="comment">//对内存块进行初始化</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h5><p>如果获取的内存块的范围处于 small bin 的范围，那么执行如下流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If a small request, check regular bin.  Since these &quot;smallbins&quot; hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">       (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">       processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">       anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果是小的内存请求，检查常规的空闲块链表。由于这些&quot;smallbins&quot;只包含一种大小的内存块，所以不需要在链表中进行搜索。</span></span><br><span class="line"><span class="comment">   （对于大的内存请求，我们需要等待未排序的内存块被处理以找到最佳匹配。但对于小的请求，匹配是精确的，所以我们可以立即检查，这样更快。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">        <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。//自循环</span></span><br><span class="line">        <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">                <span class="comment">// 细致的检查，非调试状态没有作用</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">                <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">                alloc_perturb(p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h5><p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">       While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">       even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">       fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">       Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">       large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">       invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">       it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果这是一个大的内存请求，在继续之前先合并 fastbins。</span></span><br><span class="line"><span class="comment">   尽管在查看是否有可用空间之前杀死所有 fastbins 看起来可能有些过度，</span></span><br><span class="line"><span class="comment">   但这样可以避免通常与 fastbins 相关的碎片化问题。</span></span><br><span class="line"><span class="comment">   此外，在实践中，程序往往会有连续的小内存请求或大内存请求的运行，</span></span><br><span class="line"><span class="comment">   但很少有混合请求，因此在大多数程序中不经常调用合并操作。</span></span><br><span class="line"><span class="comment">   而对于频繁调用合并操作的程序，通常会发生碎片化问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取large bin的下标。</span></span><br><span class="line">        idx = largebin_index(nb);</span><br><span class="line">        <span class="comment">// 如果存在fastbin的话，会处理 fastbin</span></span><br><span class="line">        <span class="keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>bk是前驱节点，fd是后继节点，别记错了咩</strong></p>
<h5 id="大循环-遍历-unsorted-bin"><a href="#大循环-遍历-unsorted-bin" class="headerlink" title="大循环 - 遍历 unsorted bin"></a>大循环 - 遍历 unsorted bin</h5><p><strong>如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk 可以直接满足需求 ，但是 large chunk 则是在这个大循环中处理</strong>。</p>
<p>在接下来的这个循环中，主要做了以下的操作</p>
<ul>
<li>按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来<ul>
<li>如果是 small request，则考虑是不是恰好满足，是的话，直接返回。</li>
<li>如果不是的话，放到对应的 bin 中。</li>
</ul>
</li>
<li>尝试从 large bin 中分配用户所需的内存</li>
</ul>
<p>该部分是一个大循环，这是<strong>为了尝试重新分配 small bin chunk</strong>，这是因为我们虽然会首先使用 large bin，top chunk 来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功 small bin，我们并没有对 fast bin 中的 chunk 进行合并，所以<strong>这里会进行 fast bin chunk 的合并</strong>，进而<strong>使用一个大循环来尝试再次分配 small bin chunk</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">       it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">       the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">       bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">       chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">       near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">       do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">       otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   处理最近释放或剩余的内存块，只有在精确匹配时才取一个块，或者如果这是一个小的请求，并且该块是最近一个非精确匹配的剩余块。将其他经过遍历的块放入 bins 中。请注意，这一步是任何例程中唯一将块放入 bins 中的地方。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   外部循环在这里是必需的，因为直到接近 malloc 的末尾，我们可能才意识到应该进行合并，所以必须这样做并重试。这最多发生一次，仅当我们否则需要扩展内存来处理一个 &quot;小&quot; 请求时。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> iters = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="unsorted-bin-遍历"><a href="#unsorted-bin-遍历" class="headerlink" title="unsorted bin 遍历"></a>unsorted bin 遍历</h5><p><strong>先考虑 unsorted bin</strong>，<strong>再考虑 last remainder</strong>(是最近一次非精确匹配的剩余块) ，但是对于 small bin chunk 的请求会有所例外。</p>
<p><strong>注意 unsorted bin 的遍历顺序为 bk。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 unsorted bin 不为空</span></span><br><span class="line"><span class="comment">// First In First Out</span></span><br><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">    <span class="comment">// victim 为 unsorted bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// bck 为 unsorted bin 的倒数第二个 chunk</span></span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="comment">// 判断得到的 chunk 是否满足要求，不能过小，也不能过大</span></span><br><span class="line">    <span class="comment">// 一般 system_mem 的大小为132K</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">    <span class="comment">// 得到victim对应的chunk大小。</span></span><br><span class="line">    size = chunksize(victim);</span><br></pre></td></tr></table></figure>

<h5 id="SMALL-REQUEST"><a href="#SMALL-REQUEST" class="headerlink" title="SMALL REQUEST"></a>SMALL REQUEST</h5><p>如果用户的请求为 small bin chunk，那么我们首先考虑 last remainder，如果 last remainder 是 unsorted bin 中的唯一一块的话， 并且 last remainder 的大小分割后还可以作为一个 chunk ，<strong>为什么没有等号</strong>？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">           only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">           runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">           exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">           no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果是一个小的内存请求，如果未排序的 bin 中只有一个块，并且它是上一个剩余块，尝试使用它。</span></span><br><span class="line"><span class="comment">	这有助于提高连续小内存请求的局部性。这是对最佳适配算法的唯一例外，仅适用于没有完全匹配的小块。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;victim == av-&gt;last_remainder &amp;&amp;(<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">            <span class="comment">// 获取新的 remainder 的大小</span></span><br><span class="line">            remainder_size          = size - nb;</span><br><span class="line">            <span class="comment">// 获取新的 remainder 的位置</span></span><br><span class="line">            remainder               = chunk_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 更新 unsorted bin 的情况</span></span><br><span class="line">            unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">            <span class="comment">// 更新 av 中记录的 last_remainder</span></span><br><span class="line">            av-&gt;last_remainder                                = remainder;</span><br><span class="line">            <span class="comment">// 更新last remainder的指针</span></span><br><span class="line">            remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置victim的头部，</span></span><br><span class="line">            set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                                 (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 设置 remainder 的头部</span></span><br><span class="line">            set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            <span class="comment">// 设置记录 remainder 大小的 prev_size 字段，因为此时 remainder 处于空闲状态。</span></span><br><span class="line">            set_foot(remainder, remainder_size);</span><br><span class="line">            <span class="comment">// 细致的检查，非调试状态下没有作用</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将 victim 从 chunk 模式转化为mem模式</span></span><br><span class="line">            <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始取出"><a href="#初始取出" class="headerlink" title="初始取出"></a>初始取出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd                 = unsorted_chunks(av);</span><br></pre></td></tr></table></figure>

<h5 id="EXACT-FIT"><a href="#EXACT-FIT" class="headerlink" title="EXACT FIT"></a>EXACT FIT</h5><p>如果从 unsorted bin 中取出来的 chunk 大小正好合适，就直接使用。这里应该已经把合并后恰好合适的 chunk 给分配出去了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="PLACE-CHUNK-IN-SMALL-BIN"><a href="#PLACE-CHUNK-IN-SMALL-BIN" class="headerlink" title="PLACE CHUNK IN SMALL BIN"></a>PLACE CHUNK IN SMALL BIN</h5><p>把取出来的 chunk 放到对应的 small bin 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">    victim_index = smallbin_index(size);</span><br><span class="line">    bck          = bin_at(av, victim_index);</span><br><span class="line">    fwd          = bck-&gt;fd;</span><br></pre></td></tr></table></figure>

<h5 id="PLACE-CHUNK-IN-LARGE-BIN"><a href="#PLACE-CHUNK-IN-LARGE-BIN" class="headerlink" title="PLACE CHUNK IN LARGE BIN"></a>PLACE CHUNK IN LARGE BIN</h5><p>把取出来的 chunk 放到对应的 large bin 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// large bin 范围</span></span><br><span class="line">    victim_index = largebin_index(size);</span><br><span class="line">    bck          = bin_at(av, victim_index); <span class="comment">// 当前 large bin 的头部</span></span><br><span class="line">    fwd          = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="comment">/* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。</span></span><br><span class="line"><span class="comment">       同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，</span></span><br><span class="line"><span class="comment">       而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，</span></span><br><span class="line"><span class="comment">       可以减低开销。此外，bin 头不参与 nextsize 链接。*/</span></span><br><span class="line">    <span class="comment">// 如果 large bin 链表不空</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        <span class="comment">// 加速比较，应该不仅仅有这个考虑，因为链表里的 chunk 都会设置该位。</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        <span class="comment">// bck-&gt;bk 存储着相应 large bin 中最小的chunk。</span></span><br><span class="line">        <span class="comment">// 如果遍历的 chunk 比当前最小的还要小，那就只需要插入到链表尾部。</span></span><br><span class="line">        <span class="comment">// 判断 bck-&gt;bk 是不是在 main arena。</span></span><br><span class="line">      assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt;</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask(bck-&gt;bk)) &#123;</span><br><span class="line">            <span class="comment">// 令 fwd 指向 large bin 头</span></span><br><span class="line">            fwd = bck;</span><br><span class="line">            <span class="comment">// 令 bck 指向 largin bin 尾部 chunk</span></span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line">            <span class="comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            <span class="comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span></span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            <span class="comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span></span><br><span class="line">            <span class="comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span></span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize =</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前要插入的 victim 的大小大于最小的 chunk</span></span><br><span class="line">            <span class="comment">// 判断 fwd 是否在 main arena</span></span><br><span class="line">            assert(chunk_main_arena(fwd));</span><br><span class="line">            <span class="comment">// 从链表头部开始找到不比 victim 大的 chunk</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask(fwd)) &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert(chunk_main_arena(fwd));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果找到了一个和 victim 一样大的 chunk，</span></span><br><span class="line">            <span class="comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size ==</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask(fwd))</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找到的chunk和当前victim大小不一样</span></span><br><span class="line">                <span class="comment">// 那么就需要构造 nextsize 双向链表了</span></span><br><span class="line">                victim-&gt;fd_nextsize              = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize                 = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最终取出"><a href="#最终取出" class="headerlink" title="最终取出"></a>最终取出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放到对应的 bin 中，构成 bck&lt;--&gt;victim&lt;--&gt;fwd。</span></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk    = victim;</span><br><span class="line">bck-&gt;fd    = victim;</span><br></pre></td></tr></table></figure>

<h5 id="WHILE-迭代次数"><a href="#WHILE-迭代次数" class="headerlink" title="WHILE 迭代次数"></a>WHILE 迭代次数</h5><p>while 最多迭代 10000 次后退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// #define MAX_ITERS 10000</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= MAX_ITERS) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="large-chunk"><a href="#large-chunk" class="headerlink" title="large chunk"></a>large chunk</h5><p><strong>注： 或许会很奇怪，为什么这里没有先去看 small chunk 是否满足新需求了呢？这是因为 small bin 在循环之前已经判断过了，这里如果有的话，就是合并后的才出现 chunk。但是在大循环外，large chunk 只是单纯地找到其索引，所以觉得在这里直接先判断是合理的，而且也为了下面可以再去找较大的 chunk。</strong></p>
<p>如果请求的 chunk 在 large chunk 范围内，就在对应的 bin 中从小到大进行扫描，找到第一个合适的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">   sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="comment">// 如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过</span></span><br><span class="line">    <span class="comment">// first(bin)=bin-&gt;fd 表示当前链表中最大的chunk//双向链表的首部是最大的</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask(victim) &gt;=</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) &#123;</span><br><span class="line">        <span class="comment">// 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize(victim)) &lt;(<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">            victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">           list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="comment">// 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk</span></span><br><span class="line">        <span class="comment">// 的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize</span></span><br><span class="line">        <span class="comment">//  链表。因为大小相同的chunk只有一个会被串在nextsize链上。</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last(bin) &amp;&amp;</span><br><span class="line">            chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))</span><br><span class="line">            victim = victim-&gt;fd;</span><br><span class="line">        <span class="comment">// 计算分配后剩余的大小</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">// 进行unlink</span></span><br><span class="line">        unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="comment">// 剩下的大小不足以当做一个块</span></span><br><span class="line">        <span class="comment">// 很好奇接下来会怎么办？</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">            set_inuse_bit_at_offset(victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) 						     set_non_main_arena(victim);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="comment">//  剩下的大小还可以作为一个chunk，进行分割。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取剩下那部分chunk的指针，称为remainder</span></span><br><span class="line">            remainder = chunk_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">               have to perform a complete insert here.  */</span></span><br><span class="line">            <span class="comment">// 插入unsorted bin中</span></span><br><span class="line">            bck = unsorted_chunks(av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="comment">// 判断 unsorted bin 是否被破坏。</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd       = remainder;</span><br><span class="line">            fwd-&gt;bk       = remainder;</span><br><span class="line">            <span class="comment">// 如果不处于small bin范围内，就设置对应的字段</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置分配的chunk的标记</span></span><br><span class="line">            set_head(victim,</span><br><span class="line">                     nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置remainder的上一个chunk，即分配出去的chunk的使用状态</span></span><br><span class="line">            <span class="comment">// 其余的不用管，直接从上面继承下来了</span></span><br><span class="line">            set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            <span class="comment">// 设置remainder的大小</span></span><br><span class="line">            set_foot(remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="comment">// 转换为mem状态</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="寻找较大-chunk"><a href="#寻找较大-chunk" class="headerlink" title="寻找较大 chunk"></a>寻找较大 chunk</h5><p>如果走到了这里，那说明对于用户所需的 chunk，不能直接从其对应的合适的 bin 中获取 chunk，所以我们需要来查找比当前 bin 更大的 fast bin ， small bin 或者 large bin。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">           bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">           (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">           that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">           The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">           when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   通过扫描 bin，从下一个更大的 bin 开始，搜索一个块。这个搜索严格按照最佳适配原则进行；</span></span><br><span class="line"><span class="comment">   也就是说，选择适合的最小块（如果有多个相同大小的块，则选择近期最少使用的块）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   位图的使用避免了需要检查大多数块是否非空的情况。</span></span><br><span class="line"><span class="comment">   在热身阶段（warm-up phases）中，当还没有返回任何块时，跳过所有 bin 的特殊情况比看起来快得多。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        ++idx;</span><br><span class="line">        <span class="comment">// 获取对应的bin</span></span><br><span class="line">        bin   = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// 获取当前索引在binmap中的block索引</span></span><br><span class="line">        <span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span></span><br><span class="line">        <span class="comment">// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在</span></span><br><span class="line">        <span class="comment">// 所以这里是右移5</span></span><br><span class="line">        block = idx2block(idx);</span><br><span class="line">        <span class="comment">// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块</span></span><br><span class="line">        <span class="built_in">map</span>   = av-&gt;binmap[ block ];</span><br><span class="line">        <span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line">        <span class="comment">// 将idx对应的比特位设置为1，其它位为0</span></span><br><span class="line">        bit   = idx2bit(idx);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br></pre></td></tr></table></figure>

<h5 id="找到一个合适的-MAP"><a href="#找到一个合适的-MAP" class="headerlink" title="找到一个合适的 MAP"></a>找到一个合适的 MAP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Skip rest of block if there are no more set bits in this block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块</span></span><br><span class="line"><span class="comment">// 如果bit为0，那么说明，上面idx2bit带入的参数为0。</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找下一个block，直到其对应的map不为0。</span></span><br><span class="line">        <span class="comment">// 如果已经不存在的话，那就只能使用top chunk了</span></span><br><span class="line">        <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[ block ]) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且</span></span><br><span class="line">    <span class="comment">// map本身不为0，所以必然存在满足需求的chunk。</span></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="找到合适的-BIN"><a href="#找到合适的-BIN" class="headerlink" title="找到合适的 BIN"></a>找到合适的 BIN</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="comment">// 从当前map的最小的bin一直找，直到找到合适的bin。</span></span><br><span class="line"><span class="comment">// 这里是一定存在的</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="简单检查-CHUNK"><a href="#简单检查-CHUNK" class="headerlink" title="简单检查 CHUNK"></a>简单检查 CHUNK</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line"><span class="comment">// 获取对应的bin</span></span><br><span class="line">victim = last(bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span></span><br><span class="line"><span class="comment">// 这种情况发生的概率应该很小。</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">    av-&gt;binmap[ block ] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin                 = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="真正取出-CHUNK"><a href="#真正取出-CHUNK" class="headerlink" title="真正取出 CHUNK"></a>真正取出 CHUNK</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对应victim的大小</span></span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line">    <span class="comment">// 计算分割后剩余的大小</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="comment">// 如果分割后不够一个chunk怎么办？</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="comment">// 如果够，尽管分割</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算剩余的chunk的偏移</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">           have to perform a complete insert here.  */</span></span><br><span class="line">        <span class="comment">// 将剩余的chunk插入到unsorted bin中</span></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd       = remainder;</span><br><span class="line">        fwd-&gt;bk       = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="comment">// 如果在small bin范围内，就将其标记为remainder</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置victim的使用状态</span></span><br><span class="line">        set_head(victim,</span><br><span class="line">                 nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置remainder的使用状态，这里是为什么呢？</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">// 设置remainder的大小</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// chunk状态转换到mem状态</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-top-chunk"><a href="#使用-top-chunk" class="headerlink" title="使用 top chunk"></a>使用 top chunk</h5><p>如果所有的 bin 中的 chunk 都没有办法直接满足要求（即不合并），或者说都没有空闲的 chunk。那么我们就只能使用 top chunk 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">       (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">       search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">       less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">       be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">       limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">       MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">       exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">       reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">       to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果足够大，将与内存末尾（保存在 av-&gt;top 中）相邻的块分割出来。</span></span><br><span class="line"><span class="comment">   注意，这符合最佳适配搜索规则。实际上，av-&gt;top 被视为比任何其他可用块都更大（因此更不适配），</span></span><br><span class="line"><span class="comment">   因为它可以扩展到任意大小（受系统限制）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   我们要求 av-&gt;top 在初始化后始终存在（即大小 &gt;= MINSIZE），</span></span><br><span class="line"><span class="comment">   因此如果当前请求会耗尽它，它将被重新补充。</span></span><br><span class="line"><span class="comment">   （确保其存在的主要原因是我们可能需要 MINSIZE 的空间来放置 sysmalloc 中的栅栏。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size   = chunksize(victim);</span><br><span class="line">    <span class="comment">// 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">        av-&gt;top        = remainder;</span><br><span class="line">        <span class="comment">// 这里设置 PREV_INUSE 是因为 top chunk 前面的 chunk 如果不是 fastbin，就必然会和</span></span><br><span class="line">        <span class="comment">// top chunk 合并，所以这里设置了 PREV_INUSE。</span></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，判断是否有 fast chunk</span></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        <span class="comment">// 先执行一次fast bin的合并</span></span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="comment">// 判断需要的chunk是在small bin范围内还是large bin范围内</span></span><br><span class="line">        <span class="comment">// 并计算对应的索引</span></span><br><span class="line">        <span class="comment">// 等待下次再看看是否可以</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            idx = smallbin_index(nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="堆内存不够"><a href="#堆内存不够" class="headerlink" title="堆内存不够"></a>堆内存不够</h5><p>如果堆内存不够，我们就需要使用 <code>sysmalloc</code> 来申请内存了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 否则的话，我们就只能从系统中再次申请一点内存了。</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="_libc_calloc"></a>_libc_calloc</h5><p>calloc 也是 libc 中的一种申请内存块的函数。在 <code>libc</code>中的封装为 <code>_libc_calloc</code>，具体介绍如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  Returns a pointer to n_elements * element_size bytes, with all locations</span></span><br><span class="line"><span class="comment">  set to zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  返回一个指向 n_elements * element_size 字节的指针，其中所有位置都被设置为零。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_calloc(<span class="type">size_t</span>, <span class="type">size_t</span>);</span><br></pre></td></tr></table></figure>

<h5 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h5><p>正如该函数头的注释所言，该函数用于当前堆内存不足时，需要向系统申请更多的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc handles malloc cases requiring more memory from the system.</span></span><br><span class="line"><span class="comment">   On entry, it is assumed that av-&gt;top does not have enough</span></span><br><span class="line"><span class="comment">   space to service request for nb bytes, thus requiring that av-&gt;top</span></span><br><span class="line"><span class="comment">   be extended or replaced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc 处理需要从系统获取更多内存的 malloc 情况。</span></span><br><span class="line"><span class="comment">   在进入函数时，假设 av-&gt;top 没有足够的空间来满足 nb 字节的请求，</span></span><br><span class="line"><span class="comment">   因此需要扩展或替换 av-&gt;top。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h5 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span> &#123;</span><br><span class="line">  mchunkptr old_top;        <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size; <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">char</span> *old_end;            <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size; <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="type">char</span> *brk; <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction; <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;   <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                  <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;          <span class="comment">/* remainder frOm allocation */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span> &#123;</span><br><span class="line">  mchunkptr old_top;        <span class="comment">/* av-&gt;top 的初始值 */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size; <span class="comment">/* 其大小 */</span></span><br><span class="line">  <span class="type">char</span> *old_end;            <span class="comment">/* 其结束地址 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size; <span class="comment">/* 传递给第一次 MORECORE 或 mmap 调用的参数 */</span></span><br><span class="line">  <span class="type">char</span> *brk; <span class="comment">/* MORECORE 的返回值 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction; <span class="comment">/* 传递给第二次 MORECORE 调用的参数 */</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;   <span class="comment">/* 第二次 MORECORE 的返回值 */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* 新空间前面不可用的字节数 */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* 新空间末尾剩余的部分页面 */</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">/* 对齐后的 brk 偏移量 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                  <span class="comment">/* 分配/返回的块 */</span></span><br><span class="line">  mchunkptr remainder;          <span class="comment">/* 剩余的分配块 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* 剩余块的大小 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以主要关注一下 <code>pagesize</code>，其</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXEC_PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXEC_PAGESIZE   4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GLRO(name) _##name</span></span><br><span class="line"><span class="type">size_t</span> _dl_pagesize = EXEC_PAGESIZE;</span><br></pre></td></tr></table></figure>

<p>所以，<code>pagesize=4096=0x1000</code>。</p>
<h5 id="考虑-mmap"><a href="#考虑-mmap" class="headerlink" title="考虑 mmap"></a>考虑 mmap</h5><p>正如开头注释所言如果满足如下任何一种条件</p>
<ol>
<li>没有分配堆。</li>
<li>申请的内存大于 <code>mp_.mmap_threshold</code>，并且 mmap 的数量小于最大值，就可以尝试使用 mmap。</li>
</ol>
<p>默认情况下，临界值为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span> &#123;</span><br><span class="line">    .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">    .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">    .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">    .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line">    .arena_test = NARENAS_FROM_NCORES(<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        ,</span><br><span class="line">    .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">    .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">    .tcache_max_bytes = tidx2usize(TCACHE_MAX_BINS - <span class="number">1</span>),</span><br><span class="line">    .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>DEFAULT_MMAP_THRESHOLD</code> 为 128*1024 字节，即 128 K。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically</span></span><br><span class="line"><span class="comment">  adjusted MMAP_THRESHOLD.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="comment">/* For 32-bit platforms we cannot increase the maximum mmap</span></span><br><span class="line"><span class="comment">   threshold much because it is also the minimum value for the</span></span><br><span class="line"><span class="comment">   maximum heap size and its alignment.  Going above 512k (i.e., 1M</span></span><br><span class="line"><span class="comment">   for new heaps) wastes too much address space.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>下面为这部分代码，目前不是我们关心的重点，<strong>可以暂时跳过</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">   the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">   allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">   rather than expanding top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span> ||</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">     (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123;</span><br><span class="line">  <span class="type">char</span> *mm; <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">try_mmap:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">     is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">     is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">     need for further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    size = ALIGN_UP(nb + SIZE_SZ, pagesize);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">  tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">    mm = (<span class="type">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm != MAP_FAILED) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">         in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">         returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">         and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">         address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ) &#123;</span><br><span class="line">        <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">           MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">           aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">        assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">        front_misalign = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">        p = (mchunkptr)(mm + correction);</span><br><span class="line">        set_prev_size(p, correction);</span><br><span class="line">        set_head(p, (size - correction) | IS_MMAPPED);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (mchunkptr)mm;</span><br><span class="line">        set_prev_size(p, <span class="number">0</span>);</span><br><span class="line">        set_head(p, size | IS_MMAPPED);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> new = atomic_exchange_and_add(&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="type">atomic_max</span>(&amp;mp_.max_n_mmaps, new);</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">      sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">      <span class="type">atomic_max</span>(&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">      check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="mmap-失败或者未分配堆"><a href="#mmap-失败或者未分配堆" class="headerlink" title="mmap 失败或者未分配堆"></a>mmap 失败或者未分配堆</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas and mmap also failed.  */</span></span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如果是这两种情况中的任何一种，其实就可以退出了。。</p>
<h5 id="记录旧堆信息"><a href="#记录旧堆信息" class="headerlink" title="记录旧堆信息"></a>记录旧堆信息</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"><span class="comment">/* 记录传入的 top 的配置信息 */</span></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize(old_top);</span><br><span class="line">old_end = (<span class="type">char</span> *)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="type">char</span> *)(MORECORE_FAILURE);</span><br></pre></td></tr></table></figure>

<h5 id="检查旧堆信息-1"><a href="#检查旧堆信息-1" class="headerlink" title="检查旧堆信息 1"></a>检查旧堆信息 1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果不是第一次执行，我们要求 old_size 至少为 MINSIZE，并且设置了 prev_inuse。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">       ((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top) &amp;&amp;</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>这个检查要求满足其中任何一个条件</p>
<ol>
<li><code>old_top == initial_top(av) &amp;&amp; old_size == 0</code>，即如果是第一次的话，堆的大小需要是 0。</li>
<li>新的堆，那么<ol>
<li><code>(unsigned long)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top)</code>，堆的大小应该不小于 <code>MINSIZE</code>，并且前一个堆块应该处于使用中。</li>
<li><code>((unsigned long)old_end &amp; (pagesize - 1)) == 0)</code>，堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为 0。</li>
</ol>
</li>
</ol>
<h5 id="检查旧堆信息-2"><a href="#检查旧堆信息-2" class="headerlink" title="检查旧堆信息 2"></a>检查旧堆信息 2</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br></pre></td></tr></table></figure>

<p>根据 malloc 中的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *_int_malloc(mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  <span class="comment">/* normalized request size */</span></span><br></pre></td></tr></table></figure>

<p><code>nb</code> 应该是已经加上 chunk 头部的字节，为什么还要加上 <code>MINSIZE</code>呢？这是因为 top chunk 的大小应该至少预留 MINSIZE 空间，以便于合并。</p>
<h3 id="tcache-gblic-2-26"><a href="#tcache-gblic-2-26" class="headerlink" title="tcache(gblic&gt;&#x3D;2.26)"></a>tcache(gblic&gt;&#x3D;2.26)</h3><p>tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术（see <a target="_blank" rel="noopener" href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc">commit</a>），目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。</p>
<blockquote>
<p>主要参考了 glibc 源码，angelboy 的 slide 以及 tukan.farm，链接都放在最后了。</p>
</blockquote>
<h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><p>tcache 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code>。</p>
<p>这其实和 fastbin 很像，但又不一样。</p>
<h4 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="comment">/* 当块存储在每个线程的缓存中时，我们将此结构叠加在块的用户数据部分上。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>

<p><code>tcache_entry</code> 用于<strong>链接空闲的 chunk 结构体</strong>，其中的 <code>next</code> 指针指向<strong>下一个大小相同</strong>的 chunk。</p>
<p>需要注意的是这里的 next <strong>指向 chunk 的 user data</strong>，而 fastbin 的 fd 指向 chunk 开头的地址。</p>
<p>而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p>
<h4 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">每个线程都有一个这样的结构，其中包含每个线程的缓存（因此称为 &quot;tcache_perthread_struct&quot;）。保持整体大小较小略为重要。请注意，COUNTS 和 ENTRIES 是冗余的（我们每次都可以计算链表的长度），这是出于性能考虑。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p>
<ul>
<li><strong><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</strong></li>
<li><strong><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</strong>（为了在tcache中保持较小的内存开销和更好的性能，可能在不同libc上有不同的限制，例如较早版本有的4或者8）</li>
</ul>
<p>用图表示大概是：<strong>（next指针存在fd区域）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202403132101109.jpeg" alt="img" style="zoom: 67%;" />

<h4 id="基本工作方式"><a href="#基本工作方式" class="headerlink" title="基本工作方式"></a>基本工作方式</h4><ul>
<li><strong>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</strong></li>
<li>free 内存，且 size 小于 small bin size 时</li>
<li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 后：<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空</li>
<li>tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h4 id="Tcache的相关知识"><a href="#Tcache的相关知识" class="headerlink" title="Tcache的相关知识"></a>Tcache的相关知识</h4><p>在32位系统中，bin会存放12-512字节的chunk，<strong>在64位系统中bin会存放24-1032字节的chunk</strong>。也就是说<strong>符合这些大小的chunk被释放后不会先加入fastbin</strong>，而是会先放入TcacheBin中。**(和fastbin的存储大小差不多一致)**</p>
<p>TcacheBin以单链表构成</p>
<h5 id="什么时候用到Tcache："><a href="#什么时候用到Tcache：" class="headerlink" title="什么时候用到Tcache："></a>什么时候用到Tcache：</h5><p><strong>free：</strong>在释放chunk的时候，如果chunk符合Tcachebin的大小，并且该bin还没有被装满(没有七个)，则会优先放入TcacheBin中</p>
<p><strong>malloc：</strong></p>
<ol>
<li>当我们使用malloc的时候，返回一个chunk，并且该chunk是从fastbin中返回的，那么该chunk所对应下标的所有chunk都会被放入TcacheBin(当然，前提是Tcachebin没有被装满)，而且由于fastbin和Tcachebin都是先进后出，所以就会导致chunk在移动完以后chunk的顺序和fastbin中的顺序相反。</li>
<li>smallbin中的也一样，返回的一个chunk属于smallbin，那么smallbin中对应的chunk就会全部放入Tcachebin(前提是没有装满)</li>
<li>当出现堆块的合并等其它情况的时候，每一个符合条件的chunk都会优先放入TcacheBin中，而不是直接返回(除非Tcache已满)。寻找结束后Tcache会返回其中一个</li>
</ol>
<p><strong>比较重要的一点，当我们调用malloc的时候，其实是先调用libc_malloc然后调用int_malloc，但是如果我们请求的大小在Tcachebin中有符合的chunk那么就会在libc_malloc中返回该chunk，而不会调用int_malloc</strong></p>
<p><strong>我们在处理chunk的过程中，如果在Tcache中的chunk已满，那么会直接返回最后一个chunk；binning code 结束后，如果没有直接返回（如上），那么如果有至少一个符合要求的 chunk 被找到，则返回最后一个。</strong></p>
<p><strong>tcache 中的 chunk 不会被合并，无论是相邻 chunk，还是 chunk 和 top chunk。因为这些 chunk 会被标记为 inuse。</strong></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>接下来从源码的角度分析一下 tcache。</p>
<h5 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h5><p>第一次 malloc 时，会进入到 <code>MAYBE_INIT_TCACHE ()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="comment">/*int_free 函数还会调用 request2size 函数，请注意不要重复进行填充。(提醒开发者在释放内存块时，注意在调用 request2size 函数时避免重复进行填充操作)	*/</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span></span><br><span class="line">  checked_request2size (bytes, tbytes);  <span class="comment">//tbytes应该是对应tcache的大小</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);  <span class="comment">//计算下标</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 tcache</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();  <span class="comment">//检查当前线程的 tcache 是否已经初始化，如果没有初始化，则进行初始化</span></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;  			<span class="comment">//在编译器诊断信息中添加一个注释没有实质性作用</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="comment">// 根据 size 得到的 idx 在合法的范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// tcache-&gt;entries[tc_idx] 有 chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tcache-init"><a href="#tcache-init" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>附:arena是一块连续的内存区域(包括Heap Arena[Small bin and Large bin]和Thread-specific Arena[Fast bin and Tcache])</p>
<p>其中 **<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 为空（即第一次 malloc）时调用了 <code>tcache_init()</code>**，直接查看 <code>tcache_init()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">tcache_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  arena_get (ar_ptr, bytes); <span class="comment">// 找到可用的 arena</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)  <span class="comment">//没有可用的arena或者没有申请chunk成功</span></span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);    <span class="comment">//重试</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);        <span class="comment">//重试</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);       <span class="comment">//解锁arena</span></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="comment">/* 在内存紧张的情况下，我们可能无法分配内存 - 在这种情况下，我们稍后会继续尝试。</span></span><br><span class="line"><span class="comment">   不过，通常我们会在很早的阶段进行这个尝试，</span></span><br><span class="line"><span class="comment">   因此要么有足够的内存，要么根本没有足够的内存来进行非平凡的分配操作。 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim) <span class="comment">// 初始化 tcache</span></span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_init()</code> 成功返回后，<code>tcache_perthread_struct</code> 就被成功建立了。</p>
<h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><p>接下来将进入申请内存的步骤</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// 由 size 计算的 idx 在合法范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 进入与无 tcache 时类似的流程</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);   <span class="comment">//tcache为空就直接_int_malloc</span></span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</p>
<h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>看一下 <code>tcache_get()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，<strong>几乎没有任何保护。</strong></p>
<h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h4><p>看完申请，再看看<strong>有 tcache 时的释放</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__libc_free()</code> 没有太多变化，**<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用**。</p>
<h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h4><p>跟进 &#96;_int_free()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是要释放的 chunk 和该 chunk 对应的 size 在 tcache 中的下标。</p>
<h4 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="comment">/* 调用者必须确保我们知道 tc_idx 是有效的，并且还有足够的空间来存放更多的块。 */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];  <span class="comment">//FIFO</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。(P位是指前一个内存是否分配)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io">s1nec-1o</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io/2024/02/29/heap-note/">http://s1nec-1o.github.io/2024/02/29/heap-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://s1nec-1o.github.io" target="_blank">S1nec-1o's B1og</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/traditional-pwn/">traditional pwn</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/03/IO%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" title="IO函数源码阅读"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IO函数源码阅读</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/29/%E5%A0%86bug%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/" title="堆bug利用总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">堆bug利用总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/27/2024-1-26%E6%B2%99%E7%9B%92%E7%9A%84%E5%AD%A6%E4%B9%A0/" title="2024-1-26沙盒的学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-27</div><div class="title">2024-1-26沙盒的学习</div></div></a></div><div><a href="/2024/01/17/2024mapna/" title="2024mapna"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-17</div><div class="title">2024mapna</div></div></a></div><div><a href="/2024/02/01/2024-1-31-pwnable-bookwriter/" title="2024-1-31 pwnable_bookwriter"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="title">2024-1-31 pwnable_bookwriter</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">s1nec-1o</div><div class="author-info__description">完事胜意</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="http://github.com/s1nec-1o"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习iot pwn 欢迎广大师傅与我交流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86"><span class="toc-number">1.0.1.</span> <span class="toc-text">什么是堆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">堆的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc"><span class="toc-number">1.1.1.</span> <span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free"><span class="toc-number">1.1.2.</span> <span class="toc-text">free</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%83%8C%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">内存分配背后的系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#s-brk"><span class="toc-number">1.1.4.</span> <span class="toc-text">(s)brk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap"><span class="toc-number">1.1.5.</span> <span class="toc-text">mmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81"><span class="toc-number">1.1.6.</span> <span class="toc-text">多线程支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87"><span class="toc-number">1.1.7.</span> <span class="toc-text">glibc内存管理篇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.1.8.</span> <span class="toc-text">5.  源代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-%E8%BE%B9%E7%95%8C%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">5.1  边界标记法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-%E5%88%86%E7%AE%B1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">5.2 分箱式内存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">问题小结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-Small-bins"><span class="toc-number">1.1.8.4.</span> <span class="toc-text">5.2.1 Small bins</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-2-Large-bins"><span class="toc-number">1.1.8.5.</span> <span class="toc-text">5.2.2 Large bins</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-3-Unsorted-bin"><span class="toc-number">1.1.8.6.</span> <span class="toc-text">5.2.3  Unsorted bin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-4-Fast-bins"><span class="toc-number">1.1.8.7.</span> <span class="toc-text">5.2.4  Fast bins</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-number">1.1.8.8.</span> <span class="toc-text">5.3 核心结构体分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-1-malloc-state"><span class="toc-number">1.1.8.9.</span> <span class="toc-text">5.3.1 malloc_state</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%A7%E9%83%A8%E5%88%86%E4%B8%8E%E4%B8%8A%E8%BF%B0%E9%87%8D%E5%A4%8D"><span class="toc-number">1.1.9.</span> <span class="toc-text">堆相关数据结构(大部分与上述重复)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Top-Chunk"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">Top Chunk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#last-remainder"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">last remainder</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E8%A7%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.10.</span> <span class="toc-text">宏观结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#arena"><span class="toc-number">1.1.10.1.</span> <span class="toc-text">arena</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arena-%E6%95%B0%E9%87%8F"><span class="toc-number">1.1.10.2.</span> <span class="toc-text">arena 数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arena-%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99-%E6%9D%A5%E8%87%AA%E4%BA%8E%E4%B8%8D%E7%9F%A5%E5%90%8D%E5%8D%9A%E5%AE%A2%EF%BC%8C%E4%B8%8D%E7%A1%AE%E5%AE%9A%E5%85%B6%E5%AE%8C%E5%85%A8%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">1.1.10.3.</span> <span class="toc-text">arena 分配规则(来自于不知名博客，不确定其完全正确性)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.10.4.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#heap-info"><span class="toc-number">1.1.10.5.</span> <span class="toc-text">heap_info</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc-state"><span class="toc-number">1.1.10.6.</span> <span class="toc-text">malloc_state</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc-par"><span class="toc-number">1.1.10.7.</span> <span class="toc-text">malloc_par</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.11.</span> <span class="toc-text">基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unlink"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">unlink</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc-printerr"><span class="toc-number">1.1.11.2.</span> <span class="toc-text">malloc_printerr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.11.3.</span> <span class="toc-text">堆初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%9D%97"><span class="toc-number">1.1.12.</span> <span class="toc-text">申请内存块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#libc-malloc"><span class="toc-number">1.1.12.1.</span> <span class="toc-text">__libc_malloc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-malloc"><span class="toc-number">1.1.12.2.</span> <span class="toc-text">_int_malloc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arena-1"><span class="toc-number">1.1.12.3.</span> <span class="toc-text">arena</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fast-bin"><span class="toc-number">1.1.12.4.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#small-bin"><span class="toc-number">1.1.12.5.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#large-bin"><span class="toc-number">1.1.12.6.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%BE%AA%E7%8E%AF-%E9%81%8D%E5%8E%86-unsorted-bin"><span class="toc-number">1.1.12.7.</span> <span class="toc-text">大循环 - 遍历 unsorted bin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unsorted-bin-%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.12.8.</span> <span class="toc-text">unsorted bin 遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SMALL-REQUEST"><span class="toc-number">1.1.12.9.</span> <span class="toc-text">SMALL REQUEST</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8F%96%E5%87%BA"><span class="toc-number">1.1.12.10.</span> <span class="toc-text">初始取出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EXACT-FIT"><span class="toc-number">1.1.12.11.</span> <span class="toc-text">EXACT FIT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PLACE-CHUNK-IN-SMALL-BIN"><span class="toc-number">1.1.12.12.</span> <span class="toc-text">PLACE CHUNK IN SMALL BIN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PLACE-CHUNK-IN-LARGE-BIN"><span class="toc-number">1.1.12.13.</span> <span class="toc-text">PLACE CHUNK IN LARGE BIN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%8F%96%E5%87%BA"><span class="toc-number">1.1.12.14.</span> <span class="toc-text">最终取出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WHILE-%E8%BF%AD%E4%BB%A3%E6%AC%A1%E6%95%B0"><span class="toc-number">1.1.12.15.</span> <span class="toc-text">WHILE 迭代次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#large-chunk"><span class="toc-number">1.1.12.16.</span> <span class="toc-text">large chunk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E8%BE%83%E5%A4%A7-chunk"><span class="toc-number">1.1.12.17.</span> <span class="toc-text">寻找较大 chunk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84-MAP"><span class="toc-number">1.1.12.18.</span> <span class="toc-text">找到一个合适的 MAP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84-BIN"><span class="toc-number">1.1.12.19.</span> <span class="toc-text">找到合适的 BIN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A3%80%E6%9F%A5-CHUNK"><span class="toc-number">1.1.12.20.</span> <span class="toc-text">简单检查 CHUNK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E5%8F%96%E5%87%BA-CHUNK"><span class="toc-number">1.1.12.21.</span> <span class="toc-text">真正取出 CHUNK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-top-chunk"><span class="toc-number">1.1.12.22.</span> <span class="toc-text">使用 top chunk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F"><span class="toc-number">1.1.12.23.</span> <span class="toc-text">堆内存不够</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#libc-calloc"><span class="toc-number">1.1.12.24.</span> <span class="toc-text">_libc_calloc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sysmalloc"><span class="toc-number">1.1.12.25.</span> <span class="toc-text">sysmalloc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.12.26.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%83%E8%99%91-mmap"><span class="toc-number">1.1.12.27.</span> <span class="toc-text">考虑 mmap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mmap-%E5%A4%B1%E8%B4%A5%E6%88%96%E8%80%85%E6%9C%AA%E5%88%86%E9%85%8D%E5%A0%86"><span class="toc-number">1.1.12.28.</span> <span class="toc-text">mmap 失败或者未分配堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%97%A7%E5%A0%86%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.12.29.</span> <span class="toc-text">记录旧堆信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%97%A7%E5%A0%86%E4%BF%A1%E6%81%AF-1"><span class="toc-number">1.1.12.30.</span> <span class="toc-text">检查旧堆信息 1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%97%A7%E5%A0%86%E4%BF%A1%E6%81%AF-2"><span class="toc-number">1.1.12.31.</span> <span class="toc-text">检查旧堆信息 2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-gblic-2-26"><span class="toc-number">1.2.</span> <span class="toc-text">tcache(gblic&gt;&#x3D;2.26)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">相关结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-entry"><span class="toc-number">1.2.2.</span> <span class="toc-text">tcache_entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-perthread-struct"><span class="toc-number">1.2.3.</span> <span class="toc-text">tcache_perthread_struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">基本工作方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tcache%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">1.2.5.</span> <span class="toc-text">Tcache的相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0Tcache%EF%BC%9A"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">什么时候用到Tcache：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.6.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#libc-malloc-1"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">__libc_malloc</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-init"><span class="toc-number">1.2.7.</span> <span class="toc-text">__tcache_init()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">1.2.8.</span> <span class="toc-text">申请内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-get"><span class="toc-number">1.2.9.</span> <span class="toc-text">tcache_get()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#libc-free"><span class="toc-number">1.2.10.</span> <span class="toc-text">__libc_free()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-free"><span class="toc-number">1.2.11.</span> <span class="toc-text">_int_free()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcache-put"><span class="toc-number">1.2.12.</span> <span class="toc-text">tcache_put()</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/11/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/" title="buu做题记录">buu做题记录</a><time datetime="2024-03-11T15:00:19.000Z" title="发表于 2024-03-11 23:00:19">2024-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/03/IO%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" title="IO函数源码阅读">IO函数源码阅读</a><time datetime="2024-03-03T06:30:53.000Z" title="发表于 2024-03-03 14:30:53">2024-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/29/heap-note/" title="heap note">heap note</a><time datetime="2024-02-29T10:20:14.000Z" title="发表于 2024-02-29 18:20:14">2024-02-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/29/%E5%A0%86bug%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/" title="堆bug利用总结">堆bug利用总结</a><time datetime="2024-02-29T10:16:03.000Z" title="发表于 2024-02-29 18:16:03">2024-02-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/29/malloc-free%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/" title="malloc/free源码实现">malloc/free源码实现</a><time datetime="2024-02-29T10:15:31.000Z" title="发表于 2024-02-29 18:15:31">2024-02-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By s1nec-1o</div><div class="footer_custom_text">介是s1nec-1o的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>