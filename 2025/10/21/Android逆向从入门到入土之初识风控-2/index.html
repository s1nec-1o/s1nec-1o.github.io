<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Android逆向从入门到入土之初识风控(2) | S1nec-1o's B1og</title><meta name="author" content="s1nec-1o"><meta name="copyright" content="s1nec-1o"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文几乎都是来自于珍惜any大佬的文章，主要是作为小白的学习记录 原文： https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-273838.htm https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-273759.htm https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-277402.htm https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-277637.h">
<meta property="og:type" content="article">
<meta property="og:title" content="Android逆向从入门到入土之初识风控(2)">
<meta property="og:url" content="http://s1nec-1o.github.io/2025/10/21/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8B%E5%88%9D%E8%AF%86%E9%A3%8E%E6%8E%A7-2/index.html">
<meta property="og:site_name" content="S1nec-1o&#39;s B1og">
<meta property="og:description" content="前言本文几乎都是来自于珍惜any大佬的文章，主要是作为小白的学习记录 原文： https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-273838.htm https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-273759.htm https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-277402.htm https:&#x2F;&#x2F;bbs.kanxue.com&#x2F;thread-277637.h">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png">
<meta property="article:published_time" content="2025-10-21T14:17:54.000Z">
<meta property="article:modified_time" content="2025-10-21T14:22:50.429Z">
<meta property="article:author" content="s1nec-1o">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281712481.jpg"><link rel="canonical" href="http://s1nec-1o.github.io/2025/10/21/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8B%E5%88%9D%E8%AF%86%E9%A3%8E%E6%8E%A7-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离文章发布已经过去","messageNext":"天了，信息可能已经过时"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android逆向从入门到入土之初识风控(2)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-21 22:22:50'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="S1nec-1o's B1og" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><nav id="nav"><span id="blog-info"><a href="/" title="S1nec-1o's B1og"><span class="site-name">S1nec-1o's B1og</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Android逆向从入门到入土之初识风控(2)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-21T14:17:54.000Z" title="发表于 2025-10-21 22:17:54">2025-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-21T14:22:50.429Z" title="更新于 2025-10-21 22:22:50">2025-10-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/">安卓逆向</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文几乎都是来自于<strong>珍惜any大佬</strong>的文章，主要是作为小白的学习记录</p>
<p>原文：</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273838.htm">https://bbs.kanxue.com/thread-273838.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273759.htm">https://bbs.kanxue.com/thread-273759.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277402.htm">https://bbs.kanxue.com/thread-277402.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-277637.htm">https://bbs.kanxue.com/thread-277637.htm</a></p>
<p>其中一些较为难懂的（其实是我看不懂）的代码都做了分析的随笔（其实是AI）</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="设备指纹（Device-Fingerprint）"><a href="#设备指纹（Device-Fingerprint）" class="headerlink" title="设备指纹（Device Fingerprint）"></a>设备指纹（Device Fingerprint）</h3><ul>
<li>设备指纹是应用用来识别你手机的一种技术，类似于给你的设备一个”身份证”</li>
<li>它会收集你的：<strong>IMEI、Android ID、MAC地址、设备型号、屏幕分辨率等</strong>信息</li>
<li>应用通过这些信息来识别是否是同一台设备，用于风控、防作弊等</li>
</ul>
<h3 id="Hook-Binder"><a href="#Hook-Binder" class="headerlink" title="Hook Binder"></a>Hook Binder</h3><ul>
<li>Binder是Android的<strong>核心IPC（进程间通信）机制</strong></li>
<li>应用获取设备信息时，都要通过Binder与系统服务通信</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">应用 → Binder → 系统服务（获取IMEI等信息）</span><br><span class="line">       ↑</span><br><span class="line">    Hook这里拦截和修改返回值</span><br></pre></td></tr></table></figure>

<p><strong>缺点：</strong></p>
<ul>
<li>需要在应用进程内注入代码<strong>（二次打包或Xposed&#x2F;Frida）</strong></li>
<li>留下很多痕迹<strong>（注入特征、Hook特征）</strong></li>
</ul>
<h3 id="APatch-内核层对抗"><a href="#APatch-内核层对抗" class="headerlink" title="APatch - 内核层对抗"></a>APatch - 内核层对抗</h3><ul>
<li>新一代Root方案，基于内核模块</li>
<li>相比Magisk，它可以直接在内核层进行修改</li>
</ul>
<blockquote>
<p>Magisk是通过修改<code>/boot.img</code>，在系统启动时挂载系统文件，来达到root的目的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">传统Hook流程：</span><br><span class="line">应用 → [Hook框架在应用层拦截] → Binder → 系统服务 → 内核</span><br><span class="line"></span><br><span class="line">APatch方式：</span><br><span class="line">应用 → Binder → 系统服务 → [在内核层直接拦截并返回假数据]</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>绕过应用层的检测（<strong>反Frida、反Xposed检测</strong>）</li>
<li>在内核层修改，<strong>应用层完全无感知</strong></li>
</ul>
<blockquote>
<p>对抗的本质：谁在更底层，谁就有优势</p>
</blockquote>
<p>风控的全称应该是风险控制，为了解决和预防将要发生，或者可能发生的一些危险情况，从而减轻损失。</p>
<h2 id="风控概述"><a href="#风控概述" class="headerlink" title="风控概述"></a>风控概述</h2><h3 id="蜜罐数据"><a href="#蜜罐数据" class="headerlink" title="蜜罐数据"></a>蜜罐数据</h3><p>什么是蜜罐数据？当发现作弊以后返回的数据是<strong>非正常的数据</strong>，可能存在<strong>埋点</strong>等信息，<strong>比如视频里面在随机帧率里面添加水印，或者返回一些错误数据或者重复的数据</strong>，这些数据往往是已经被污染或者肉眼无法识别是否正确，从而<strong>欺骗攻击者</strong>。</p>
<h3 id="IP限制："><a href="#IP限制：" class="headerlink" title="IP限制："></a>IP限制：</h3><p>这个不多说，当某一个IP过量或者过快请求的时候会进行限制，返回错误的数据或者返回蜜罐数据。</p>
<blockquote>
<p>很多爬虫会买入很多代理，这些代理也都是不安全的，很多大厂也会买入一部分代理，代理毕竟是谁都可以用的，买完以后在服务端直接配置上黑名单即可，很多黑产或者攻击者会采用流量的方式进行请求，将数据转发到路由器，一个类似“猫池”的路由器，里面内置很多手机卡，可以通过设置，将数据通过内部随机手机卡进行发送请求，从而实现动态代理。从而规避一些IP限制的检测。</p>
</blockquote>
<h3 id="设备指纹"><a href="#设备指纹" class="headerlink" title="设备指纹"></a>设备指纹</h3><p>设备指纹主要为了解决就是设备的唯一性，防护方通过采集手机的某些字段，从而实现得到设备唯一的标识</p>
<p>客户端的采集准确程度，有时候也大幅度的决定了后端策略的风控方向</p>
<p>设备指纹唯一ID，相当于用户的<code>token</code> ，设备指纹的准确性和唯一性，决定安全SDK的强度</p>
<p><strong>其检测方式也只是为了提升攻击者绕过的成本</strong></p>
<p>但是手机重置以后或者恢复出厂设置以后，大部分大厂的设备指纹都无法做到设备唯一性的确认</p>
<h3 id="App环境信息"><a href="#App环境信息" class="headerlink" title="App环境信息"></a>App环境信息</h3><p>当策略或者防护发现某个token或者某个设备唯一标识出现问题的时候，可能第一时间就是去检测这个设备的环境信息，用于是否石锤当前用户是否作弊</p>
<ul>
<li>正常设备 （字面含义，正常用户使用的设备，服务端信任此设备）</li>
<li>灰产设备 （可能存在作弊可能的设备，当手机环境存在root等，hook框架等）</li>
<li>黑产设备 （已经被石锤作弊的设备）</li>
</ul>
<p>常用的环境检测主要包含以下几部分</p>
<h4 id="Root检测"><a href="#Root检测" class="headerlink" title="Root检测"></a>Root检测</h4><p><strong>传统检测方法：</strong>检测su文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var suPaths = [</span><br><span class="line">    &quot;/system/bin/su&quot;,</span><br><span class="line">    &quot;/system/xbin/su&quot;,</span><br><span class="line">    &quot;/sbin/su&quot;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><strong>现代检测方法：</strong>Magisk检测，LSPosed&#x2F;EdXposed检测，系统属性检测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 1. 检测Magisk特征文件</span><br><span class="line">var magiskPaths = [</span><br><span class="line">    &quot;/sbin/.magisk&quot;,</span><br><span class="line">    &quot;/data/adb/magisk&quot;,</span><br><span class="line">    &quot;/data/adb/modules&quot;,</span><br><span class="line">    &quot;/cache/magisk.log&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 2. 检测Magisk端口（默认：随机端口）</span><br><span class="line">// Native层扫描 /proc/net/tcp</span><br><span class="line"></span><br><span class="line">// 3. 扫描/proc/self/maps内存映射</span><br><span class="line">function checkMapsForMagisk() &#123;</span><br><span class="line">    // 读取 /proc/self/maps</span><br><span class="line">    // 查找关键字：magisk, zygisk, riru</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 检测/proc/self/mount挂载点</span><br><span class="line">function checkMountForMagisk() &#123;</span><br><span class="line">    // 检测tmpfs等可疑挂载</span><br><span class="line">&#125;</span><br><span class="line">// LSPosed 特征路径</span><br><span class="line">var lsposedPaths = [</span><br><span class="line">    &quot;/data/misc/lsposed&quot;,</span><br><span class="line">    &quot;/system/framework/lspatch.jar&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 检测Zygote注入</span><br><span class="line">function checkZygoteHook() &#123;</span><br><span class="line">    // 检查 /proc/self/maps 是否包含 libriru.so</span><br><span class="line">    // 检查 /proc/[pid]/maps 中的可疑库</span><br><span class="line">&#125;</span><br><span class="line">// Java层</span><br><span class="line">String buildTags = Build.TAGS;</span><br><span class="line">boolean isTestKeys = buildTags.contains(&quot;test-keys&quot;); // 非官方ROM标志</span><br><span class="line"></span><br><span class="line">// Native层检测selinux状态</span><br><span class="line">// getenforce() == &quot;Permissive&quot; 表示可能被修改</span><br></pre></td></tr></table></figure>

<h4 id="Hook检测"><a href="#Hook检测" class="headerlink" title="Hook检测"></a>Hook检测</h4><p><strong>Xposed检测：</strong>上报Hook方法清单，检测Xposed环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 扫描所有被Hook的方法</span><br><span class="line">public static List&lt;String&gt; getXposedHookedMethods() &#123;</span><br><span class="line">    List&lt;String&gt; hookedMethods = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    // 遍历关键类的所有方法</span><br><span class="line">    Class&lt;?&gt; targetClass = YourClass.class;</span><br><span class="line">    for (Method method : targetClass.getDeclaredMethods()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 检查方法是否包含Xposed桥接</span><br><span class="line">            Field fieldHookedMethod = </span><br><span class="line">                Method.class.getDeclaredField(&quot;artMethod&quot;);</span><br><span class="line">            fieldHookedMethod.setAccessible(true);</span><br><span class="line">            long artMethod = (long) fieldHookedMethod.get(method);</span><br><span class="line">            </span><br><span class="line">            // 分析ArtMethod结构，检测hook标志</span><br><span class="line">            // ...</span><br><span class="line">            </span><br><span class="line">        &#125; catch (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return hookedMethods;</span><br><span class="line">&#125;</span><br><span class="line">// 检测XposedBridge类</span><br><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;de.robv.android.xposed.XposedBridge&quot;);</span><br><span class="line">    // 发现Xposed框架</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    // 未发现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测ClassLoader异常</span><br><span class="line">ClassLoader classLoader = YourClass.class.getClassLoader();</span><br><span class="line">String clName = classLoader.getClass().getName();</span><br><span class="line">if (clName.contains(&quot;XposedBridge&quot;)) &#123;</span><br><span class="line">    // 检测到Xposed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Frida检测：</strong>Inline Hook检测，Frida特征检测，检测常见Hook点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// Native层实现</span><br><span class="line">#include &lt;elf.h&gt;</span><br><span class="line"></span><br><span class="line">// 1. 解析本地ELF文件获取原始指令</span><br><span class="line">uint32_t getOriginalInstruction(const char* soPath, </span><br><span class="line">                                  const char* funcName) &#123;</span><br><span class="line">    // 解析ELF文件</span><br><span class="line">    // 获取函数符号表</span><br><span class="line">    // 读取函数偏移处的指令</span><br><span class="line">    return originalInstruction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 读取内存中的当前指令</span><br><span class="line">uint32_t getCurrentInstruction(void* funcAddr) &#123;</span><br><span class="line">    return *(uint32_t*)funcAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 对比检测</span><br><span class="line">bool isFunctionHooked(const char* soPath, </span><br><span class="line">                       const char* funcName, </span><br><span class="line">                       void* funcAddr) &#123;</span><br><span class="line">    uint32_t original = getOriginalInstruction(soPath, funcName);</span><br><span class="line">    uint32_t current = getCurrentInstruction(funcAddr);</span><br><span class="line">    </span><br><span class="line">    if (original != current) &#123;</span><br><span class="line">        // 检测到Hook！</span><br><span class="line">        log(&quot;Function %s is hooked!&quot;, funcName);</span><br><span class="line">        log(&quot;Original: 0x%08x, Current: 0x%08x&quot;, original, current);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">// 检测Frida-server端口（默认27042）</span><br><span class="line">bool checkFridaPort() &#123;</span><br><span class="line">    FILE* fp = fopen(&quot;/proc/net/tcp&quot;, &quot;r&quot;);</span><br><span class="line">    // 扫描端口：27042, 27043等</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测Frida线程</span><br><span class="line">bool checkFridaThread() &#123;</span><br><span class="line">    DIR* dir = opendir(&quot;/proc/self/task&quot;);</span><br><span class="line">    // 遍历线程，检查线程名：gmain, gdbus, gum-js-loop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测Frida库文件</span><br><span class="line">const char* fridaLibs[] = &#123;</span><br><span class="line">    &quot;frida-agent&quot;,</span><br><span class="line">    &quot;frida-gadget&quot;, </span><br><span class="line">    &quot;libfrida&quot;,</span><br><span class="line">    &quot;re.frida&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 扫描 /proc/self/maps</span><br><span class="line">// 检查libc.so关键函数</span><br><span class="line">void* funcs[] = &#123;</span><br><span class="line">    dlopen,</span><br><span class="line">    dlsym,</span><br><span class="line">    open,</span><br><span class="line">    read,</span><br><span class="line">    write,</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; sizeof(funcs)/sizeof(void*); i++) &#123;</span><br><span class="line">    if (isFunctionHooked(&quot;libc.so&quot;, funcNames[i], funcs[i])) &#123;</span><br><span class="line">        // 上报被Hook的函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="沙箱-虚拟环境检测"><a href="#沙箱-虚拟环境检测" class="headerlink" title="沙箱&amp;虚拟环境检测"></a>沙箱&amp;虚拟环境检测</h4><p>进程环境检测，私有路径检测，文件描述符检测，IPC动态代理检测，Parent PID检测</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查启动时进程数量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">checkProcessCount</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE* fp = popen(<span class="string">&quot;ps -A&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), fp)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常设备启动时进程数 &gt; 50</span></span><br><span class="line">    <span class="comment">// 沙箱环境可能只有几个进程</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="comment">// 可疑沙箱环境</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查应用私有目录</span></span><br><span class="line">String dataDir = getApplicationInfo().dataDir;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常路径: /data/data/com.example.app</span></span><br><span class="line"><span class="comment">// 沙箱路径: /data/data/com.virtualapp.xxx/virtual/data/com.example.app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dataDir.equals(<span class="string">&quot;/data/data/&quot;</span> + getPackageName())) &#123;</span><br><span class="line">    <span class="comment">// 检测到虚拟环境！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测异常的fd</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">checkFileDescriptors</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR* dir = opendir(<span class="string">&quot;/proc/self/fd&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">entry</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span> fdPath[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(fdPath, <span class="string">&quot;/proc/self/fd/%s&quot;</span>, entry-&gt;d_name);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> linkPath[<span class="number">256</span>];</span><br><span class="line">        <span class="type">ssize_t</span> len = readlink(fdPath, linkPath, <span class="keyword">sizeof</span>(linkPath)<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否有异常的socket、pipe等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(linkPath, <span class="string">&quot;virtualapp&quot;</span>) || </span><br><span class="line">            <span class="built_in">strstr</span>(linkPath, <span class="string">&quot;parallel&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 检测到沙箱特征</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测系统服务是否被代理</span></span><br><span class="line">Object activityManager = context.getSystemService(</span><br><span class="line">    Context.ACTIVITY_SERVICE);</span><br><span class="line">    </span><br><span class="line">String className = activityManager.getClass().getName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (className.contains(<span class="string">&quot;Proxy&quot;</span>) || </span><br><span class="line">    className.contains(<span class="string">&quot;$Proxy&quot;</span>) ||</span><br><span class="line">    className.contains(<span class="string">&quot;Hook&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 检测到动态代理！典型的VA特征</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;IPC被代理: &quot;</span> + className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测多个系统服务</span></span><br><span class="line">String[] services = &#123;</span><br><span class="line">    Context.ACTIVITY_SERVICE,</span><br><span class="line">    Context.PACKAGE_SERVICE,</span><br><span class="line">    Context.LOCATION_SERVICE,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 检查父进程</span></span><br><span class="line"><span class="type">pid_t</span> ppid = getppid();</span><br><span class="line"><span class="type">char</span> cmdline[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(cmdline, <span class="string">&quot;/proc/%d/cmdline&quot;</span>, ppid);</span><br><span class="line"></span><br><span class="line">FILE* fp = fopen(cmdline, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fgets(cmdline, <span class="keyword">sizeof</span>(cmdline), fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常情况下父进程是zygote</span></span><br><span class="line"><span class="comment">// 沙箱环境下可能是VA、Parallel Space等</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strstr</span>(cmdline, <span class="string">&quot;zygote&quot;</span>)) &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">&quot;异常父进程: %s&quot;</span>, cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>此字段一般在环境占比中很重要，当当前App环境一旦被石锤沙箱环境以后，直接可认定当前用户为黑设备</strong></p>
</blockquote>
<h4 id="APK签名检测"><a href="#APK签名检测" class="headerlink" title="APK签名检测"></a>APK签名检测</h4><p>检测签名信息，检测签名来源（Android 9+），Native层校验（防篡改），</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取APK签名</span></span><br><span class="line"><span class="type">PackageInfo</span> <span class="variable">packageInfo</span> <span class="operator">=</span> context.getPackageManager()</span><br><span class="line">    .getPackageInfo(context.getPackageName(), </span><br><span class="line">                    PackageManager.GET_SIGNATURES);</span><br><span class="line"></span><br><span class="line">Signature[] signatures = packageInfo.signatures;</span><br><span class="line"><span class="type">String</span> <span class="variable">signMd5</span> <span class="operator">=</span> getMD5(signatures[<span class="number">0</span>].toByteArray());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与预置的正版签名对比</span></span><br><span class="line"><span class="type">String</span> <span class="variable">OFFICIAL_SIGN</span> <span class="operator">=</span> <span class="string">&quot;你的官方签名MD5&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (!signMd5.equals(OFFICIAL_SIGN)) &#123;</span><br><span class="line">    <span class="comment">// 检测到重打包！</span></span><br><span class="line">    <span class="comment">// 这是黑产设备的石锤证据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Android P及以上</span></span><br><span class="line"><span class="type">PackageInfo</span> <span class="variable">info</span> <span class="operator">=</span> pm.getPackageInfo(packageName,</span><br><span class="line">    PackageManager.GET_SIGNING_CERTIFICATES);</span><br><span class="line"></span><br><span class="line"><span class="type">SigningInfo</span> <span class="variable">signingInfo</span> <span class="operator">=</span> info.signingInfo;</span><br><span class="line"><span class="keyword">if</span> (signingInfo.hasMultipleSigners()) &#123;</span><br><span class="line">    <span class="comment">// 多签名，可疑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取APK文件，计算hash</span></span><br><span class="line"><span class="comment">// 对比预埋的hash值</span></span><br><span class="line">bool <span class="title function_">verifyApkIntegrity</span><span class="params">()</span> &#123;</span><br><span class="line">    const <span class="type">char</span>* apkPath = <span class="string">&quot;/data/app/.../base.apk&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算APK的SHA256</span></span><br><span class="line">    <span class="type">char</span>* hash = calculateSHA256(apkPath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对比预埋hash（加密存储）</span></span><br><span class="line">    <span class="keyword">if</span> (strcmp(hash, OFFICIAL_HASH) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 被篡改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h4><p>基础特征检测，CPU特征检测，传感器检测，硬件特征检测</p>
<h4 id="自定义ROM"><a href="#自定义ROM" class="headerlink" title="自定义ROM"></a>自定义ROM</h4><p>系统文件MD5检查，Build属性检测</p>
<h3 id="查杀分离"><a href="#查杀分离" class="headerlink" title="查杀分离"></a>查杀分离</h3><p>这个也是一种很重要的策略，主要就是<strong>当服务端或者命中风控</strong>以后，他不会及时封你的号，或者立刻给你号返回错误数据。</p>
<p>而是隔一段时间，可能是几个小时，也有可能是几天，这样做的好处防止你去不断地试探从而找到正确的检测规律。</p>
<p>防止攻击者不断试探的方式去获取正确的风控规则。规避风险。</p>
<h3 id="用户行为-心跳包上报"><a href="#用户行为-心跳包上报" class="headerlink" title="用户行为&amp;心跳包上报"></a>用户行为&amp;心跳包上报</h3><h4 id="检测原理："><a href="#检测原理：" class="headerlink" title="检测原理："></a>检测原理：</h4><p>一般大厂会使用这种方案，在一些SDK初始化以后会开启一个<code>socket</code>，tcp长连接，覆盖App整个生命周期，当用户进行点击的时候</p>
<p>对页面某个位置点击的时候会进行上报，后台可以很清楚的看到当前用户的点击路径。如果攻击者直接通过<strong>rpc或者算法还原接口破解</strong>的方式调用接口的话，就<strong>可能会存在心跳包遗漏的问题</strong>，当长时间无心跳以后，可能会直接认为当前IP是风险IP，从而实现封禁。</p>
<p>这个方法也是很好用的办法，可以通过AI等进行自动化的行为判断，等AI的模型和数据足够完善以后，即可实现，自动化判断自动化&amp;非自动化（人手点击）的判断。</p>
<p>比如某些的自动点击框架，如果只是为了业务去点击的话，是没有一些多余操作的，而我们们的手在屏幕不断滑动的时候是会产生很多用户路径，我们称之为<strong>随机路径</strong>。</p>
<h4 id="对抗原理"><a href="#对抗原理" class="headerlink" title="对抗原理"></a>对抗原理</h4><p>自动化点击脚本控制App+用户随机路径，自动化脚本控制App去实现自动化点击，防止心跳包和用户点击路径的遗漏。</p>
<p>需要添加随机路径，防止被AI检测出来自动化操作，添加随机路径也很简单，在不影响点击结果的情况下，仿人触摸随机对屏幕滑动。</p>
<p>（可以提前录制一些用户的操作流程，将数据保存到Json里面，在对屏幕进行dispatch事件分发的时候，采用真人点击的event即可）</p>
<blockquote>
<p>细节点：如何记录用户的点击行为？</p>
<p>手机屏幕好像是一个分发器，而屏幕的view是消费者。他可能选择消费这个事件，也可以选择抛出去，给下级view去消费。</p>
<p>但是事件只要被消费了就一定会走<code>view-&gt;ontouch();</code>方法，所以我们只需要<code>hook view的view-&gt;ontouch();</code> 方法，把参数1进行toString打印和保存即可。即可得到全部的的点击事件消费对象<code>objection</code>。</p>
</blockquote>
<h3 id="异常-行为埋点"><a href="#异常-行为埋点" class="headerlink" title="异常&amp;行为埋点"></a>异常&amp;行为埋点</h3><h4 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h4><p>指的是在某个页面进行埋点，只有触发某条请求或者打开某个页面的时候才会进行埋点上报。</p>
<blockquote>
<p><strong>举个case:</strong></p>
<p>当攻击者调用登入接口获取token的时候，正常肯定需要打开App的登入页面，而这个埋点是通过打开页面时候进行上报。</p>
<p><strong>如果攻击者只进行了调用登入接口，没有调用埋点接口，可能会导致当前请求缺少前置埋点。</strong>可能会导致数据被风控。</p>
</blockquote>
<p>埋点上报其实在风控里面发挥的作用还是很大的，正常用户从登入到查看个人信息，需要触发5个埋点信息。</p>
<p>但是攻击者只触发了1-2个埋点，则可认定当前用户存在作弊行为，可能存在脱机的嫌疑。会被直接标识成黑设备。</p>
<p>在后台看的话就是一些点点，而这些点就是不同的埋点信息，哪个点被点亮，哪个点没有被点亮，和正常的用户做一下对比，很容易就可以确认。</p>
<h4 id="对抗原理："><a href="#对抗原理：" class="headerlink" title="对抗原理："></a>对抗原理：</h4><p>同上</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>说了这么多总结一下，用上述的方法可以有效对抗，RPC，或者常规的自动点击，包括一些大批量的数据获取。</p>
<p>当账号数量足够多的时候（账号足够成熟，很多新号会有限制），并且满足一下条件的时候：</p>
<p><strong>群控+自动点击+用户点击随机路径+完善的改机软件+一机多号（设备够多无视），即可实现风控的对抗。</strong></p>
<p>当然还需要分析，一些账号的临界值，不同的数据可能触发的风控点也不一样。</p>
<p>比如有的数据单用户日获取量不超过20条，那么你你就不可能获取超过20次。群控服务端还需要记录每个用户的日点击数，等信息。</p>
<h1 id="设备指纹获取"><a href="#设备指纹获取" class="headerlink" title="设备指纹获取"></a>设备指纹获取</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Android-IPC代理"><a href="#Android-IPC代理" class="headerlink" title="Android IPC代理"></a>Android IPC代理</h3><p>Android本身是CS架构，客户端（client）服务端（server），我们常用的通过context上下文调用的API都是直接调用代理人的方式去调用的，而真正的服务端是ActivityManagerServer 简称，AMS， 他有很多代理，比如PackageManager，ActivityManager 等，这些都是AMS的<strong>代理人</strong>。而AMS就是<strong>被代理人</strong>。代理模式是一种设计模式，代理人可以提供被代理人的部分或者全部功能，实现代码封装，做鉴权，代码安全的角度，代理模式很常用的设计模式。</p>
<p>AMS和代理们通过Binder进行通讯，Binder是什么，有什么好处这里就不详细展开了，安卓面试八股文，可以理解成<strong>进程间通讯</strong>的东西，底层实现是<strong>通过共享内存，数据传输，读取速度更快</strong>。<strong>当我们调用代理人的API的时候，本质上是通过Binder去发送一些数据包，和AMS通讯</strong>，当<strong>AMS收到消息以后把结果在传输给对应的代理人</strong>。然后返回给调用方。在每个Manager里面都有一个代理人 。</p>
<p>之前很久之前有一种动态代理的技术，原理就是替换了里面的代理人，因为代理是一个接口，然后我们自己通过Proxy这个类创建一个代理，然后反射set回去，就可以实现常用的API拦截和Hook。类似VA的沙盒，对多开的App提供一份自己实现的代理，然后控制这些代理的返回值，以此实现沙盒相关操作。还有一种比较好的过APK签名的方法就是直接Hook”水管” 也就是hook binder的通讯的方法，当接收到指定事件以后，直接修改具体的结果，以此对Java层进行全量Hook(<strong>binder的通讯方法被Hook以后，调用者和代理人只能拿到被修改以后的结果，以此实现Java层的全量Hook</strong>，后面再讲签名验证的时候我在详细说。)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正常流程：App → 代理 → Binder → 系统服务 → 返回真实签名</span><br><span class="line">Hook后：App → 代理 → [被Hook的Binder] → 系统服务 → 真实签名</span><br><span class="line">                           ↓</span><br><span class="line">                      拦截并修改为伪造签名</span><br><span class="line">                           ↓</span><br><span class="line">         App ← 代理 ← [被Hook的Binder] ← 伪造签名返回</span><br></pre></td></tr></table></figure>

<h2 id="设备指纹-1"><a href="#设备指纹-1" class="headerlink" title="设备指纹"></a>设备指纹</h2><p>设备指纹主要分为三部分，<strong>Java层设备指纹，Native设备指纹</strong>，popen执行一些命令获取设备信息，包括<strong>一些核心的设备指纹</strong>。</p>
<h3 id="Java层设备指纹"><a href="#Java层设备指纹" class="headerlink" title="Java层设备指纹"></a>Java层设备指纹</h3><h4 id="Setting相关（重要）"><a href="#Setting相关（重要）" class="headerlink" title="Setting相关（重要）"></a>Setting相关（重要）</h4><h5 id="Get"><a href="#Get" class="headerlink" title="Get:"></a>Get:</h5><p>在<code>setting</code>里面大家经常遇到的可能就是<code>android id</code>的获取的</p>
<p><code>API</code>如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Secure.getString(context.getContentResolver(),Settings.Secure.ANDROID_ID)</span><br></pre></td></tr></table></figure>

<p>但是其实<code>Setting</code>里面还有很多别的功能东西，常见的就是<code>Settings.Secure</code> 和 <code>Settings.Global</code></p>
<p>在<code>Settings.Global</code> 里面其实还有一些别的字段，具体<code>API</code>如下。这些都是一些比较隐蔽的设备指纹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;mi_health_id&quot;)</span><br><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;mi_health_id&quot;)</span><br><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;gcbooster_uuid&quot;)</span><br><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;key_mqs_uuid&quot;)</span><br><span class="line">Settings.Global.getString(context.getContentResolver(),&quot;ad_aaid&quot;)</span><br></pre></td></tr></table></figure>

<h5 id="Mock"><a href="#Mock" class="headerlink" title="Mock:"></a>Mock:</h5><p><strong>方法Hook</strong></p>
<p><code>Global</code>和<code>Secure</code> 都是实现的<code>NameValueTable</code>接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static String getString(ContentResolver resolver, String name) &#123;</span><br><span class="line">      return getStringForUser(resolver, name, resolver.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层调用的是<code>getStringForUser(resolver, name, resolver.getUserId())</code> 三个参数，如果Hook的话可以对这个方法进行入手</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings.Secure-&gt;getStringForUser &amp; Settings.Global-&gt;getStringForUser</span><br></pre></td></tr></table></figure>

<p><strong>内存反射</strong></p>
<p>很多开发者会采用内存反射的方式去获取变量，所以仅仅是通过<code>mock</code>方法的方式不够，如果进行Mock需要将<code>Settings.Secure</code> 和 <code>Settings.Global</code> 里面的内存变量进行修复，<code>Settings.Global</code>是放了一些全局变量，<code>Settings.Secure</code>放一些安全相关</p>
<p><code>Settings.Secure-&gt;getStringForUser Settings.Global-&gt;getStringForUser</code> 和 具体方法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static final HashSet&lt;String&gt; MOVED_TO_GLOBAL;</span><br><span class="line">private static final NameValueCache sNameValueCache = new NameValueCache(</span><br><span class="line">                CONTENT_URI,</span><br><span class="line">                CALL_METHOD_GET_SYSTEM,</span><br><span class="line">                CALL_METHOD_PUT_SYSTEM,</span><br><span class="line">                sProviderHolder,</span><br><span class="line">                System.class);</span><br><span class="line">                 </span><br><span class="line">public static String getStringForUser(ContentResolver resolver, String name,</span><br><span class="line">                int userHandle) &#123;</span><br><span class="line">            if (MOVED_TO_GLOBAL.contains(name)) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Setting &quot; + name + &quot; has moved from android.provider.Settings.Secure&quot;</span><br><span class="line">                        + &quot; to android.provider.Settings.Global.&quot;);</span><br><span class="line">                return Global.getStringForUser(resolver, name, userHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            return sNameValueCache.getStringForUser(resolver, name, userHandle);</span><br><span class="line">       &#125;</span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">@UnsupportedAppUsage</span><br><span class="line">public static String getStringForUser(ContentResolver resolver, String name,</span><br><span class="line">                int userHandle) &#123;</span><br><span class="line">            if (MOVED_TO_SECURE.contains(name)) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Setting &quot; + name + &quot; has moved from android.provider.Settings.System&quot;</span><br><span class="line">                        + &quot; to android.provider.Settings.Secure, returning read-only value.&quot;);</span><br><span class="line">                return Secure.getStringForUser(resolver, name, userHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            if (MOVED_TO_GLOBAL.contains(name) || MOVED_TO_SECURE_THEN_GLOBAL.contains(name)) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Setting &quot; + name + &quot; has moved from android.provider.Settings.System&quot;</span><br><span class="line">                        + &quot; to android.provider.Settings.Global, returning read-only value.&quot;);</span><br><span class="line">                return Global.getStringForUser(resolver, name, userHandle);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<strong>整体的cache都是放在sNameValueCache变量和MOVED_TO_GLOBAL变量内部进行存储 。</strong></p>
<p>我们可以直接反射<code>MOVED_TO_GLOBAL</code>这个<code>HashSet</code>或者去<code>sNameValueCache</code> 这个变量然后去获取这个值的话，也是很容易可以拿到最真实的值的。所以光<code>mock</code>是不够的。</p>
<p>比如很多大厂就是<strong>Android高版本绕过了反射限制以后，或者判断当前手机没有API反射限制以后直接通过反射变量的方式去获取。</strong></p>
<p><code>sNameValueCache</code>在高版本是一个对象，低版本安卓他是一个<code>ArrayMap</code> 这块需要注意。</p>
<p><code>sNameValueCache</code>修改的话可以调用<code>API putStringForUser</code>  往里面强制赋值。这么一来下次对方在通过<code>API</code>去调用的时候就会拿到你已经进行过<code>Mock</code>的值。所以你修改的时候需要进行判断，当前获取的值是否是你已经<code>Mock</code>过的。</p>
<h4 id="蓝牙网卡MAC（普通）"><a href="#蓝牙网卡MAC（普通）" class="headerlink" title="蓝牙网卡MAC（普通）"></a>蓝牙网卡MAC（普通）</h4><p>蓝牙的网卡不是普通的网卡，后面会介绍netlinker获取真实的网卡。</p>
<h5 id="Get-1"><a href="#Get-1" class="headerlink" title="Get:"></a>Get:</h5><p>主要方法就是通过BluetoothAdapter-&gt;getAddress</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mManagerService.getAddress(mAttributionSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">应用进程 → Binder Proxy → Binder 驱动 → Binder Stub → system_server (实际服务)</span><br></pre></td></tr></table></figure>

<h5 id="Mock："><a href="#Mock：" class="headerlink" title="Mock："></a>Mock：</h5><p>可以看到这个方法主要是通过<code>IPC</code>的代理类方式去获取的。<strong>所以Hook的话尽可能先Hook代理的IPC类。先尝试反射 android.bluetooth.IBluetooth$Stub$Proxy然后Hook IPC里面的getAddress 而不是直接HookBluetoothAdapter-&gt;getAddress</strong></p>
<p>因为很多大厂获取设备的指纹的时候会检测这个方法是否被Hook，检测也很简单，只需要获取这个<code>artmethod</code>结构体以后</p>
<p>判断这个方法入口是否被替换，比如Sandhook之类的常用的Hook框架，低版本采用的是inlinehook形式，在高版本里面采用的是入口替换，可以直接获取到方法的入口的函数地址，判断一下函数所在的so即可。所以尽可能HookIPC的方法。<strong>如果用XPosed去修改的话，还需要注意魔改，否则大厂会通过XposedHelpers-&gt;sHookedMethodCallbacks变量把你Hook的方法进行上报</strong>。</p>
<blockquote>
<p>小技巧：这个变量是一个静态变量，所以我们只需要拿到XposedHelpers这个class即可。想要拿到class必须先拿到这个类的classloader，正常的Xposed是通过系统的classloader作为父类classloader，但是edxp这种，是一个方法内部的成员变量，没有任何地方引用这个classloader，所以想拿到这个classloader需要用到内存漫游。把内存全部的classloader都从内存抠出来，然后挨个去反射获取XposedHelpers 即可。</p>
</blockquote>
<p><code>sHookedMethodCallbacks</code>里面保存了XPosed全部的Hook方法信息，用于石锤当前方法是否被Hook。获取被Hook方法具体如下：</p>
<blockquote>
<p><strong>XposedHelpers-&gt;methodCache 不建议使用，如果攻击者使用了XposedBridge-&gt;HookAllmethod 的话，可能会导致Hook方法上报的遗漏。</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void getHookItemDemo() &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; choose = ChooseUtils.choose(ClassLoader.class, true);</span><br><span class="line">    for(Object obj :choose)&#123;</span><br><span class="line">        ClassLoader clazzloader = (ClassLoader) obj;</span><br><span class="line">        Class&lt;?&gt; clazzXh = null;</span><br><span class="line">        Class&lt;?&gt; clazzBR = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Log.e(&quot;Test&quot;, &quot;-----------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">            clazzBR =  Class.forName(&quot;de.robv.android.xposed.XposedBridge&quot;,false,clazzloader);</span><br><span class="line">            Field callbacksField = clazzBR.getDeclaredField(&quot;sHookedMethodCallbacks&quot;);</span><br><span class="line">            callbacksField.setAccessible(true);</span><br><span class="line">            Map&lt;Member, Object&gt; callback = (Map&lt;Member, Object&gt;) callbacksField.get(null);</span><br><span class="line"></span><br><span class="line">            for(Member key :callback.keySet()) &#123;</span><br><span class="line">                Log.e(&quot;Test&quot;, &quot;sHookedMethodCallbacks  &quot; + key.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(&quot;Test&quot;, &quot;-----------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            Log.e(&quot;Test&quot;,&quot;find errror &quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为正常的使用zygisk的Xposed hook的classloader如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│         BootClassLoader (系统类)             │</span><br><span class="line">│    (String, Object, Activity...)            │</span><br><span class="line">└──────────────────┬──────────────────────────┘</span><br><span class="line">                │ parent</span><br><span class="line">┌──────────────────▼──────────────────────────┐</span><br><span class="line">│      PathClassLoader (系统 Framework)        │</span><br><span class="line">│  ✅ XposedBridge.jar 被注入到这里              │</span><br><span class="line">│  ✅ 所有 App 共享这个 ClassLoader              │</span><br><span class="line">└──────────────────┬──────────────────────────┘</span><br><span class="line">                │ parent</span><br><span class="line">     ┏━━━━━━━━━━┻━━━━━━━━━━┓</span><br><span class="line">     ▼                      ▼</span><br><span class="line">┌────────────────┐    ┌────────────────┐</span><br><span class="line">│   App1 的       │    │   App2 的       │</span><br><span class="line">│  ClassLoader   │    │  ClassLoader   │</span><br><span class="line">└────────────────┘    └────────────────┘</span><br></pre></td></tr></table></figure>

<p>而使用riru的<code>EdXposed</code> 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────┐</span><br><span class="line">│         BootClassLoader                     │</span><br><span class="line">└──────────────────┬──────────────────────────┘</span><br><span class="line">                │</span><br><span class="line">┌──────────────────▼──────────────────────────┐</span><br><span class="line">│      系统 PathClassLoader                    │</span><br><span class="line">│  ❌ 没有 XposedBridge（隐蔽性）               │</span><br><span class="line">└──────────────────┬──────────────────────────┘</span><br><span class="line">                │</span><br><span class="line">     ┏━━━━━━━━━━╋━━━━━━━━━━┓</span><br><span class="line">     ▼          ▼          ▼</span><br><span class="line">┌────────────┐ ┌──────────────────┐ ┌────────────┐</span><br><span class="line">│  App 的     │ │ 🔒 隐藏的独立     │ │  其他...   │</span><br><span class="line">│ ClassLoader│ │   ClassLoader    │ └────────────┘</span><br><span class="line">└────────────┘ │ XposedBridge.jar │</span><br><span class="line">            │  加载在这里        │</span><br><span class="line">            │ ❗ 没有任何地方    │</span><br><span class="line">            │    引用它！        │</span><br><span class="line">            └──────────────────┘</span><br></pre></td></tr></table></figure>

<p>没有任何的App加载了相应的<code>ClassLoader</code>，因此需要通过内存漫游的方式获取所有的<code>ClassLoader</code>，然后再加载相应的类</p>
</blockquote>
<h4 id="serial（普通）"><a href="#serial（普通）" class="headerlink" title="serial（普通）"></a>serial（普通）</h4><p>这个变量在高版本里面基本已经拿不到，及时拿到了也是一个unknow，但是也需要兼容低版本的Android</p>
<h5 id="get"><a href="#get" class="headerlink" title="get:"></a>get:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; </span><br><span class="line">        <span class="keyword">return</span> Build.getSerial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Mock-1"><a href="#Mock-1" class="headerlink" title="Mock:"></a>Mock:</h5><p>如果返回的不是空，并且不是 <code>unknow</code> 或者<code>UNKNOWN</code>，随机一份原始长度的字符串即可。另外该字段同上，也可以直接对<code>IPC</code>类进行处理，直接<code>Hook IPC</code>对象<code>getSerialForPackage</code> 方法即可 ，实现方法具体如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSerial</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">IDeviceIdentifiersPolicyService</span> <span class="variable">service</span> <span class="operator">=</span> IDeviceIdentifiersPolicyService.Stub</span><br><span class="line">            .asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Application</span> <span class="variable">application</span> <span class="operator">=</span> ActivityThread.currentApplication();</span><br><span class="line">        <span class="type">String</span> <span class="variable">callingPackage</span> <span class="operator">=</span> application != <span class="literal">null</span> ? application.getPackageName() : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> service.getSerialForPackage(callingPackage, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UNKNOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IMEI-IMSI-ICCID-Line1Number-普通"><a href="#IMEI-IMSI-ICCID-Line1Number-普通" class="headerlink" title="IMEI , IMSI ,ICCID,Line1Number (普通)"></a>IMEI , IMSI ,ICCID,Line1Number (普通)</h4><h5 id="get："><a href="#get：" class="headerlink" title="get："></a>get：</h5><ul>
<li><p><code>IMEI</code> 与你的手机是绑定关系 用于区别移动终端设备，<code>DeviceId</code>就是IMEI</p>
</li>
<li><p><code>IMSI</code> 与你的手机卡是绑定关系 用于区别移动用户的有效信息 IMSI是用户的标识。</p>
</li>
<li><p><code>ICCID</code>是卡的标识，由20位数字组成</p>
</li>
<li><p><code>ICCID</code>只是用来<strong>区别SIM卡</strong>，<strong>不作接入网络的鉴权认证</strong>。而IMSI在接入网络的时候，会到运营商的服务器中进行验证。<code>SimSerialNumber</code>就是ICCID</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the phone status.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must hold &#123;<span class="doctag">@code</span> &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * IMEI 与你的手机是绑定关系 用于区别移动终端设备</span></span><br><span class="line"><span class="comment"> * IMSI 与你的手机卡是绑定关系 用于区别移动用户的有效信息 IMSI是用户的标识。</span></span><br><span class="line"><span class="comment"> * DeviceId就是IMEI</span></span><br><span class="line"><span class="comment"> * DeviceId = 99000311726612&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * DeviceSoftwareVersion = 00&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * Line1Number =&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * NetworkCountryIso = cn&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * NetworkOperator = 46003&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * NetworkOperatorName = 中国电信&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * NetworkType = 6&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * PhoneType = 2&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SimCountryIso = cn&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SimOperator = 46003&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SimOperatorName = 中国电信&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * ICCID ICCID是卡的标识，由20位数字组成</span></span><br><span class="line"><span class="comment"> * ICCID只是用来区别SIM卡，不作接入网络的鉴权认证。而IMSI在接入网络的时候，会到运营商的服务器中进行验证。</span></span><br><span class="line"><span class="comment"> * SimSerialNumber就是ICCID</span></span><br><span class="line"><span class="comment"> * SimSerialNumber = 89860315045710604022&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SimState = 5&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SubscriberId(IMSI) = 460030419724900&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * VoiceMailNumber = *86&lt;br&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressLint(&quot;HardwareIds&quot;)</span></span><br><span class="line"><span class="meta">@RequiresPermission(READ_PHONE_STATE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPhoneStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TelephonyManager</span> <span class="variable">tm</span> <span class="operator">=</span> getTelephonyManager();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">    str += <span class="string">&quot;DeviceId(IMEI) = &quot;</span> + tm.getDeviceId() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;DeviceSoftwareVersion = &quot;</span> + tm.getDeviceSoftwareVersion() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;Line1Number = &quot;</span> + tm.getLine1Number() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;NetworkCountryIso = &quot;</span> + tm.getNetworkCountryIso() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;NetworkOperator = &quot;</span> + tm.getNetworkOperator() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;NetworkOperatorName = &quot;</span> + tm.getNetworkOperatorName() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;NetworkType = &quot;</span> + tm.getNetworkType() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;PhoneType = &quot;</span> + tm.getPhoneType() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimCountryIso = &quot;</span> + tm.getSimCountryIso() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimOperator = &quot;</span> + tm.getSimOperator() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimOperatorName = &quot;</span> + tm.getSimOperatorName() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimSerialNumber = &quot;</span> + tm.getSimSerialNumber() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SimState = &quot;</span> + tm.getSimState() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;SubscriberId(IMSI) = &quot;</span> + tm.getSubscriberId() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;VoiceMailNumber = &quot;</span> + tm.getVoiceMailNumber();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Mock：-1"><a href="#Mock：-1" class="headerlink" title="Mock："></a>Mock：</h5><p><code>TelephonyManager</code>源码：<a target="_blank" rel="noopener" href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/telephony/java/android/telephony/TelephonyManager.java">https://github.com/aosp-mirror/platform_frameworks_base/blob/master/telephony/java/android/telephony/TelephonyManager.java</a></p>
<p>尝试优先<code>Hook ipc</code>即可</p>
<h4 id="Build相关（次要）"><a href="#Build相关（次要）" class="headerlink" title="Build相关（次要）"></a>Build相关（次要）</h4><p>Build里面还是有很多有用的东西，比如手机是否开启adb ,usb接口的状态之类的。我们主要将Build里面分为两部分 。指纹相关又分为两部分，<strong>单一字段 &#x2F;复合字段</strong>。</p>
<ol>
<li>配置相关</li>
<li>指纹相关<ul>
<li>单一字段（只有一个设备信息）</li>
<li>复合字段（多个单一字段复合而成）</li>
</ul>
</li>
</ol>
<p>这个单独通过Java层去修改是完全不够的，底层走的是<code>system_property_get</code> 这个方法（在native指纹部分会详细介绍）。</p>
<p>还有要防止popen getprop 这种方法去扫描全部的Build相关参数（popen getprop 在popen相关会详细介绍，这里只介绍Java应该如何处理），这个Build相关需要重点关注，他在<strong>Android底层实现类似树状结构。也就是说很多树枝都会有相同的内容。目前所有的作用域一共有七种。</strong></p>
<p>举个例子，比如常见的fingerprint复合字段系列 ，就分为如下七种作用域。</p>
<ul>
<li><code>ro.build.fingerprint/</code></li>
<li><code>ro.build.build.fingerprint/</code></li>
<li><code>ro.bootimage.build.fingerprint/</code></li>
<li><code>ro.odm.build.fingerprint/</code></li>
<li><code>ro.product.build.fingerprint/</code></li>
<li><code>ro.system_ext.build.fingerprint/</code></li>
<li><code>ro.system.build.fingerprint/</code></li>
<li><code>ro.vendor.build.fingerprint/</code></li>
</ul>
<p>作用域分别如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final String Region[] = &#123;  </span><br><span class="line">      &quot;build&quot;, &quot;bootimage&quot;, &quot;odm&quot;, &quot;product&quot;, &quot;system_ext&quot;, &quot;system&quot;, &quot;vendor&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里面的值构成顺序也都是一样，所以Hook的话也需要全部进行hook，只处理单一是没用的。因为很多大厂做采集，不会只收集一项。</p>
<p>会七个作用域都进行收集。</p>
<h5 id="配置相关："><a href="#配置相关：" class="headerlink" title="配置相关："></a>配置相关：</h5><p>常见的配置如下，这些字段其实修改不修改不重要，因为很多大厂如果手机开了开发者选项或者debug模式之类的。</p>
<p><strong>会增加当前手机的风险值。</strong>所以尝试进行Mock 和修改 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;sys.usb.config&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;sys.usb.state&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;persist.sys.usb.config&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;persist.sys.usb.qmmi.func&quot;, &quot;none&quot;, null, true);</span><br><span class="line">//这两个config可能会拿不到,拿不到则不进行mock</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;vendor.usb.mimode&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;persist.vendor.usb.config&quot;, &quot;none&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;ro.debuggable&quot;, &quot;0&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;init.svc.adbd&quot;, &quot;stopped&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;ro.secure&quot;, &quot;1&quot;, null, true);</span><br><span class="line">//手机解锁状态</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;ro.boot.flash.locked&quot;, &quot;1&quot;, null, true);</span><br><span class="line">PUT_MOCK_AND_SAVE_ORG(&quot;sys.oem_unlock_allowed&quot;, &quot;1&quot;, null, true);</span><br></pre></td></tr></table></figure>

<h5 id="单一字段"><a href="#单一字段" class="headerlink" title="单一字段:"></a>单一字段:</h5><p>在不修改机型的前提下，下面这些应该都是需要处理的 。大厂扫描频率很高的Build参数 ，随机的话，在原有的基础上开头或者结尾，随机几位数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ro.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.build.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.bootimage.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.odm.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.product.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.system_ext.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.system.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.vendor.build.id org-&gt; [RKQ1.200826.002] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">ro.build.version.security_patch org-&gt; [2021-11-01] mock -&gt; [2021-11-19]</span><br><span class="line">ro.boot.vbmeta.digest org-&gt; [ebe54be57a4fb91d8c22c3d69f68651931878d8925eb8a517d8110084fe45513] mock -&gt; [ebe54be57a4fb91d8c22c3d69f68651931878d8925eb8a517d8110084fa69209]</span><br><span class="line">ro.netflix.bsp_rev org-&gt; [Q8250-19134-1] mock -&gt; [P3660-19134-1]</span><br><span class="line">gsm.version.baseband org-&gt; [MPSS.HI.2.0.c7-00266-1025_0156_49a7b03461,MPSS.HI.2.0.c7-00266-1025_0156_49a7b03461] mock -&gt; [MPSS.HI.2.0.c7-00266-1025_0156_49a7b03846,MPSS.HI.2.0.c7-00266-1025_0156_49a7b03846]</span><br><span class="line"> </span><br><span class="line">ro.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.build.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.bootimage.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.odm.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.product.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.system_ext.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.system.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line">ro.vendor.build.date.utc org-&gt; [1639708288] mock -&gt; [1663313901]</span><br><span class="line"> </span><br><span class="line">ro.build.display.id org-&gt; [RKQ1.200826.002 test-keys] mock -&gt; [RKQ1.200826.945]</span><br><span class="line">// maybe debug-key</span><br><span class="line">ro.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.build.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.bootimage.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.odm.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.product.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.system_ext.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.system.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.vendor.build.tags org-&gt; [release-keys] mock -&gt; [release-keys]</span><br><span class="line">ro.build.host org-&gt; [m1-xm-ota-bd148.bj.idc.xiaomi.com] mock -&gt; [m1-xm-ota-be811.bj.idc.xiaomi.com]</span><br><span class="line">ro.build.user org-&gt; [builder] mock -&gt; [buizcdn]</span><br><span class="line">ro.config.ringtone org-&gt; [MiRemix.ogg] mock -&gt; [MiRemix.acc]</span><br><span class="line">ro.miui.ui.version.name org-&gt; [V125] mock -&gt; [V635]</span><br><span class="line"> </span><br><span class="line">ro.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.build.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.bootimage.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.odm.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.product.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.system_ext.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.system.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br><span class="line">ro.vendor.build.version.incremental org-&gt; [V12.5.19.0.RKHCNXM] mock -&gt; [V12.5.19.0.RKHWCRG]</span><br></pre></td></tr></table></figure>

<h5 id="复合字段："><a href="#复合字段：" class="headerlink" title="复合字段："></a>复合字段：</h5><p>复合字段是多个单一字段拼成的字段，常用的有<code>ro.build.description</code> 还有之前说的7个<code>fingerprint</code> 相关。 这些Mock以后的值要和之前单一字段Mock的值对等。比如某个单一字段值被Mock成A 以后，复合字段里面的内也应该是A 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ro.build.description org-&gt; [alioth-user 11 RKQ1.200826.002 V12.5.19.0.RKHCNXM release-keys] mock -&gt; [alioth-user 11 RKQ1.200826.945 V12.5.19.0.RKHWCRG release-keys]</span><br><span class="line"> </span><br><span class="line">ro.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.build.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.bootimage.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.odm.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.product.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.system_ext.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.system.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br><span class="line">ro.vendor.build.fingerprint org-&gt; [Redmi/alioth/alioth:11/RKQ1.200826.002/V12.5.19.0.RKHCNXM:user/release-keys] mock -&gt; [Redmi/alioth/alioth:11/RKQ1.200826.945/V12.5.19.0.RKHWCRG:user/release-keys]</span><br></pre></td></tr></table></figure>

<h5 id="Get-2"><a href="#Get-2" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.SystemProperties-&gt;get(key)</span><br></pre></td></tr></table></figure>

<h5 id="Mock-2"><a href="#Mock-2" class="headerlink" title="Mock:"></a>Mock:</h5><p><code>android.os.SystemProperties-&gt;get</code> 底层调用的是<code>native_get</code> ，一个native方法，所以Hook的时候优先处理 <code>native_get</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.SystemProperties-&gt;native_get</span><br></pre></td></tr></table></figure>

<p><code>Java hook</code>完毕以后 还需要反射将<code>Build</code>里面的成员变量进行<code>set</code>。防止采集通过反射的方式去获取</p>
<h4 id="系统默认账号（普通）："><a href="#系统默认账号（普通）：" class="headerlink" title="系统默认账号（普通）："></a>系统默认账号（普通）：</h4><p>很多大厂会把这个字段也作为指纹的一部分，所以这个方法也需要处理。</p>
<h5 id="Get-3"><a href="#Get-3" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AccountManager-&gt;getAccounts</span><br></pre></td></tr></table></figure>

<h5 id="Mock-3"><a href="#Mock-3" class="headerlink" title="Mock:"></a>Mock:</h5><p>优先<code>Hook ipc</code></p>
<h4 id="音量相关函数（普通）"><a href="#音量相关函数（普通）" class="headerlink" title="音量相关函数（普通）"></a>音量相关函数（普通）</h4><h5 id="Get-4"><a href="#Get-4" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioManager-&gt;getStreamVolume</span><br></pre></td></tr></table></figure>

<h5 id="Mock-4"><a href="#Mock-4" class="headerlink" title="Mock:"></a>Mock:</h5><p>优先<code>Hook ipc</code></p>
<h4 id="传感器相关（普通）："><a href="#传感器相关（普通）：" class="headerlink" title="传感器相关（普通）："></a>传感器相关（普通）：</h4><p>这个函数不需要太多处理，每个手机类型基本都差不多，每次打乱一下返回结果排序顺序即可。</p>
<h5 id="Get-5"><a href="#Get-5" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SensorManager-&gt;getFullSensorList</span><br></pre></td></tr></table></figure>

<h5 id="Mock-5"><a href="#Mock-5" class="headerlink" title="Mock:"></a>Mock:</h5><p>优先Hook ipc</p>
<h4 id="Java层DRM相关（重要字段）"><a href="#Java层DRM相关（重要字段）" class="headerlink" title="Java层DRM相关（重要字段）"></a>Java层DRM相关（重要字段）</h4><p>这个DRM是<strong>水印相关</strong>，主要为了处理不同手机加水印的唯一 ID 核心的是一个叫<code>deviceUniqueId</code> 的东西，这玩意是一个<strong>随机的32位字节数组</strong>。很多大厂用这个作为<strong>核心的设备指纹</strong>，不仅在Java层进行获取，还有在Native层进行获取，在后面Native设备指纹会再次介绍到。</p>
<h5 id="Get-6"><a href="#Get-6" class="headerlink" title="Get:"></a>Get:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Med</span><br><span class="line">iaDrm-&gt;getPropertyByteArray</span><br><span class="line">MediaDrm-&gt;getPropertyString</span><br></pre></td></tr></table></figure>

<p>Hook的话很简单，这个方法<strong>没有IPC底层有自己的实现</strong>，直接<code>Hook get</code>的方法即可 。java层Hook是远远不够的，还需要处理<code>native</code>层。</p>
<p><strong>每次随机32位字节数组即可。</strong></p>
<h4 id="Java层网卡信息（普通）"><a href="#Java层网卡信息（普通）" class="headerlink" title="Java层网卡信息（普通）"></a>Java层网卡信息（普通）</h4><p>大厂应该<strong>不会信任Java层的mac</strong>，底层都是通过<code>netlinker</code><strong>直接获取网卡</strong>，或者直接popen执行 <code>ip a</code> 进行网卡信息的全量获取（详细参考后面popen相关介绍）。我直接在底层处理的netlinker  socket通讯的时候，所以Java层不进行处理。<strong>任何获取网卡的方法，底层最终走的都是netlinker去获取的网卡</strong></p>
<blockquote>
<p>直接通过netlinker获取网卡，这种方式在安卓10上面貌似已经失效了，但是手机Root以后是没有限制的（亲测android 13 开发板获取成功），这种方式还可以用来检测当前手机是否Root。</p>
</blockquote>
<p>但是当执行ip a这种命令的时候，或者调用Java层原始API的时候，底层还是走的netlinker，直接在底层通过ptrace在函数调用执行完毕以后，对寄存器进行Mock 和 Set即可 。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-271698.htm">Android netlink&amp;svc 获取 Mac方法深入分析</a></p>
<h4 id="文件创建时间（次要）"><a href="#文件创建时间（次要）" class="headerlink" title="文件创建时间（次要）"></a>文件创建时间（次要）</h4><p>很多大厂会收集<code>/sdcard/</code> 或者相册目录的一些创建时间，作为设备指纹，但是很多文件都是默认的1970时间戳，有的少数文件夹创建时间也是很重要的设备标识 。<strong>Java里面File对象有文件的创建时间。</strong></p>
<h3 id="Native设备指纹"><a href="#Native设备指纹" class="headerlink" title="Native设备指纹"></a>Native设备指纹</h3><p>聊了挺多Java相关的设备指纹，其实Java层采集的指纹，并不是关键因素，核心的指纹基本都在native层进行处理的。Native部分会详细介绍包括内核文件，还有一些获取指纹的骚操作</p>
<h4 id="Build-system-property-get-system-property-read-重要"><a href="#Build-system-property-get-system-property-read-重要" class="headerlink" title="Build(system_property_get &amp; system_property_read)(重要)"></a>Build(system_property_get &amp; system_property_read)(重要)</h4><p>Java获取最终总的是native_get，而<code>native_get</code>底层走的就是这个<code>system_property_get</code> 。</p>
<p>在介绍之前我们需要先看看这个函数的源码，android 9以上和9以下实现的方式是不同的。</p>
<p><strong>android 9：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__BIONIC_WEAK_FOR_NATIVE_BRIDGEint __system_property_get(const char* name, char* value) &#123; </span><br><span class="line"> return system_properties.Get(name, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>android 9以下 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int __system_property_get(const char* name, char* value) &#123;</span><br><span class="line">  const prop_info* pi = __system_property_find(name);</span><br><span class="line"> </span><br><span class="line">  if (pi != 0) &#123;</span><br><span class="line">    return __system_property_read(pi, nullptr, value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    value[0] = 0;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安卓9以下是直接实现的这个方法，所以这块又有个细节，<strong>android 9 以上 hook __system_property_get 不仅仅需要Hook</strong></p>
<p>入口方法，还需要<code>Hook system_properties.Get</code> 这个方法。</p>
<blockquote>
<p>很多大厂在android 9以上会直接调用<code>system_properties.Get</code> ，先解析So获取到<code>system_properties.Get</code> 非导出函数的函数指针</p>
<p>强转成函数指针以后，直接去调用<code>system_properties</code>.Get ，而<strong>非直接调用system_property_get</strong> ，如果<strong>只Hook system_property_get的话可能就会导致指纹泄漏</strong>。所以在android 9以上需要额外处理 <code>system_properties.Get(name, value);</code> 这个方法。</p>
</blockquote>
<p>如果直接<code>Hook __system_property_get</code> 可能会存在短指令问题。因为这个方法就一个BL指令，普通的inlinehook 可能会失效。</p>
<p>这块需要用到异常Hook 。当然也可以直接判断安卓版本号在9.0以上直接<code>Hook system_properties.Get</code> 即可。这个<code>system_properties.Get</code> 是一个<strong>非导出函数</strong>，需要解析So获取到非导出函数的地址。可以参考<strong>sandhook的ELFUtils.cpp</strong> 。</p>
<p><strong>同理read方法也是如此，也需要这么处理 ，在9.0以上需要特殊处理</strong>。</p>
<p>Hook的时候需要注意一件事就是<strong>Mock的值长度不能大于原始长度</strong>。当 <code>system_property_get</code> 执行完毕以后<code>memcpy</code> 将Mock的value拷贝进去即可 。处理的过程函数如下 。实现也很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">new_system_property_get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = origin_system_property_get(name, value);</span><br><span class="line">    <span class="built_in">string</span> sname = <span class="built_in">string</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (gLobalfakeProperties.find(sname) == gLobalfakeProperties.end()) &#123;</span><br><span class="line">        <span class="comment">//ALOGE(&quot;hook native system_property_get_1 , not replace -&gt; %s value-&gt; %s &quot; ,name,value);</span></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// get org value</span></span><br><span class="line">    <span class="built_in">string</span> fake_value = gLobalfakeProperties[sname];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(value, (<span class="type">char</span> *) fake_value.c_str(), <span class="built_in">strlen</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么不直接在__system_property_find 函数处理？</strong></p>
<p>因为get和read底层走的都是find函数，为什么不直接在find函数处理呢，find函数返回的是<code>prop_info*</code></p>
<p>这个指针指向的是系统内存的变量，直接写入会直接sign11 如果使用mprotect如果直接对内存变量强制写入可能会导致系统的不稳定，导致出现问题。之前踩过这个坑。所以就只处理了get和read这两个函数 。</p>
<h5 id="Get-7"><a href="#Get-7" class="headerlink" title="Get:"></a>Get:</h5><p>使用的话很简单，直接导入头文件就好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/system_properties.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sdk[PROP_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">__system_property_get(<span class="string">&quot;ro.build.version.sdk&quot;</span>, sdk);</span><br></pre></td></tr></table></figure>

<h4 id="Native获取DRM-ID（重要）"><a href="#Native获取DRM-ID（重要）" class="headerlink" title="Native获取DRM ID（重要）"></a>Native获取DRM ID（重要）</h4><p>这个指纹也是很多大厂用作唯一ID的核心指纹。处理的话也需要注意，<strong>很核心的一个设备指纹ID。</strong></p>
<h5 id="Get-8"><a href="#Get-8" class="headerlink" title="Get:"></a>Get:</h5><p>使用的话很简单，直接导入头文件就好。代码不超过10行 。</p>
<p>导入的头文件实现这个So在mediandk.so里面 ，所以<code>cmake-&gt;target_link_libraries</code>引入的时候别忘记添加mediandk 引入依赖。</p>
<p><strong>这个值不同App 读取的内容都不一样，这块需要注意。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;media/NdkMediaDrm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> uuid[] = &#123;<span class="number">0xed</span>,<span class="number">0xef</span>,<span class="number">0x8b</span>,<span class="number">0xa9</span>,<span class="number">0x79</span>,<span class="number">0xd6</span>,<span class="number">0x4a</span>,<span class="number">0xce</span>,</span><br><span class="line">                            <span class="number">0xa3</span>,<span class="number">0xc8</span>,<span class="number">0x27</span>,<span class="number">0xdc</span>,<span class="number">0xd5</span>,<span class="number">0x1d</span>,<span class="number">0x21</span>,<span class="number">0xed</span></span><br><span class="line">&#125;;</span><br><span class="line">AMediaDrm *mediaDrm = <span class="built_in">AMediaDrm_createByUUID</span>(uuid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取 deviceUniqueId</span></span><br><span class="line">AMediaDrmByteArray aMediaDrmByteArray;</span><br><span class="line"><span class="built_in">AMediaDrm_getPropertyByteArray</span>(mediaDrm,PROPERTY_DEVICE_UNIQUE_ID, &amp;aMediaDrmByteArray);</span><br><span class="line">string resut = Base64Utils::<span class="built_in">Encode</span>((<span class="type">uint8_t</span> *)aMediaDrmByteArray.ptr,aMediaDrmByteArray.length);</span><br></pre></td></tr></table></figure>

<h5 id="Mock-6"><a href="#Mock-6" class="headerlink" title="Mock:"></a>Mock:</h5><p>Hook的话也很简单，直接Hook这个函数地址就行，但是这个方法也是一个短指令，需要用到异常Hook。</p>
<p>处理逻辑如下，因为我们只需要关注description 即可。其他内容不处理。这块有时候直接写入可能会导致问题，需要先mprotect，不能直接用mprotect需要计算一下扇叶大小，是否内存对齐。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MPROTECT</span><span class="params">(<span class="type">size_t</span> addr,<span class="type">size_t</span> size,<span class="type">int</span> __prot)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算页面对齐</span></span><br><span class="line">    <span class="keyword">auto</span> alignment = (<span class="type">unsigned</span>) ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) addr % <span class="built_in">sysconf</span>(_SC_PAGESIZE));</span><br><span class="line">    <span class="comment">// 保证开始地址减去扇叶大小</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">mprotect</span>((<span class="type">void</span> *) (addr - alignment), (<span class="type">size_t</span>) (alignment + size),__prot);</span><br><span class="line">    <span class="keyword">return</span> i == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HOOK_DEF_DRM</span>(<span class="type">media_status_t</span>, AMediaDrm_getPropertyByteArray,</span><br><span class="line">             AMediaDrm * drm, <span class="type">const</span> <span class="type">char</span> *propertyName, AMediaDrmByteArray *propertyValue)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 调用原函数获取真实值</span></span><br><span class="line">    <span class="type">media_status_t</span> array = <span class="built_in">orig_AMediaDrm_getPropertyByteArray</span>(drm, propertyName, propertyValue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 检查是否为目标属性</span></span><br><span class="line">    <span class="keyword">if</span>(propertyName != <span class="literal">nullptr</span> &amp;&amp; </span><br><span class="line">       <span class="built_in">strstr</span>(propertyName, PROPERTY_DEVICE_UNIQUE_ID) != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">       propertyValue != <span class="literal">nullptr</span> &amp;&amp; </span><br><span class="line">       propertyValue-&gt;ptr != <span class="literal">nullptr</span> &amp;&amp; </span><br><span class="line">       propertyValue-&gt;length != <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 检查Mock数据是否准备好</span></span><br><span class="line">        <span class="keyword">if</span>(gMockdrmid == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array; <span class="comment">// 返回原值</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 修改内存保护属性</span></span><br><span class="line">        <span class="built_in">MPROTECT</span>((<span class="type">size_t</span>)propertyValue-&gt;ptr, propertyValue-&gt;length, MEMORY_RWX);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 替换数据</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span>*)propertyValue-&gt;ptr, gMockdrmid, <span class="built_in">strlen</span>(gMockdrmid));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Netlinker获取网卡信息"><a href="#Netlinker获取网卡信息" class="headerlink" title="Netlinker获取网卡信息"></a>Netlinker获取网卡信息</h4><p>Linux底层不管什么样的获取网卡，最终底层直接会走<code>Netlinker</code>去获取网卡。在<strong>android 10以下</strong>可以绕过系统权限从而获取网卡信息，高版本已经失效了。</p>
<p>底层都是<code>svc</code>直接调用<code>recvfrom</code>或者<code>recvmsg</code>去接受<code>socket</code>的消息 。所以不处理<code>svc</code>的话，无法做到全量修改的。</p>
<p><strong>我用的是ptrace 在recvfrom 执行完毕以后，读取参数寄存器，将数据修改以后在重新覆盖寄存器即可。</strong>处理过程如下</p>
<blockquote>
<p>细节点：</p>
<p>socket主要接受消息的函数主要就三个，<code>recvfrom,recvmsg,recv</code>  ，netlinker通讯就是通过这三个函数处理的，recv底层调用的是recvfrom ，所以我们只需要处理<strong>recvfrom，和 recvmsg</strong> 即可。</p>
<p>recvfrom执行完毕以后参数是个数组，我们只需要把这个数组buff的值进行覆盖即可，但是recvmsg的话不能这么处理，他的参数是iovec指针，这个东西大家可以理解成一个箱子。里面装了具体的内容，长度和开始位置 。所以修改的时候需要读取这个开始位置的指针才可以进行set。</p>
</blockquote>
<p><strong>处理svc -&gt; recvmsg：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NetlinkMacHandler::netlinkHandler_recmsg</span><span class="params">(Tracer *tracee)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(peek_reg(tracee, CURRENT, SYSARG_RESULT));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// get org value </span></span><br><span class="line">        <span class="type">word_t</span> msg = peek_reg(tracee, CURRENT, SYSARG_2);</span><br><span class="line">        <span class="keyword">if</span>(msg == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *my_Msg = (msghdr *) alloca(<span class="keyword">sizeof</span>(msghdr));</span><br><span class="line">        <span class="type">int</span> msg_ret = read_data(tracee, (<span class="type">void</span> *) my_Msg, (<span class="type">word_t</span>) msg, <span class="keyword">sizeof</span>(msghdr));</span><br><span class="line">        <span class="keyword">if</span> (msg_ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//LOGE(&quot;ptrace SC_recvmsg msg_ret read sucess ! &quot;)</span></span><br><span class="line">            <span class="keyword">auto</span> *iov = (iovec *) alloca(<span class="keyword">sizeof</span>(iovec));</span><br><span class="line">            <span class="type">int</span> iov_ret = read_data(tracee, (<span class="type">void</span> *) iov, (<span class="type">word_t</span>) my_Msg-&gt;msg_iov, <span class="keyword">sizeof</span>(iovec));</span><br><span class="line">            <span class="keyword">if</span> (iov_ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//LOGE(&quot;ptrace SC_recvmsg iov read sucess ! buff size -&gt;%lu  &quot;,iov-&gt;iov_len)</span></span><br><span class="line">                <span class="comment">//保存一份临时的temp buff</span></span><br><span class="line">                <span class="keyword">auto</span> *temp_hdr = (nlmsghdr *) alloca(iov-&gt;iov_len);</span><br><span class="line">                <span class="comment">//temp_hdr使我们自己的创建的,但是在handler_mac_callback_svc 方法里面可能存在</span></span><br><span class="line"> </span><br><span class="line">                <span class="type">int</span> hdr_ret = read_data(tracee, (<span class="type">void</span> *) temp_hdr, (<span class="type">word_t</span>) iov-&gt;iov_base,</span><br><span class="line">                                        iov-&gt;iov_len);</span><br><span class="line">                <span class="keyword">if</span> (hdr_ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//LOGE(&quot;ptrace SC_recvmsg hdr read sucess ! &quot;)</span></span><br><span class="line">                    NetlinkMacHandler::handler_mac_callback_svc(tracee,temp_hdr, bytes_read);</span><br><span class="line">                    <span class="comment">//LOGE(&quot;handler_mac_callback_svc sucess ! &quot;)</span></span><br><span class="line">                    <span class="comment">//覆盖和重写</span></span><br><span class="line">                    write_data(tracee, (<span class="type">word_t</span>) iov-&gt;iov_base, temp_hdr, iov-&gt;iov_len);</span><br><span class="line">                    <span class="comment">//LOGE(&quot;ptrace SC_recvmsg write_data sucess ! &quot;)</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//LOGE(&quot;ptrace SC_recvmsg hdr read  fail ! &quot;)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//LOGE(&quot;ptrace SC_recvmsg iov read  fail ! &quot;)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//LOGE(&quot;ptrace SC_recvmsg msg_ret read fail ! &quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理svc-&gt;recvfrom:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void NetlinkMacHandler::netlinkHandler_recv(Tracer *tracee) &#123;</span><br><span class="line">    ssize_t bytes_read = TEMP_FAILURE_RETRY(peek_reg(tracee, CURRENT, SYSARG_RESULT));</span><br><span class="line">    if (bytes_read &gt; 0) &#123;</span><br><span class="line">        //get org value </span><br><span class="line">        word_t buff = peek_reg(tracee, CURRENT, SYSARG_2);</span><br><span class="line">        if(buff == 0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //buff长度</span><br><span class="line">        auto size = (size_t) peek_reg(tracee, CURRENT, SYSARG_3);</span><br><span class="line">        if(size == 0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        char tempBuff[size];</span><br><span class="line">        int readStr_ret = read_data(tracee, tempBuff, buff, size);</span><br><span class="line">        if (readStr_ret != 0) &#123;</span><br><span class="line">            LOGE(&quot;svc netlink handler read_string error  %s&quot;, strerror(errno))</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        auto *hdr = reinterpret_cast&lt;nlmsghdr *&gt;(tempBuff);</span><br><span class="line">        //netlink数据包结构体</span><br><span class="line">        NetlinkMacHandler::handler_mac_callback_svc(tracee,hdr, bytes_read);</span><br><span class="line">        //将数据写入覆盖掉原来的数据</span><br><span class="line">        write_data(tracee, buff, tempBuff, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-271698.htm">Android netlink&amp;svc 获取 Mac方法深入分析</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-273160.htm">SVC的TraceHook沙箱的实现&amp;无痕Hook实现思路</a></p>
<h4 id="内核文件相关（重要）"><a href="#内核文件相关（重要）" class="headerlink" title="内核文件相关（重要）"></a>内核文件相关（重要）</h4><p>内核文件指的是系统的相关文件，很多大厂会直接通过<code>popen cat</code>或者直接<code>fopen</code>只读的方式去读取文件内容。核心的也就那几个。</p>
<p><strong>一般读取的时候都是直接svc openat 底层需要用到svc的IO重定向，如果这块不处理的话，基本没办法进行mock和修改 。</strong></p>
<h4 id="build-prop相关"><a href="#build-prop相关" class="headerlink" title="build.prop相关"></a>build.prop相关</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;/system/build.prop&quot;</span><br><span class="line">&quot;/odm/etc/build.prop&quot;</span><br><span class="line">&quot;/product/build.prop&quot;</span><br><span class="line">&quot;/vendor/build.prop&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>主要就是这四个文件，在低版本这个文件可以直接去读，所以这个文件也需要在Mock value以后生成一份新的，作为备份。</p>
<p>生成新的值要和之前Mock的值是一样的，防止出现不相同的情况 。当对方如果使用了SVC读取这个文件的时候，通过SVC的IO重定向绕过读取。</p>
<h4 id="proc-sys-kernel-random-boot-id"><a href="#proc-sys-kernel-random-boot-id" class="headerlink" title="&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id"></a>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id</h4><p>这个ID重启或者刷机以后发生变化，很多大厂会读取这个值，这个值类似一个UUID，SVC读取这个值，然后将这个值保存到私有目录。</p>
<p>跟DRM ID 相比，好处就是不同App读取的值是一样的。一个设备指纹占比很重的值。</p>
<h4 id="proc-sys-kernel-random-uuid"><a href="#proc-sys-kernel-random-uuid" class="headerlink" title="&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;uuid"></a>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;uuid</h4><p>同上</p>
<h4 id="sys-block-mmcblk0-device-cid"><a href="#sys-block-mmcblk0-device-cid" class="headerlink" title="&#x2F;sys&#x2F;block&#x2F;mmcblk0&#x2F;device&#x2F;cid"></a>&#x2F;sys&#x2F;block&#x2F;mmcblk0&#x2F;device&#x2F;cid</h4><p>同上</p>
<h4 id="sys-devices-soc0-serial-number"><a href="#sys-devices-soc0-serial-number" class="headerlink" title="&#x2F;sys&#x2F;devices&#x2F;soc0&#x2F;serial_number"></a>&#x2F;sys&#x2F;devices&#x2F;soc0&#x2F;serial_number</h4><p>同上</p>
<h4 id="proc-misc"><a href="#proc-misc" class="headerlink" title="&#x2F;proc&#x2F;misc"></a>&#x2F;proc&#x2F;misc</h4><p>同上</p>
<h4 id="proc-version"><a href="#proc-version" class="headerlink" title="&#x2F;proc&#x2F;version"></a>&#x2F;proc&#x2F;version</h4><p>这个是一个linux系统内核文件，里面记录了当前Linux系统版本的相关信息。里面的值类似如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. Linux version 3.18.31-perf-g9b0888a(builder@c3-miui-ota-bd96.bj)</span><br></pre></td></tr></table></figure>

<p>这个文件在android 11以上基本读不到了 ，但是在android 9是可以读到的 。但是android 11有没有什么代替方案呢？答案是有的，svc 调用uname 。 使用方式类似如下，uname也是一个命令行，还可以通过popen <code>uname -a</code>的方式去获取 （popen部分会介绍到）。这个函数在IOS上面也比较实用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> <span class="title">buff</span>;</span></span><br><span class="line">   <span class="type">int</span> i = uname(&amp;buff);</span><br><span class="line">   LOGE(<span class="string">&quot;uname sysname %s &quot;</span>, buff.sysname)</span><br><span class="line">   LOGE(<span class="string">&quot;uname nodename %s &quot;</span>, buff.nodename)</span><br><span class="line">   LOGE(<span class="string">&quot;uname release %s &quot;</span>, buff.release)</span><br><span class="line">   LOGE(<span class="string">&quot;uname version %s &quot;</span>, buff.version)</span><br><span class="line">   LOGE(<span class="string">&quot;uname machine %s &quot;</span>, buff.machine)</span><br><span class="line">   LOGE(<span class="string">&quot;uname domainname %s &quot;</span>, buff.domainname)</span><br></pre></td></tr></table></figure>

<p>通过这几项就可以拿到&#x2F;proc&#x2F;version 里面的所有信息，</p>
<p><strong>很多大厂会用&#x2F; popen uname -a &#x2F; svc uname函数 &#x2F; 和svc openat去读&#x2F;proc&#x2F;version以此判断获取的值是否准确，如果有一个对不上都会认为当前设备被修改。</strong></p>
<p>修改方式如下 ，一般只需要处理release和Version即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handlerLinuxEnvInfo</span><span class="params">(Tracer* tracee)</span>&#123;</span><br><span class="line">    <span class="type">word_t</span> reg = peek_reg(tracee, ORIGINAL, SYSARG_1);</span><br><span class="line">    <span class="keyword">if</span>(reg == <span class="number">0</span>)&#123;</span><br><span class="line">        LOGI(<span class="string">&quot;svc after org peek_reg reg 1 == 0 &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> *buff = (<span class="keyword">struct</span> utsname *) alloca(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> utsname));</span><br><span class="line">    <span class="type">int</span> msg_ret = read_data(tracee,  buff, reg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> utsname));</span><br><span class="line">    <span class="keyword">if</span> (msg_ret == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> mockLinuxRelease ;</span><br><span class="line">        getZhenxiRuntimeMMKV()-&gt;getString(LINUX_VERSION_RELEASE,mockLinuxRelease);</span><br><span class="line">        <span class="built_in">memcpy</span>(buff-&gt;release,mockLinuxRelease.c_str() ,SYS_NMLN);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> mockLinuxVersion ;</span><br><span class="line">        getZhenxiRuntimeMMKV()-&gt;getString(LINUX_VERSION_VERSION,mockLinuxVersion);</span><br><span class="line">        <span class="built_in">memcpy</span>(buff-&gt;version,mockLinuxVersion.c_str() ,SYS_NMLN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入内存</span></span><br><span class="line">        <span class="type">int</span> ret = write_data(tracee, reg, buff, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> utsname));</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">            LOGE(<span class="string">&quot;linux info write data error %s &quot;</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        LOGE(<span class="string">&quot;read_data read data error %s &quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="popen相关"><a href="#popen相关" class="headerlink" title="popen相关"></a>popen相关</h3><p><strong>注意1：</strong></p>
<p>因为popen底层走的是execve的这个命令行，是一个shell命令的入口，在64位So里面只要对svc的openat进行IO重定向，哪怕他执行的是execve 也可以进行IO重定向。<strong>因为64位execve 底层读取文件，走的也是openat</strong></p>
<p>举个例子:</p>
<p>当我执行<code>popen cat /sys/devices/soc0/serial_number</code>，如果<code>/sys/devices/soc0/serial_number</code>这个文件被svc openat重定向到<code>/sdcard/a</code>文件。最终<code>cat /sys/devices/soc0/serial_number</code>读取到的也是<code>/sdcard/a</code> ，而不是原始的&#x2F;sys&#x2F;devices&#x2F;soc0&#x2F;serial_number 。</p>
<p><strong>注意2：</strong></p>
<p>popen这个函数它本身会开启一条线程去执行shell ，因为execve本身就是开一条线程去执行。返回的是一个File 句柄，如果我直接Hook popen 修改他的返回结果，<strong>把返回结果替换成我自己的句柄</strong>，这样是不被允许的，因为Linux 特性 默认情况<strong>A线程的文件创建的文件 B线程无法读取</strong>，跨线程找不到文件句柄fd（解决也很简单，<strong>可以将文件设置成组内可读即可</strong>）</p>
<p><strong>那么有没有一种方案可以不修改文件权限实现修改返回内容的Mock呢？</strong></p>
<p>其实很简单，只需要把参数修改成 <code>cat 被修改的返回结果路径即可</code> ，这样他读取到的内容也是你修改过以后的。</p>
<blockquote>
<p>或者直接吧参数1 设置成“ ” ，这样他读取到的内容一定是null。</p>
</blockquote>
<h4 id="uname-a"><a href="#uname-a" class="headerlink" title="uname -a"></a>uname -a</h4><p>这个命令行在之前介绍过了，主要为了解决&#x2F;proc&#x2F;version 读取不到的问题。可以直接通过下面的方式去去获取Linux的一些版本信息。</p>
<p><strong>Mock:</strong></p>
<p>这个uname底层走的还是<code>svc uname</code>函数，所以修改的时候只需要在<strong>svc层面直接修改uname函数返回结果</strong>即可。</p>
<p>参考<code>native /proc/version</code> 修改。</p>
<h4 id="getprop"><a href="#getprop" class="headerlink" title="getprop"></a>getprop</h4><p>这个执行的内容返回的值和，adb shell 以后执行getprop 结果是一样的。输出的是当前手机全部的<code>Build</code>相关配置。</p>
<h5 id="Mock-7"><a href="#Mock-7" class="headerlink" title="Mock:"></a>Mock:</h5><p>Hook的话也很简单，直接Hook popen 提前生产一份已经Mock好的 ,生产的这个要和Java层Build mock的值是一样的 ，然后直接换成<code>cat 成你自己的文件即可</code> 。这块需要注意，就是 getprop 有三种模式。代码如下</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getprop ro.odm.build.id</span><br><span class="line">getprop | grep dalvik</span><br><span class="line">getprop</span><br></pre></td></tr></table></figure>
</blockquote>
<p>需要对这种过滤模式进行处理。</p>
<h4 id="内核相关文件的cat"><a href="#内核相关文件的cat" class="headerlink" title="内核相关文件的cat"></a>内核相关文件的cat</h4><p>之前在native层说的内核文件都可以通过popen去cat 。代码如下，修改的话直接<code>svc openat</code> io重定向就好</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = popen(&quot;cat /sys/devices/soc0/serial_number&quot;, &quot;r&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="ps-ef-ps"><a href="#ps-ef-ps" class="headerlink" title="ps -ef &amp; ps"></a>ps -ef &amp; ps</h4><p>这个文件是扫描当前进程的 ，可以用来做反调试检测，比如刚启动的时候去获取一下当前进程列表。</p>
<p><strong>就可以知道是否存在frida ，或者当前进程是否被ptrace  ，因为用ptrace调试的话是需要多开启一条调试线程的。</strong></p>
<h4 id="ip-a（重要）"><a href="#ip-a（重要）" class="headerlink" title="ip a（重要）"></a>ip a（重要）</h4><p>其实就是<code>ip addr</code></p>
<p>这个也是很核心的设备指纹，里面会获取当前手机的网卡信息，<code>whan0 wlan1 p2p0</code> 这些信息。这个底层走的也是<code>netlinker</code></p>
<p>所以在<code>netlinker</code>层直接修改拦截，他哪怕执行的命令行也是生效的 。返回的东西很多，可以自己尝试打印一下。很多大厂也会用这种方式去扫描你的网卡Mac地址 。</p>
<h4 id="ls-al-sdcard-Android-data"><a href="#ls-al-sdcard-Android-data" class="headerlink" title="ls -al &#x2F;sdcard&#x2F;Android&#x2F;data"></a>ls -al &#x2F;sdcard&#x2F;Android&#x2F;data</h4><p>扫描私有目录，返回私有目录的一些信息 。可以判断当前App是否存在其他App目录下，<strong>主要用于检测沙箱</strong>。</p>
<p>其实检测沙箱还有一个很好的办法，就是检测手机的进程信息 。如果当前App在自己正常情况启动，只会有一条线程。</p>
<p>但是如果放在VA沙盒内部的话，VA沙盒本身会启动一条线程，自己的App本身也会启动一条线程。所以线程数量就对不上。也可以认为作弊。代码参考如下，<strong>绕过的话也很简单 Hook readdir 当发现读取的是调试线程直接return null即可 。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test::checkSandbox</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *pdr = opendir(<span class="string">&quot;/proc&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pdr == nullptr) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dirent *read_ptr;</span><br><span class="line">    <span class="comment">//在app启动之前检测当前app所有的进程,判断是否存在和main不一样的进程</span></span><br><span class="line">    <span class="keyword">while</span> ((read_ptr = readdir(pdr)) != nullptr) &#123;</span><br><span class="line">        <span class="type">int</span> procpid = atoi(read_ptr-&gt;d_name);</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">&quot;find /proc/ child dir  &quot;</span> &lt;&lt; procpid;</span><br><span class="line">        <span class="comment">//打开成功&amp;&amp;发现一条不等于主进程id的pid</span></span><br><span class="line">        <span class="keyword">if</span> (procpid &amp;&amp; procpid != getpid()) &#123;</span><br><span class="line">            <span class="comment">//这个文件所属主线程</span></span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;  FIND OTHER THREAD SANDBOX &quot;</span> &lt;&lt; procpid;</span><br><span class="line">            closedir(pdr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(pdr);</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">&quot;&gt;&gt;&gt;&gt;&gt; NOT FIND SANDBOX &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="popen扫描Magisk"><a href="#popen扫描Magisk" class="headerlink" title="popen扫描Magisk"></a>popen扫描Magisk</h4><p>这些命令都可以进行magisk的列表的扫描，判断当前线程是否存在magisk等关键字，都是很好的办法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popen(<span class="string">&quot;df | grep /sbin/.magisk&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">popen(<span class="string">&quot;mount  | grep /sbin/.magisk&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">popen(<span class="string">&quot;ps | grep magisk&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>修改的话也很简单，如果是ps 或者 df 直接生成一份不存在magisk关键字的文件，（还有一些痕迹关键字，比如xposed,edxp,riru这些都是常用的检测关键字）</p>
<p>mout直接 svc IO重定向绕过即可 </p>
<h4 id="popen-logcat"><a href="#popen-logcat" class="headerlink" title="popen logcat"></a>popen logcat</h4><p>有很多大厂，他当发现你设备信息异常的时候，会直接执行<code>popen logcat</code>直接扫描你当前手机的日志系统 </p>
<p>把<strong>异常的log都进行上报</strong>，用于石锤当前用户是否作弊 。所以这个也需要处理 。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pfile = popen(<span class="string">&quot;/system/bin/logcat -b main -d -v threadtime -t 200 --pid 当前线程pid&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), pfile)) &#123;</span><br><span class="line">    LOGE(<span class="string">&quot;logcat  -&gt; %s&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="APK签名："><a href="#APK签名：" class="headerlink" title="APK签名："></a>APK签名：</h2><p>目前主要的获取签名就两种办法</p>
<h3 id="Java-层直接-通过binder和-AMS-通讯获取真实签名信息。"><a href="#Java-层直接-通过binder和-AMS-通讯获取真实签名信息。" class="headerlink" title="Java 层直接 通过binder和 AMS 通讯获取真实签名信息。"></a>Java 层直接 通过binder和 AMS 通讯获取真实签名信息。</h3><p>直接和AMS通讯，获取最真实的签名信息</p>
<p>这么一来你不管你Hook pms里面的哪些方法也没啥用</p>
<h4 id="绕过原理"><a href="#绕过原理" class="headerlink" title="绕过原理"></a>绕过原理</h4><p>因为和AMS通讯需要用到Binder，Binder可以理解成“水管” ，他虽然和AMS直接进行通讯，但是还是要经过我们的水管，我们直接对这个水管处理即可 。</p>
<p>在通讯时候对水管进行拦截。在<code>BinderProxy-&gt;transact</code> 的方法里面进行拦截和替换签名信息即可</p>
<p>我们会使用到<code>PMS</code>，来获取apk的签名值 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c559852c4878">参考</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSignature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PackageInfo</span> <span class="variable">packageInfo</span> <span class="operator">=</span> getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">            Log.i(SHARK, <span class="string">&quot;len:&quot;</span>+packageInfo.signatures.length);</span><br><span class="line">            <span class="keyword">if</span> (packageInfo.signatures != <span class="literal">null</span>) &#123;</span><br><span class="line">                Log.i(SHARK, <span class="string">&quot;sig:&quot;</span>+packageInfo.signatures[<span class="number">0</span>].toCharsString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们要使用动态代理的方式替换掉这里的两个属性</strong></p>
<ul>
<li><strong>ActivityThread的静态变量sPackageManager</strong></li>
<li><strong>ApplicationPackageManager对象里面的mPM变量</strong></li>
</ul>
<h4 id="Hook-demp"><a href="#Hook-demp" class="headerlink" title="Hook demp"></a>Hook demp</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//ServiceManagerWraper.java</span><br><span class="line">package com.shark.hookpms;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.pm.PackageManager;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">public class ServiceManagerWraper &#123;</span><br><span class="line"></span><br><span class="line">    public final static String SHARK = &quot;Shark&quot;;</span><br><span class="line"></span><br><span class="line">    public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取全局的ActivityThread对象</span><br><span class="line">            Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">            Method currentActivityThreadMethod =</span><br><span class="line">                    activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);</span><br><span class="line">            Object currentActivityThread = currentActivityThreadMethod.invoke(null);</span><br><span class="line">            // 获取ActivityThread里面原始的sPackageManager</span><br><span class="line">            Field sPackageManagerField = activityThreadClass.getDeclaredField(&quot;sPackageManager&quot;);</span><br><span class="line">            sPackageManagerField.setAccessible(true);</span><br><span class="line">            Object sPackageManager = sPackageManagerField.get(currentActivityThread);</span><br><span class="line">            // 准备好代理对象, 用来替换原始的对象</span><br><span class="line">            Class&lt;?&gt; iPackageManagerInterface = Class.forName(&quot;android.content.pm.IPackageManager&quot;);</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(</span><br><span class="line">                    iPackageManagerInterface.getClassLoader(),</span><br><span class="line">                    new Class&lt;?&gt;[]&#123;iPackageManagerInterface&#125;,</span><br><span class="line">                    new PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, 0));</span><br><span class="line">            // 1. 替换掉ActivityThread里面的 sPackageManager 字段</span><br><span class="line">            sPackageManagerField.set(currentActivityThread, proxy);</span><br><span class="line">            // 2. 替换 ApplicationPackageManager里面的 mPM对象</span><br><span class="line">            PackageManager pm = context.getPackageManager();</span><br><span class="line">            Field mPmField = pm.getClass().getDeclaredField(&quot;mPM&quot;);</span><br><span class="line">            mPmField.setAccessible(true);</span><br><span class="line">            mPmField.set(pm, proxy);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.d(SHARK, &quot;hook pms error:&quot; + Log.getStackTraceString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void hookPMS(Context context) &#123;</span><br><span class="line">        String qqSign = &quot;30820253308201bca00302010202044bbb0361300d06092a864886f70d0101050500306d310e300c060355040613054368696e61310f300d06035504080c06e58c97e4baac310f300d06035504070c06e58c97e4baac310f300d060355040a0c06e885bee8aeaf311b3019060355040b0c12e697a0e7babfe4b89ae58aa1e7b3bbe7bb9f310b30090603550403130251513020170d3130303430363039343831375a180f32323834303132303039343831375a306d310e300c060355040613054368696e61310f300d06035504080c06e58c97e4baac310f300d06035504070c06e58c97e4baac310f300d060355040a0c06e885bee8aeaf311b3019060355040b0c12e697a0e7babfe4b89ae58aa1e7b3bbe7bb9f310b300906035504031302515130819f300d06092a864886f70d010101050003818d0030818902818100a15e9756216f694c5915e0b529095254367c4e64faeff07ae13488d946615a58ddc31a415f717d019edc6d30b9603d3e2a7b3de0ab7e0cf52dfee39373bc472fa997027d798d59f81d525a69ecf156e885fd1e2790924386b2230cc90e3b7adc95603ddcf4c40bdc72f22db0f216a99c371d3bf89cba6578c60699e8a0d536950203010001300d06092a864886f70d01010505000381810094a9b80e80691645dd42d6611775a855f71bcd4d77cb60a8e29404035a5e00b21bcc5d4a562482126bd91b6b0e50709377ceb9ef8c2efd12cc8b16afd9a159f350bb270b14204ff065d843832720702e28b41491fbc3a205f5f2f42526d67f17614d8a974de6487b2c866efede3b4e49a0f916baa3c1336fd2ee1b1629652049&quot;;</span><br><span class="line">        hookPMS(context, qqSign, &quot;com.shark.hookpms&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//PmsHookBinderInvocationHandler.java</span><br><span class="line">package com.shark.hookpms;</span><br><span class="line"></span><br><span class="line">import android.content.pm.PackageInfo;</span><br><span class="line">import android.content.pm.PackageManager;</span><br><span class="line">import android.content.pm.Signature;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class PmsHookBinderInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object base;</span><br><span class="line"></span><br><span class="line">    public final static String SHARK = &quot;Shark&quot;;</span><br><span class="line"></span><br><span class="line">    //应用正确的签名信息</span><br><span class="line">    private String SIGN;</span><br><span class="line">    private String appPkgName = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public PmsHookBinderInvocationHandler(Object base, String sign, String appPkgName, int hashCode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.base = base;</span><br><span class="line">            this.SIGN = sign;</span><br><span class="line">            this.appPkgName = appPkgName;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Log.d(SHARK, &quot;error:&quot;+Log.getStackTraceString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Log.i(SHARK, method.getName());</span><br><span class="line">        //查看是否是getPackageInfo方法</span><br><span class="line">        if(&quot;getPackageInfo&quot;.equals(method.getName()))&#123;</span><br><span class="line">            String pkgName = (String)args[0];</span><br><span class="line">            Integer flag = (Integer)args[1];</span><br><span class="line">            //是否是获取我们需要hook apk的签名</span><br><span class="line">            if(flag == PackageManager.GET_SIGNATURES &amp;&amp; appPkgName.equals(pkgName))&#123;</span><br><span class="line">                //将构造方法中传进来的新的签名覆盖掉原来的签名</span><br><span class="line">                Signature sign = new Signature(SIGN);</span><br><span class="line">                PackageInfo info = (PackageInfo) method.invoke(base, args);</span><br><span class="line">                info.signatures[0] = sign;</span><br><span class="line">                return info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(base, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>来自于<a target="_blank" rel="noopener" href="https://blog.csdn.net/cshao888/article/details/72859470%EF%BC%9A">https://blog.csdn.net/cshao888/article/details/72859470：</a></p>
<p>Android应用ui是绘制在主线程中的，这个线程就是<code>ActivityThread</code>。</p>
<p>但实际上看源码发现<code>ActivityThread</code>并没有继承自Thread,<strong>而是一个独立的类</strong>，只是在其main方法中开了一个<strong>Looper</strong>循环消息，<strong>不断接收处理发到主线程里面的消息</strong>，比如performLaunchActivity</p>
<p>而<code>ApplicationThread</code>也不是一个Thread,<strong>是一个<code>Binder</code></strong>,主要<strong>用于应用进程和ActivityManagerService进程间通信</strong>的。</p>
<p>整个ActivityThread框架是<strong>基于Binder通信的C&#x2F;S结构</strong>，从图可知<code>Server</code>端是<code>ActivityThread、ApplicationThread</code></p>
<p><code>Client</code>是<code>AMS</code>（ActivityManagerService），而<code>ApplicationThreadProxy</code>可以看作AMS中Server代表。</p>
</blockquote>
<h3 id="Native层-svc读取-data-app-包名-base-apk-解析zip-解析里面的签名文件信息。"><a href="#Native层-svc读取-data-app-包名-base-apk-解析zip-解析里面的签名文件信息。" class="headerlink" title="Native层 svc读取&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 解析zip 解析里面的签名文件信息。"></a>Native层 svc读取&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 解析zip 解析里面的签名文件信息。</h3><p>Java层是通过AMS通讯获取签名信息，我们直接用svc openat读取apk文件 ， 进行手动解析apk 的签名 。不信任系统Api的解析结果。这个也是常用的检测签名办法。这样拿到的结果就是可信的结果。</p>
<h4 id="绕过原理："><a href="#绕过原理：" class="headerlink" title="绕过原理："></a>绕过原理：</h4><p>svc openat的<code>IO重定向</code>，当他读取原始&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 的时候我们将它修改成原始apk的路径。</p>
<p>这么一来他读取到的是原始apk路径，而不是被修改的路径，得到的签名也就是原始的签名。底层在处理一下svc  readlink readlintat 防止检测路径被替换。</p>
<p><strong>用这两种方案可以目前干掉市面上99%签名检测 。</strong></p>
<h2 id="设备指纹2"><a href="#设备指纹2" class="headerlink" title="设备指纹2"></a>设备指纹2</h2><h3 id="Android-Id"><a href="#Android-Id" class="headerlink" title="Android Id"></a>Android Id</h3><p>获取方式</p>
<h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//原始获取android id</span><br><span class="line">String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);</span><br><span class="line">CLog.i(String.format(&quot;android_id -&gt; 2222 %s&quot;, androidId));</span><br></pre></td></tr></table></figure>

<h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>第一种获取以后，系统会把<code>Android id</code> 保存起来，保存到一个<code>HashMap</code>里面，防止多次<code>IPC</code>初始化 ，所以为了验证第一种方法的准确性，可以二次获取<code>cache</code></p>
<p>9.0以上需要绕过<code>Android id</code> 的反射限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射查询android id cache</span></span><br><span class="line"><span class="type">ArrayMap</span> <span class="variable">mValues</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">sNameValueCache</span> <span class="operator">=</span> Settings.Secure.class.getDeclaredField(<span class="string">&quot;sNameValueCache&quot;</span>);</span><br><span class="line">    sNameValueCache.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">sLockSettings</span> <span class="operator">=</span> sNameValueCache.get(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">fieldmValues</span> <span class="operator">=</span> sLockSettings.getClass().getDeclaredField(<span class="string">&quot;mValues&quot;</span>);</span><br><span class="line">    								  <span class="comment">//sLockSettings不仅是静态字段，还是一个静态对象字段</span></span><br><span class="line">    fieldmValues.setAccessible(<span class="literal">true</span>); <span class="comment">//private</span></span><br><span class="line">    mValues = (ArrayMap&lt;String,String&gt;) fieldmValues.get(sLockSettings); </span><br><span class="line">    								  <span class="comment">//调用的是 java.lang.reflect.Field 类 的 get() 方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">android_id</span> <span class="operator">=</span> (String)mValues.get(<span class="string">&quot;android_id&quot;</span>);</span><br><span class="line">                                      <span class="comment">//调用的是 ArrayMap 的get方法</span></span><br><span class="line">    CLog.i(String.format(<span class="string">&quot;android_id -&gt; 3333 %s&quot;</span>, android_id));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用 <code>get(null)</code> 的原因是 <code>sNameValueCache</code> 这个字段 (field) 是一个 <strong>静态字段 (static field)</strong></p>
</blockquote>
<blockquote>
<ol>
<li><p><strong><code>fieldmValues</code> 是什么？</strong></p>
<ul>
<li><p>它的类型是 <code>java.lang.reflect.Field</code>。</p>
</li>
<li><p>你是通过 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">fieldmValues</span> <span class="operator">=</span> sLockSettings.getClass().getDeclaredField(<span class="string">&quot;mValues&quot;</span>);</span><br></pre></td></tr></table></figure>

<p> 得到的。</p>
</li>
<li><p>它本身<strong>不是字段的值</strong>，而是字段的一个<strong>描述或者说“句柄”</strong>。它代表了 <code>sLockSettings</code> 这个对象所属的类里面的那个叫做 <code>mValues</code> 的字段。</p>
</li>
</ul>
</li>
<li><p><strong><code>.get(sLockSettings)</code> 是在做什么？</strong></p>
<ul>
<li>这是在调用 <code>Field</code> 对象的 <code>get()</code> 方法。</li>
<li>这个方法的含义是：“<strong>请通过我（<code>fieldmValues</code> 这个字段描述）去把 <code>sLockSettings</code> 这个具体对象实例里面的字段值给取出来。</strong>”</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h4><p>方法3也是很基础的Api ，主要通过<code>ContentResolver</code> 进行间接获取 。很多大厂也都在使用 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">callResult</span> <span class="operator">=</span> context.getContentResolver().call(</span><br><span class="line">            Uri.parse(<span class="string">&quot;content://settings/secure&quot;</span>), <span class="string">&quot;GET_secure&quot;</span>, <span class="string">&quot;android_id&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bundle</span>()</span><br><span class="line">    );</span><br><span class="line">    <span class="type">String</span> <span class="variable">androidIdValue</span> <span class="operator">=</span> callResult.getString(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    CLog.i(String.format(<span class="string">&quot;android_id -&gt; 1111 %s&quot;</span>, androidIdValue));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    CLog.e(e.toString(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>Bundle</code> 是什么？</strong></p>
<p> <code>Bundle</code> 是 Android 中用于在不同组件（如 <code>Activities, Services, Content Providers</code>）之间传递数据的关键类。你可以把它想象成一个 <code>Map&lt;String, Object&gt;</code>，它通过键值对（<code>Key-Value</code>）的形式存储数据。它可以存储各种基本数据类型（<code>String</code>, <code>int</code>, <code>boolean</code>等）以及可序列化的对象。</p>
<p><code>Bundle</code> 之所以能被<strong>跨进程传递</strong>，是因为它实现了 <code>Parcelable</code> 接口。这个接口定义了如何将一个对象“拍扁”（<strong>序列化</strong>&#x2F;编组）成一串可被传输的数据，以及如何从这串数据中恢复（<strong>反序列化</strong>&#x2F;解组）成原始对象。</p>
<p><strong><code>Bundle</code> 是数据的容器</strong></p>
<p><strong><code>Binder</code> 是通信的通道</strong></p>
</blockquote>
<h4 id="方法4："><a href="#方法4：" class="headerlink" title="方法4："></a>方法4：</h4><p>通过query命令去查询，获取Android id ，这种方式底层走的也是<code>ContentResolver</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//通过content命令查询android id</span><br><span class="line">String android_id = NativeEngine.popen(</span><br><span class="line">        &quot;content query --uri content://settings/secure --where \&quot;name=\\&#x27;android_id\\&#x27;\&quot;&quot;,</span><br><span class="line">        &quot;&quot;);</span><br><span class="line">CLog.i(String.format(&quot;android_id -&gt; 4444 %s&quot;, android_id));</span><br></pre></td></tr></table></figure>

<h3 id="硬盘字节总大小"><a href="#硬盘字节总大小" class="headerlink" title="硬盘字节总大小"></a>硬盘字节总大小</h3><p>在设备指纹里面，如果想恢复出厂设置也能保证原有的设备信息 ，这个字段可以在服务端的相似度算法里面占比很重 ，可以以型号进行分类。我之前测试过，回复出厂设置指纹也不发生变化的设备指纹核心的设备指纹就几个</p>
<p>比如<code>硬盘大小</code>，<code>ipv6</code> ，还有一个就是<code>MAC地址</code>，这几个设备指纹也是很核心的设备指纹</p>
<p>先介绍硬盘字节大小。 也是三种获取方法，但是<strong>方法底层都是一条系统调用</strong>。所以如果要进行对抗的话，只需要在<strong>SVC层</strong>进行处理即可 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">jclass pJclass = env-&gt;FindClass(&quot;android/os/StatFs&quot;);</span><br><span class="line">jmethodID id = env-&gt;GetMethodID(pJclass, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;);</span><br><span class="line">jobject pJobject =</span><br><span class="line">        env-&gt;NewObject(pJclass, id, env-&gt;NewStringUTF(&quot;/storage/emulated/0&quot;));</span><br><span class="line"> </span><br><span class="line">jlong i = env-&gt;CallLongMethod(pJobject, env-&gt;GetMethodID(pJclass, &quot;getTotalBytes&quot;, &quot;()J&quot;));</span><br><span class="line">LOG(ERROR) &lt;&lt; &quot;Java获取getTotalBytes &quot;&lt;&lt;i;</span><br><span class="line"></span><br><span class="line">char buffer[1024];</span><br><span class="line">FILE *fp = popen(&quot;stat -f /storage/emulated/0&quot;, &quot;r&quot;);</span><br><span class="line">if (fp != nullptr) &#123;</span><br><span class="line">    while (fgets(buffer, sizeof(buffer), fp) != nullptr) &#123;</span><br><span class="line">        //LOGI(&quot;ps -ef %s&quot;,buffer)</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;stat -f /storage/emulated/0&quot; &lt;&lt; buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    pclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct statfs64 buf=&#123;&#125;;</span><br><span class="line">if (statfs64(&quot;/storage/emulated/0&quot;, &amp;buf) == -1) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;statfs64系统信息失败&quot;;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_type (文件系统类型): &quot; &lt;&lt; buf.f_type;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_bsize (块大小): &quot; &lt;&lt; buf.f_bsize;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_blocks (总数据块): &quot; &lt;&lt; buf.f_blocks;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_bfree (空闲块): &quot; &lt;&lt; buf.f_bfree;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_bavail (非特权用户可用的空闲块): &quot; &lt;&lt; buf.f_bavail;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_files (总文件节点数): &quot; &lt;&lt; buf.f_files;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_ffree (空闲文件节点数): &quot; &lt;&lt; buf.f_ffree;</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_fsid (文件系统 ID): &quot; &lt;&lt; buf.f_fsid.__val[0] &lt;&lt; &quot;, &quot; &lt;&lt; buf.f_fsid.__val[1];</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;f_namelen (最大文件名长度): &quot; &lt;&lt; buf.f_namelen;</span><br></pre></td></tr></table></figure>

<p>这三种方法底层走的都是<code>statfs64</code>（<code>arm</code>） 或者<code>statfs</code>（<code>arm64</code>）函数，对抗的话也很简单，直接在<code>statfs64</code> 或者<code>statfs</code> 的<code>after</code>里面对<strong>参数2</strong>进行替换和复写即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//int statfs(const char *path, struct statfs *buf);</span></span><br><span class="line">        <span class="comment">//int statfs64(const char *path, struct statfs64 *buf);</span></span><br><span class="line">        <span class="keyword">case</span> SC_statfs:</span><br><span class="line">        <span class="keyword">case</span> SC_statfs64: &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMockFingerptint()) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">int</span>) syscall_result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//              f_type：文件系统类型。</span></span><br><span class="line"><span class="comment">//              f_bsize：文件系统块的大小。</span></span><br><span class="line"><span class="comment">//              f_blocks：文件系统中的总块数。</span></span><br><span class="line"><span class="comment">//              f_bfree：文件系统中的可用块数。</span></span><br><span class="line"><span class="comment">//              f_bavail：非超级用户可获取的块数。</span></span><br><span class="line"><span class="comment">//              f_files：文件系统中的总文件节点数。</span></span><br><span class="line"><span class="comment">//              f_ffree：文件系统中的可用文件节点数。</span></span><br><span class="line"><span class="comment">//              f_fsid：文件系统标识。</span></span><br><span class="line"><span class="comment">//              f_namelen：文件名的最大长度。</span></span><br><span class="line">                <span class="type">char</span> pathBuff[PATH_MAX];</span><br><span class="line">                <span class="type">word_t</span> pPath = peek_reg(tracee, ORIGINAL, SYSARG_1);</span><br><span class="line">                <span class="type">int</span> ret = read_string(tracee, pathBuff, pPath, PATH_MAX);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(get_sysnum(tracee, ORIGINAL) == SC_statfs64)&#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">statfs64</span> <span class="title">fs</span> =</span> &#123;&#125;;</span><br><span class="line">                    <span class="type">word_t</span> arg2 = peek_reg(tracee, ORIGINAL, SYSARG_2);</span><br><span class="line">                    read_data(tracee,&amp;fs,arg2,<span class="keyword">sizeof</span> (<span class="keyword">struct</span> statfs64));</span><br><span class="line">                    NativeFingerHandler::StatfsHandler64(pathBuff,&amp;fs);</span><br><span class="line">                    write_data(tracee,arg2,&amp;fs,<span class="keyword">sizeof</span> (<span class="keyword">struct</span> statfs64));</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">struct</span> statfs fs = &#123;&#125;;</span><br><span class="line">                    <span class="type">word_t</span> arg2 = peek_reg(tracee, ORIGINAL, SYSARG_2);</span><br><span class="line">                    read_data(tracee,&amp;fs,arg2,<span class="keyword">sizeof</span> (<span class="keyword">struct</span> statfs));</span><br><span class="line">                    NativeFingerHandler::StatfsHandler32(pathBuff,&amp;fs);</span><br><span class="line">                    write_data(tracee,arg2,&amp;fs,<span class="keyword">sizeof</span> (<span class="keyword">struct</span> statfs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mac地址"><a href="#Mac地址" class="headerlink" title="Mac地址"></a>Mac地址</h3><p>基础字段，<strong>Java层获取，netlink获取，命令行获取 ，读文件获取</strong>，四种获取方法</p>
<p>直接在svc的 <code>recvmsg ，recv，recvfrom</code>的after进行数据包替换即可</p>
<p>如果判断是<code>netlink</code>的消息，并且是获取网卡类型直接对里面的数据包解析和替换即可 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case SC_recvmsg: &#123;</span><br><span class="line">    //LOGI(&quot;start handle SC_recvmsg systexit after&quot;)</span><br><span class="line">    if (isMockFingerptint()) &#123;</span><br><span class="line">        NetlinkMacHandler::netlinkHandler_recmsg(tracee);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">case SC_recv:</span><br><span class="line">case SC_recvfrom: &#123;</span><br><span class="line">    //LOGE(&quot;start handle SC_recvfrom systexit after&quot;)</span><br><span class="line">    //recv底层走的recvfrom,所以不需要处理recvfrom</span><br><span class="line">    if (isMockFingerptint()) &#123;</span><br><span class="line">        NetlinkMacHandler::netlinkHandler_recv(tracee);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在读文件获取这块因为网卡信息已经在内存里面 ，所以直接<strong>IO重定向</strong>过去即可 。</p>
<p>常用的获取网卡信息的文件 ，以<code>wlan0</code>为例子 ,场景的获取目录如下：可以cat获取，也可以直接读文件 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/net/wlan0/address</span><br><span class="line">/sys/devices/virtual/net/wlan0/address</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="附近网卡信息"><a href="#附近网卡信息" class="headerlink" title="附近网卡信息"></a>附近网卡信息</h3><p>这个字段主要是<strong>监控群控的一些信息</strong>的，主要作用是获取当前<code>wifi</code> 附近的人<code>MAC</code>信息的 。</p>
<p>比如大厂一般检测群控的手段就是获取附近的网卡，<strong>如果有聚集性就可以认为是群控</strong></p>
<p>获取的方式也也跟上面一样，五种获取方法 。</p>
<p>获取方法底层也是和<code>MAC</code>获取方法一样 ，底层都是<code>netlink</code>，比如可以直接执行 <code>popen</code>获取 ，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popen(<span class="string">&quot;ip neigh show&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>也可以直接直接读文件 ，路径如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/net/arp</span><br></pre></td></tr></table></figure>

<p>还可以直接<code>netlink</code>获取 ，在收到消息以后判断消息类型是 <code>hdr-&gt;nlmsg_type == RTM_NEWNEIGH</code> 直接进行替换即可 </p>
<p>直接在<code>recv</code>收到消息以后对数据里面的<code>buff</code>进行替换即可。主要核心代码如下，包括上面的mac地址替换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">static void _getifaddrs_callback(void *context, nlmsghdr *hdr) &#123;</span><br><span class="line">    auto **out = reinterpret_cast&lt;ifaddrs **&gt;(context);</span><br><span class="line"> </span><br><span class="line">    //首先先判断消息类型是不是RTM_NEWLINK类型</span><br><span class="line">    if (hdr-&gt;nlmsg_type == RTM_NEWLINK) &#123;</span><br><span class="line">        auto *ifi = reinterpret_cast&lt;ifinfomsg *&gt;(NLMSG_DATA(hdr));</span><br><span class="line"> </span><br><span class="line">        ifaddrs_storage new_addr(out);</span><br><span class="line">        new_addr.interface_index = ifi-&gt;ifi_index;</span><br><span class="line">        new_addr.ifa.ifa_flags = ifi-&gt;ifi_flags;</span><br><span class="line"> </span><br><span class="line">        // Get the interface name</span><br><span class="line">        char ifname[IFNAMSIZ];</span><br><span class="line">        if_indextoname(ifi-&gt;ifi_index, ifname);</span><br><span class="line"> </span><br><span class="line">        // Go through the various bits of information and find the name.</span><br><span class="line">        rtattr *rta = IFLA_RTA(ifi);</span><br><span class="line">        //获取这个消息的长度</span><br><span class="line">        size_t rta_len = IFLA_PAYLOAD(hdr);</span><br><span class="line">        //这块是判断这个消息是否是合格的消息</span><br><span class="line">        while (RTA_OK(rta, rta_len)) &#123;</span><br><span class="line">            if (rta-&gt;rta_type == IFLA_ADDRESS)&#123; // MAC地址</span><br><span class="line">                if (RTA_PAYLOAD(rta) &lt; sizeof(new_addr.addr)) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    //修改mac地址</span><br><span class="line">                    setMacInData(data, ifname, ZHENXI_RUNTIME_NETLINK_MAC, false);</span><br><span class="line">                    new_addr.SetAddress(AF_PACKET, data, RTA_PAYLOAD(rta));</span><br><span class="line">                    new_addr.SetPacketAttributes(ifi-&gt;ifi_index, ifi-&gt;ifi_type,</span><br><span class="line">                                                 RTA_PAYLOAD(rta));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rta-&gt;rta_type == IFLA_BROADCAST) &#123;</span><br><span class="line">                if (RTA_PAYLOAD(rta) &lt; sizeof(new_addr.ifa_ifu)) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    size_t byteCount = RTA_PAYLOAD(rta);</span><br><span class="line">                    new_addr.SetBroadcastAddress(AF_PACKET, data, byteCount);</span><br><span class="line">                    new_addr.SetPacketAttributes(ifi-&gt;ifi_index, ifi-&gt;ifi_type,</span><br><span class="line">                                                 RTA_PAYLOAD(rta));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rta-&gt;rta_type == IFLA_IFNAME) &#123;</span><br><span class="line">                if (RTA_PAYLOAD(rta) &lt; sizeof(new_addr.name)) &#123;</span><br><span class="line">                    memcpy(new_addr.name, RTA_DATA(rta), RTA_PAYLOAD(rta));</span><br><span class="line">                    new_addr.ifa.ifa_name = new_addr.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rta = RTA_NEXT(rta, rta_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (hdr-&gt;nlmsg_type == RTM_NEWADDR) &#123;  // IP 地址</span><br><span class="line">        //这个类型在获取网卡的时候未发现调用</span><br><span class="line">        auto *msg = reinterpret_cast&lt;ifaddrmsg *&gt;(NLMSG_DATA(hdr));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // We should already know about this from an RTM_NEWLINK message.</span><br><span class="line">        const auto *addr = reinterpret_cast&lt;const ifaddrs_storage *&gt;(*out);</span><br><span class="line"> </span><br><span class="line">        while (addr != nullptr &amp;&amp; addr-&gt;interface_index != static_cast&lt;int&gt;(msg-&gt;ifa_index)) &#123;</span><br><span class="line">            //LOGE(&quot;Current interface index: %d&quot;, addr-&gt;interface_index); // 添加当前接口索引日志</span><br><span class="line">            addr = reinterpret_cast&lt;const ifaddrs_storage *&gt;(addr-&gt;ifa.ifa_next);</span><br><span class="line">        &#125;</span><br><span class="line">        // If this is an unknown interface,</span><br><span class="line">        // ignore whatever we&#x27;re being told about it.</span><br><span class="line">        if (addr == nullptr) &#123;</span><br><span class="line">            //LOGE (&quot;_getifaddrs_callback RTM_NEWADDR return&quot;)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ifaddrs_storage new_addr(out);</span><br><span class="line">        strcpy(new_addr.name, addr-&gt;name);</span><br><span class="line">        new_addr.ifa.ifa_name = new_addr.name;</span><br><span class="line">        new_addr.ifa.ifa_flags = addr-&gt;ifa.ifa_flags;</span><br><span class="line">        new_addr.interface_index = addr-&gt;interface_index;</span><br><span class="line">        // Go through the various bits of information and find the address</span><br><span class="line">        // and any broadcast/destination address.</span><br><span class="line">        rtattr *rta = IFA_RTA(msg);</span><br><span class="line">        size_t rta_len = IFA_PAYLOAD(hdr);</span><br><span class="line">        while (RTA_OK(rta, rta_len)) &#123;</span><br><span class="line">            LOGE(&quot;RTA type: %d&quot;, rta-&gt;rta_type);</span><br><span class="line">            if (rta-&gt;rta_type == IFA_ADDRESS) &#123;</span><br><span class="line">                //LOGE (&quot;_getifaddrs_callback RTM_NEWADDR IFA_ADDRESS %d &quot;,msg-&gt;ifa_family)</span><br><span class="line">                if (msg-&gt;ifa_family == AF_INET || msg-&gt;ifa_family == AF_INET6) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    // 确保 RTA_DATA(rta) 的大小是正确的</span><br><span class="line">                    if (msg-&gt;ifa_family == AF_INET6 &amp;&amp; RTA_PAYLOAD(rta) &lt; sizeof(struct in6_addr)) &#123;</span><br><span class="line">                        LOGE(&quot;RTA_PAYLOAD size is less than sizeof(struct in6_addr)&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    struct in6_addr addr_v6_address&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr_v6_address, RTA_DATA(rta), sizeof(struct in6_addr));</span><br><span class="line">                    char str[INET6_ADDRSTRLEN];</span><br><span class="line">                    inet_ntop(AF_INET6, &amp;addr_v6_address, str, sizeof(str));</span><br><span class="line">                    LOGE(&quot;RTM_NEWADDR&amp;IFA_ADDRESS&amp;AF_INET6 111 %s&quot;, str)</span><br><span class="line"> </span><br><span class="line">                    size_t byteCount = RTA_PAYLOAD(rta);</span><br><span class="line">                    LOGE (&quot;RTM_NEWADDR&amp;IFA_ADDRESS %zu  %s &quot;,</span><br><span class="line">                          byteCount, getpData(data, byteCount).c_str())</span><br><span class="line">                    new_addr.SetAddress(msg-&gt;ifa_family, data, byteCount);</span><br><span class="line">                    new_addr.SetNetmask(msg-&gt;ifa_family, msg-&gt;ifa_prefixlen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rta-&gt;rta_type == IFA_BROADCAST) &#123;</span><br><span class="line">                if (msg-&gt;ifa_family == AF_INET||msg-&gt;ifa_family == AF_INET6) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    size_t byteCount = RTA_PAYLOAD(rta);</span><br><span class="line">                    LOGE (&quot;RTM_NEWADDR&amp;IFA_BROADCAST %zu  %s &quot;,</span><br><span class="line">                          byteCount, getpData(data, byteCount).c_str())</span><br><span class="line">                    new_addr.SetBroadcastAddress(msg-&gt;ifa_family, data,</span><br><span class="line">                                                 byteCount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (rta-&gt;rta_type == IFA_LOCAL) &#123;</span><br><span class="line">                //LOGE (&quot;_getifaddrs_callback RTM_NEWADDR IFA_LOCAL %d &quot;,msg-&gt;ifa_family)</span><br><span class="line">                if (msg-&gt;ifa_family == AF_INET || msg-&gt;ifa_family == AF_INET6) &#123;</span><br><span class="line">                    void *data = RTA_DATA(rta);</span><br><span class="line">                    struct in6_addr addr_v6_local&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr_v6_local, RTA_DATA(rta), sizeof(struct in6_addr));</span><br><span class="line">                    char str[INET6_ADDRSTRLEN];</span><br><span class="line">                    inet_ntop(AF_INET6, &amp;addr_v6_local, str, sizeof(str));</span><br><span class="line">                    LOGE(&quot;RTM_NEWADDR&amp;IFA_ADDRESS&amp;AF_INET6 222 %s&quot;, str)</span><br><span class="line"> </span><br><span class="line">                    size_t byteCount = RTA_PAYLOAD(rta);</span><br><span class="line">                    LOGE (&quot;RTM_NEWADDR&amp;IFA_LOCAL %zu  %s &quot;,</span><br><span class="line">                          byteCount, getpData(data, byteCount).c_str())</span><br><span class="line">                    new_addr.SetLocalAddress(msg-&gt;ifa_family, data, byteCount);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rta = RTA_NEXT(rta, rta_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (hdr-&gt;nlmsg_type == RTM_NEWNEIGH) &#123; // 拦截和修改邻居缓存信息</span><br><span class="line">        // RTM_NEWNEIGH 类型消息为网上邻居(arp表)，需要进行随机化</span><br><span class="line">        auto *ifinfo = reinterpret_cast&lt;ndmsg *&gt;(NLMSG_DATA(hdr));</span><br><span class="line">        rtattr *rta = NDA_RTA(ifinfo);</span><br><span class="line">        size_t rta_len = NDA_PAYLOAD(hdr);</span><br><span class="line"> </span><br><span class="line">        int if_index = ifinfo-&gt;ndm_ifindex;</span><br><span class="line">        char if_name[IFNAMSIZ];</span><br><span class="line">        if_indextoname(if_index, if_name);</span><br><span class="line">        //遍历具体的消息类型</span><br><span class="line">        while (RTA_OK(rta, rta_len)) &#123;</span><br><span class="line">            //a neighbor cache n/w layer destination address</span><br><span class="line">            //邻居缓存nw层目标地址,ip地址区分32和64</span><br><span class="line">            //ip地址,ip可以是v4也可以是v6</span><br><span class="line">            if (rta-&gt;rta_type == NDA_DST) &#123;</span><br><span class="line">                if (ifinfo-&gt;ndm_family == AF_INET) &#123;</span><br><span class="line">                    //32</span><br><span class="line">                    struct in_addr addr&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr, RTA_DATA(rta), sizeof(struct in_addr));</span><br><span class="line">                    char *ntoa = inet_ntoa(addr);</span><br><span class="line">                    //LOGE(&quot;NDA_DST&amp;AF_INET   %s&quot;, inet_ntoa(addr))</span><br><span class="line">                &#125; else if (ifinfo-&gt;ndm_family == AF_INET6) &#123;</span><br><span class="line">                    //64</span><br><span class="line">                    struct in6_addr addr&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr, RTA_DATA(rta), sizeof(struct in6_addr));</span><br><span class="line">                    char str[INET6_ADDRSTRLEN];</span><br><span class="line">                    inet_ntop(AF_INET6, &amp;addr, str, sizeof(str));</span><br><span class="line">                    //LOGE(&quot;NDA_DST&amp;AF_INET6  %s&quot;, str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (rta-&gt;rta_type == NDA_LLADDR) &#123;</span><br><span class="line">                //网卡地址</span><br><span class="line">                auto *data = RTA_DATA(rta);</span><br><span class="line">                setMacInData(data, if_name, ZHENXI_RUNTIME_NETLINK_NEIGH, true);</span><br><span class="line">            &#125;</span><br><span class="line">            rta = RTA_NEXT(rta, rta_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (hdr-&gt;nlmsg_type == RTM_GETADDR) &#123; // 处理对 RTM_GETADDR 请求的响应</span><br><span class="line">        //LOGE(&quot;RTM_GETADDR &quot;)</span><br><span class="line">        auto *ifa = reinterpret_cast&lt;ifaddrmsg *&gt;(NLMSG_DATA(hdr));</span><br><span class="line"> </span><br><span class="line">        // Get the interface name</span><br><span class="line">        char ifname[IFNAMSIZ];</span><br><span class="line">        if_indextoname(ifa-&gt;ifa_index, ifname);</span><br><span class="line"> </span><br><span class="line">        // Process the attributes</span><br><span class="line">        rtattr *rta = IFA_RTA(ifa);</span><br><span class="line">        size_t rta_len = IFA_PAYLOAD(hdr);</span><br><span class="line">        while (RTA_OK(rta, rta_len)) &#123;</span><br><span class="line">            if (rta-&gt;rta_type == IFA_ADDRESS) &#123;</span><br><span class="line">                if (ifa-&gt;ifa_family == AF_INET6) &#123;</span><br><span class="line">                    // Ensure RTA_DATA(rta) size is correct</span><br><span class="line">                    if (RTA_PAYLOAD(rta) &lt; sizeof(struct in6_addr)) &#123;</span><br><span class="line">                        LOGE(&quot;RTM_GETADDR RTA_PAYLOAD size is less than sizeof(struct in6_addr)&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    struct in6_addr addr_v6_address&#123;&#125;;</span><br><span class="line">                    memcpy(&amp;addr_v6_address, RTA_DATA(rta), sizeof(struct in6_addr));</span><br><span class="line">                    char str[INET6_ADDRSTRLEN];</span><br><span class="line">                    inet_ntop(AF_INET6, &amp;addr_v6_address, str, sizeof(str));</span><br><span class="line">                    LOGE(&quot;RTM_GETADDR RTM_GETADDR&amp;IFA_ADDRESS&amp;AF_INET6 %s&quot;, str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rta = RTA_NEXT(rta, rta_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>设个设备指纹也是很核心的设备指纹 ，这个玩意<strong>底层获取也是netlink</strong>，但是netlink获取，这块处理很不好处理 </p>
<p>常用的获取方式比如，Java获取，命令获取。如果需要进行替换的话，只需要处理命令行和Java Hook即可 </p>
<p><strong>命令行可以在对方执行命令之前，将命令换成cat命令，去cat自己提前Mock好的文件，效果是一样的 。</strong></p>
<p>当然，还有另一种思路，其实这个字段可以服务端获取，客户端二次上报，进行匹配 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 1. 声明变量</span><br><span class="line">    NetworkInterface networkInterface;</span><br><span class="line">    InetAddress inetAddress;</span><br><span class="line"></span><br><span class="line">    // 2. 外层循环：遍历所有网络接口</span><br><span class="line">    for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123;</span><br><span class="line">        // 3. 获取当前网络接口</span><br><span class="line">        networkInterface = en.nextElement();</span><br><span class="line"></span><br><span class="line">        // 4. 内层循环：遍历当前接口上的所有 IP 地址</span><br><span class="line">        for (Enumeration&lt;InetAddress&gt; enumIpAddr = networkInterface.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123;</span><br><span class="line">            // 5. 获取当前 IP 地址</span><br><span class="line">            inetAddress = enumIpAddr.nextElement();</span><br><span class="line"></span><br><span class="line">            // 6. 判断是否为 IPv6 地址</span><br><span class="line">            if (inetAddress instanceof Inet6Address) &#123;</span><br><span class="line">                // 7. 如果是，则打印该地址</span><br><span class="line">                CLog.e(&quot;Java 获取 ipv6 &quot; + inetAddress.getHostAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Throwable ex) &#123;</span><br><span class="line">    // 8. 异常处理</span><br><span class="line">    CLog.e(&quot;printf ipv6 info error &quot; + ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历当前设备上所有的网络接口（Network Interface），找出并打印出与这些接口关联的所有 IPv6 地址</strong></p>
<p>命令行获取如下，ip命令获取如下 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ip -6 addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 state UNKNOWN qlen 1000</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: dummy0: &lt;BROADCAST,NOARP,UP,LOWER_UP&gt; mtu 1500 state UNKNOWN qlen 1000</span><br><span class="line">    inet6 fe80::b86c:79ff:fe96:4945/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">10: rmnet_data0@rmnet_ipa0: &lt;UP,LOWER_UP&gt; mtu 1500 state UNKNOWN qlen 1000</span><br><span class="line">    inet6 fe80::2ad1:b5a0:792b:9ec4/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">30: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 state UP qlen 3000</span><br><span class="line">    inet6 fe80::8670:a04c:b8cf:467c/64 scope link stable-privacy</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<h3 id="系统内核信息"><a href="#系统内核信息" class="headerlink" title="系统内核信息"></a>系统内核信息</h3><p>这玩意底层走的都是uname函数 ，直接对<code>uname</code>系统调用处理即可 。获取方法比如，也可以直接svc调用uname函数 ，也可以直接根据命令行 ，</p>
<p>修改的话也很简单，直接在uname的after里面直接对数据进行替换即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<h3 id="包名随机路径"><a href="#包名随机路径" class="headerlink" title="包名随机路径"></a>包名随机路径</h3><p><strong>这个是一个非常非常核心的字段，就是&#x2F;data&#x2F;app&#x2F;随机Base64路径&#x2F;base.apk</strong></p>
<p><strong>这个随机路径就是设备指纹，比如一些大厂会玩，读取你微信的随机路径，获取微信的包信息，然后获取里面的随机路径</strong></p>
<p><strong>比如微信，快手，京东，淘宝这种随机路径 ，作为核心的唯一设备指纹，只要你不卸载微信，或者其他大厂apk ，你的设备指纹永远不发生变化，无论你如何修改他自己Apk里面的信息，跟他都不产生任何影响 。</strong></p>
<h3 id="系统账号"><a href="#系统账号" class="headerlink" title="系统账号"></a>系统账号</h3><p>一般尝试比如小米之类的，登入了指定账号，可以得到一个账号的<code>id</code>信息 ，这个也需要处理一下 。最好的办法是不登入账号 。</p>
<h2 id="环境检测"><a href="#环境检测" class="headerlink" title="环境检测"></a>环境检测</h2><p>检测环境大多数围绕Hunter的源码检测思路去复现 ，很多都是Hunter的源码 ，很多也都是行业内没有公开的一些检测思路</p>
<h3 id="Apk签名"><a href="#Apk签名" class="headerlink" title="Apk签名"></a>Apk签名</h3><p>提到环境检测不得不说的就是<strong>Apk重打包检测</strong> ，现在检测方法千奇百怪，我这边也是一一罗列一下，把一些可能存在的风险点，检测和绕过的原理详细叙述一下 。</p>
<p><strong>想要绕过签名检测最好的办法或者说成本最低有效的办法就是修改完毕以后不签名配合核心破解直接安装。</strong></p>
<blockquote>
<p>核心破解是<code>lsp</code>的模块，<code>lsp</code>商店直接下载，<code>Hook apk</code>的系统签名解析方法，直接绕过签名检测流程 ，已实现不签名直接安装</p>
</blockquote>
<p>首先先说一下大厂或者一些企业壳的检测点，Java层基础的获取签名的方法这块就不一一叙述了 。</p>
<h4 id="Native层获取签名方法"><a href="#Native层获取签名方法" class="headerlink" title="Native层获取签名方法"></a>Native层获取签名方法</h4><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>这块以<code>Hunter</code>源码开始介绍 </p>
<p>核心就三部分 。</p>
<ul>
<li><code>svc openat</code>读apk，去解析签名 。</li>
<li>检测打开的fd，对fd的路径进行反查，这块有个细节 <code>buff[len] = &#39;\0&#39;</code>; 就是加这个，如果攻击者没修改<code>readlinkat</code>的返回值，就可以检测出来 。</li>
<li>检测完毕路径以后<strong>对这个文件的权限进行反查</strong>，正常apk是在系统下的，<strong>权限GID和UID应该是1000</strong> ，如果攻击者忘记修改权限也可以检测出来 。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">const char *path = getApkPath(env, context); // 获取绝对路径 </span><br><span class="line">//check svc apk sign</span><br><span class="line">const string &amp;string = checkSign(env, path).substr(0, 10); // 截取签名哈希值的前10个字符</span><br><span class="line">LOG(INFO) &lt;&lt; &quot;apk sign  &quot; &lt;&lt; string;</span><br><span class="line">if (string == Base64Utils::VTDecode(&quot;TFtCRU58UERAUQ==&quot;)) &#123; // Base64变体</span><br><span class="line">    //check sign success,but maybe svc io hook</span><br><span class="line">    //check apk path</span><br><span class="line">    int fd = my_openat(AT_FDCWD, reinterpret_cast&lt;const char *&gt;(path),</span><br><span class="line">                       O_RDONLY | O_CLOEXEC,</span><br><span class="line">                       0640);</span><br><span class="line">    //check apk path</span><br><span class="line">    char buff[PATH_MAX] = &#123;0&#125;;</span><br><span class="line">    std::string fdPath(&quot;/proc/&quot;);</span><br><span class="line">    fdPath.append(to_string(getpid())).append(&quot;/fd/&quot;).append(to_string(fd));</span><br><span class="line">    long len = raw_syscall(__NR_readlinkat, AT_FDCWD, fdPath.c_str(), buff, PATH_MAX);</span><br><span class="line">    if (len &lt; 0) &#123;</span><br><span class="line">        return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                           &quot;readlinkat error&quot;, true,</span><br><span class="line">                           RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line">    &#125;</span><br><span class="line">    //截断,如果攻击者hook了readlinkat,只修改了参数,没修改返回值也可以检测出来。</span><br><span class="line">    buff[len] = &#x27;\0&#x27;;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;check apk sign path &quot; &lt;&lt; buff;</span><br><span class="line">    if (my_strcmp(path, buff) == 0) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;check apk sign path success &quot;;</span><br><span class="line">        //start check memory&amp;location inode</span><br><span class="line">        struct stat statBuff = &#123;0&#125;;</span><br><span class="line">        long stat = raw_syscall(__NR_fstat, fd, &amp;statBuff);</span><br><span class="line">        if (stat &lt; 0) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;check apk sign path fail __NR_fstat&lt;0&quot;;</span><br><span class="line">            return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                               &quot;fstat error&quot;, true, RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line">        &#125;</span><br><span class="line">        //check uid&amp;gid (1000 = system group)</span><br><span class="line">        if (statBuff.st_uid != 1000 &amp;&amp; statBuff.st_gid != 1000) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;check apk sign gid&amp;uid fail &quot;;</span><br><span class="line">            return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                               nullptr, true, RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line">        &#125;</span><br><span class="line">        size_t inode = getFileInMapsInode(path);</span><br><span class="line">        if (statBuff.st_ino != inode) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;check apk sign inode fail &quot;&lt;&lt;statBuff.st_ino&lt;&lt;&quot; maps -&gt;&quot;&lt;&lt;inode;</span><br><span class="line">            return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                               nullptr, true, RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; check apk sign success! uid-&gt; &quot; &lt;&lt; statBuff.st_uid</span><br><span class="line">                   &lt;&lt; &quot; gid-&gt; &quot;</span><br><span class="line">                   &lt;&lt; statBuff.st_gid;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;check apk sign path fail &quot;;</span><br><span class="line">        return getItemData(env, &quot;APK签名验证失败&quot;,</span><br><span class="line">                           nullptr, true, RISK_LEAVE_DEADLY, TAG_REPACKAGE);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;check apk sign success&quot;;</span><br><span class="line"> </span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Inode 校验检测的不是内存中的<strong>内容</strong>是否被修改，而是检测内存的<strong>来源</strong>是否被偷换</p>
</blockquote>
<h4 id="对抗"><a href="#对抗" class="headerlink" title="对抗"></a>对抗</h4><p>针对上面的检测对抗也很简单，对svc的<code>openat</code>拦截了以后，对<code>readlinkat</code>和<code>stat</code>函数进行处理即可。很轻松即可绕过检测。很多加壳基本都是检测<code>ROOT</code>检测<code>LSP</code>调用栈之类的，并不只是单一的去检测签名一个纬度。比如发现了开启了<code>seccomp</code>就会闪退，发现<code>Root</code>就会闪退。</p>
<h4 id="Java层获取签名方法"><a href="#Java层获取签名方法" class="headerlink" title="Java层获取签名方法"></a>Java层获取签名方法</h4><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><h5 id="检测CREATOR是否被替换"><a href="#检测CREATOR是否被替换" class="headerlink" title="检测CREATOR是否被替换"></a>检测CREATOR是否被替换</h5><p>这里先说一下<code>Hunter</code>的<code>Java</code>层检测签名的方法，这块相当于反射<code>CREATOR</code> 变量，这个变量是保存一些<code>IPC</code>通讯的东西</p>
<p>很多攻击者会用<code>Lspatch</code>进行打包 ，对变量进行替换，这时候我们去检测这个变量的<code>Classloader</code>是不是系统<code>ClassLoader</code></p>
<p>防止被替换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Field creatorField = PackageInfo.class.getField(&quot;CREATOR&quot;);</span><br><span class="line">    creatorField.setAccessible(true);</span><br><span class="line">    Object creator = creatorField.get(null);</span><br><span class="line">    if (creator != null) &#123;</span><br><span class="line">        ClassLoader creatorClassloader = creator.getClass().getClassLoader();</span><br><span class="line">        ClassLoader sysClassloader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        if (creatorClassloader == null || sysClassloader == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 系统的是 bootclassloader</span><br><span class="line">        // 用户创建的都是 pathclassloader</span><br><span class="line">        // 如果相等则认为系统的被替换</span><br><span class="line">        if (sysClassloader.getClass().getName().</span><br><span class="line">                equals(creatorClassloader.getClass().getName())) &#123;</span><br><span class="line">            return new ListItemBean(&quot;Apk签名验证失败！&quot;,</span><br><span class="line">                    ListItemBean.RiskLeave.Deadly,</span><br><span class="line">                    &quot;Apk签名方法被替换!\n&quot;</span><br><span class="line">                            + creatorClassloader.getClass().getName() + &quot;\n&quot;</span><br><span class="line">                            + sysClassloader.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    CLog.e(&quot;checkApkPackageInfoCreator error &quot; + e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final Creator&lt;PackageInfo&gt; CREATOR</span><br></pre></td></tr></table></figure>

<p><code>Creator&lt;PackageInfo&gt;</code>是说明这是一个用于创建<code>PackageInfo</code>类型对象的创建器</p>
</blockquote>
<p>我们之前分析<code>Java 层直接 通过binder和 AMS 通讯获取真实签名信息</code>这个的时候</p>
<p>我们是使用<code>getPackageInfo()</code>来获取签名的，如果通过Java反射找到<code>PackageInfo.CREATOR</code>这个静态字段，然后将这个字段的值替换成自己编写的恶意<code>Creator</code>实现，当App调用<code>getPackageInfo()</code>获取签名时，Android系统内部会使用这个被污染的<code>CREATOR</code>来创建<code>PackageInfo</code>对象，恶意<code>Creator</code>在创建对象时，将签名信息篡改为正版的签名，从而绕过App的签名校验</p>
<p>而这个检查的<strong>原理</strong>是：系统类的<code>Classloader</code>是<code>BootClassloader</code>，而我们呢通过Hook模块的代码是由App的<code>PathClassLoader</code>，因此只需要判断一下这个<code>Classloader</code>正不正确即可</p>
<h4 id="对抗-1"><a href="#对抗-1" class="headerlink" title="对抗"></a>对抗</h4><p>对抗的方法主要下面三种：</p>
<p>现在大厂一般会直接通过IPC直接和PMS进行通讯 ，不过这种思路也很好过 ，我这边也是参考的<code>Lspatch</code> </p>
<p>这块有两个很核心的思路 ，就是拦截<code>Binder IPC</code>通讯的方法，和<code>Hook</code>服务端的签名解析方法 。代码如下：</p>
<h5 id="Hook服务端解析签名方法"><a href="#Hook服务端解析签名方法" class="headerlink" title="Hook服务端解析签名方法"></a>Hook服务端解析签名方法</h5><p>在系统进行签名解析的时候进行签名替换替换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private static void hookPackageParser(Signature[] fakeSignature) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        RposedBridge.hookAllMethods(</span><br><span class="line">                RposedHelpers.findClass(&quot;android.content.pm.PackageParser&quot;, ClassLoader.getSystemClassLoader()),</span><br><span class="line">                &quot;generatePackageInfo&quot;, new RC_MethodHook() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                        PackageInfo packageInfo = (PackageInfo) param.getResult();</span><br><span class="line">                        if (packageInfo == null) return;</span><br><span class="line">                        if (packageInfo.packageName.equals(RuntimeToolKit.packageName)) &#123;</span><br><span class="line">                            if (packageInfo.signatures != null &amp;&amp; packageInfo.signatures.length &gt; 0) &#123;</span><br><span class="line">                                CLog.i(&quot;PackageParser signature info (method 1)&quot;);</span><br><span class="line">                                packageInfo.signatures[0] = fakeSignature[0];</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">                                if (packageInfo.signingInfo != null) &#123;</span><br><span class="line">                                    CLog.i(&quot;PackageParser signature info (method 2)&quot;);</span><br><span class="line">                                    Signature[] signaturesArray = packageInfo.signingInfo.getApkContentsSigners();</span><br><span class="line">                                    if (signaturesArray != null &amp;&amp; signaturesArray.length &gt; 0) &#123;</span><br><span class="line">                                        signaturesArray[0] = fakeSignature[0];</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        CLog.e(&quot;hook apkSign PackageParser -&gt; generatePackageInfo &quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="替换CREATOR"><a href="#替换CREATOR" class="headerlink" title="替换CREATOR"></a>替换CREATOR</h5><p>这个思路也是抄的<code>lspatch</code> ，这种思路可以通过检测<code>CREATOR</code> 变量<code>Classloader</code>的方式检测出来 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void byPassSignatureForCREATOR(Signature[] fakeSignature) &#123;</span><br><span class="line">    if (fakeSignature == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcelable.Creator&lt;PackageInfo&gt; originalCreator = PackageInfo.CREATOR;</span><br><span class="line">    Parcelable.Creator&lt;PackageInfo&gt; proxiedCreator = new Parcelable.Creator&lt;PackageInfo&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public PackageInfo createFromParcel(Parcel source) &#123;</span><br><span class="line">            PackageInfo packageInfo = originalCreator.createFromParcel(source);</span><br><span class="line">            if (packageInfo.packageName.equals(RuntimeToolKit.packageName)) &#123;</span><br><span class="line">                if (packageInfo.signatures != null &amp;&amp; packageInfo.signatures.length &gt; 0) &#123;</span><br><span class="line">                    //CLog.i(&quot;CREATOR Replace signature info (method 1)&quot;);</span><br><span class="line">                    packageInfo.signatures[0] = fakeSignature[0];</span><br><span class="line">                &#125;</span><br><span class="line">                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">                    if (packageInfo.signingInfo != null) &#123;</span><br><span class="line">                        //CLog.i(&quot;CREATOR Replace signature info (method 2)&quot;);</span><br><span class="line">                        Signature[] signaturesArray = packageInfo.signingInfo.getApkContentsSigners();</span><br><span class="line">                        if (signaturesArray != null &amp;&amp; signaturesArray.length &gt; 0) &#123;</span><br><span class="line">                            signaturesArray[0] = fakeSignature[0];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return packageInfo;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        public PackageInfo[] newArray(int size) &#123;</span><br><span class="line">            return originalCreator.newArray(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    RposedHelpers.setStaticObjectField(PackageInfo.class, &quot;CREATOR&quot;, proxiedCreator);</span><br><span class="line">    try &#123;</span><br><span class="line">        Map&lt;?, ?&gt; mCreators = (Map&lt;?, ?&gt;) RposedHelpers.getStaticObjectField(Parcel.class, &quot;mCreators&quot;);</span><br><span class="line">        mCreators.clear();</span><br><span class="line">    &#125; catch (NoSuchFieldError ignore) &#123;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        CLog.e(&quot;fail to clear Parcel.mCreators&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        Map&lt;?, ?&gt; sPairedCreators = (Map&lt;?, ?&gt;)</span><br><span class="line">                RposedHelpers.getStaticObjectField(Parcel.class,</span><br><span class="line">                        &quot;sPairedCreators&quot;);</span><br><span class="line">        sPairedCreators.clear();</span><br><span class="line">    &#125; catch (NoSuchFieldError ignore) &#123;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        CLog.e(&quot;fail to clear Parcel.sPairedCreators&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Binder-transact-方法"><a href="#Binder-transact-方法" class="headerlink" title="Binder transact 方法"></a>Binder transact 方法</h5><p>有很多大厂会自己伪造IPC和服务端进行通讯，用这种方法可以进行签名的修改和替换，实现思路主要就是<code>Hook binder</code>通讯解析的方法 。判断如果传输类型数据是获取签名的话就进行替换 。主要思路就是<code>Hook</code>传输数据的“水管”，对水管里面的内容进行替换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">RposedHelpers.findAndHookMethod(&quot;android.os.BinderProxy&quot;, // 目标类名</span><br><span class="line">        context.getClassLoader(),  // 类加载器</span><br><span class="line">        &quot;transact&quot;,                // 目标方法名</span><br><span class="line">        int.class,</span><br><span class="line">        Parcel.class,</span><br><span class="line">        Parcel.class,</span><br><span class="line">        int.class,</span><br><span class="line">        new RC_MethodHook() &#123; // Hook 回调逻辑</span><br><span class="line">            @Override</span><br><span class="line">            protected void afterHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Object object = param.thisObject;</span><br><span class="line">                    int id = (int) param.args[0];    // 事务码 </span><br><span class="line">                    Parcel write = (Parcel) param.args[1];  // 请求数据 (data)</span><br><span class="line">                    Parcel out = (Parcel) param.args[2];    // 响应数据 (reply)</span><br><span class="line">                    // forward check</span><br><span class="line">                    if (write == null || out == null) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // prevent recurise call (防止递归)</span><br><span class="line">                    if (id == IBinder.INTERFACE_TRANSACTION) &#123;</span><br><span class="line">                        //IBinder协议事务代码：询问事务的收件人端以获取其规范接口描述符。</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    String desc = (String) RposedHelpers.callMethod(object, &quot;getInterfaceDescriptor&quot;);</span><br><span class="line">                    if (desc == null || !desc.equals(&quot;android.content.pm.IPackageManager&quot;)) &#123; // 筛选服务</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (id == TRANSACTION_getPackageInfo_ID) &#123; // 筛选目标操作</span><br><span class="line">                        out.readException();             // 读取和解析原始结果</span><br><span class="line">                        if (0 != out.readInt()) &#123;  // 检查是否有有效的 PackageInfo 返回</span><br><span class="line">                            PackageInfo packageInfo = PackageInfo.CREATOR.createFromParcel(out);  // 从 Parcel 中反序列化出 PackageInfo 对象  </span><br><span class="line">                            if (packageInfo.packageName.equals(context.getApplicationInfo().packageName)) &#123;</span><br><span class="line">                                if (fakeSignature[0] == null) &#123;</span><br><span class="line">                                    CLog.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; byPassSignature fakeSignature == null&quot;);</span><br><span class="line">                                    System.exit(0);</span><br><span class="line">                                    return;</span><br><span class="line">                                &#125;</span><br><span class="line">                                //CLog.i( &quot;org data size -&gt;  &quot;+out.dataSize());</span><br><span class="line"> </span><br><span class="line">                                if (packageInfo.signatures != null &amp;&amp; packageInfo.signatures.length &gt; 0) &#123; </span><br><span class="line">                                    packageInfo.signatures[0] = fakeSignature[0];</span><br><span class="line">                                    //CLog.i(&quot; byPassSignatureByLSPosed 1 !!&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                                // 核心:替换签名 </span><br><span class="line">                                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">                                    if (packageInfo.signingInfo != null) &#123;</span><br><span class="line">                                        Signature[] signaturesArray = packageInfo.signingInfo.getApkContentsSigners();</span><br><span class="line">                                        if (signaturesArray != null &amp;&amp; signaturesArray.length &gt; 0) &#123;</span><br><span class="line">                                            signaturesArray[0] = fakeSignature[0];</span><br><span class="line">                                            //CLog.i( &quot; byPassSignatureByLSPosed 2 !!&quot;);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                           // 将修改后的结果写回 Parcel</span><br><span class="line">                                out.setDataPosition(0);</span><br><span class="line">                                out.setDataSize(0);</span><br><span class="line">                                out.writeNoException();</span><br><span class="line">                                out.writeInt(1);</span><br><span class="line">                                packageInfo.writeToParcel(out, PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        // reset pos 重置读写位置</span><br><span class="line">                        out.setDataPosition(0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable err) &#123;</span><br><span class="line">                    CLog.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; byPassSignatureByLSPosed error &quot; + err.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>还有很多很好思路的代码 ，比如<code>ISO</code>线程去读取<code>apk</code>签名信息，防止<code>SVC</code>被<code>IO</code>重定向掉 。</p>
<blockquote>
<ul>
<li><strong><code>&quot;android.os.BinderProxy&quot;</code></strong>: 这是要 Hook 的目标类。<code>BinderProxy</code> 是客户端（应用进程）中 Binder 远程服务的一个代理对象。当你的应用调用一个系统服务（如 <code>PackageManagerService</code>）时，实际上是调用了本地 <code>BinderProxy</code> 对象的方法</li>
<li><code>transact</code> 方法是 Binder 通信的核心。所有跨进程的数据请求和响应都会经过这个方法</li>
<li>在确定了是发往 <code>PackageManagerService</code> 的通信后，我们再通过事务码 <code>id</code> 来判断具体的操作，<code>TRANSACTION_getPackageInfo_ID</code> (这个常量需要在别处定义) 明确告诉我们，这是一个获取 <code>PackageInfo</code> 的请求</li>
<li><code>PackageInfo.CREATOR.createFromParcel(out)</code>: 这是安卓 <code>Parcelable</code> 机制的标准用法，将 <code>Parcel</code> 中的二进制数据反序列化成一个 <code>PackageInfo</code> Java 对象</li>
<li><code>packageInfo.signatures[0] = fakeSignature[0]</code>: 在旧版 Android 中，签名信息直接存储在 <code>PackageInfo</code> 的 <code>signatures</code> 数组里。这里直接将第一个签名替换成我们预先准备好的 <code>fakeSignature</code></li>
<li><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P)</code>: 从 Android 9 (Pie) 开始，引入了 <code>SigningInfo</code> 类来更好地支持多签名和签名轮换。因此，为了兼容新系统，必须同时修改 <code>SigningInfo</code> 里面的签名信息。这段代码处理了高版本的兼容性问题</li>
</ul>
</blockquote>
<h3 id="模拟器检测-1"><a href="#模拟器检测-1" class="headerlink" title="模拟器检测"></a>模拟器检测</h3><p>Java层基础的获取api架构啥的</p>
<h4 id="Seccomp检测架构"><a href="#Seccomp检测架构" class="headerlink" title="Seccomp检测架构"></a>Seccomp检测架构</h4><p>主要思路来自B哥 ，感谢B哥 ，先安装<code>seccomp</code>架子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void install_check_arch_seccomp() &#123;</span><br><span class="line">    struct sock_filter filter[15] = &#123;</span><br><span class="line">            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, nr)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, __NR_getpid, 0, 12),</span><br><span class="line">            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, args[0])),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, DetectX86Flag, 0, 10),</span><br><span class="line">            BPF_STMT(BPF_LD + BPF_W + BPF_ABS, (uint32_t) offsetof(struct seccomp_data, arch)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_X86_64, 0, 1),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (864 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_I386, 0, 1),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (386 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_ARM, 0, 1),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (0xA32 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_JUMP(BPF_JMP + BPF_JEQ, AUDIT_ARCH_AARCH64, 0, 1),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (0xA64 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (6 &amp; SECCOMP_RET_DATA)),</span><br><span class="line">            BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br><span class="line">    struct sock_fprog program = &#123;</span><br><span class="line">            .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])),</span><br><span class="line">            .filter = filter</span><br><span class="line">    &#125;;</span><br><span class="line">    errno = 0;</span><br><span class="line">    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;prctl(PR_SET_NO_NEW_PRIVS) &quot; &lt;&lt; strerror(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = 0;</span><br><span class="line">    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;program)) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;prctl(PR_SET_SECCOMP) &quot; &lt;&lt; strerror(errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><strong>Seccomp (Secure Computing Mode)</strong>: 这是Linux内核的一项安全功能，用于限制进程可以调用的系统调用（syscall）。它有两种模式：<ul>
<li><code>SECCOMP_MODE_STRICT</code>: 极度严格，只允许 <code>read</code>, <code>write</code>, <code>sigreturn</code>, <code>exit</code> 四个系统调用。</li>
<li><code>SECCOMP_MODE_FILTER</code>: 允许用户提供一个 BPF 程序，内核会对进程的每一次系统调用都运行这个 BPF 程序，由程序来决定是允许、拒绝、还是执行其他操作。本代码使用的就是这种模式。</li>
</ul>
</li>
<li><strong>BPF (Berkeley Packet Filter)</strong>: BPF 是一种在内核中运行的、功能强大的虚拟机。虽然它最初是为过滤网络数据包而设计的，但现在已被广泛用于内核的各个子系统，包括 seccomp。它执行一组简单的指令（BPF字节码），对输入数据进行判断。在 seccomp 的上下文中，这个“输入数据”就是 <code>struct seccomp_data</code>，包含了当前系统调用的所有信息。</li>
<li><strong><code>prctl()</code> 系统调用</strong>: 这是一个用于控制进程行为的通用系统调用。代码中用到了它的两个选项：<ul>
<li><code>PR_SET_NO_NEW_PRIVS</code>: 这是安装 seccomp 过滤器前的<strong>关键安全步骤</strong>。将其设置为 1 后，当前进程及其子进程将无法通过 <code>execve</code> 等方式获得比当前更高的权限（例如，通过执行 SUID 程序）。这可以防止恶意代码利用漏洞来绕过 seccomp 限制。</li>
<li><code>PR_SET_SECCOMP</code>: 用于实际安装 seccomp 过滤器。</li>
</ul>
</li>
</ol>
</blockquote>
<p>总结：这段代码通过 Seccomp-BPF 实现了一个非常规但高效的架构检测机制。它选择了一个几乎无害的系统调用 (<code>getpid</code>)，并为其增加了一个“隐藏功能”：当以特定方式调用时，它不再返回进程ID，而是通过返回一个特定的 <code>errno</code> 来<strong>报告CPU架构</strong>。这种方法在高度沙箱化的环境中非常有用，因为在这些环境中，像执行 <code>uname</code> 命令或读取 <code>/proc</code> 文件系统等常规的检测方法可能都已被禁止。</p>
<p>配合上面的代码 。启动调用<code>getpid</code>， 上面的架子会对<code>getpid</code>函数进行拦截 ，然后架构进行判断 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string check_arch_by_seccomp() &#123;</span><br><span class="line">    if (get_sdk_level() &lt; __ANDROID_API_N_MR1__)&#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    errno = 0;</span><br><span class="line">    syscall(__NR_getpid, DetectX86Flag);</span><br><span class="line">    if (errno == 386) &#123;</span><br><span class="line">        return &quot;I386设备&quot;;</span><br><span class="line">    &#125; else if (errno == 864) &#123;</span><br><span class="line">        return &quot;X86_64设备&quot;;</span><br><span class="line">    &#125; else if (errno == 0xA32 || errno == 0xA64) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;else if (errno == 0) &#123;</span><br><span class="line">        //可能是没有开启seccomp</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return (&quot;疑似X86模拟器设备&quot;+ to_string(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测温度挂载文件"><a href="#检测温度挂载文件" class="headerlink" title="检测温度挂载文件"></a><strong>检测温度挂载文件</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int thermal_check() &#123;</span><br><span class="line">    DIR *dir_ptr;</span><br><span class="line">    int count = 0;</span><br><span class="line">    struct dirent *entry;</span><br><span class="line">    if ((dir_ptr = opendir(&quot;/sys/class/thermal/&quot;)) != nullptr) &#123;</span><br><span class="line">        while ((entry = readdir(dir_ptr))) &#123;</span><br><span class="line">            if (!strcmp(entry-&gt;d_name, &quot;.&quot;) || !strcmp(entry-&gt;d_name, &quot;..&quot;)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            char *tmp = entry-&gt;d_name;</span><br><span class="line">            if (strstr(tmp, &quot;thermal_zone&quot;) != nullptr) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dir_ptr);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        count = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟器特征文件"><a href="#模拟器特征文件" class="headerlink" title="模拟器特征文件"></a><strong>模拟器特征文件</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">string simulator_files_check() &#123;</span><br><span class="line">    if (file_exist(&quot;/system/bin/androVM-prop&quot;)) &#123;//检测androidVM</span><br><span class="line">        return &quot;/system/bin/androVM-prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/microvirt-prop&quot;)) &#123;//检测逍遥模拟器--新版本找不到特征</span><br><span class="line">        return &quot;/system/bin/microvirt-prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/lib/libdroid4x.so&quot;)) &#123;//检测海马模拟器</span><br><span class="line">        return &quot;/system/lib/libdroid4x.so&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/windroyed&quot;)) &#123;//检测文卓爷模拟器</span><br><span class="line">        return &quot;/system/bin/windroyed&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/nox-prop&quot;)) &#123;//检测夜神模拟器--某些版本找不到特征</span><br><span class="line">        return &quot;/system/bin/nox-prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;system/lib/libnoxspeedup.so&quot;)) &#123;//检测夜神模拟器</span><br><span class="line">        return &quot;system/lib/libnoxspeedup.so&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/ttVM-prop&quot;)) &#123;//检测天天模拟器</span><br><span class="line">        return &quot;/system/bin/ttVM-prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/data/.bluestacks.prop&quot;)) &#123;//检测bluestacks模拟器  51模拟器</span><br><span class="line">        return &quot;/data/.bluestacks.prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/bin/duosconfig&quot;)) &#123;//检测AMIDuOS模拟器</span><br><span class="line">        return &quot;/system/bin/duosconfig&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/etc/xxzs_prop.sh&quot;)) &#123;//检测星星模拟器</span><br><span class="line">        return &quot;/system/etc/xxzs_prop.sh&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/etc/mumu-configs/device-prop-configs/mumu.config&quot;)) &#123;//网易MuMu模拟器</span><br><span class="line">        return &quot;/system/etc/mumu-configs/device-prop-configs/mumu.config&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/priv-app/ldAppStore&quot;)) &#123;//雷电模拟器</span><br><span class="line">        return &quot;/system/priv-app/ldAppStore&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;system/bin/ldinit&quot;) &amp;&amp; file_exist(&quot;system/bin/ldmountsf&quot;)) &#123;//雷电模拟器</span><br><span class="line">        return &quot;system/bin/ldinit&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/app/AntStore&quot;) &amp;&amp; file_exist(&quot;/system/app/AntLauncher&quot;)) &#123;//小蚁模拟器</span><br><span class="line">        return &quot;/system/app/AntStore&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;vmos.prop&quot;)) &#123;//vmos虚拟机</span><br><span class="line">        return &quot;vmos.prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;fstab.titan&quot;) &amp;&amp; file_exist(&quot;init.titan.rc&quot;)) &#123;//光速虚拟机</span><br><span class="line">        return &quot;fstab.titan&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;x8.prop&quot;)) &#123;//x8沙箱和51虚拟机</span><br><span class="line">        return &quot;x8.prop&quot;;</span><br><span class="line">    &#125; else if (file_exist(&quot;/system/lib/libc_malloc_debug_qemu.so&quot;)) &#123;//AVD QEMU</span><br><span class="line">        return &quot;/system/lib/libc_malloc_debug_qemu.so&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGD(&quot;simulator file check info not find  &quot;);</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟器基础特征"><a href="#模拟器基础特征" class="headerlink" title="模拟器基础特征"></a>模拟器基础特征</h4><p>这块思路主要来自非虫 ，在次感谢 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line">      public static ListItemBean checkEmulator(Context context) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; choose = new ArrayList&lt;&gt;();</span><br><span class="line">//        try &#123;</span><br><span class="line">//            String[] strArr = &#123;</span><br><span class="line">//                    &quot;/boot/bstmods/vboxguest.ko&quot;,</span><br><span class="line">//                    &quot;/boot/bstmods/vboxsf.ko&quot;,</span><br><span class="line">//                    &quot;/dev/mtp_usb&quot;,</span><br><span class="line">//                    &quot;/dev/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/dev/socket/baseband_genyd&quot;,</span><br><span class="line">//                    &quot;/dev/socket/genyd&quot;,</span><br><span class="line">//                    &quot;/dev/socket/qemud&quot;,</span><br><span class="line">//                    &quot;/dev/socket/windroyed-audio&quot;,</span><br><span class="line">//                    &quot;/dev/socket/windroyed-camera&quot;,</span><br><span class="line">//                    &quot;/dev/socket/windroyed-gps&quot;,</span><br><span class="line">//                    &quot;/dev/socket/windroyed-sensors&quot;,</span><br><span class="line">//                    &quot;/dev/vboxguest&quot;,</span><br><span class="line">//                    &quot;/dev/vboxpci&quot;,</span><br><span class="line">//                    &quot;/dev/vboxuser&quot;,</span><br><span class="line">//                    &quot;/fstab.goldfish&quot;,</span><br><span class="line">//                    &quot;/fstab.nox&quot;,</span><br><span class="line">//                    &quot;/fstab.ranchu-encrypt&quot;,</span><br><span class="line">//                    &quot;/fstab.ranchu-noencrypt&quot;,</span><br><span class="line">//                    &quot;/fstab.ttVM_x86&quot;,</span><br><span class="line">//                    &quot;/fstab.vbox86&quot;,</span><br><span class="line">//                    &quot;/init.goldfish.rc&quot;,</span><br><span class="line">//                    &quot;/init.magisk.rc&quot;,</span><br><span class="line">//                    &quot;/init.nox.rc&quot;,</span><br><span class="line">//                    &quot;/init.ranchu-encrypt.rc&quot;,</span><br><span class="line">//                    &quot;/init.ranchu-noencrypt.rc&quot;,</span><br><span class="line">//                    &quot;/init.ranchu.rc&quot;,</span><br><span class="line">//                    &quot;/init.ttVM_x86.rc&quot;,</span><br><span class="line">//                    &quot;/init.vbox86.rc&quot;,</span><br><span class="line">//                    &quot;/init.vbox86p.rc&quot;,</span><br><span class="line">//                    &quot;/init.windroye.rc&quot;,</span><br><span class="line">//                    &quot;/init.windroye.sh&quot;,</span><br><span class="line">//                    &quot;/init.x86.rc&quot;,</span><br><span class="line">//                    &quot;/proc/irq/20/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sdcard/Android/data/com.redfinger.gamemanage&quot;,</span><br><span class="line">//                    &quot;/stab.andy&quot;,</span><br><span class="line">//                    &quot;/sys/bus/pci/drivers/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/bus/pci/drivers/vboxpci&quot;,</span><br><span class="line">//                    &quot;/sys/bus/platform/drivers/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/bus/platform/drivers/qemu_pipe/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/bus/platform/drivers/qemu_trace&quot;,</span><br><span class="line">//                    &quot;/sys/bus/virtio/drivers/itolsvmlgtp&quot;,</span><br><span class="line">//                    &quot;/sys/bus/virtio/drivers/itoolsvmhft&quot;,</span><br><span class="line">//                    &quot;/sys/class/bdi/vboxsf-1&quot;,</span><br><span class="line">//                    &quot;/sys/class/bdi/vboxsf-2&quot;,</span><br><span class="line">//                    &quot;/sys/class/bdi/vboxsf-3&quot;,</span><br><span class="line">//                    &quot;/sys/class/misc/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/class/misc/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/class/misc/vboxuser&quot;,</span><br><span class="line">//                    &quot;/sys/devices/platform/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/bdi/vboxsf-1&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/bdi/vboxsf-2&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/bdi/vboxsf-3&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/misc/qemu_pipe&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/misc/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/misc/vboxpci&quot;,</span><br><span class="line">//                    &quot;/sys/devices/virtual/misc/vboxuser&quot;,</span><br><span class="line">//                    &quot;/sys/fs/selinux/booleans/in_qemu&quot;,</span><br><span class="line">//                    &quot;/sys/kernel/debug/bdi/vboxsf-1&quot;,</span><br><span class="line">//                    &quot;/sys/kernel/debug/bdi/vboxsf-2&quot;,</span><br><span class="line">//                    &quot;/sys/kernel/debug/x86&quot;,</span><br><span class="line">//                    &quot;/sys/module/qemu_trace_sysfs&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxguest/drivers/pci:vboxguest&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxpcism&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxsf&quot;,</span><br><span class="line">//                    &quot;/sys/module/vboxvideo&quot;,</span><br><span class="line">//                    &quot;/sys/module/virtio_pt/drivers/virtio:itoolsvmhft&quot;,</span><br><span class="line">//                    &quot;/sys/module/virtio_pt_ie/drivers/virtio:itoolsvmlgtp&quot;,</span><br><span class="line">//                    &quot;/sys/qemu_trace&quot;,</span><br><span class="line">//                    &quot;/system/app/GenymotionLayout&quot;,</span><br><span class="line">//                    &quot;/system/bin/OpenglService&quot;,</span><br><span class="line">//                    &quot;/system/bin/androVM-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/droid4x&quot;,</span><br><span class="line">//                    &quot;/system/bin/droid4x-prop&quot;,</span><br><span class="line">//                    &quot;/system/bin/droid4x-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/droid4x_setprop&quot;,</span><br><span class="line">//                    &quot;/system/bin/enable_nox&quot;,</span><br><span class="line">//                    &quot;/system/bin/genymotion-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/microvirt-prop&quot;,</span><br><span class="line">//                    &quot;/system/bin/microvirt-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/microvirt_setprop&quot;,</span><br><span class="line">//                    &quot;/system/bin/microvirtd&quot;,</span><br><span class="line">//                    &quot;/system/bin/mount.vboxsf&quot;,</span><br><span class="line">//                    &quot;/system/bin/nox&quot;,</span><br><span class="line">//                    &quot;/system/bin/nox-prop&quot;,</span><br><span class="line">//                    &quot;/system/bin/nox-vbox-sf&quot;,</span><br><span class="line">//                    &quot;/system/bin/nox_setprop&quot;,</span><br><span class="line">//                    &quot;/system/bin/noxd&quot;,</span><br><span class="line">//                    &quot;/system/bin/noxscreen&quot;,</span><br><span class="line">//                    &quot;/system/bin/noxspeedup&quot;,</span><br><span class="line">//                    &quot;/system/bin/qemu-props&quot;,</span><br><span class="line">//                    &quot;/system/bin/qemud&quot;,</span><br><span class="line">//                    &quot;/system/bin/shellnox&quot;,</span><br><span class="line">//                    &quot;/system/bin/ttVM-prop&quot;,</span><br><span class="line">//                    &quot;/system/bin/windroyed&quot;,</span><br><span class="line">//                    &quot;/system/droid4x&quot;,</span><br><span class="line">//                    &quot;/system/etc/init.droid4x.sh&quot;,</span><br><span class="line">//                    &quot;/system/etc/init.tiantian.sh&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libEGL_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libEGL_tiantianVM.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libEGL_windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv1_CM_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv1_CM_tiantianVM.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv1_CM_windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv2_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv2_tiantianVM.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/egl/libGLESv2_windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/audio.primary.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/audio.primary.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/audio.primary.x86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/autio.primary.nox.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/camera.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/camera.windroye.jpeg.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/camera.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/camera.x86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gps.nox.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gps.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gps.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gralloc.nox.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gralloc.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/gralloc.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/sensors.nox.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/sensors.vbox86.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/hw/sensors.windroye.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/init.nox.sh&quot;,</span><br><span class="line">//                    &quot;/system/lib/libGM_OpenglSystemCommon.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/libc_malloc_debug_qemu.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/libclcore_x86.bc&quot;,</span><br><span class="line">//                    &quot;/system/lib/libdroid4x.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/libnoxd.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/libnoxspeedup.so&quot;,</span><br><span class="line">//                    &quot;/system/lib/modules/3.10.30-android-x86.hd+&quot;,</span><br><span class="line">//                    &quot;/system/lib/vboxguest.ko&quot;,</span><br><span class="line">//                    &quot;/system/lib/vboxpcism.ko&quot;,</span><br><span class="line">//                    &quot;/system/lib/vboxsf.ko&quot;,</span><br><span class="line">//                    &quot;/system/lib/vboxvideo.ko&quot;,</span><br><span class="line">//                    &quot;/system/lib64/egl/libEGL_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib64/egl/libGLESv1_CM_emulation.so&quot;,</span><br><span class="line">//                    &quot;/system/lib64/egl/libGLESv2_emulation.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/egl/libEGL_emulation.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/egl/libGLESv1_CM_emulation.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/egl/libGLESv2_emulation.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libandroidemu.so&quot;,</span><br><span class="line">//                    &quot;/system/lib64/hw/gralloc.ranchu.so&quot;,</span><br><span class="line">//                    &quot;/system/lib64/libc_malloc_debug_qemu.so&quot;,</span><br><span class="line">//                    &quot;/system/usr/Keylayout/droid4x_Virtual_Input.kl&quot;,</span><br><span class="line">//                    &quot;/system/usr/idc/Genymotion_Virtual_Input.idc&quot;,</span><br><span class="line">//                    &quot;/system/usr/idc/droid4x_Virtual_Input.idc&quot;,</span><br><span class="line">//                    &quot;/system/usr/idc/nox_Virtual_Input.idc&quot;,</span><br><span class="line">//                    &quot;/system/usr/idc/windroye.idc&quot;,</span><br><span class="line">//                    &quot;/system/usr/keychars/nox_gpio.kcm&quot;,</span><br><span class="line">//                    &quot;/system/usr/keychars/windroye.kcm&quot;,</span><br><span class="line">//                    &quot;/system/usr/keylayout/Genymotion_Virtual_Input.kl&quot;,</span><br><span class="line">//                    &quot;/system/usr/keylayout/nox_Virtual_Input.kl&quot;,</span><br><span class="line">//                    &quot;/system/usr/keylayout/nox_gpio.kl&quot;,</span><br><span class="line">//                    &quot;/system/usr/keylayout/windroye.kl&quot;,</span><br><span class="line">//                    &quot;system/etc/init/ndk_translation_arm64.rc&quot;,</span><br><span class="line">//                    &quot;/system/xbin/noxsu&quot;,</span><br><span class="line">//                    &quot;/ueventd.android_x86.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.andy.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.goldfish.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.nox.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.ranchu.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.ttVM_x86.rc&quot;,</span><br><span class="line">//                    &quot;/ueventd.vbox86.rc&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libgoldfish-ril.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libgoldfish_codecs_common.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libstagefright_goldfish_avcdec.so&quot;,</span><br><span class="line">//                    &quot;/vendor/lib64/libstagefright_goldfish_vpxdec.so&quot;,</span><br><span class="line">//                    &quot;/x86.prop&quot;</span><br><span class="line">//            &#125;;</span><br><span class="line">//            for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">//                String f = strArr[i];</span><br><span class="line">//                if (new File(f).exists())</span><br><span class="line">//                    choose.add(f);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125; catch (Exception e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;generic&quot;,</span><br><span class="line">                    &quot;vbox&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.FINGERPRINT.contains(str))</span><br><span class="line">                    choose.add(Build.FINGERPRINT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;google_sdk&quot;,</span><br><span class="line">                    &quot;emulator&quot;,</span><br><span class="line">                    &quot;android sdk built for&quot;,</span><br><span class="line">                    &quot;droid4x&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.MODEL.contains(str))</span><br><span class="line">                    choose.add(Build.MODEL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;Genymotion&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.MANUFACTURER.contains(str))</span><br><span class="line">                    choose.add(Build.MANUFACTURER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;google_sdk&quot;, &quot;sdk_phone&quot;, &quot;sdk_x86&quot;, &quot;vbox86p&quot;, &quot;nox&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.PRODUCT.toLowerCase(Locale.ROOT).contains(str))</span><br><span class="line">                    choose.add(Build.PRODUCT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;nox&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.BOARD.toLowerCase(Locale.ROOT).contains(str))</span><br><span class="line">                    choose.add(Build.BOARD);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;nox&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.BOOTLOADER.toLowerCase(Locale.ROOT).contains(str))</span><br><span class="line">                    choose.add(Build.BOOTLOADER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            String[] myArr = &#123;</span><br><span class="line">                    &quot;ranchu&quot;, &quot;vbox86&quot;, &quot;goldfish&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String str : myArr) &#123;</span><br><span class="line">                if (Build.HARDWARE.equalsIgnoreCase(str))</span><br><span class="line">                    choose.add(Build.HARDWARE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">            while (networkInterfaces.hasMoreElements()) &#123;</span><br><span class="line">                NetworkInterface ele = networkInterfaces.nextElement();</span><br><span class="line">                if (ele != null) &#123;</span><br><span class="line">                    Enumeration&lt;InetAddress&gt; inetAddresses = ele.getInetAddresses();</span><br><span class="line">                    while (inetAddresses.hasMoreElements()) &#123;</span><br><span class="line">                        InetAddress nextElement = inetAddresses.nextElement();</span><br><span class="line">                        if (!nextElement.isLoopbackAddress() &amp;&amp;</span><br><span class="line">                                (nextElement instanceof Inet4Address)) &#123;</span><br><span class="line">                            String ip = nextElement.getHostAddress();</span><br><span class="line">                            if (ip == null) continue;</span><br><span class="line">                            if (ip.equalsIgnoreCase(&quot;10.0.2.15&quot;) ||</span><br><span class="line">                                    ip.equalsIgnoreCase(&quot;10.0.2.16&quot;)) &#123;</span><br><span class="line">                                choose.add(ip);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">//        try &#123;</span><br><span class="line">//            String[] qemuProps = &#123;</span><br><span class="line">//                    &quot;ro.kernel.qemu.avd_name&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.gles&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.gltransport&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.opengles.version&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.uirenderer&quot;,</span><br><span class="line">//                    &quot;ro.kernel.qemu.vsync&quot;,</span><br><span class="line">//                    &quot;ro.qemu.initrc&quot;,</span><br><span class="line">//                    &quot;init.svc.qemu-props&quot;,</span><br><span class="line">//                    &quot;qemu.adb.secure&quot;,</span><br><span class="line">//                    &quot;qemu.cmdline&quot;,</span><br><span class="line">//                    &quot;qemu.hw.mainkeys&quot;,</span><br><span class="line">//                    &quot;qemu.logcat&quot;,</span><br><span class="line">//                    &quot;ro.adb.qemud&quot;,</span><br><span class="line">//                    &quot;qemu.sf.fake_camera&quot;,</span><br><span class="line">//                    &quot;qemu.sf.lcd_density&quot;,</span><br><span class="line">//                    &quot;qemu.timezone&quot;,</span><br><span class="line">//                    &quot;init.svc.goldfish-logcat&quot;,</span><br><span class="line">//                    &quot;ro.boottime.goldfish-logcat&quot;,</span><br><span class="line">//                    &quot;ro.hardware.audio.primary&quot;,</span><br><span class="line">//                    &quot;init.svc.ranchu-net&quot;,</span><br><span class="line">//                    &quot;init.svc.ranchu-setup&quot;,</span><br><span class="line">//                    &quot;ro.boottime.ranchu-net&quot;,</span><br><span class="line">//                    &quot;ro.boottime.ranchu-setup&quot;,</span><br><span class="line">//                    &quot;init.svc.droid4x&quot;,</span><br><span class="line">//                    &quot;init.svc.noxd&quot;,</span><br><span class="line">//                    &quot;init.svc.qemud&quot;,</span><br><span class="line">//                    &quot;init.svc.goldfish-setup&quot;,</span><br><span class="line">//                    &quot;init.svc.goldfish-logcat&quot;,</span><br><span class="line">//                    &quot;init.svc.ttVM_x86-setup&quot;,</span><br><span class="line">//                    &quot;vmos.browser.home&quot;,</span><br><span class="line">//                    &quot;vmos.camera.enable&quot;,</span><br><span class="line">//                    &quot;ro.trd_yehuo_searchbox&quot;,</span><br><span class="line">//                    &quot;init.svc.microvirtd&quot;,</span><br><span class="line">//                    &quot;init.svc.vbox86-setup&quot;,</span><br><span class="line">//                    &quot;ro.ndk_translation.version&quot;,</span><br><span class="line">//                    &quot;redroid.width&quot;,</span><br><span class="line">//                    &quot;redroid.height&quot;,</span><br><span class="line">//                    &quot;redroid.fps&quot;,</span><br><span class="line">//                    &quot;ro.rf.vmname&quot;</span><br><span class="line">//            &#125;;</span><br><span class="line">//</span><br><span class="line">//            for (String str : qemuProps) &#123;</span><br><span class="line">//                String val = SystemPropertiesUtils.getProperty(str, null);</span><br><span class="line">//                if (val != null) &#123;</span><br><span class="line">//                    choose.add(str);</span><br><span class="line">//                &#125;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125; catch (Throwable e) &#123;</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//        &#125;</span><br><span class="line">        //判断是否存在指定硬件</span><br><span class="line">        PackageManager pm = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            pm = context.getPackageManager();</span><br><span class="line">            String[] features = &#123;</span><br><span class="line">                    //PackageManager.FEATURE_RAM_NORMAL,//这个存在问题,自己组装的手机可能导致这个痕迹找不到</span><br><span class="line">                    PackageManager.FEATURE_BLUETOOTH,</span><br><span class="line">                    PackageManager.FEATURE_CAMERA_FLASH,</span><br><span class="line">                    PackageManager.FEATURE_TELEPHONY</span><br><span class="line">            &#125;;</span><br><span class="line">            for (String feature : features) &#123;</span><br><span class="line">                if (!pm.hasSystemFeature(feature)) &#123;</span><br><span class="line">                    choose.add(feature);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">        String[] emuPkgs = &#123;</span><br><span class="line">                &quot;com.google.android.launcher.layouts.genymotion&quot;,</span><br><span class="line">                &quot;com.bluestacks&quot;,</span><br><span class="line">                &quot;com.bignox.app&quot;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        for (String pkg : emuPkgs) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (pm != null) &#123;</span><br><span class="line">                    pm.getPackageInfo(pkg, 0);</span><br><span class="line">                &#125;</span><br><span class="line">                choose.add(pkg);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                //e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable ignored) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">        SensorManager sensor = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);</span><br><span class="line">        int sensorSize = sensor.getSensorList(Sensor.TYPE_ALL).size();</span><br><span class="line">        for (int i = 0; i &lt; sensorSize; i++) &#123;</span><br><span class="line">            Sensor s = sensor.getDefaultSensor(i);</span><br><span class="line">            if (s != null &amp;&amp; s.getName().contains(&quot;Goldfish&quot;)) &#123;</span><br><span class="line">                choose.add(s.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable ignored) &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">        if (checkSelfPermission(context, &quot;android.permission.READ_SMS&quot;) == 0 ||</span><br><span class="line">                checkSelfPermission(context, &quot;android.permission.READ_PHONE_NUMBERS&quot;) == 0 ||</span><br><span class="line">                    checkSelfPermission(context, &quot;android.permission.READ_PHONE_STATE&quot;) == 0) &#123;</span><br><span class="line">            TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">            String phoneNumber = telephonyManager.getLine1Number();</span><br><span class="line"> </span><br><span class="line">            String[] phoneNumbers = &#123;</span><br><span class="line">                    &quot;15555215554&quot;,</span><br><span class="line">                    &quot;15555215556&quot;,</span><br><span class="line">                    &quot;15555215558&quot;,</span><br><span class="line">                    &quot;15555215560&quot;,</span><br><span class="line">                    &quot;15555215562&quot;,</span><br><span class="line">                    &quot;15555215564&quot;,</span><br><span class="line">                    &quot;15555215566&quot;,</span><br><span class="line">                    &quot;15555215568&quot;,</span><br><span class="line">                    &quot;15555215570&quot;,</span><br><span class="line">                    &quot;15555215572&quot;,</span><br><span class="line">                    &quot;15555215574&quot;,</span><br><span class="line">                    &quot;15555215576&quot;,</span><br><span class="line">                    &quot;15555215578&quot;,</span><br><span class="line">                    &quot;15555215580&quot;,</span><br><span class="line">                    &quot;15555215582&quot;,</span><br><span class="line">                    &quot;15555215584&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            if(phoneNumber!=null) &#123;</span><br><span class="line">                for (String phone : phoneNumbers) &#123;</span><br><span class="line">                    if (phoneNumber.equalsIgnoreCase(phone)) &#123;</span><br><span class="line">                        choose.add(phone);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (choose.size() &gt; 0) &#123;</span><br><span class="line">        ListItemBean item = new ListItemBean(&quot;检测到APK运行在虚拟机&amp;模拟器中&quot;,</span><br><span class="line">                ListItemBean.RiskLeave.Deadly,</span><br><span class="line">                choose.toString()</span><br><span class="line">        );</span><br><span class="line">        for (String str : choose) &#123;</span><br><span class="line">            item.putData(str);</span><br><span class="line">        &#125;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Android系统提供了一个<code>android.os.Build</code>类，其中包含了大量关于设备硬件和软件版本的信息</p>
<ul>
<li>**<code>Build.FINGERPRINT</code> (设备指纹)**：官方模拟器（AVD）的指纹通常以 <code>generic/</code> 开头。许多基于VirtualBox的模拟器（如Genymotion、Nox）的指纹中可能会包含<code>vbox</code>字样。而真实设备的指纹通常是制造商和型号的组合，如 <code>samsung/sm-g9980/...</code>。</li>
<li>**<code>Build.MODEL</code> (设备型号)**：AVD的型号通常是<code>sdk_gphone64_x86_64</code>或<code>Android SDK built for x86</code>等。Droid4X（卓壮模拟器）也会明确标识其型号。真实设备的型号则是<code>Pixel 7 Pro</code>, <code>SM-G9980</code>等。</li>
<li>**<code>Build.MANUFACTURER</code> (制造商)**：Genymotion模拟器会将其制造商设置为<code>Genymotion</code>。真实设备则为<code>Google</code>, <code>Samsung</code>, <code>Xiaomi</code>等</li>
<li>**<code>Build.PRODUCT</code> (产品名称)**：与型号类似，模拟器的产品名也通常是通用的<code>sdk_x86</code>或带有模拟器标识的名称，如<code>nox</code>（夜神模拟器）、<code>vbox86p</code>（VirtualBox平台）</li>
<li>**<code>Build.BOARD</code> &#x2F; <code>Build.BOOTLOADER</code> (主板&#x2F;引导程序)**：某些模拟器（如夜神）可能会在这些更底层的标识中留下自己的名字。</li>
<li>**<code>Build.HARDWARE</code> (硬件名称)**：是非常可靠的指标。<code>goldfish</code>是早期AVD使用的虚拟硬件平台名称。<code>ranchu</code>是较新版AVD使用的虚拟硬件平台。<code>vbox86</code>明确指向了VirtualBox x86平台。真实设备的硬件名称通常是芯片组的代号，如<code>qcom</code> (高通), <code>kirin</code> (麒麟), <code>exynos</code> (猎户座)</li>
</ul>
<p>**网络环境特征 (Network Environment)**：这是官方Android模拟器（AVD）的默认网络配置。在AVD内部，它通过一个虚拟路由器连接到宿主机网络。这个虚拟路由器将<code>10.0.2.15</code>这个IP地址分配给模拟器本身。这是一个广为人知的特征。</p>
<p><strong>硬件功能缺失 (Missing Hardware Features)：</strong>使用<code>PackageManager.hasSystemFeature()</code>检查设备是否缺少蓝牙 (<code>FEATURE_BLUETOOTH</code>)、相机闪光灯 (<code>FEATURE_CAMERA_FLASH</code>) 或电话功能 (<code>FEATURE_TELEPHONY</code>)。模拟器为了节省资源，通常不会去模拟这些不常用的硬件</p>
<p><strong>特定应用包名 (Specific Application Packages)：</strong>检查设备上是否安装了特定包名的应用，如<code>com.bluestacks</code> (蓝叠), <code>com.bignox.app</code> (夜神)</p>
<p><code>com.google.android.launcher.layouts.genymotion</code> (Genymotion的定制启动器)。</p>
<p>许多模拟器会预装一些自家的辅助工具、应用商店或服务。通过检查这些应用的包名是否存在，可以直接识别出对应的模拟器</p>
<p><strong>硬件和驱动特征 (Hardware and Driver Signatures)：</strong>与<code>Build.HARDWARE</code>中的<code>goldfish</code>类似，AVD模拟的传感器（如加速度计、陀螺仪等）也是基于”Goldfish”虚拟硬件的，因此它们的驱动名称会暴露这一信息。真实设备的传感器名称通常来自博世(Bosch)、意法半导体(STMicro)等硬件制造商</p>
<p><strong>设备信息特征 (Device Information)：</strong>官方模拟器允许设置一个电话号码用于测试，这些<code>1555...</code>开头的号码是Android文档中指定的官方测试号码。如果在设备上读到了这些号码，几乎可以肯定是模拟器环境。此项检测需要<code>READ_PHONE_STATE</code>等相关权限</p>
<p>**文件系统特征 (File System Artifacts) - *已注释***：模拟器为了正常运行，会在Android文件系统的各个角落留下自己的组件。</p>
<ul>
<li><p><strong>QEMU&#x2F;AVD相关</strong>: <code>qemu_pipe</code>, <code>fstab.goldfish</code>, <code>init.ranchu.rc</code>,</p>
<p> <code>/sys/fs/selinux/booleans/in_qemu</code> 等，这些都与QEMU虚拟机引擎直接相关。</p>
</li>
<li><p><strong>VirtualBox相关</strong>: <code>vboxguest.ko</code>, <code>vboxsf.ko</code>, <code>mount.vboxsf</code>, <code>/sys/module/vboxguest</code> 等，这些是VirtualBox的Guest Additions（增强功能）组件，用于虚拟机和宿主机之间的通信与集成。</p>
</li>
<li><p><strong>特定模拟器</strong>: <code>init.nox.rc</code> (夜神), <code>droid4x</code> (卓壮), <code>GenymotionLayout</code> (Genymotion), <code>init.tiantian.sh</code> (天天模拟器), <code>windroyed</code> (文卓爷) 等，这些是各家模拟器专属的配置文件、可执行文件或库文件。</p>
</li>
</ul>
<p>**系统属性特征 (System Properties) - *已注释***：</p>
<p>除了<code>Build</code>类提供的标准信息，Android系统内部还有大量的系统属性（ro.开头的只读属性和qemu.等其他属性）。模拟器会设置很多特定的属性来控制其行为。</p>
<ul>
<li><code>ro.kernel.qemu.*</code>: 明确表示内核是在QEMU环境下运行。</li>
<li><code>init.svc.*</code>: 检查是否有模拟器相关的服务在运行，如<code>init.svc.qemud</code>, <code>init.svc.noxd</code>。</li>
<li><code>redroid.*</code>, <code>ro.rf.vmname</code>: 这些是云手机方案（如Redroid, 红手指）特有的属性。</li>
</ul>
<h3 id="检测云手机"><a href="#检测云手机" class="headerlink" title="检测云手机"></a>检测云手机</h3><p>这块思路还是很多的，不同的云手机检测的思路也不一样 。大部分云手机做的还是很好的，很多都可以过掉<code>Hunter</code>的检测 。</p>
<h4 id="检测电流-电压"><a href="#检测电流-电压" class="headerlink" title="检测电流&amp;电压"></a>检测电流&amp;电压</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private final BroadcastReceiver batteryInfoReceiver = new BroadcastReceiver() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"> </span><br><span class="line">        // 电池状态</span><br><span class="line">        int plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line"> </span><br><span class="line">        // 电压（以毫伏为单位）</span><br><span class="line">        int voltage = intent.getIntExtra(BatteryManager.EXTRA_VOLTAGE, -1);</span><br><span class="line"> </span><br><span class="line">        // 获取电池电流（毫安）</span><br><span class="line">        int currentNow = -1;</span><br><span class="line">        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            BatteryManager batteryManager = (BatteryManager) context.getSystemService(Context.BATTERY_SERVICE);</span><br><span class="line">            currentNow = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CURRENT_NOW);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 判断是否在充电</span><br><span class="line">        if (plugged == BatteryManager.BATTERY_PLUGGED_AC || plugged == BatteryManager.BATTERY_PLUGGED_USB || plugged == BatteryManager.BATTERY_PLUGGED_WIRELESS) &#123;</span><br><span class="line">            // 在充电</span><br><span class="line">            if (voltage != -1 &amp;&amp; currentNow != -1) &#123;</span><br><span class="line">                float voltageInVolts = voltage / 1000f; // 将电压转换为伏特</span><br><span class="line">                float currentInAmperes = currentNow / 1000000f; // 将电流转换为安培</span><br><span class="line">                float chargingPower = voltageInVolts * currentInAmperes; // 计算充电功率（瓦特）</span><br><span class="line">                CLog.i(String.format(&quot;充电功率: %.2fW&quot;, chargingPower));</span><br><span class="line">                if (Math.abs(chargingPower) &gt; 300) &#123;</span><br><span class="line">                    CLog.e(&quot;充电功率过高&quot;);</span><br><span class="line">                    handlerItemData(new ListItemBean(</span><br><span class="line">                            &quot;电池异常:充电功率过高(可能是云手机)&quot;,</span><br><span class="line">                            ListItemBean.RiskLeave.Deadly,</span><br><span class="line">                            &quot;检测到过大的充电功率 -&gt; &quot; + String.format(&quot;%.2fW&quot;, Math.abs(chargingPower))</span><br><span class="line">                    ));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="检测摄像头-传感器相关"><a href="#检测摄像头-传感器相关" class="headerlink" title="检测摄像头&amp;传感器相关"></a>检测摄像头&amp;传感器相关</h4><p>判断摄像头有个数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    CameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">    String[] cameraIds = manager.getCameraIdList();</span><br><span class="line">    //摄像头个数</span><br><span class="line">    CLog.i(&quot;cameraIds -&gt; &quot;+ Arrays.toString(cameraIds));</span><br><span class="line">    if(cameraIds.length &lt; CAMERA_MINIMUM_QUANTITY_LIMIT)&#123;</span><br><span class="line">        items.add(</span><br><span class="line">                new ListItemBean(</span><br><span class="line">                &quot;当前手机可能是模拟器&amp;云手机&quot;,</span><br><span class="line">                ListItemBean.RiskLeave.Warn,</span><br><span class="line">                &quot;camera size -&gt; &quot;+cameraIds.length</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Throwable ignored) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测传感器个数"><a href="#检测传感器个数" class="headerlink" title="检测传感器个数"></a>检测传感器个数</h4><p>这块思路就是直接获取个数，少于<code>10</code>个可以直接认定为黑产 。 我目前没发现那个手机少于10个传感器 ，这块如果可能的话可以尝试调用一下传感器，保证传感器是否可用 ，防止云手机以假乱真 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //3,检测传感器类型,支持的全部类型传感器</span><br><span class="line">    SensorManager sm = (SensorManager) context.getSystemService(SENSOR_SERVICE);</span><br><span class="line">    List&lt;Sensor&gt; sensorlist = sm.getSensorList(Sensor.TYPE_ALL);</span><br><span class="line"> </span><br><span class="line">    ArrayList&lt;Integer&gt; sensorTypeS = new ArrayList&lt;&gt;();</span><br><span class="line">    for (Sensor sensor : sensorlist) &#123;</span><br><span class="line">        //获取传感器类型</span><br><span class="line">        int type = sensor.getType();</span><br><span class="line">        if (!sensorTypeS.contains(type)) &#123;</span><br><span class="line">            //发现一种类型则添加一种类型</span><br><span class="line">            sensorTypeS.add(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //小米k40 51个传感器类型</span><br><span class="line">    //普通的pix 27个</span><br><span class="line">    //华为荣耀20 18个传感器</span><br><span class="line">    CLog.e(&quot;sensor types size -&gt; &quot; + sensorlist.size());</span><br><span class="line">    //我们认为传感器少于20个则认为是风险设备</span><br><span class="line">    if (sensorlist.size() &lt; SENSOR_MINIMUM_QUANTITY_LIMIT) &#123;</span><br><span class="line">        items.add(new ListItemBean(</span><br><span class="line">                &quot;当前手机可能是模拟器&amp;云手机&quot;,</span><br><span class="line">                ListItemBean.RiskLeave.Warn,</span><br><span class="line">                &quot;sensor size -&gt; (&quot;+ sensorlist.size()+&quot;) \n&quot; +</span><br><span class="line">                &quot;sensor type size -&gt; (&quot;+sensorTypeS.size()+&quot;) \n&quot;</span><br><span class="line">                //+ &quot;sensor info -&gt; \n&quot;+ Sensorlist   //打印全部传感器信息</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测传感器名称"><a href="#检测传感器名称" class="headerlink" title="检测传感器名称"></a>检测传感器名称</h4><p>这块检测思路主要是检测传感器的名称，正常小米之类的手机他是不可能存在叫什么 <code>AOSP</code>的传感器的 。</p>
<p>这种<code>AOSP</code>基本都是自己编译的<code>ROM</code> ，所以这块也可以作为监测点 。可以上报传感器的一些名称信息，也是环境检测一个很重要的抓手</p>
<p>一般小白肯定不会说去改传感器名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    ArrayList&lt;Sensor&gt; aospSensor = new ArrayList&lt;&gt;();</span><br><span class="line">    for(Sensor sensor:sensorlist)&#123;</span><br><span class="line">        if(sensor.getVendor().contains(&quot;AOSP&quot;))&#123;</span><br><span class="line">            aospSensor.add(sensor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (aospSensor.size()&gt;3) &#123;</span><br><span class="line">        CLog.e(&quot;传感器参数是否异常(生产厂商为AOSP)&quot;);</span><br><span class="line">        items.add(new ListItemBean(</span><br><span class="line">                &quot;当前手机可能是模拟器&amp;云手机&quot;,</span><br><span class="line">                ListItemBean.RiskLeave.Warn,</span><br><span class="line">                aospSensor.size()</span><br><span class="line">                        +&quot;/&quot;+sensorlist.size()+&quot;传感器参数异常 -&gt; &quot;+ aospSensor</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测挂载文件"><a href="#检测挂载文件" class="headerlink" title="检测挂载文件"></a>检测挂载文件</h4><p>这块就是去遍历<code>mounts</code> 下面这几个文件，检测里面是否包含<code>docker</code>关键字 ，防止一些云手机搞虚拟化，通过使用<code>docker</code>进行挂载 。</p>
<p>这块也是很好的监测点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String[] marks = &#123;&quot;docker&quot;&#125;;</span><br><span class="line">//检测proc/mounts是否包含docker关键字</span><br><span class="line">String mark = NativeEngine.getZhenxiInfoK(&quot;/proc/mounts&quot;,marks );</span><br><span class="line">if(mark == null)&#123;</span><br><span class="line">    mark = NativeEngine.getZhenxiInfoK(&quot;/proc/self/mountstats&quot;, marks);</span><br><span class="line">    if(mark == null)&#123;</span><br><span class="line">        mark = NativeEngine.getZhenxiInfoK(&quot;/proc/self/mountinfo&quot;, marks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(mark!=null)&#123;</span><br><span class="line">    items.add(new ListItemBean(</span><br><span class="line">            &quot;当前手机可能是模拟器&amp;云手机&quot;,</span><br><span class="line">            ListItemBean.RiskLeave.Warn,</span><br><span class="line">            &quot;(mounts异常)\n&quot;+mark</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检测ROM是否Match"><a href="#检测ROM是否Match" class="headerlink" title="检测ROM是否Match"></a>检测ROM是否Match</h4><h5 id="检测环境信息："><a href="#检测环境信息：" class="headerlink" title="检测环境信息："></a>检测环境信息：</h5><p>这块思路主要好多种 ，主要是为了防止一些自定义<code>ROM</code> ，通过修改机型的方法，绕过自定义<code>ROM</code>检测逃逸 </p>
<p>可以直接执行<code>getprop</code> 把所有的环境信息都拿到手 ，如果是小米手机，里面环境信息里面，肯定是有MIUI关键字。</p>
<p>比如小米的手机，我会去检测是否包含这几个关键环境信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final String KEY_MIUI_VERSION_NAME = &quot;ro.miui.ui.version.name&quot;;</span><br><span class="line">private static final String KEY_MIUI_VERSION_CODE = &quot;ro.miui.ui.version.code&quot;;</span><br><span class="line">private static final String KEY_MIUI_INTERNAL_STORAGE = &quot;ro.miui.internal.storage&quot;;</span><br></pre></td></tr></table></figure>

<p>这块可以采集以后服务端进行判断。防止自定义ROM 机型伪造</p>
<h5 id="检测服务列表："><a href="#检测服务列表：" class="headerlink" title="检测服务列表："></a>检测服务列表：</h5><p>这块还是执行 <code>service list</code> ，一般小米手机之类的，都会有小米的系统服务，这种东西很难去伪造，如果他伪造了假的 。你就尝试调用即可</p>
<p>这块还是建议上传到服务端，由服务端算法同学去根据相似度算法去推断，不要再本地进行判断 ，因为<code>Hunter</code>是非联网<code>Apk</code>，所以只是在客户端打了个样子</p>
<h3 id="检测当前环境是否被Hook"><a href="#检测当前环境是否被Hook" class="headerlink" title="检测当前环境是否被Hook"></a>检测当前环境是否被Hook</h3><p>这块检测方法千奇百怪，首先最基本maps去检测frida或者根据调用栈检测lsp特征 ，基础的检测方案不说了 。因为我觉得并不是一个很好的方案 。改个名就绕过了 。</p>
<p>比如frida特征三件套 。检测思路主要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static const char *FRIDA_THREAD_GUM_JS_LOOP = &quot;gum-js-loop&quot;;</span><br><span class="line">static const char *FRIDA_THREAD_GMAIN = &quot;gmain&quot;;</span><br><span class="line">static const char *FRIDA_NAMEDPIPE_LINJECTOR = &quot;linjector&quot;;</span><br></pre></td></tr></table></figure>

<p>Hook检测，我们其实只需要检测内存没有被修改即可 。这块需要介绍一下基础原理。和实现的伪代码 。</p>
<p>正常我们知道一个SO加载到内存里，本质上是通过mmap把so分配到内存里面 ，比如A函数的指令是BBB，那么加载到内存里面应该也是BBB 。</p>
<p>记住上面这句话 ，我们就可以对内存里面的指令转换成一个int值，然后累加 。如果内存没有被修改 ，累加值文件里面和内存里面的值应该是一样的 。</p>
<p>因为现在Hook基本都是text段和plt端，一个<code>inlinehook</code>一个<code>got</code>表 。当然Frida可能会延迟启动 ，所以开启一条检测线程，进行轮训操作。</p>
<p>这块还有一个设计问题，很多开发者也都没注意到 ，就是我开启的这一条线程，被攻击者<code>anti</code>掉 应该怎么办呢？</p>
<p>因为想要anti掉一条检测线程，方法太多了，N种方法，比如监听全部线程的文件读写，看看那个线程在读取文件 ，只做这一件事，基本八九不离十 ，</p>
<p>也可以直接Hook开启线程的方法，对开启的线程进行anti 。当然这种思路 就没有好的对抗或者检测办法了么？</p>
<blockquote>
<p><strong>其实很简单 ，只需要把在你的检测代码里，对某个变量进行赋值 ，修改flag即可 。</strong></p>
<p><strong>然后第一次检测完毕以后将主进程的某个变量标志为true，可以使用__NR_process_vm_writev ，又因为是异步的关系，主线程可以延迟2秒对这个标识进行获取，判断是否为true ，</strong></p>
<p><strong>以确保检测线程成功开启 。</strong></p>
</blockquote>
<p>具体检测流程如下，以检测libc为例子，路径可以换成自己需要的路径 ：</p>
<p>首先获取本地So文件的累加值 ，返回<code>execSection</code> 结构体 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">//记录可执行段的结构体,一个是plt段一个是text段</span><br><span class="line">//所以对应的数量是2</span><br><span class="line">typedef struct stExecSection &#123;</span><br><span class="line">    int execSectionCount;</span><br><span class="line">    unsigned long offset[2];</span><br><span class="line">    unsigned long memsize[2];</span><br><span class="line">    unsigned long checksum[2];</span><br><span class="line">    unsigned long startAddrinMem;</span><br><span class="line">    bool isSuccess = false;</span><br><span class="line">&#125; execSection;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 获取本地文件的 Check sum</span><br><span class="line"> * 读取耗时操作,只初始化一次保存到本地。</span><br><span class="line"> */</span><br><span class="line">execSection fetch_checksum_of_library(const char *filePath) &#123;</span><br><span class="line">    execSection section = &#123;0&#125;;</span><br><span class="line">    Elf_Ehdr ehdr;</span><br><span class="line">    Elf_Shdr sectHdr;</span><br><span class="line">    int fd;</span><br><span class="line">    int execSectionCount = 0;</span><br><span class="line">    fd = my_openat(AT_FDCWD, filePath, O_RDONLY, 0);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        return section;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    my_read(fd, &amp;ehdr, sizeof(Elf_Ehdr));</span><br><span class="line">    my_lseek(fd, (off_t) ehdr.e_shoff, SEEK_SET);</span><br><span class="line"> </span><br><span class="line">    unsigned long memSize[2] = &#123;0&#125;;</span><br><span class="line">    unsigned long offset[2] = &#123;0&#125;;</span><br><span class="line"> </span><br><span class="line">    //查找section的plt和text开始位置和长度</span><br><span class="line">    for (int i = 0; i &lt; ehdr.e_shnum; i++) &#123;</span><br><span class="line">        my_memset(&amp;sectHdr, 0, sizeof(Elf_Shdr));</span><br><span class="line">        my_read(fd, &amp;sectHdr, sizeof(Elf_Shdr));</span><br><span class="line">        //通常 PLT and Text 一般都是可执行段</span><br><span class="line">        if (sectHdr.sh_flags &amp; SHF_EXECINSTR) &#123;</span><br><span class="line">            offset[execSectionCount] = sectHdr.sh_offset;</span><br><span class="line">            memSize[execSectionCount] = sectHdr.sh_size;</span><br><span class="line">            execSectionCount++;</span><br><span class="line">            if (execSectionCount == 2) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (execSectionCount == 0) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; &quot;get elf section error &quot; &lt;&lt; filePath;</span><br><span class="line">        my_close(fd);</span><br><span class="line">        return section;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //记录个数</span><br><span class="line">    section.execSectionCount = execSectionCount;</span><br><span class="line"> </span><br><span class="line">    section.startAddrinMem = 0;</span><br><span class="line">    for (int i = 0; i &lt; execSectionCount; i++) &#123;</span><br><span class="line">        my_lseek(fd, (off_t) offset[i], SEEK_SET);</span><br><span class="line">        //void * buffer = alloca(memSize[i] * sizeof(uint8_t));</span><br><span class="line">        //存放text或者plt全部的数据内容,大约5-10M大小,为了兼容小内存手机。</span><br><span class="line">        //所以放在堆里面,而不是栈,防止小内存手机栈指针溢出。</span><br><span class="line">        auto buffer = (void *) calloc(1, memSize[i] * sizeof(uint8_t));</span><br><span class="line">        if (buffer == nullptr) &#123;</span><br><span class="line">            free(buffer);</span><br><span class="line">            return section;</span><br><span class="line">        &#125;</span><br><span class="line">        my_read(fd, buffer, memSize[i]);</span><br><span class="line">        section.offset[i] = offset[i];</span><br><span class="line">        section.memsize[i] = memSize[i];</span><br><span class="line">        section.checksum[i] = checksum(buffer, memSize[i]);</span><br><span class="line"> </span><br><span class="line">//        LOGE(&quot;fetch_checksum_of_library %s ExecSection:[%d][%ld][%ld][%ld]&quot;,</span><br><span class="line">//             filePath, i, offset[i], memSize[i], section-&gt;checksum[i])</span><br><span class="line">        free(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    section.isSuccess = true;</span><br><span class="line">    my_close(fd);</span><br><span class="line">    return section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后和本地的指令去计算 。计算本地的指令方法就是对maps进行遍历，只遍历text和plt段 ，计算累加值和本地进行判断 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 检测问的check sum</span><br><span class="line"> * 检测到check未修改返回0</span><br><span class="line"> * 检测已修改返回1</span><br><span class="line"> * 检测失败返回-1</span><br><span class="line"> */</span><br><span class="line">int detect_elf_checksum(const char *soPath, execSection *pSection) &#123;</span><br><span class="line">    if (pSection == nullptr) &#123;</span><br><span class="line">        LOGI(&quot;detect_elf_checksum execSection == null  &quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    char map[MAX_LINE];</span><br><span class="line">    const char *maps_path = string(&quot;proc/&quot;).append(to_string(getpid())).append(&quot;/maps&quot;).c_str();</span><br><span class="line"> </span><br><span class="line">    int fd = my_openat(AT_FDCWD, maps_path, O_RDONLY, 0);</span><br><span class="line"> </span><br><span class="line">    if (fd &lt;= 0) &#123;</span><br><span class="line">        LOGE(&quot;detect_elf_checksum open %s fail &quot;, PROC_MAPS);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int checkSum = 0;</span><br><span class="line">    while ((read_one_line(fd, map, MAX_LINE)) &gt; 0) &#123;</span><br><span class="line">        if (my_strstr(map, soPath) != nullptr) &#123;</span><br><span class="line">            checkSum = scan_executable_segments(map, pSection, soPath);</span><br><span class="line">            if (checkSum == 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    my_close(fd);</span><br><span class="line">    return checkSum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 检测问的check sum</span><br><span class="line"> * 检测到check未修改返回0</span><br><span class="line"> * 检测已修改返回1</span><br><span class="line"> * 检测失败返回-1</span><br><span class="line"> */</span><br><span class="line">int scan_executable_segments(</span><br><span class="line">        char *mapItem,</span><br><span class="line">        execSection *pElfSectArr,</span><br><span class="line">        const char *libraryName) &#123;</span><br><span class="line">    unsigned long start, end;</span><br><span class="line">    char buf[MAX_LINE] = &quot;&quot;;</span><br><span class="line">    char path[MAX_LENGTH] = &quot;&quot;;</span><br><span class="line">    char tmp[100] = &quot;&quot;;</span><br><span class="line"> </span><br><span class="line">    sscanf(mapItem, &quot;%lx-%lx %s %s %s %s %s&quot;, &amp;start, &amp;end, buf, tmp, tmp, tmp, path);</span><br><span class="line"> </span><br><span class="line">    if (buf[2] == &#x27;x&#x27;) &#123;</span><br><span class="line">        if (buf[0] == &#x27;r&#x27;) &#123;</span><br><span class="line">            uint8_t *buffer;</span><br><span class="line"> </span><br><span class="line">            buffer = (uint8_t *) start;</span><br><span class="line">            for (int i = 0; i &lt; pElfSectArr-&gt;execSectionCount; i++) &#123;</span><br><span class="line">                if (start + pElfSectArr-&gt;offset[i] + pElfSectArr-&gt;memsize[i] &gt; end) &#123;</span><br><span class="line">                    if (pElfSectArr-&gt;startAddrinMem != 0) &#123;</span><br><span class="line">                        buffer = (uint8_t *) pElfSectArr-&gt;startAddrinMem;</span><br><span class="line">                        pElfSectArr-&gt;startAddrinMem = 0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt; pElfSectArr-&gt;execSectionCount; i++) &#123;</span><br><span class="line">                auto begin = (void *) (buffer + pElfSectArr-&gt;offset[i]);</span><br><span class="line">                unsigned long size = pElfSectArr-&gt;memsize[i];</span><br><span class="line">                LOGI(&quot;%s [%p] size -&gt;[%lu]&quot;, libraryName, begin, size);</span><br><span class="line">                //MPROTECT((size_t)begin, size, MEMORY_R);</span><br><span class="line">                unsigned long output = checksum(begin, size);</span><br><span class="line">                LOGI(&quot;%s checksum:[%ld][%ld]&quot;, libraryName, output, pElfSectArr-&gt;checksum[i])</span><br><span class="line">                if (output != pElfSectArr-&gt;checksum[i]) &#123;</span><br><span class="line">                    //和本地的So Checksum 对不上</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (buf[0] == &#x27;r&#x27;) &#123;</span><br><span class="line">            pElfSectArr-&gt;startAddrinMem = start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这块就一定是比较完善的检测方案了么？其实有很多对抗思路 。比如把maps里面的内存进行隐藏，变成匿名内存，这样他在扫描maps的就找不到，对应的比如上面说的libc的item</p>
<p>这块可以参考riru里面的 map_hide ，代码路径如下 </p>
<p><a target="_blank" rel="noopener" href="https://github.com/RikkaApps/Riru/blob/master/riru/src/main/cpp/hide_utils.cpp">https://github.com/RikkaApps/Riru/blob/master/riru/src/main/cpp/hide_utils.cpp</a></p>
<p>当然这种方式一定是安全的么？</p>
<blockquote>
<p>其实，不是的，因为在他的这个代码里面我发现存在一个遗漏点，可以作为检测入手点 ，某个加固厂商，不仅仅会对<code>maps item</code>进行遍历 ，还会对里面的匿名内存进行遍历 ，检测匿名内存里面的 <code>magic</code> ，比如<code>so</code> 文件的<code>magic</code>是<code>elf</code> ，如果<code>magic</code> 匹配上一样当<code>maps</code>去解析 去遍历。</p>
<p>所以可以在原有的基础上改改，在将内存变成匿名内存以后，<strong>把elf的前四个字节抹掉</strong>，也就是magic的 内容，抹掉以后记得把权限修改成和之前的一样 。防止内存检测 。</p>
</blockquote>
<h3 id="检测沙箱"><a href="#检测沙箱" class="headerlink" title="检测沙箱"></a>检测沙箱</h3><p>这块检测核心逻辑全部放在<code>ISO</code>线程检测 。可以配置一个服务，然后服务里使用如下变量即可 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.ZhenxiServer&quot;</span><br><span class="line">    android:isolatedProcess=&quot;true&quot;</span><br><span class="line">    android:useAppZygote=&quot;true&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure>

<p>这块有人可能会问什么是iso线程？<strong>可以理解成一个独立的安全的线程</strong>，只能通过和外部IPC交互的方式进行通讯 。useAppZygote 相当于让这个进程运行在Zygote中 。<strong>这个时候时机特别早</strong>，早到什么程度呢？就<strong>连libart.so 都没加载</strong>，所以这个检测进程只能调用一些原始的libc方法，不能调用任何Art相关的函数 。</p>
<p>下面也是主要介绍一下<code>hunter</code>的检测思路 。</p>
<h4 id="检测多余线程PID"><a href="#检测多余线程PID" class="headerlink" title="检测多余线程PID:"></a>检测多余线程PID:</h4><p>主要实现思路就是去检测proc下面是否有除了main进程以外的其他pid ,因为正常启动的话，肯定是只有一个main进程 。</p>
<p>但是沙箱的话会在启动之前去启动别的进程 ，所以这块可以进行bypass 。后面我会统一说这块应该如何对抗 ，包括如何绕过</p>
<p>这块先介绍检测思路 ，和检测原理 。这块里面有一个<code>replaceSecInsns</code>是封装的一个函数，我担心 <code>opendir</code> 被<code>Hook</code>了，所以每次执行都去把指令替换成</p>
<p>本地文件的指令，而不是去执行内存里面的指令 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">auto orig_opendir = reinterpret_cast&lt;DIR *(*)</span><br><span class="line">            (const char *)&gt;(replaceSecInsns(getlibcPath(), &quot;opendir&quot;));</span><br><span class="line">    DIR *pdr = orig_opendir(&quot;/proc&quot;);</span><br><span class="line">    if (pdr == nullptr) &#123;</span><br><span class="line">        return getItemData(env, &quot;程序出错请放弃修改后重试&quot;,</span><br><span class="line">                           nullptr, true, RISK_LEAVE_DEADLY, TAG_SANDBOX);</span><br><span class="line">    &#125;</span><br><span class="line">    auto orig_ator = reinterpret_cast&lt;struct dirent *(*)(DIR *)&gt;</span><br><span class="line">    (replaceSecInsns(getlibcPath(), &quot;readdir&quot;));</span><br><span class="line">    dirent *read_ptr;</span><br><span class="line">    //在app启动之前检测当前app所有的进程,判断是否存在和main不一样的进程</span><br><span class="line">    while ((read_ptr = orig_ator(pdr)) != nullptr) &#123;</span><br><span class="line">        long procPid = strtol(read_ptr-&gt;d_name, nullptr, 10);</span><br><span class="line">        //LOG(INFO) &lt;&lt; &quot;find /proc/ child dir  &quot; &lt;&lt; procPid;</span><br><span class="line">        //打开成功&amp;&amp;发现一条不等于主进程id的pid</span><br><span class="line">        if (procPid &amp;&amp; procPid != getpid()) &#123;</span><br><span class="line">            auto title = string(&quot;检测到APK存在沙箱内部&quot;);</span><br><span class="line">            char buff[200];</span><br><span class="line">            getNameByPid((pid_t) procPid, buff);</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt;  FIND OTHER THREAD SANDBOX &quot; &lt;&lt; procPid &lt;&lt; &quot;  &quot; &lt;&lt; buff;</span><br><span class="line">            auto &amp;data =</span><br><span class="line">                    string(&quot;当前线程主进程PID(&quot;).append(to_string(getpid())).append(&quot;)&quot;).append(&quot;\n&quot;).</span><br><span class="line">                            append(&quot;异常pid -&gt; &quot;).append(to_string(procPid)).</span><br><span class="line">                            append(&quot;(&quot;).append(&quot;pid name: &quot;).append(buff).append(&quot;)&quot;);</span><br><span class="line">            //可能存在多个异常pid而非一个</span><br><span class="line">            getItemData(env, title, data.c_str(), false, RISK_LEAVE_WARN, TAG_SANDBOX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(pdr);</span><br></pre></td></tr></table></figure>

<h5 id="对抗："><a href="#对抗：" class="headerlink" title="对抗："></a>对抗：</h5><p>这块想要绕过也很简单，<code>opendir</code> 底层其实就是 <code>getdents64，getdents</code> 如果遇到你想隐藏的文件直接对文件进行<code>bypass</code>就可以了，直接指向下一个指针</p>
<p>代码来自<code>proot</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">        case SC_getdents64:</span><br><span class="line">        case SC_getdents: &#123;</span><br><span class="line">            /* get the result of the syscall, which is the number of bytes read by getdents</span><br><span class="line">             * 获取系统调用的结果，即getdents读取的字节数</span><br><span class="line">             * */</span><br><span class="line">            unsigned int res = peek_reg(tracee, CURRENT, SYSARG_RESULT);</span><br><span class="line">            if (res &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            /* get the system call arguments */</span><br><span class="line">            word_t orig_start = peek_reg(tracee, CURRENT, SYSARG_2);</span><br><span class="line">            unsigned int count = peek_reg(tracee, CURRENT, SYSARG_3);</span><br><span class="line">            char orig[count];</span><br><span class="line"> </span><br><span class="line">            char path[PATH_MAX];</span><br><span class="line">            int status = readlink_proc_pid_fd(tracee-&gt;pid,</span><br><span class="line">                                              (int) peek_reg(tracee, ORIGINAL, SYSARG_1), path);</span><br><span class="line">            if (status &lt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //不属于绑定路径则不处理,这块应该加个判断。如果这个path没有处理的路径应该返回 。</span><br><span class="line">            //目前需要处理的只有proc,用于隐藏调试线程。</span><br><span class="line">//            if(!belongs_to_guestfs(tracee, path))</span><br><span class="line">//                return 0;</span><br><span class="line">            if (!StringUtils::containsInsensitive(path,&quot;proc&quot;))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            /* retrieve the data from getdents</span><br><span class="line">             * 从getdents检索数据</span><br><span class="line">             * */</span><br><span class="line">            status = read_data(tracee, orig, orig_start, res);</span><br><span class="line">            if (status &lt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            /* allocate a space for the copy of the data we want</span><br><span class="line">             * 为我们想要的数据的副本分配一个空间</span><br><span class="line">             * */</span><br><span class="line">            char copy[count];</span><br><span class="line">            /* curr will hold the current struct we&#x27;re examining</span><br><span class="line">             * curr将保存我们正在检查的当前结构</span><br><span class="line">             * */</span><br><span class="line">            struct linux_dirent64 *curr64;</span><br><span class="line">            struct linux_dirent *curr32;</span><br><span class="line">            /* pos keeps track of where in memory the copy is</span><br><span class="line">             * pos跟踪副本在内存中的位置</span><br><span class="line">             * */</span><br><span class="line">            char *pos = copy;</span><br><span class="line">            /* ptr keeps track of where in memory the original is</span><br><span class="line">             * ptr跟踪原始文件在内存中的位置</span><br><span class="line">             * */</span><br><span class="line">            char *ptr = orig;</span><br><span class="line">            /* nleft keeps track of how many bytes we&#x27;ve saved</span><br><span class="line">             * nleft跟踪我们保存了多少字节</span><br><span class="line">             * */</span><br><span class="line">            unsigned int nleft = 0;</span><br><span class="line"> </span><br><span class="line">            /* while we&#x27;re still within the memory allowed</span><br><span class="line">             * 当我们还在允许的memory范围内时</span><br><span class="line">             * */</span><br><span class="line">            if (get_sysnum(tracee, ORIGINAL) == SC_getdents64) &#123;</span><br><span class="line">                while (ptr &lt; orig + res) &#123;</span><br><span class="line"> </span><br><span class="line">                    /* get the current struct</span><br><span class="line">                     * 获取当前结构</span><br><span class="line">                     * */</span><br><span class="line">                    curr64 = (struct linux_dirent64 *) ptr;</span><br><span class="line"> </span><br><span class="line">                    /* if the name does not matche a given prefix</span><br><span class="line">                     * 如果名称与给定前缀不匹配</span><br><span class="line">                     *</span><br><span class="line">                     * 如果这个目录项的名称不以HIDDEN_PREFIX开始，</span><br><span class="line">                     * 也就是hasprefix(HIDDEN_PREFIX, curr64-&gt;d_name)返回false，</span><br><span class="line">                     * 那么这个目录项会被保留在结果中，否则，这个目录项会被忽略，也就是隐藏。</span><br><span class="line">                     * */</span><br><span class="line">                    //if (!hasprefix(HIDDEN_PREFIX, curr64-&gt;d_name)) &#123;</span><br><span class="line">                    if (!isRuntimeHideDir(tracee-&gt;pid,curr64-&gt;d_name, tracer_pc(tracee), tracer_lr(tracee))) &#123;</span><br><span class="line">                        /* copy the information</span><br><span class="line">                         * 复制信息</span><br><span class="line">                         * */</span><br><span class="line">                        mybcopy(ptr, pos, curr64-&gt;d_reclen);</span><br><span class="line"> </span><br><span class="line">                        /* move the pos and nleft */</span><br><span class="line">                        pos += curr64-&gt;d_reclen;</span><br><span class="line">                        nleft += curr64-&gt;d_reclen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    /* move to the next linux_dirent</span><br><span class="line">                     * 隐藏这个目录,指向下一个文件</span><br><span class="line">                     * */</span><br><span class="line">                    ptr += curr64-&gt;d_reclen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (ptr &lt; orig + res) &#123;</span><br><span class="line"> </span><br><span class="line">                    /* get the current struct */</span><br><span class="line">                    curr32 = (struct linux_dirent *) ptr;</span><br><span class="line"> </span><br><span class="line">                    /* if the name does not matche a given prefix */</span><br><span class="line">//                    if (!hasprefix(HIDDEN_PREFIX, curr64-&gt;d_name)) &#123;</span><br><span class="line">                    if (!isRuntimeHideDir(tracee-&gt;pid,curr32-&gt;d_name, tracer_pc(tracee), tracer_lr(tracee))) &#123;</span><br><span class="line"> </span><br><span class="line">                        /* copy the information */</span><br><span class="line">                        mybcopy(ptr, pos, curr32-&gt;d_reclen);</span><br><span class="line"> </span><br><span class="line">                        /* move the pos and nleft */</span><br><span class="line">                        pos += curr32-&gt;d_reclen;</span><br><span class="line">                        nleft += curr32-&gt;d_reclen;</span><br><span class="line">                    &#125;</span><br><span class="line">                    /* move to the next linux_dirent */</span><br><span class="line">                    ptr += curr32-&gt;d_reclen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /* If there is nothing left</span><br><span class="line">             * 这个文件夹里面本身没有东西,暂不处理</span><br><span class="line">             * */</span><br><span class="line">            if (!nleft) &#123;</span><br><span class="line">//                /* call getdents again */</span><br><span class="line">//                if (get_sysnum(tracee, ORIGINAL) == PR_getdents64)</span><br><span class="line">//                    register_chained_syscall(tracee, PR_getdents64, peek_reg(tracee, ORIGINAL, SYSARG_1), orig_start, count, 0, 0, 0);</span><br><span class="line">//                else</span><br><span class="line">//                    register_chained_syscall(tracee, PR_getdents, peek_reg(tracee, ORIGINAL, SYSARG_1), orig_start, count, 0, 0, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* copy the data back into the register */</span><br><span class="line">                status = write_data(tracee, orig_start, copy, nleft);</span><br><span class="line">                if (status &lt; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                /* update the return value to match the data */</span><br><span class="line">                poke_reg(tracee, SYSARG_RESULT, nleft);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行ps命令："><a href="#执行ps命令：" class="headerlink" title="执行ps命令："></a>执行ps命令：</h4><p>这块的思路就是<strong>检测是否存在其他进程</strong> ，通过执行<code>ps -ef</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">if (get_sdk_level() &gt; ANDROID_Q) &#123;</span><br><span class="line">    //check process</span><br><span class="line">    auto orig_popen = reinterpret_cast&lt;FILE *(*)(const char *,</span><br><span class="line">                                                 const char *)&gt;(replaceSecInsns(getlibcPath(),</span><br><span class="line">                                                                                &quot;popen&quot;));</span><br><span class="line">    FILE *file = orig_popen(&quot;ps -ef&quot;, &quot;r&quot;);</span><br><span class="line">    if (file == nullptr) &#123;</span><br><span class="line">        return getItemData(env, &quot;程序出错请放弃修改后重试&quot;,</span><br><span class="line">                           &quot;ps error&quot;, true, 3, TAG_SANDBOX);</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[0x1000];</span><br><span class="line">    string buffStr;</span><br><span class="line">    uint size = 0;</span><br><span class="line">    // get process count size</span><br><span class="line">    while (fgets(buf, sizeof(buf), file)) &#123;</span><br><span class="line">        buffStr.append(buf).append(&quot;\n&quot;);</span><br><span class="line">        //不包含++</span><br><span class="line">        if(!StringUtils::contains(buf,&quot;hunter&quot;))&#123;</span><br><span class="line">            size++;</span><br><span class="line">            LOG(INFO) &lt;&lt; &quot;ps -ef match -&gt; %s &quot; &lt;&lt; buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (size &gt; 2) &#123;</span><br><span class="line">        //UID             PID   PPID C STIME TTY          TIME CMD</span><br><span class="line">        //u0_a531        6187    885 72 10:27:53 ?    00:00:00 com.zhenxi.hunter</span><br><span class="line">        //u0_a531        6236   6187 0 10:27:53 ?     00:00:00 ps -ef</span><br><span class="line">        pclose(file);</span><br><span class="line"> </span><br><span class="line">        return getItemData(env, &quot;检测到APK存在沙箱内部(异常线程)&quot;,</span><br><span class="line">                           buffStr.c_str(), false, RISK_LEAVE_DEADLY, TAG_SANDBOX);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;&gt;&gt;&gt;&gt;&gt; NOT FIND SANDBOX &quot;;</span><br><span class="line">    pclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对抗：-1"><a href="#对抗：-1" class="headerlink" title="对抗："></a>对抗：</h5><p>可以先伪造一个正常的文件，在执行到 ps -ef的时候把命令换成cat 你自己的文件 即可 。</p>
<h4 id="内存Choose"><a href="#内存Choose" class="headerlink" title="内存Choose:"></a>内存Choose:</h4><p>这块的实现思路就是，检测内存里面的 Activity 或者 Application的个数 。正常我们的apk启动只会有我们自己的</p>
<p>Application，沙箱因为预启动的关系，会存在其他的Application ，这块也是一个很好的检测思路 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static ListItemBean checkSandbox() &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; choose;</span><br><span class="line">    try &#123;</span><br><span class="line">        choose = ChooseUtils.choose(Activity.class, true);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (choose != null) &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        //移除我们的Activity,把其他的activity实例加到List里面</span><br><span class="line">        for(Object activty:choose)&#123;</span><br><span class="line">            String name = activty.getClass().getName();</span><br><span class="line">            if(!name.equals(MainActivity.class.getName())&amp;&amp;</span><br><span class="line">                    !name.equals(ShareActivity.class.getName())&amp;&amp;</span><br><span class="line">                        !name.equals(FeedbackActivity.class.getName())</span><br><span class="line">                )&#123;</span><br><span class="line">                list.add(activty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断list数量是否大于1</span><br><span class="line">        if (list.size() &gt;= 1) &#123;</span><br><span class="line">            ListItemBean item = new ListItemBean(</span><br><span class="line">                    &quot;检测到APK存在沙箱内部&quot;,</span><br><span class="line">                    ListItemBean.RiskLeave.Deadly);</span><br><span class="line">            for (Object obj : list) &#123;</span><br><span class="line">                item.putData(obj.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            return item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测Google-lineageos"><a href="#检测Google-lineageos" class="headerlink" title="检测Google&amp;lineageos"></a>检测Google&amp;lineageos</h3><p>因为在国内手机里基本<code>Google</code>和<code>lineageos</code>都是黑产的标配 ，大部分都是自己刷的ROM</p>
<p>这种手机理论上在国内 不应该出现，如果出现也会被打上标签，被认定为黑产 。可以直接Build.MODEL 获取厂商</p>
<p>另外这块还有一个细节点 ，就是<code>lineageos</code>一个特有文件<code>/system/addon.d</code> 。具体如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static void isLineageOs(ArrayList&lt;ListItemBean&gt; items) &#123;</span><br><span class="line">    //lineage检测</span><br><span class="line">    String display = NativeEngine.getZhenxiInfoH(&quot;ro.build.display.id&quot;);</span><br><span class="line">    if (display.toLowerCase(Locale.ROOT).contains(&quot;lineage&quot;)) &#123;</span><br><span class="line">        items.add(</span><br><span class="line">                new ListItemBean(&quot;当前手机为Lineage系统&quot;,</span><br><span class="line">                        ListItemBean.RiskLeave.Warn,</span><br><span class="line">                        &quot;可能存在自定义ROM,当前设备不可信！&quot;</span><br><span class="line">                ));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //lineage 特有文件</span><br><span class="line">    File file = new File(&quot;/system/addon.d&quot;);</span><br><span class="line">    if (file.exists()) &#123;</span><br><span class="line">        items.add(</span><br><span class="line">                new ListItemBean(&quot;当前手机为Lineage系统&quot;,</span><br><span class="line">                        ListItemBean.RiskLeave.Warn,</span><br><span class="line">                        &quot;可能存在自定义ROM,当前设备不可信！&quot;</span><br><span class="line">                ));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这块有一个细节点：</p>
<p>直接获取 <code>ro.build.display.id</code> 可能会被<code>Hook</code> ，所以这块我的建议是直接去解析配置文件</p>
<p>核心解析（&#x2F;dev&#x2F;<strong>properties</strong>&#x2F;u:object_r: ）文件方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    public PropArea(String area) throws IOException &#123;</span><br><span class="line">        area = &quot;/dev/__properties__/u:object_r:&quot; + area + &quot;:s0&quot;;</span><br><span class="line">        File file = new File(area);</span><br><span class="line">        if (!file.isFile()) throw new FileNotFoundException(&quot;Not a file: &quot; + area);</span><br><span class="line">        long size = file.length();</span><br><span class="line">        if (size &lt;= 0 || size &gt;= 0x7fffffffL) throw new IllegalArgumentException(&quot;invalid file size &quot; + size);</span><br><span class="line"> </span><br><span class="line">        try (FileChannel channel = new FileInputStream(area).getChannel()) &#123;</span><br><span class="line">            data = channel.map(FileChannel.MapMode.READ_ONLY, 0, size).order(ByteOrder.nativeOrder());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        byteUsed = data.getInt();</span><br><span class="line">        data.getInt(); // serial</span><br><span class="line">        int magic = data.getInt();</span><br><span class="line">        if (magic != PROP_AREA_MAGIC) throw new IllegalArgumentException(&quot;Bad file magic: &quot; + magic);</span><br><span class="line">        int version = data.getInt();</span><br><span class="line">        if (version != PROP_AREA_VERSION) throw new IllegalArgumentException(&quot;Bad area versin: &quot; + version);</span><br><span class="line">        data.position(data.position() + 28); // reserved</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">public List&lt;String&gt; findPossibleValues(String name) &#123;</span><br><span class="line">    List&lt;String&gt; values ;</span><br><span class="line">    try &#123;</span><br><span class="line">        //  atomic_uint_least32_t serial;</span><br><span class="line">        //  union &#123;</span><br><span class="line">        //    char value[PROP_VALUE_MAX];</span><br><span class="line">        //    struct &#123;</span><br><span class="line">        //      char error_message[kLongLegacyErrorBufferSize];</span><br><span class="line">        //      uint32_t offset;</span><br><span class="line">        //    &#125; long_property;</span><br><span class="line">        //  &#125;;</span><br><span class="line">        final int LONG_PROP_FLAG = 1 &lt;&lt; 16;</span><br><span class="line">        final int PROP_VALUE_MAX = 92;</span><br><span class="line">        final int VALUE_OFFSET = 4;</span><br><span class="line">        final int NAME_OFFSET = VALUE_OFFSET + 92;</span><br><span class="line">        values = new ArrayList&lt;&gt;(2);</span><br><span class="line">        findFromBuffer(data.slice(), name.getBytes(StandardCharsets.UTF_8), (buffer, offset) -&gt; &#123;</span><br><span class="line">            if (offset &lt; NAME_OFFSET) return;</span><br><span class="line">            int base = offset - NAME_OFFSET;</span><br><span class="line">            int serial = buffer.getInt(base);</span><br><span class="line">            if ((serial &amp; LONG_PROP_FLAG) != 0) return; // Long properties are not supported</span><br><span class="line">            values.add(toString(buffer, base + VALUE_OFFSET, PROP_VALUE_MAX));</span><br><span class="line">        &#125;);</span><br><span class="line">        CLog.i(&quot;Found &quot; + name + &quot;=&quot; + values);</span><br><span class="line">        return values;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        CLog.e(&quot;findPossibleValues get error &quot;+ name+&quot; &quot;+e);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检测IDA和反调试："><a href="#检测IDA和反调试：" class="headerlink" title="检测IDA和反调试："></a>检测IDA和反调试：</h3><p>这块检测方法太多了，比如核心A和B方法里面加个时间戳，如果A执行到B大于5秒就可以认为被调试 。</p>
<p>检测调试状态也是很不错的选择，不过这块可以利用<code>ISO</code>线程去检测调试状态，防止被<code>ptrace</code></p>
<h4 id="service-list"><a href="#service-list" class="headerlink" title="service list"></a>service list</h4><p>也可以执行 “<code>service list</code>“ 获取服务列表 ，判断是否包含frida关键字 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static CheckServerRet checkServer(Context context, String[] fit) &#123;</span><br><span class="line">    CheckServerRet ret = new CheckServerRet();</span><br><span class="line">    ArrayList&lt;String&gt; list = ret.list;</span><br><span class="line">    BufferedReader reader = null;</span><br><span class="line">    Process process;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 执行 service list 命令</span><br><span class="line">        process = Runtime.getRuntime().exec(&quot;service list&quot;);</span><br><span class="line"> </span><br><span class="line">        // 读取命令输出结果</span><br><span class="line">        reader = new BufferedReader(new InputStreamReader(process.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">            if (line.length() &gt; 1) &#123;</span><br><span class="line">                for (String fitItem : fit) &#123;</span><br><span class="line">                    //比较不区分大小写</span><br><span class="line">                    if (line.toLowerCase().contains(fitItem.toLowerCase())) &#123;</span><br><span class="line">                        list.add(line);</span><br><span class="line">                        //CLog.e(&quot;checkServer find item is match &quot; + Arrays.toString(fit) + &quot; &quot; + line);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //走到这里说明能拿到。返回的不是空</span><br><span class="line">                        ret.isSuccess = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 关闭流</span><br><span class="line">        reader.close();</span><br><span class="line"> </span><br><span class="line">        // 等待命令执行完毕</span><br><span class="line">        int exitValue = process.waitFor();</span><br><span class="line">        CLog.e(&quot;checkServer ret mark &quot; + Arrays.toString(fit) + &quot; &quot; + ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        if (reader != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; catch (IOException ignored) &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设备指纹3"><a href="#设备指纹3" class="headerlink" title="设备指纹3"></a>设备指纹3</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="IPC代理-IPC协议是什么？"><a href="#IPC代理-IPC协议是什么？" class="headerlink" title="IPC代理&amp;IPC协议是什么？"></a>IPC代理&amp;IPC协议是什么？</h4><p>Android是基础的CS架构，客户端和服务端架构 。安卓为什么要这么设计呢？如果服务端和客户端在一个进程内，客户端崩溃了，服务端也会一起崩溃，导致整个系统不稳定 </p>
<p>安卓和Java相比多个一个Context，这个Context是调用安卓本身提供api的桥梁 ，里面有各种安卓系统提供的各种基础API</p>
<p>这些API可以直接操作Android系统 ，安卓本身通过各种各样的Manager去提供对应的Api去获取和修改 。比如<code>PackageManager，ActivityManager</code>等，这些Manager里面都会持有一个代理人 。当我们去调用这个Manager里面的一些Api的时候，一些简单的Api他会尝试去自己在本进程Native或者Java去实现，如果一些复杂的字段，比如查询系统的一些信息，或者调用一些系统关键函数，这种时候他会去调用“IPC代理人 ”，这个IPC代理人就是像服务端通讯的关键 。他相当于是向服务端的传话得人 ，代理设计模式 。对不同的Manager提供不一样的功能 ，而他传的话就是对应的IPC协议 。这个协议如何传递的，就是通过底层的共享内存<code>Binder</code>去实现的 。</p>
<p>而这个协议里面具体发送的内容，就是IPC协议装的“包裹”就是用的<code>Parcel</code> 。</p>
<p>这块举个栗子，当用户调用一个未初始化的<code>API</code>时候，需要跨进程通讯，到底发生了哪些动作</p>
<p><strong>用户调用系统API-&gt;Manager收到调用消息-&gt;判断是否需要调用服务端-&gt;调用IPC代理里面的方法-&gt;IPC代理构建发送的数据包调用Binder进行通讯数据写入以后返回</strong></p>
<p>这个IPC代理实现了Binder的接口，当前进程调用的最后一个API就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;android.os.BinderProxy&quot;-&gt;transact</span><br></pre></td></tr></table></figure>

<p>也就是说这个方法底层调用的是Binder的驱动，最终会去native层写入，剩下的就是开始运行服务端的逻辑了。把数据写入到transact方法的参数3里面。然后程序返回，下面是这个方法的原型</p>
<blockquote>
<p>之前通过hook binder来bypass指纹，有一个方法就是通过hook这个<code>transact</code>方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Perform a binder transaction on a proxy.</span><br><span class="line">     *</span><br><span class="line">     * @param code The action to perform.  This should</span><br><span class="line">     * be a number between &#123;@link #FIRST_CALL_TRANSACTION&#125; and</span><br><span class="line">     * &#123;@link #LAST_CALL_TRANSACTION&#125;.</span><br><span class="line">     * @param data Marshalled data to send to the target.  Must not be null.</span><br><span class="line">     * If you are not sending any data, you must create an empty Parcel</span><br><span class="line">     * that is given here.</span><br><span class="line">     * @param reply Marshalled data to be received from the target.  May be</span><br><span class="line">     * null if you are not interested in the return value.</span><br><span class="line">     * @param flags Additional operation flags.  Either 0 for a normal</span><br><span class="line">     * RPC, or &#123;@link #FLAG_ONEWAY&#125; for a one-way RPC.</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     * @throws RemoteException</span><br><span class="line">     */</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数就是code，这个code指的是具体的<strong>事件类型</strong>，不同的事件传入的数字也不一样</p>
<p>第二参数是<strong>发送的数据包</strong>，这时候IPC已经往里面进行了写入对应的数据包 </p>
<p>第三个参数是reply，也就是<strong>服务端返回的保存内容</strong></p>
<p>注意：</p>
<blockquote>
<p><strong>这块可能存在一个问题，有的数据，这个时候你在after去覆写这个参数3已结晚了，因为数据在别的进程已结写入了 。</strong> <strong>如果你想对这个参数进行修改，最好的办法是直接模拟服务端手动往reply进行写入</strong></p>
</blockquote>
<p>第四个参数是flags，举个例子，比如你想获取正常的<code>PackageInfo</code>，不需要获取签名之类的信息，你传入0即可 </p>
<p>如果想获取签名就需要传入<code>PackageManager.GET_SIGNATURES</code>，这个flag相当于告诉服务端，都需要哪些功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getPackageManager().getPackageInfo(&quot;aaa&quot;,0);</span><br><span class="line">getPackageManager().getPackageInfo(&quot;aaa&quot;,PackageManager.GET_SIGNATURES);</span><br></pre></td></tr></table></figure>

<p>比如第一个Api获取到的<code>PackageInfo</code>里面是不包含签名信息的，第二个则包含 。当你需要什么功能的时候使用 “或” 连接即可。</p>
<blockquote>
<p>这块我们得到一个结论，这个方法是Java层通讯最后一个方法，也就是当前进程能操作的最后一个方法，剩下的就是服务端进程的事情了。这个方法是Java层的 <strong>“边界值 ”</strong>，这个边界值记住后面在总结里面会介绍到不同的边界值和风控的关系。</p>
</blockquote>
<blockquote>
<p>这块还有的大厂更恶心，他不走transact方法，因为transact方法底层走的就是Binder，<strong>可以直接在Native层调用的Binder 驱动，实现了transact 这个方法</strong> 。然后进行IPC通讯，直接不走Java层 。</p>
<p>当然他这种方法也是很不稳定，需要对每个android 版本都进行兼容，属于伤敌1000自损800类型 ，适配难度也很大。</p>
<p>随着安卓不断增强安全性，后面这种方式肯定会慢慢被PASS掉 ，现在利用跨进程在低版本越权App的太多了 。</p>
</blockquote>
<h4 id="动态代理IPC"><a href="#动态代理IPC" class="headerlink" title="动态代理IPC"></a>动态代理IPC</h4><p>就是我不用hook可以实现IPC的代理人替换么？</p>
<blockquote>
<p>这块有一个动态代理的知识点，就是他代理人本身是实现了一个接口，<strong>我们可以直接反射把他这个代理人给替换成我们的</strong>，然后我们使用<code>Proxy.newProxyInstance</code>动态代理这个接口类，也可以实现不需要Hook框架的情况下实现动态代理 。比如一些VA之类的用的就是这种，因为Hook其实稳定性啥的没有动态代理的稳定性好，Hook的话需要对不同版本兼容，一旦版本发生变化需要适配很多东西，而动态代理则不需要。</p>
<p>Hook的话痕迹可能更少一点，<strong>动态代理检测的话只需要反射这个IPC代理人，然后getClass().getName() 里面直接就有proxy之类的关键字</strong> ，各有各的好处</p>
</blockquote>
<h3 id="设备指纹-2"><a href="#设备指纹-2" class="headerlink" title="设备指纹"></a>设备指纹</h3><h4 id="IPCAndroid-Id"><a href="#IPCAndroid-Id" class="headerlink" title="IPCAndroid_Id"></a>IPCAndroid_Id</h4><h5 id="方法5："><a href="#方法5：" class="headerlink" title="方法5："></a>方法5：</h5><p>直接构建IPC协议和服务端进行通讯 ，这块<code>targetSdkVersion</code>必须升级到32以上</p>
<p>因为<code>getAttributionSource</code>这个玩意32版本以上好像才有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public String getAndroidId5(Context context) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // Acquire the ContentProvider</span><br><span class="line">            Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">            Method currentActivityThreadMethod = activityThreadClass.getMethod(&quot;currentActivityThread&quot;);</span><br><span class="line">            Object currentActivityThread = currentActivityThreadMethod.invoke(null);</span><br><span class="line">            // 通过ActivityThread获取一个指向远程&quot;settings&quot; ContentProvider的代理对象</span><br><span class="line">            Method acquireProviderMethod = activityThreadClass.getMethod(&quot;acquireProvider&quot;, Context.class, String.class, int.class, boolean.class);</span><br><span class="line">            Object provider = acquireProviderMethod.invoke(currentActivityThread, context, &quot;settings&quot;, 0, true);</span><br><span class="line"> </span><br><span class="line">            // 获取IContentProvider接口的Class对象，为后续获取Binder通信的“事务码”做准备</span><br><span class="line">            Class&lt;?&gt; iContentProviderClass = Class.forName(&quot;android.content.IContentProvider&quot;);</span><br><span class="line">            // ContentProvider的代理对象内部有一个名为mRemote的成员变量，它就是真正的Binder通信对象</span><br><span class="line">            Field mRemoteField = provider.getClass().getDeclaredField(&quot;mRemote&quot;);</span><br><span class="line">            mRemoteField.setAccessible(true);</span><br><span class="line">            IBinder binder = (IBinder) mRemoteField.get(provider);</span><br><span class="line"> </span><br><span class="line">            // Create the Parcel for the arguments</span><br><span class="line">            Parcel data = Parcel.obtain();</span><br><span class="line">            data.writeInterfaceToken(&quot;android.content.IContentProvider&quot;);</span><br><span class="line">            if (android.os.Build.VERSION.SDK_INT</span><br><span class="line">                    &gt;= android.os.Build.VERSION_CODES.S) &#123;</span><br><span class="line">                context.getAttributionSource().writeToParcel(data, 0); // 1. 写入归因源</span><br><span class="line">                data.writeString(&quot;settings&quot;);   // 2. 写入 authority</span><br><span class="line">                data.writeString(&quot;GET_secure&quot;); // 3. 写入方法名</span><br><span class="line">                data.writeString(&quot;android_id&quot;); // 4. 写入参数</span><br><span class="line">                data.writeBundle(Bundle.EMPTY); // 5. 写入额外Bundle</span><br><span class="line">            &#125; else if (android.os.Build.VERSION.SDK_INT</span><br><span class="line">                    == android.os.Build.VERSION_CODES.R) &#123;// API 30</span><br><span class="line">                //android 11</span><br><span class="line">                data.writeString(context.getPackageName());</span><br><span class="line">                data.writeString(null); //featureId</span><br><span class="line"> </span><br><span class="line">                data.writeString(&quot;settings&quot;); //authority</span><br><span class="line">                data.writeString(&quot;GET_secure&quot;); //method</span><br><span class="line">                data.writeString(&quot;android_id&quot;); //stringArg</span><br><span class="line">                data.writeBundle(Bundle.EMPTY);</span><br><span class="line">            &#125; else if (android.os.Build.VERSION.SDK_INT</span><br><span class="line">                    == android.os.Build.VERSION_CODES.Q) &#123; // API 29</span><br><span class="line">                //android 10</span><br><span class="line">                data.writeString(context.getPackageName());</span><br><span class="line"> </span><br><span class="line">                data.writeString(&quot;settings&quot;); //authority</span><br><span class="line">                data.writeString(&quot;GET_secure&quot;); //method</span><br><span class="line">                data.writeString(&quot;android_id&quot;); //stringArg</span><br><span class="line">                data.writeBundle(Bundle.EMPTY);</span><br><span class="line">            &#125; else &#123;                                // 更早版本</span><br><span class="line">                data.writeString(context.getPackageName());</span><br><span class="line">                data.writeString(&quot;GET_secure&quot;); //method</span><br><span class="line">                data.writeString(&quot;android_id&quot;); //stringArg</span><br><span class="line">                data.writeBundle(Bundle.EMPTY);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Parcel reply = Parcel.obtain();</span><br><span class="line">            // 调用transact向一个IBinder象(这里的binder变量是IBinder类)发送请求</span><br><span class="line">            binder.transact((int) iContentProviderClass.getDeclaredField(&quot;CALL_TRANSACTION&quot;).get(null), data, reply, 0);</span><br><span class="line">            reply.readException();</span><br><span class="line">            Bundle bundle = reply.readBundle();</span><br><span class="line">            reply.recycle();</span><br><span class="line">            data.recycle();</span><br><span class="line"> </span><br><span class="line">            return bundle.getString(&quot;value&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>分析：标准获取Android ID的标准、公开方法是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import android.provider.Settings;</span><br><span class="line"></span><br><span class="line">String androidId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);</span><br></pre></td></tr></table></figure>

<p>这个标准方法内部其实也是通过 <code>ContentResolver</code> -&gt; <code>ContentProvider</code> 的机制，最终通过 Binder IPC 与系统服务（具体是 <code>SettingsProvider</code>）进行通信来获取值的。</p>
<blockquote>
<p>我们调用 <code>IBinder.transact()</code> 给一个 IBinder 对象发送请求，然后经过 Binder <code>Binder.onTransact()</code> 得到调用，接着远程操作的目标得到对应的调用</p>
</blockquote>
<h4 id="IPCAppSign"><a href="#IPCAppSign" class="headerlink" title="IPCAppSign"></a>IPCAppSign</h4><p>IPC获取签名也是一些大厂经常用检测签名的办法，修改的话也很简单，直接替换掉数据包即可</p>
<p>具体获取方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static int TRANSACTION_getPackageInfo() &#123;</span><br><span class="line">    if(TRANSACTION_getPackageInfo == -1) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">                Field field = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Class&lt;?&gt; pkmIPCClazz = Class.forName(&quot;android.content.pm.IPackageManager$Stub&quot;);</span><br><span class="line">                    field = pkmIPCClazz.getDeclaredField(&quot;TRANSACTION_getPackageInfo&quot;);</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    CLog.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; getTranscationId forName error &quot; + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                assert field != null;</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                TRANSACTION_getPackageInfo = field.getInt(null);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                CLog.e(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; getTranscationId error &quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return TRANSACTION_getPackageInfo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">try &#123;</span><br><span class="line">    PackageManager packageManager = getBaseContext().getPackageManager();</span><br><span class="line"></span><br><span class="line">    // 1. 获取底层的 IPackageManager 代理对象</span><br><span class="line">    Object IPC_PM_Obj = RposedHelpers.getObjectField(packageManager, &quot;mPM&quot;);</span><br><span class="line">    // 2. 从代理对象中获取真正的 IBinder 对象</span><br><span class="line">    IBinder mRemote = (IBinder) RposedHelpers.getObjectField(IPC_PM_Obj, &quot;mRemote&quot;);</span><br><span class="line"></span><br><span class="line">    // 3. 准备数据 Parcel 和回复 Parcel</span><br><span class="line">    Parcel _data = Parcel.obtain();</span><br><span class="line">    Parcel _reply = Parcel.obtain();</span><br><span class="line"></span><br><span class="line">    // 4. 按照 AIDL 协定，手动打包参数到 _data 中</span><br><span class="line">    _data.writeInterfaceToken(&quot;android.content.pm.IPackageManager&quot;); // 写入接口令牌，用于验证</span><br><span class="line">    _data.writeString(getPackageName()); // 参数1: packageName (String)</span><br><span class="line">    _data.writeLong(PackageManager.GET_SIGNATURES); // 参数2: flags (long), 注意这里用了writeLong</span><br><span class="line">    _data.writeInt(android.os.Process.myUid()); // 参数3: userId (int)</span><br><span class="line"></span><br><span class="line">    // 5. 发起远程调用</span><br><span class="line">    boolean _status = mRemote.transact(TransactCase.TRANSACTION_getPackageInfo(), _data, _reply, 0);</span><br><span class="line">    _reply.readException(); // 检查远程调用是否发生异常</span><br><span class="line"></span><br><span class="line">    // 6. 从 _reply 中解包返回值</span><br><span class="line">    PackageInfo packageInfo = _reply.readTypedObject(PackageInfo.CREATOR);</span><br><span class="line"></span><br><span class="line">    // 7. 回收 Parcel 对象</span><br><span class="line">    _data.recycle();</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    CLog.e(&quot;签名信息: &quot;+packageInfo.signatures[0].toCharsString());</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">    CLog.i(&quot;IPC_TEST_getPackageInfo error &quot;+e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>绕过高层 API Hook，直接通过底层 Binder IPC (进程间通信) 来获取应用签名信息</strong></p>
<p><strong>什么是 Transaction Code?</strong> </p>
<p>在 Android 的 Binder IPC 机制中，客户端（App）调用服务端（System Service）的方法时，并不是直接传递方法名。为了效率，每个方法都被映射到一个唯一的整数ID，这个ID就叫做 <code>Transaction Code</code>。当客户端发起 <code>transact</code> 调用时，它会把这个整数ID和参数一起打包发送给服务端，服务端根据这个ID就知道要调用哪个具体的方法。</p>
<p><strong>为什么要用反射获取？</strong></p>
<p><code>TRANSACTION_getPackageInfo</code> 是 <code>IPackageManager.aidl</code> 文件在编译后自动生成的 <code>IPackageManager$Stub</code> 类中的一个私有静态常量。它的值在不同 Android 版本中<strong>可能</strong>会改变（虽然实践中很少改变）。如果直接在代码里硬编码一个整数值（例如 <code>int a = 14;</code>），那么当应用运行在一个该值已改变的 Android 系统上时，调用就会失败。 因此，通过反射去动态获取当前运行环境下的确切值，是一种<strong>兼容性更好、更稳健</strong>的做法。</p>
<h4 id="Maps解析Apk签名"><a href="#Maps解析Apk签名" class="headerlink" title="Maps解析Apk签名"></a>Maps解析Apk签名</h4><p>这块还有一个方案，主要实现思路就是因为我们当前进程去打开apk是存在风险的 。</p>
<p>很有可能被IO重定向，导致得到的签名是错误的，所以我们可以<strong>让三方进程去加载当前apk文件，通过共享内存的方式，然后当前进程对apk文件maps里面的内存签名进行解析即可</strong> 。这块需要双进程通讯 。</p>
<h4 id="其他字段IPC"><a href="#其他字段IPC" class="headerlink" title="其他字段IPC"></a>其他字段IPC</h4><p>根据上面的两个经典IPC例子，可以发现只要是服务端获取的都可以使用<strong>IPC协议</strong>的方式去获取 。</p>
<p>其他字段其实一样也可以这么玩 ，如果需要什么字段，就对照安卓源码客户端往里面写入对应的数据，直接IPC即可</p>
<blockquote>
<p>分析SO文件的时候直接对jni交互进行监听，在保存的调用栈里面看</p>
<p>他如果调用了<code>Parcel.obtain()</code> 初始化或者 这种<code>writeLong ()</code>写入数据的方法，基本就可以确认他是IPC获取的一些字段，具体看他写入的内容是什么，或者看他写入的token是什么，比如上面的获取签名的token就是<code>&quot;android.content.pm.IPackageManager&quot;</code> ，即可知道他想做什么字段的获取</p>
</blockquote>
<h4 id="IPC总结-反思"><a href="#IPC总结-反思" class="headerlink" title="IPC总结&amp;反思"></a>IPC总结&amp;反思</h4><p>后来又思考了一下，IPC服务端这些设备指纹，或者说这些配置到底哪里来的，一直在源码里面跟。</p>
<p>发现就拿android id来说，他最终读取的文件路径是<code>/data/system/users/0/settings_ssaid.xml</code> ，这个目录下，<code>/data/system/users/0/</code>我发现这里面全是各种注册表和各种配置信息。我这边尝试改了一下里面的<code>android id</code> 。然后直接手机重启 ，我发现我之前自己写的<code>Hunter</code>获取的设备指纹<code>android id</code>竟然变了</p>
<p>后来我把这些文件都拷贝出来，把里面熟悉的值都随机了一份，通过magisk 插件系统文件替换的方式，对文件<code>/data/system/users/0/</code>进行替换 ，真没想到以前被封的设备解封了。而且不需要回复出厂设置，只需要<strong>软重启</strong>一下就行</p>
<p><strong>而且基本可以做到无痕 ，因为没有对apk任何修改，改的全是系统级别的变量，而我只需要Root ，替换系统文件，相当于每一次都是恢复出厂设置</strong></p>
<p>现在基本大厂想要在回复出厂设置保持设备指纹不变基本不可能 。这套方案我测试过一段时间，现阶段基本大厂从客户端角度基本没办法对抗，只能靠一些服务端指纹去做检测。</p>
<h4 id="服务端级别设备指纹"><a href="#服务端级别设备指纹" class="headerlink" title="服务端级别设备指纹"></a>服务端级别设备指纹</h4><p>服务端去获取客户端的IPV6信息，配合客户端上报。IPV6号称能给世界上每粒沙子分配一个ip，2的128次方</p>
<p>可以在设备指纹初始化的时候调用一下接口，服务端网关层去获取IpV6信息 。将信息保存作为客户端设备指纹</p>
<p><strong>tls最新版+socket进行通讯</strong> ，用这个ipv6作为设备指纹 。当然这块也需要防代理，具体的方案也很多，比如一些大厂会去购买一些代理IP，试用的时候去请求自己的网关，然后把这些IP都拉黑</p>
<h3 id="Hunter检测-反制"><a href="#Hunter检测-反制" class="headerlink" title="Hunter检测&amp;反制"></a>Hunter检测&amp;反制</h3><p>这块主要是介绍一些比较新奇的对抗和检测 ，也是我之前在做黑产对抗的时候发现的一些办法</p>
<h4 id="MapIo重定向Anti"><a href="#MapIo重定向Anti" class="headerlink" title="MapIo重定向Anti"></a>MapIo重定向Anti</h4><p>一般在实现一机多号的时候，因为需要对不同的账号进行<strong>IO重定向</strong>，把不同的账号，保存到自己的虚拟分身里面</p>
<p>这时候如果你要读取<code>Maps</code>去遍历<code>Item</code>的时候就会发现这个<code>Item</code>异常，一般沙箱开发者会将<code>MapsIo</code>重定向</p>
<p>当发现读取<code>Maps</code>的时候指向自己的文件，因为这个Maps是不断变化的，所以需要在<code>svc openat</code>这块进行拦截生成一份新的。然后指向到这份新的文件，在新的<code>maps</code>里面他会对里面的<code>item</code>路径进行反转，转换成正常的目录，而不是包含沙箱的目录，导致获取的数据被欺骗</p>
<p>这块读文件偏移完全可以不读取<code>Maps</code> ，而是读取<code>proc/self/maps_files</code>对这个文件进行<code>opendir</code> ，对每个文件进行遍历，然后再路径拼接，通过<code>readlinkat</code>去反查路径即可</p>
<h4 id="“反调试”进程检测实现细节"><a href="#“反调试”进程检测实现细节" class="headerlink" title="“反调试”进程检测实现细节"></a>“反调试”进程检测实现细节</h4><p>一般<code>Apk</code>都会开启一条线程作为检测反调试线程，这条线每隔几秒对线程进行一些特征进行检查当前进程是否被调试</p>
<p>有很多攻击者会<code>Hook</code>线程创建的办法，然后在线程启动的时候进行<code>pass</code>，不让其启动，以实现逃过检测的办法</p>
<p>这种情况其实对抗也很简单，可以在主线程搞个<code>flag</code>，只有在调试线程开启的时候，并且检测执行成功的时候使用<code>process_vm_writev</code>对<code>flag</code>进行写入</p>
<p>因为是异步，所以主线程可以延迟2秒钟对这个<code>flag</code>进行检测，判断调试线程是否开启，如果没开启上报埋点即可</p>
<h4 id="自实现RegisterNativeMethod"><a href="#自实现RegisterNativeMethod" class="headerlink" title="自实现RegisterNativeMethod"></a>自实现RegisterNativeMethod</h4><p>我们正常注册一个native方法是调用的<code>env-&gt;RegisterNatives</code> ，但是这种直接api调用很有可能被Hook</p>
<p>所以我们可以自己实现一份 ，因为native注册底层本质上是给<code>artmethod</code>里面的<code>fnptr</code>进行赋值，最终调用<code>artmethod</code>里面的<code>RegisterNative</code>方法，所以我们可以不直接调用<code>Jni</code>直接走<code>artmethod</code>里面的注册方法</p>
<p>具体实现如下，因为<code>artmethod</code>里面的注册方法每个版本的实现都不一样 ，所以这块需要根据不同版本进行<code>case</code>分发 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//call art method register</span><br><span class="line">if (!RegisterNativeMethod(env, NativeEngine,</span><br><span class="line">                          SignatureFixMethods,</span><br><span class="line">                          sizeof(SignatureFixMethods) / sizeof(SignatureFixMethods[0]))) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; &quot;JNI_OnLoad call art method register fail ,start env register natives! &quot;;</span><br><span class="line"> </span><br><span class="line">    env-&gt;RegisterNatives(NativeEngine,</span><br><span class="line">                         SignatureFixMethods,</span><br><span class="line">                         sizeof(SignatureFixMethods) / sizeof(SignatureFixMethods[0]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的话很简单直接尝试调用我们自己实现的方法，如果失败了则调用系统的api ，这样可以有效防止<code>jni</code>被<code>hook</code>实现，<code>jni RegisterNative</code> 函数被监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Created by Zhenxi on 2022/8/22.</span><br><span class="line">//</span><br><span class="line"> </span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &quot;../include/logging.h&quot;</span><br><span class="line">#include &quot;../include/libpath.h&quot;</span><br><span class="line">#include &quot;../include/dlfcn_compat.h&quot;</span><br><span class="line">#include &quot;../include/version.h&quot;</span><br><span class="line">#include &quot;../include/main.h&quot;</span><br><span class="line"> </span><br><span class="line">static void *art_method_register = nullptr;</span><br><span class="line"> </span><br><span class="line">static void *class_linker_ = nullptr;</span><br><span class="line"> </span><br><span class="line">size_t OffsetOfJavaVm(bool has_small_irt, int SDK_INT) &#123;</span><br><span class="line"> </span><br><span class="line">    if (has_small_irt) &#123;</span><br><span class="line">        switch (SDK_INT) &#123;</span><br><span class="line">            case ANDROID_T:</span><br><span class="line">            case ANDROID_SL:</span><br><span class="line">            case ANDROID_S:</span><br><span class="line">                return sizeof(void *) == 8 ? 624 : 300;</span><br><span class="line">            case ANDROID_R:</span><br><span class="line">            case ANDROID_Q:</span><br><span class="line">                return sizeof(void *) == 8 ? 528 : 304;</span><br><span class="line">            default:</span><br><span class="line">                LOGE(&quot;OffsetOfJavaVM Unexpected android version %d&quot;, SDK_INT);</span><br><span class="line">                abort();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        switch (SDK_INT) &#123;</span><br><span class="line">            case ANDROID_T:</span><br><span class="line">            case ANDROID_SL:</span><br><span class="line">            case ANDROID_S:</span><br><span class="line">                return sizeof(void *) == 8 ? 520 : 300;</span><br><span class="line">            case ANDROID_R:</span><br><span class="line">            case ANDROID_Q:</span><br><span class="line">                return sizeof(void *) == 8 ? 496 : 288;</span><br><span class="line">            default:</span><br><span class="line">                LOGE(&quot;OffsetOfJavaVM Unexpected android version %d&quot;, SDK_INT);</span><br><span class="line">                abort();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">int findOffset(void *start, size_t len, size_t step, T value) &#123;</span><br><span class="line"> </span><br><span class="line">    if (nullptr == start) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt;= len; i += step) &#123;</span><br><span class="line">        T current_value = *reinterpret_cast&lt;T *&gt;((size_t) start + i);</span><br><span class="line">        if (value == current_value) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line">* 根据runtime获取class_linker</span><br><span class="line">* https://github.com/magician8520/BlackBox/blob/99f26925aa303fd0a71543e3713ef3fc57a08e81/Bcore/pine-core/src/main/cpp/android.h#L36</span><br><span class="line">*/</span><br><span class="line">void *getClassLinker() &#123;</span><br><span class="line">    if (class_linker_ != nullptr) &#123;</span><br><span class="line">        return class_linker_;</span><br><span class="line">    &#125;</span><br><span class="line">    int SDK_INT = get_sdk_level();</span><br><span class="line">    // If SmallIrtAllocator symbols can be found, then the ROM has merged commit &quot;Initially allocate smaller local IRT&quot;</span><br><span class="line">    // This commit added a pointer member between `class_linker_` and `java_vm_`. Need to calibrate offset here.</span><br><span class="line">    // https://android.googlesource.com/platform/art/+/4dcac3629ea5925e47b522073f3c49420e998911</span><br><span class="line">    // https://github.com/crdroidandroid/android_art/commit/aa7999027fa830d0419c9518ab56ceb7fcf6f7f1</span><br><span class="line">    bool has_smaller_irt = getSymCompat(getlibArtPath(),</span><br><span class="line">                                        &quot;_ZN3art17SmallIrtAllocator10DeallocateEPNS_8IrtEntryE&quot;) !=</span><br><span class="line">                           nullptr;</span><br><span class="line">    size_t jvm_offset = OffsetOfJavaVm(has_smaller_irt, SDK_INT);</span><br><span class="line">    auto runtime_instance_ = *reinterpret_cast&lt;void **&gt;</span><br><span class="line">    (getSymCompat(getlibArtPath(), &quot;_ZN3art7Runtime9instance_E&quot;));</span><br><span class="line"> </span><br><span class="line">    auto val = jvm_offset</span><br><span class="line">               ? reinterpret_cast&lt;std::unique_ptr&lt;JavaVM&gt; *&gt;(</span><br><span class="line">                       reinterpret_cast&lt;uintptr_t&gt;(runtime_instance_) + jvm_offset)-&gt;get()</span><br><span class="line">               : nullptr;</span><br><span class="line">    if (val == getVm()) &#123;</span><br><span class="line">        LOGD(&quot;JavaVM offset matches the default offset&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        LOGW(&quot;JavaVM offset mismatches the default offset, try search the memory of Runtime&quot;);</span><br><span class="line">        int offset = findOffset(runtime_instance_, 1024, 4, getVm());</span><br><span class="line">        if (offset == -1) &#123;</span><br><span class="line">            LOGE(&quot;Failed to find java vm from Runtime&quot;);</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        jvm_offset = offset;</span><br><span class="line">        LOGW(&quot;Found JavaVM in Runtime at %zu&quot;, jvm_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    const size_t kDifference = has_smaller_irt</span><br><span class="line">                               ? sizeof(std::unique_ptr&lt;void&gt;) + sizeof(void *) * 3</span><br><span class="line">                               : SDK_INT == ANDROID_Q</span><br><span class="line">                                 ? sizeof(void *) * 2</span><br><span class="line">                                 : sizeof(std::unique_ptr&lt;void&gt;) + sizeof(void *) * 2;</span><br><span class="line"> </span><br><span class="line">    class_linker_ = *reinterpret_cast&lt;void **&gt;(reinterpret_cast&lt;uintptr_t&gt;(runtime_instance_) +</span><br><span class="line">                                               jvm_offset - kDifference);</span><br><span class="line">    return class_linker_;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">bool call_MethodRegister(JNIEnv *env, void *art_method, void *native_method) &#123;</span><br><span class="line">    if (art_method_register == nullptr) &#123;</span><br><span class="line">        if (get_sdk_level() &lt; ANDROID_S) &#123;</span><br><span class="line">            //android 11</span><br><span class="line">            art_method_register = getSymCompat(getlibArtPath(),</span><br><span class="line">                                               &quot;_ZN3art9ArtMethod14RegisterNativeEPKv&quot;);</span><br><span class="line">            if (art_method_register == nullptr) &#123;</span><br><span class="line">                art_method_register = getSymCompat(getlibArtPath(),</span><br><span class="line">                                                   &quot;_ZN3art9ArtMethod14RegisterNativeEPKvb&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //12以上还是在libart里面,但是在linker里面实现,符号名称存在变化</span><br><span class="line">            art_method_register = getSymCompat(getlibArtPath(),</span><br><span class="line">                                               &quot;_ZN3art11ClassLinker14RegisterNativeEPNS_6ThreadEPNS_9ArtMethodEPKv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (art_method_register == nullptr) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method  get art_method_register = null  &quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (get_sdk_level() &gt;= ANDROID_S) &#123;</span><br><span class="line">        //12以上</span><br><span class="line">        //const void* RegisterNative(Thread* self, ArtMethod* method, const void* native_method)</span><br><span class="line">        auto call = reinterpret_cast&lt;void *(*)(void *, void *, void *,</span><br><span class="line">                                               void *)&gt;(art_method_register);</span><br><span class="line">        //get self thread</span><br><span class="line">        void *self = getSymCompat(getlibArtPath(), &quot;_ZN3art6Thread14CurrentFromGdbEv&quot;);</span><br><span class="line">        if (self == nullptr) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method  get CurrentFromGdb = null  &quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //手动计算一下linker实例地址</span><br><span class="line">        void *classLinker = getClassLinker();</span><br><span class="line">        if (classLinker == nullptr) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method  get getClassLinker = null  &quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        call(classLinker, self, art_method, native_method);</span><br><span class="line">        //LOG(ERROR) &lt;&lt; &quot;register native method  get getClassLinker success!  &quot;;</span><br><span class="line">    &#125; else if (get_sdk_level() &gt;= ANDROID_R) &#123;</span><br><span class="line">        auto call = reinterpret_cast&lt;void *(*)(void *, void *)&gt;(art_method_register);</span><br><span class="line">        call(art_method, native_method);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        auto call = reinterpret_cast&lt;void *(*)(void *, void *, bool)&gt;(art_method_register);</span><br><span class="line">        call(art_method, native_method, true);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">inline static bool IsIndexId(jmethodID mid) &#123;</span><br><span class="line">    return ((reinterpret_cast&lt;uintptr_t&gt;(mid) % 2) != 0);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static jfieldID field_art_method = nullptr;</span><br><span class="line"> </span><br><span class="line">bool RegisterNativeMethod(JNIEnv *env,</span><br><span class="line">                          jclass clazz,</span><br><span class="line">                          const JNINativeMethod *methods,</span><br><span class="line">                          size_t nMethods) &#123;</span><br><span class="line">    if (env == nullptr) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; &quot;register native method  JNIEnv = null  &quot;;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    void *arm_method = nullptr;</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt; nMethods; i++) &#123;</span><br><span class="line">        jmethodID methodId = env-&gt;GetMethodID(clazz, methods[i].name, methods[i].signature);</span><br><span class="line">        if (methodId == nullptr) &#123;</span><br><span class="line">            //maybe static</span><br><span class="line">            env-&gt;ExceptionClear();</span><br><span class="line">            methodId = env-&gt;GetStaticMethodID(clazz, methods[i].name, methods[i].signature);</span><br><span class="line">            if (methodId == nullptr) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;register native method  get orig method  == null  &quot;</span><br><span class="line">                           &lt;&lt; methods[i].signature;</span><br><span class="line">                env-&gt;ExceptionClear();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (get_sdk_level() &gt;= ANDROID_R) &#123;</span><br><span class="line">            if (field_art_method == nullptr) &#123;</span><br><span class="line">                jclass pClazz = env-&gt;FindClass(&quot;java/lang/reflect/Executable&quot;);</span><br><span class="line">                field_art_method = env-&gt;GetFieldID(pClazz, &quot;artMethod&quot;, &quot;J&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (field_art_method == nullptr) &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; &quot;register native method  get artMethod  == null  &quot;;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (IsIndexId(methodId)) &#123;</span><br><span class="line">                jobject method = env-&gt;ToReflectedMethod(clazz, methodId, true);</span><br><span class="line">                arm_method = reinterpret_cast&lt;void *&gt;(env-&gt;GetLongField(method, field_art_method));</span><br><span class="line">                //LOG(ERROR) &lt;&lt; &quot;arm_method   &quot;&lt;&lt;arm_method ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            arm_method = methodId;</span><br><span class="line">        &#125;</span><br><span class="line">        if (arm_method == nullptr) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method art method  == null  &quot;;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!call_MethodRegister(env, arm_method, methods[i].fnPtr)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; &quot;register native method fail  &quot; &lt;&lt;</span><br><span class="line">                       methods[i].name &lt;&lt; &quot;  &quot; &lt;&lt; methods[i].signature;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">//        LOG(INFO) &lt;&lt; &quot;register native method success  &quot; &lt;&lt; methods[i].name &lt;&lt; &quot;  &quot;</span><br><span class="line">//                  &lt;&lt; methods[i].signature;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过牺牲稳定性和可移植性来换取高度的隐蔽性</p>
<h3 id="无Root情况客户端对抗的边界值"><a href="#无Root情况客户端对抗的边界值" class="headerlink" title="无Root情况客户端对抗的边界值"></a>无Root情况客户端对抗的边界值</h3><p>如果在不Root的情况下，注入方法主要两种，重打包或者把Apk放到沙箱里面</p>
<p>主要的三个核心功能组成水桶木板分别如下</p>
<ul>
<li>设备指纹</li>
<li>环境&amp;风险检测能力</li>
<li>代码防护</li>
</ul>
<p>第一项每个大厂都不一样，<strong>根据不同的策略每个字段的比重占比也都不一样</strong> 。</p>
<p>把一些常见的或者第一篇和第二篇提到的对着改一下即可</p>
<p>第三项现在So层基本大厂都差不多，都是各种混淆配合控制流 ，但是Java层防护做的不够，参考<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-255514.htm%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%BA%9F%E6%8E%89Jadx%E5%8F%8D%E7%BC%96%E8%AF%91%E8%BD%AF%E4%BB%B6">https://bbs.kanxue.com/thread-255514.htm，可以直接废掉Jadx反编译软件</a> </p>
<p>这块重点介绍一下第二项，包括一些常见的子项 ，每个子项还可以继续划分各种检测方式 。</p>
<ul>
<li>环境&amp;风险检测能力<ul>
<li>重打包检测能力</li>
<li>Hook检测能力 。</li>
<li>模拟器&amp;云手机&amp;自定义ROM检测能力</li>
<li>多开&amp;沙箱检测能力</li>
<li>风险Apk检测能力</li>
</ul>
</li>
</ul>
<p>上面说的这几项便是不同”气味“的组成部分，而这个”气味”<strong>采集方式的边界值</strong>又分为三部分 。</p>
<ul>
<li><strong>Java层就是IPC协议</strong> ，因为<strong>IPC协议是当前进程可以操作的最后一个方法</strong> 。剩下的就是服务端给喂数据了。</li>
<li><strong>Native层就是SVC拦截</strong>，因为SVC是Linux进入内核的最后一条指令。</li>
<li>还有一种是<strong>读文件</strong> ，这块区分成两部分<ul>
<li><strong>进程文件，也就是&#x2F;proc&#x2F;下面的</strong></li>
<li><strong>系统文件，系统提供的一些文件可供读取。</strong></li>
</ul>
</li>
</ul>
<p>好 ，根据上面的总结，<strong>只要我们在上面的三个边界值进行拦截理论上就是最完美的方案 。</strong></p>
<h3 id="“边界值”拦截技术实现："><a href="#“边界值”拦截技术实现：" class="headerlink" title="“边界值”拦截技术实现："></a>“边界值”拦截技术实现：</h3><p>下面的架子是珍惜大佬的沙箱的设计模式 ，这块也是分享一下对应的“架构” 。</p>
<h4 id="IPC协议拦截："><a href="#IPC协议拦截：" class="headerlink" title="IPC协议拦截："></a>IPC协议拦截：</h4><p>先说IPC，IPC的话很简单，我在上面也说了可以动态代理，也可以直接去用Hook框架<code>Hook binder</code>里面的交互方法 。当发现触发指定的IPC协议的时候，直接模拟服务端往里面写入即可。</p>
<p>这块还有个细节点，为了防止程序直接通过<code>cache</code>获取，因为有的字段初始化以后可能被保存到<code>cache</code>里面 ，如果不存在的话再通过ipc去获取。<strong>Apk在启动一瞬间就进行了初始化，cache会被保存</strong>。很多IPC代理人会这么设计，所以<strong>需要清理掉cache</strong>，这个cache可以是Parcel的cache也可以是IPC代理人里面的cache 。<strong>比如Parcel里面的mCreators 或者sPairedCreators 都需要清空</strong> 。如果是IPC代理人的话也可以看代码看具体实现，看看是否包含cache，有的话清掉即可</p>
<h4 id="SVC拦截："><a href="#SVC拦截：" class="headerlink" title="SVC拦截："></a>SVC拦截：</h4><p>主要用的是ptrace+seccomp做的架子</p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273160.htm">https://bbs.kanxue.com/thread-273160.htm</a></p>
<h4 id="文件读取："><a href="#文件读取：" class="headerlink" title="文件读取："></a>文件读取：</h4><p>这块分为两部分，<code>proc</code>下的文件我会使用<code>fuse</code> 对整个<code>proc</code>进行模拟 ，这是完美方案 。<code>proot</code>代码写好现成的，迁移到android 上直接用就好了。</p>
<p>如果是读取系统文件的话，可以直接使用 IO重定向配合SVC拦截即可，SVC都可以拦截了，任何文件读取你都可以随便修改 。 </p>
<p><strong>因为不管如何，最终都会调用到系统内核去读取文件，都会被转换成SVC指令 。</strong></p>
<p>第四篇：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-281889-1.htm">https://bbs.kanxue.com/thread-281889-1.htm</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io">s1nec-1o</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://s1nec-1o.github.io/2025/10/21/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8B%E5%88%9D%E8%AF%86%E9%A3%8E%E6%8E%A7-2/">http://s1nec-1o.github.io/2025/10/21/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8B%E5%88%9D%E8%AF%86%E9%A3%8E%E6%8E%A7-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://s1nec-1o.github.io" target="_blank">S1nec-1o's B1og</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/android/">android</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/11/03/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8BAntiFakerAndroidChecker/" title="Android逆向从入门到入土之AntiFakerAndroidChecker(3)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android逆向从入门到入土之AntiFakerAndroidChecker(3)</div></div></a></div><div class="next-post pull-right"><a href="/2025/10/11/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-1/" title="Android逆向从入门到入土(1)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android逆向从入门到入土(1)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/04/14/Android%E9%80%86%E5%90%91%E4%B9%8BWiki%E7%AF%87/" title="Android逆向之Wiki篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-14</div><div class="title">Android逆向之Wiki篇</div></div></a></div><div><a href="/2025/11/03/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8BAntiFakerAndroidChecker/" title="Android逆向从入门到入土之AntiFakerAndroidChecker(3)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-03</div><div class="title">Android逆向从入门到入土之AntiFakerAndroidChecker(3)</div></div></a></div><div><a href="/2025/10/11/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-1/" title="Android逆向从入门到入土(1)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-11</div><div class="title">Android逆向从入门到入土(1)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281614288.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">s1nec-1o</div><div class="author-info__description">万事胜意</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="http://github.com/s1nec-1o"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">正在学习iot pwn 欢迎广大师傅与我交流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9%EF%BC%88Device-Fingerprint%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">设备指纹（Device Fingerprint）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hook-Binder"><span class="toc-number">2.2.</span> <span class="toc-text">Hook Binder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#APatch-%E5%86%85%E6%A0%B8%E5%B1%82%E5%AF%B9%E6%8A%97"><span class="toc-number">2.3.</span> <span class="toc-text">APatch - 内核层对抗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%8E%E6%8E%A7%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">风控概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9C%9C%E7%BD%90%E6%95%B0%E6%8D%AE"><span class="toc-number">3.1.</span> <span class="toc-text">蜜罐数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E9%99%90%E5%88%B6%EF%BC%9A"><span class="toc-number">3.2.</span> <span class="toc-text">IP限制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9"><span class="toc-number">3.3.</span> <span class="toc-text">设备指纹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#App%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">App环境信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Root%E6%A3%80%E6%B5%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">Root检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook%E6%A3%80%E6%B5%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">Hook检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B"><span class="toc-number">3.4.3.</span> <span class="toc-text">沙箱&amp;虚拟环境检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#APK%E7%AD%BE%E5%90%8D%E6%A3%80%E6%B5%8B"><span class="toc-number">3.4.4.</span> <span class="toc-text">APK签名检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B"><span class="toc-number">3.4.5.</span> <span class="toc-text">模拟器检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89ROM"><span class="toc-number">3.4.6.</span> <span class="toc-text">自定义ROM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%9D%80%E5%88%86%E7%A6%BB"><span class="toc-number">3.5.</span> <span class="toc-text">查杀分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA-%E5%BF%83%E8%B7%B3%E5%8C%85%E4%B8%8A%E6%8A%A5"><span class="toc-number">3.6.</span> <span class="toc-text">用户行为&amp;心跳包上报</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.6.1.</span> <span class="toc-text">检测原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8A%97%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.2.</span> <span class="toc-text">对抗原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-%E8%A1%8C%E4%B8%BA%E5%9F%8B%E7%82%B9"><span class="toc-number">3.7.</span> <span class="toc-text">异常&amp;行为埋点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.1.</span> <span class="toc-text">检测原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8A%97%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.7.2.</span> <span class="toc-text">对抗原理：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">3.8.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9%E8%8E%B7%E5%8F%96"><span class="toc-number"></span> <span class="toc-text">设备指纹获取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-IPC%E4%BB%A3%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">Android IPC代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9-1"><span class="toc-number">2.</span> <span class="toc-text">设备指纹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%B1%82%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9"><span class="toc-number">2.1.</span> <span class="toc-text">Java层设备指纹</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Setting%E7%9B%B8%E5%85%B3%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">Setting相关（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Get:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">Mock:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%93%9D%E7%89%99%E7%BD%91%E5%8D%A1MAC%EF%BC%88%E6%99%AE%E9%80%9A%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">蓝牙网卡MAC（普通）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">Get:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock%EF%BC%9A"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">Mock：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#serial%EF%BC%88%E6%99%AE%E9%80%9A%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">serial（普通）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#get"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">get:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock-1"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">Mock:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IMEI-IMSI-ICCID-Line1Number-%E6%99%AE%E9%80%9A"><span class="toc-number">2.1.4.</span> <span class="toc-text">IMEI , IMSI ,ICCID,Line1Number (普通)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#get%EF%BC%9A"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">get：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock%EF%BC%9A-1"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">Mock：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Build%E7%9B%B8%E5%85%B3%EF%BC%88%E6%AC%A1%E8%A6%81%EF%BC%89"><span class="toc-number">2.1.5.</span> <span class="toc-text">Build相关（次要）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%EF%BC%9A"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">配置相关：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E5%AD%97%E6%AE%B5"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">单一字段:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%AD%97%E6%AE%B5%EF%BC%9A"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">复合字段：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-2"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">Get:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock-2"><span class="toc-number">2.1.5.5.</span> <span class="toc-text">Mock:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%EF%BC%88%E6%99%AE%E9%80%9A%EF%BC%89%EF%BC%9A"><span class="toc-number">2.1.6.</span> <span class="toc-text">系统默认账号（普通）：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-3"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">Get:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock-3"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">Mock:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9F%B3%E9%87%8F%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%EF%BC%88%E6%99%AE%E9%80%9A%EF%BC%89"><span class="toc-number">2.1.7.</span> <span class="toc-text">音量相关函数（普通）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-4"><span class="toc-number">2.1.7.1.</span> <span class="toc-text">Get:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock-4"><span class="toc-number">2.1.7.2.</span> <span class="toc-text">Mock:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9B%B8%E5%85%B3%EF%BC%88%E6%99%AE%E9%80%9A%EF%BC%89%EF%BC%9A"><span class="toc-number">2.1.8.</span> <span class="toc-text">传感器相关（普通）：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-5"><span class="toc-number">2.1.8.1.</span> <span class="toc-text">Get:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock-5"><span class="toc-number">2.1.8.2.</span> <span class="toc-text">Mock:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%B1%82DRM%E7%9B%B8%E5%85%B3%EF%BC%88%E9%87%8D%E8%A6%81%E5%AD%97%E6%AE%B5%EF%BC%89"><span class="toc-number">2.1.9.</span> <span class="toc-text">Java层DRM相关（重要字段）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-6"><span class="toc-number">2.1.9.1.</span> <span class="toc-text">Get:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%B1%82%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF%EF%BC%88%E6%99%AE%E9%80%9A%EF%BC%89"><span class="toc-number">2.1.10.</span> <span class="toc-text">Java层网卡信息（普通）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4%EF%BC%88%E6%AC%A1%E8%A6%81%EF%BC%89"><span class="toc-number">2.1.11.</span> <span class="toc-text">文件创建时间（次要）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9"><span class="toc-number">2.2.</span> <span class="toc-text">Native设备指纹</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Build-system-property-get-system-property-read-%E9%87%8D%E8%A6%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">Build(system_property_get &amp; system_property_read)(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-7"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">Get:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Native%E8%8E%B7%E5%8F%96DRM-ID%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">Native获取DRM ID（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Get-8"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">Get:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock-6"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">Mock:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netlinker%E8%8E%B7%E5%8F%96%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.3.</span> <span class="toc-text">Netlinker获取网卡信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">内核文件相关（重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#build-prop%E7%9B%B8%E5%85%B3"><span class="toc-number">2.2.5.</span> <span class="toc-text">build.prop相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proc-sys-kernel-random-boot-id"><span class="toc-number">2.2.6.</span> <span class="toc-text">&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proc-sys-kernel-random-uuid"><span class="toc-number">2.2.7.</span> <span class="toc-text">&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;uuid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sys-block-mmcblk0-device-cid"><span class="toc-number">2.2.8.</span> <span class="toc-text">&#x2F;sys&#x2F;block&#x2F;mmcblk0&#x2F;device&#x2F;cid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sys-devices-soc0-serial-number"><span class="toc-number">2.2.9.</span> <span class="toc-text">&#x2F;sys&#x2F;devices&#x2F;soc0&#x2F;serial_number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proc-misc"><span class="toc-number">2.2.10.</span> <span class="toc-text">&#x2F;proc&#x2F;misc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proc-version"><span class="toc-number">2.2.11.</span> <span class="toc-text">&#x2F;proc&#x2F;version</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#popen%E7%9B%B8%E5%85%B3"><span class="toc-number">2.3.</span> <span class="toc-text">popen相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uname-a"><span class="toc-number">2.3.1.</span> <span class="toc-text">uname -a</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getprop"><span class="toc-number">2.3.2.</span> <span class="toc-text">getprop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mock-7"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">Mock:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E7%9A%84cat"><span class="toc-number">2.3.3.</span> <span class="toc-text">内核相关文件的cat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps-ef-ps"><span class="toc-number">2.3.4.</span> <span class="toc-text">ps -ef &amp; ps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ip-a%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">2.3.5.</span> <span class="toc-text">ip a（重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ls-al-sdcard-Android-data"><span class="toc-number">2.3.6.</span> <span class="toc-text">ls -al &#x2F;sdcard&#x2F;Android&#x2F;data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#popen%E6%89%AB%E6%8F%8FMagisk"><span class="toc-number">2.3.7.</span> <span class="toc-text">popen扫描Magisk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#popen-logcat"><span class="toc-number">2.3.8.</span> <span class="toc-text">popen logcat</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APK%E7%AD%BE%E5%90%8D%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">APK签名：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%B1%82%E7%9B%B4%E6%8E%A5-%E9%80%9A%E8%BF%87binder%E5%92%8C-AMS-%E9%80%9A%E8%AE%AF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF%E3%80%82"><span class="toc-number">3.1.</span> <span class="toc-text">Java 层直接 通过binder和 AMS 通讯获取真实签名信息。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">绕过原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hook-demp"><span class="toc-number">3.1.2.</span> <span class="toc-text">Hook demp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native%E5%B1%82-svc%E8%AF%BB%E5%8F%96-data-app-%E5%8C%85%E5%90%8D-base-apk-%E8%A7%A3%E6%9E%90zip-%E8%A7%A3%E6%9E%90%E9%87%8C%E9%9D%A2%E7%9A%84%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E3%80%82"><span class="toc-number">3.2.</span> <span class="toc-text">Native层 svc读取&#x2F;data&#x2F;app&#x2F;包名&#x2F;base.apk 解析zip 解析里面的签名文件信息。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">绕过原理：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B92"><span class="toc-number">4.</span> <span class="toc-text">设备指纹2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-Id"><span class="toc-number">4.1.</span> <span class="toc-text">Android Id</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A"><span class="toc-number">4.1.1.</span> <span class="toc-text">方法1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A"><span class="toc-number">4.1.2.</span> <span class="toc-text">方法2：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A"><span class="toc-number">4.1.3.</span> <span class="toc-text">方法3：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A"><span class="toc-number">4.1.4.</span> <span class="toc-text">方法4：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E5%AD%97%E8%8A%82%E6%80%BB%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.2.</span> <span class="toc-text">硬盘字节总大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mac%E5%9C%B0%E5%9D%80"><span class="toc-number">4.3.</span> <span class="toc-text">Mac地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E8%BF%91%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">4.4.</span> <span class="toc-text">附近网卡信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV6"><span class="toc-number">4.5.</span> <span class="toc-text">IPV6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E4%BF%A1%E6%81%AF"><span class="toc-number">4.6.</span> <span class="toc-text">系统内核信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%90%8D%E9%9A%8F%E6%9C%BA%E8%B7%AF%E5%BE%84"><span class="toc-number">4.7.</span> <span class="toc-text">包名随机路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B4%A6%E5%8F%B7"><span class="toc-number">4.8.</span> <span class="toc-text">系统账号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B"><span class="toc-number">5.</span> <span class="toc-text">环境检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Apk%E7%AD%BE%E5%90%8D"><span class="toc-number">5.1.</span> <span class="toc-text">Apk签名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Native%E5%B1%82%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">Native层获取签名方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8A%97"><span class="toc-number">5.1.3.</span> <span class="toc-text">对抗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%B1%82%E8%8E%B7%E5%8F%96%E7%AD%BE%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">Java层获取签名方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B-1"><span class="toc-number">5.1.5.</span> <span class="toc-text">检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%B5%8BCREATOR%E6%98%AF%E5%90%A6%E8%A2%AB%E6%9B%BF%E6%8D%A2"><span class="toc-number">5.1.5.1.</span> <span class="toc-text">检测CREATOR是否被替换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8A%97-1"><span class="toc-number">5.1.6.</span> <span class="toc-text">对抗</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Hook%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A7%A3%E6%9E%90%E7%AD%BE%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.6.1.</span> <span class="toc-text">Hook服务端解析签名方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2CREATOR"><span class="toc-number">5.1.6.2.</span> <span class="toc-text">替换CREATOR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Binder-transact-%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.6.3.</span> <span class="toc-text">Binder transact 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B-1"><span class="toc-number">5.2.</span> <span class="toc-text">模拟器检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Seccomp%E6%A3%80%E6%B5%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">5.2.1.</span> <span class="toc-text">Seccomp检测架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%B8%A9%E5%BA%A6%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.2.</span> <span class="toc-text">检测温度挂载文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%89%B9%E5%BE%81%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.3.</span> <span class="toc-text">模拟器特征文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%9F%BA%E7%A1%80%E7%89%B9%E5%BE%81"><span class="toc-number">5.2.4.</span> <span class="toc-text">模拟器基础特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%BA%91%E6%89%8B%E6%9C%BA"><span class="toc-number">5.3.</span> <span class="toc-text">检测云手机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E7%94%B5%E6%B5%81-%E7%94%B5%E5%8E%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">检测电流&amp;电压</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%91%84%E5%83%8F%E5%A4%B4-%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">5.3.2.</span> <span class="toc-text">检测摄像头&amp;传感器相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%BC%A0%E6%84%9F%E5%99%A8%E4%B8%AA%E6%95%B0"><span class="toc-number">5.3.3.</span> <span class="toc-text">检测传感器个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%BC%A0%E6%84%9F%E5%99%A8%E5%90%8D%E7%A7%B0"><span class="toc-number">5.3.4.</span> <span class="toc-text">检测传感器名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%8C%82%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="toc-number">5.3.5.</span> <span class="toc-text">检测挂载文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8BROM%E6%98%AF%E5%90%A6Match"><span class="toc-number">5.3.6.</span> <span class="toc-text">检测ROM是否Match</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF%EF%BC%9A"><span class="toc-number">5.3.6.1.</span> <span class="toc-text">检测环境信息：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8%EF%BC%9A"><span class="toc-number">5.3.6.2.</span> <span class="toc-text">检测服务列表：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E6%98%AF%E5%90%A6%E8%A2%ABHook"><span class="toc-number">5.4.</span> <span class="toc-text">检测当前环境是否被Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%B2%99%E7%AE%B1"><span class="toc-number">5.5.</span> <span class="toc-text">检测沙箱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%A4%9A%E4%BD%99%E7%BA%BF%E7%A8%8BPID"><span class="toc-number">5.5.1.</span> <span class="toc-text">检测多余线程PID:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%8A%97%EF%BC%9A"><span class="toc-number">5.5.1.1.</span> <span class="toc-text">对抗：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cps%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">5.5.2.</span> <span class="toc-text">执行ps命令：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%8A%97%EF%BC%9A-1"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">对抗：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98Choose"><span class="toc-number">5.5.3.</span> <span class="toc-text">内存Choose:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8BGoogle-lineageos"><span class="toc-number">5.6.</span> <span class="toc-text">检测Google&amp;lineageos</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8BIDA%E5%92%8C%E5%8F%8D%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="toc-number">5.7.</span> <span class="toc-text">检测IDA和反调试：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#service-list"><span class="toc-number">5.7.1.</span> <span class="toc-text">service list</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B93"><span class="toc-number">6.</span> <span class="toc-text">设备指纹3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">6.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPC%E4%BB%A3%E7%90%86-IPC%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">IPC代理&amp;IPC协议是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86IPC"><span class="toc-number">6.1.2.</span> <span class="toc-text">动态代理IPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9-2"><span class="toc-number">6.2.</span> <span class="toc-text">设备指纹</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPCAndroid-Id"><span class="toc-number">6.2.1.</span> <span class="toc-text">IPCAndroid_Id</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%955%EF%BC%9A"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">方法5：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPCAppSign"><span class="toc-number">6.2.2.</span> <span class="toc-text">IPCAppSign</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Maps%E8%A7%A3%E6%9E%90Apk%E7%AD%BE%E5%90%8D"><span class="toc-number">6.2.3.</span> <span class="toc-text">Maps解析Apk签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5IPC"><span class="toc-number">6.2.4.</span> <span class="toc-text">其他字段IPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPC%E6%80%BB%E7%BB%93-%E5%8F%8D%E6%80%9D"><span class="toc-number">6.2.5.</span> <span class="toc-text">IPC总结&amp;反思</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BA%A7%E5%88%AB%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9"><span class="toc-number">6.2.6.</span> <span class="toc-text">服务端级别设备指纹</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hunter%E6%A3%80%E6%B5%8B-%E5%8F%8D%E5%88%B6"><span class="toc-number">6.3.</span> <span class="toc-text">Hunter检测&amp;反制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MapIo%E9%87%8D%E5%AE%9A%E5%90%91Anti"><span class="toc-number">6.3.1.</span> <span class="toc-text">MapIo重定向Anti</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E5%8F%8D%E8%B0%83%E8%AF%95%E2%80%9D%E8%BF%9B%E7%A8%8B%E6%A3%80%E6%B5%8B%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">6.3.2.</span> <span class="toc-text">“反调试”进程检测实现细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9E%E7%8E%B0RegisterNativeMethod"><span class="toc-number">6.3.3.</span> <span class="toc-text">自实现RegisterNativeMethod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0Root%E6%83%85%E5%86%B5%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9%E6%8A%97%E7%9A%84%E8%BE%B9%E7%95%8C%E5%80%BC"><span class="toc-number">6.4.</span> <span class="toc-text">无Root情况客户端对抗的边界值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E8%BE%B9%E7%95%8C%E5%80%BC%E2%80%9D%E6%8B%A6%E6%88%AA%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">6.5.</span> <span class="toc-text">“边界值”拦截技术实现：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPC%E5%8D%8F%E8%AE%AE%E6%8B%A6%E6%88%AA%EF%BC%9A"><span class="toc-number">6.5.1.</span> <span class="toc-text">IPC协议拦截：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SVC%E6%8B%A6%E6%88%AA%EF%BC%9A"><span class="toc-number">6.5.2.</span> <span class="toc-text">SVC拦截：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%9A"><span class="toc-number">6.5.3.</span> <span class="toc-text">文件读取：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/03/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8BAntiFakerAndroidChecker/" title="Android逆向从入门到入土之AntiFakerAndroidChecker(3)">Android逆向从入门到入土之AntiFakerAndroidChecker(3)</a><time datetime="2025-11-03T13:26:59.000Z" title="发表于 2025-11-03 21:26:59">2025-11-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/21/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F%E4%B9%8B%E5%88%9D%E8%AF%86%E9%A3%8E%E6%8E%A7-2/" title="Android逆向从入门到入土之初识风控(2)">Android逆向从入门到入土之初识风控(2)</a><time datetime="2025-10-21T14:17:54.000Z" title="发表于 2025-10-21 22:17:54">2025-10-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/11/Android%E9%80%86%E5%90%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-1/" title="Android逆向从入门到入土(1)">Android逆向从入门到入土(1)</a><time datetime="2025-10-11T06:38:08.000Z" title="发表于 2025-10-11 14:38:08">2025-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/05/CVE-2024-35250%E5%A4%8D%E7%8E%B0/" title="CVE-2024-35250复现">CVE-2024-35250复现</a><time datetime="2025-09-05T13:13:44.000Z" title="发表于 2025-09-05 21:13:44">2025-09-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/AFL%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bafl-fuzz%E7%BB%93%E6%9D%9F/" title="AFL源码阅读之afl-fuzz结束">AFL源码阅读之afl-fuzz结束</a><time datetime="2025-08-16T07:03:01.000Z" title="发表于 2025-08-16 15:03:01">2025-08-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/BAMBOOiii/photo@main/img/202404281616326.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By s1nec-1o</div><div class="footer_custom_text">介是s1nec-1o的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div><canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none"></canvas></div><script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script><script async type="text/javascript" src="https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>